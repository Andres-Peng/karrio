#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Jun 12 21:01:27 2018 by generateDS.py version 2.29.14.
# Python 3.6.5 (default, May 19 2018, 11:27:13)  [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('-o', 'pyfedex/ship_service_v21.py')
#
# Command line arguments:
#    /Fedex/FedExWebServicesAdvancedXSD/ShipService_v21.xsd
#
# Command line:
#    generateDS --no-namespace-defs -o "pyfedex/ship_service_v21.py"  /Fedex/FedExWebServicesAdvancedXSD/ShipService_v21.xsd
#
# Current working directory (os.getcwd()):
#   py_fedex
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AdditionalLabelsDetail(GeneratedsSuper):
    """Specifies additional labels to be produced. All required labels for
    shipments will be produced without the need to request
    additional labels. These are only available as thermal labels."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Count=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_AdditionalLabelsType(self.Type)
        self.Count = Count
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalLabelsDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalLabelsDetail.subclass:
            return AdditionalLabelsDetail.subclass(*args_, **kwargs_)
        else:
            return AdditionalLabelsDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    def validate_AdditionalLabelsType(self, value):
        # Validate type AdditionalLabelsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BROKER', 'CONSIGNEE', 'CUSTOMS', 'DESTINATION', 'FREIGHT_REFERENCE', 'MANIFEST', 'ORIGIN', 'RECIPIENT', 'SHIPPER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AdditionalLabelsType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Count is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='AdditionalLabelsDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalLabelsDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalLabelsDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='AdditionalLabelsDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='AdditionalLabelsDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='AdditionalLabelsDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Count>%s</ns:Count>%s' % (self.gds_format_integer(self.Count, input_name='Count'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type AdditionalLabelsType
            self.validate_AdditionalLabelsType(self.Type)
        elif nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
# end class AdditionalLabelsDetail


class Address(GeneratedsSuper):
    """Descriptive data for a physical location. May be used as an actual
    physical address (place to which one could go), or as a
    container of "address parts" which should be handled as a unit
    (such as a city-state-ZIP combination within the US)."""
    subclass = None
    superclass = None
    def __init__(self, StreetLines=None, City=None, StateOrProvinceCode=None, PostalCode=None, UrbanizationCode=None, CountryCode=None, CountryName=None, Residential=None, GeographicCoordinates=None):
        self.original_tagname_ = None
        if StreetLines is None:
            self.StreetLines = []
        else:
            self.StreetLines = StreetLines
        self.City = City
        self.StateOrProvinceCode = StateOrProvinceCode
        self.PostalCode = PostalCode
        self.UrbanizationCode = UrbanizationCode
        self.CountryCode = CountryCode
        self.CountryName = CountryName
        self.Residential = Residential
        self.GeographicCoordinates = GeographicCoordinates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StreetLines(self): return self.StreetLines
    def set_StreetLines(self, StreetLines): self.StreetLines = StreetLines
    def add_StreetLines(self, value): self.StreetLines.append(value)
    def insert_StreetLines_at(self, index, value): self.StreetLines.insert(index, value)
    def replace_StreetLines_at(self, index, value): self.StreetLines[index] = value
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_StateOrProvinceCode(self): return self.StateOrProvinceCode
    def set_StateOrProvinceCode(self, StateOrProvinceCode): self.StateOrProvinceCode = StateOrProvinceCode
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_UrbanizationCode(self): return self.UrbanizationCode
    def set_UrbanizationCode(self, UrbanizationCode): self.UrbanizationCode = UrbanizationCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_Residential(self): return self.Residential
    def set_Residential(self, Residential): self.Residential = Residential
    def get_GeographicCoordinates(self): return self.GeographicCoordinates
    def set_GeographicCoordinates(self, GeographicCoordinates): self.GeographicCoordinates = GeographicCoordinates
    def hasContent_(self):
        if (
            self.StreetLines or
            self.City is not None or
            self.StateOrProvinceCode is not None or
            self.PostalCode is not None or
            self.UrbanizationCode is not None or
            self.CountryCode is not None or
            self.CountryName is not None or
            self.Residential is not None or
            self.GeographicCoordinates is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Address', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Address')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Address'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StreetLines_ in self.StreetLines:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:StreetLines>%s</ns:StreetLines>%s' % (self.gds_encode(self.gds_format_string(quote_xml(StreetLines_), input_name='StreetLines')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:City>%s</ns:City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.StateOrProvinceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:StateOrProvinceCode>%s</ns:StateOrProvinceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateOrProvinceCode), input_name='StateOrProvinceCode')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PostalCode>%s</ns:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.UrbanizationCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:UrbanizationCode>%s</ns:UrbanizationCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UrbanizationCode), input_name='UrbanizationCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CountryCode>%s</ns:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CountryName>%s</ns:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.Residential is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Residential>%s</ns:Residential>%s' % (self.gds_format_boolean(self.Residential, input_name='Residential'), eol_))
        if self.GeographicCoordinates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:GeographicCoordinates>%s</ns:GeographicCoordinates>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GeographicCoordinates), input_name='GeographicCoordinates')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StreetLines':
            StreetLines_ = child_.text
            StreetLines_ = self.gds_validate_string(StreetLines_, node, 'StreetLines')
            self.StreetLines.append(StreetLines_)
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'StateOrProvinceCode':
            StateOrProvinceCode_ = child_.text
            StateOrProvinceCode_ = self.gds_validate_string(StateOrProvinceCode_, node, 'StateOrProvinceCode')
            self.StateOrProvinceCode = StateOrProvinceCode_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'UrbanizationCode':
            UrbanizationCode_ = child_.text
            UrbanizationCode_ = self.gds_validate_string(UrbanizationCode_, node, 'UrbanizationCode')
            self.UrbanizationCode = UrbanizationCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
        elif nodeName_ == 'Residential':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Residential')
            self.Residential = ival_
        elif nodeName_ == 'GeographicCoordinates':
            GeographicCoordinates_ = child_.text
            GeographicCoordinates_ = self.gds_validate_string(GeographicCoordinates_, node, 'GeographicCoordinates')
            self.GeographicCoordinates = GeographicCoordinates_
# end class Address


class AdrLicenseDetail(GeneratedsSuper):
    """Specifies the details around the ADR license required for shipping."""
    subclass = None
    superclass = None
    def __init__(self, LicenseOrPermitDetail=None):
        self.original_tagname_ = None
        self.LicenseOrPermitDetail = LicenseOrPermitDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdrLicenseDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdrLicenseDetail.subclass:
            return AdrLicenseDetail.subclass(*args_, **kwargs_)
        else:
            return AdrLicenseDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LicenseOrPermitDetail(self): return self.LicenseOrPermitDetail
    def set_LicenseOrPermitDetail(self, LicenseOrPermitDetail): self.LicenseOrPermitDetail = LicenseOrPermitDetail
    def hasContent_(self):
        if (
            self.LicenseOrPermitDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='AdrLicenseDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdrLicenseDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdrLicenseDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='AdrLicenseDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='AdrLicenseDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='AdrLicenseDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LicenseOrPermitDetail is not None:
            self.LicenseOrPermitDetail.export(outfile, level, namespace_, name_='LicenseOrPermitDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LicenseOrPermitDetail':
            obj_ = LicenseOrPermitDetail.factory()
            obj_.build(child_)
            self.LicenseOrPermitDetail = obj_
            obj_.original_tagname_ = 'LicenseOrPermitDetail'
# end class AdrLicenseDetail


class AlcoholDetail(GeneratedsSuper):
    """Specifies details for a package containing alcohol"""
    subclass = None
    superclass = None
    def __init__(self, RecipientType=None):
        self.original_tagname_ = None
        self.RecipientType = RecipientType
        self.validate_AlcoholRecipientType(self.RecipientType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlcoholDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlcoholDetail.subclass:
            return AlcoholDetail.subclass(*args_, **kwargs_)
        else:
            return AlcoholDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RecipientType(self): return self.RecipientType
    def set_RecipientType(self, RecipientType): self.RecipientType = RecipientType
    def validate_AlcoholRecipientType(self, value):
        # Validate type AlcoholRecipientType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CONSUMER', 'LICENSEE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AlcoholRecipientType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RecipientType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='AlcoholDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlcoholDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlcoholDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='AlcoholDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='AlcoholDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='AlcoholDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RecipientType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RecipientType>%s</ns:RecipientType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RecipientType), input_name='RecipientType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RecipientType':
            RecipientType_ = child_.text
            RecipientType_ = self.gds_validate_string(RecipientType_, node, 'RecipientType')
            self.RecipientType = RecipientType_
            # validate type AlcoholRecipientType
            self.validate_AlcoholRecipientType(self.RecipientType)
# end class AlcoholDetail


class AncillaryFeeAndTax(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Description=None, Amount=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_AncillaryFeeAndTaxType(self.Type)
        self.Description = Description
        self.Amount = Amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AncillaryFeeAndTax)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AncillaryFeeAndTax.subclass:
            return AncillaryFeeAndTax.subclass(*args_, **kwargs_)
        else:
            return AncillaryFeeAndTax(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def validate_AncillaryFeeAndTaxType(self, value):
        # Validate type AncillaryFeeAndTaxType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CLEARANCE_ENTRY_FEE', 'GOODS_AND_SERVICES_TAX', 'HARMONIZED_SALES_TAX', 'OTHER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AncillaryFeeAndTaxType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Description is not None or
            self.Amount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='AncillaryFeeAndTax', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AncillaryFeeAndTax')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AncillaryFeeAndTax')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='AncillaryFeeAndTax', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='AncillaryFeeAndTax'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='AncillaryFeeAndTax', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Amount is not None:
            self.Amount.export(outfile, level, namespace_, name_='Amount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type AncillaryFeeAndTaxType
            self.validate_AncillaryFeeAndTaxType(self.Type)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Amount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.Amount = obj_
            obj_.original_tagname_ = 'Amount'
# end class AncillaryFeeAndTax


class AssociatedShipmentDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Sender=None, Recipient=None, ServiceType=None, PackagingType=None, TrackingId=None, CustomerReferences=None, ShipmentOperationalDetail=None, PackageOperationalDetail=None, Label=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_AssociatedShipmentType(self.Type)
        self.Sender = Sender
        self.Recipient = Recipient
        self.ServiceType = ServiceType
        self.validate_ServiceType(self.ServiceType)
        self.PackagingType = PackagingType
        self.validate_PackagingType(self.PackagingType)
        self.TrackingId = TrackingId
        if CustomerReferences is None:
            self.CustomerReferences = []
        else:
            self.CustomerReferences = CustomerReferences
        self.ShipmentOperationalDetail = ShipmentOperationalDetail
        self.PackageOperationalDetail = PackageOperationalDetail
        self.Label = Label
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociatedShipmentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociatedShipmentDetail.subclass:
            return AssociatedShipmentDetail.subclass(*args_, **kwargs_)
        else:
            return AssociatedShipmentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Sender(self): return self.Sender
    def set_Sender(self, Sender): self.Sender = Sender
    def get_Recipient(self): return self.Recipient
    def set_Recipient(self, Recipient): self.Recipient = Recipient
    def get_ServiceType(self): return self.ServiceType
    def set_ServiceType(self, ServiceType): self.ServiceType = ServiceType
    def get_PackagingType(self): return self.PackagingType
    def set_PackagingType(self, PackagingType): self.PackagingType = PackagingType
    def get_TrackingId(self): return self.TrackingId
    def set_TrackingId(self, TrackingId): self.TrackingId = TrackingId
    def get_CustomerReferences(self): return self.CustomerReferences
    def set_CustomerReferences(self, CustomerReferences): self.CustomerReferences = CustomerReferences
    def add_CustomerReferences(self, value): self.CustomerReferences.append(value)
    def insert_CustomerReferences_at(self, index, value): self.CustomerReferences.insert(index, value)
    def replace_CustomerReferences_at(self, index, value): self.CustomerReferences[index] = value
    def get_ShipmentOperationalDetail(self): return self.ShipmentOperationalDetail
    def set_ShipmentOperationalDetail(self, ShipmentOperationalDetail): self.ShipmentOperationalDetail = ShipmentOperationalDetail
    def get_PackageOperationalDetail(self): return self.PackageOperationalDetail
    def set_PackageOperationalDetail(self, PackageOperationalDetail): self.PackageOperationalDetail = PackageOperationalDetail
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def validate_AssociatedShipmentType(self, value):
        # Validate type AssociatedShipmentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COD_AND_DELIVERY_ON_INVOICE_ACCEPTANCE_RETURN', 'COD_RETURN', 'DELIVERY_ON_INVOICE_ACCEPTANCE_RETURN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AssociatedShipmentType' % {"value" : value.encode("utf-8")} )
    def validate_ServiceType(self, value):
        # Validate type ServiceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EUROPE_FIRST_INTERNATIONAL_PRIORITY', 'FEDEX_1_DAY_FREIGHT', 'FEDEX_2_DAY', 'FEDEX_2_DAY_AM', 'FEDEX_2_DAY_FREIGHT', 'FEDEX_3_DAY_FREIGHT', 'FEDEX_DISTANCE_DEFERRED', 'FEDEX_EXPRESS_SAVER', 'FEDEX_FIRST_FREIGHT', 'FEDEX_FREIGHT_ECONOMY', 'FEDEX_FREIGHT_PRIORITY', 'FEDEX_GROUND', 'FEDEX_NEXT_DAY_AFTERNOON', 'FEDEX_NEXT_DAY_EARLY_MORNING', 'FEDEX_NEXT_DAY_END_OF_DAY', 'FEDEX_NEXT_DAY_FREIGHT', 'FEDEX_NEXT_DAY_MID_MORNING', 'FIRST_OVERNIGHT', 'GROUND_HOME_DELIVERY', 'INTERNATIONAL_ECONOMY', 'INTERNATIONAL_ECONOMY_FREIGHT', 'INTERNATIONAL_FIRST', 'INTERNATIONAL_PRIORITY', 'INTERNATIONAL_PRIORITY_EXPRESS', 'INTERNATIONAL_PRIORITY_FREIGHT', 'PRIORITY_OVERNIGHT', 'SAME_DAY', 'SAME_DAY_CITY', 'SMART_POST', 'STANDARD_OVERNIGHT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ServiceType' % {"value" : value.encode("utf-8")} )
    def validate_PackagingType(self, value):
        # Validate type PackagingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEDEX_10KG_BOX', 'FEDEX_25KG_BOX', 'FEDEX_BOX', 'FEDEX_ENVELOPE', 'FEDEX_EXTRA_LARGE_BOX', 'FEDEX_LARGE_BOX', 'FEDEX_MEDIUM_BOX', 'FEDEX_PAK', 'FEDEX_SMALL_BOX', 'FEDEX_TUBE', 'YOUR_PACKAGING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PackagingType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Sender is not None or
            self.Recipient is not None or
            self.ServiceType is not None or
            self.PackagingType is not None or
            self.TrackingId is not None or
            self.CustomerReferences or
            self.ShipmentOperationalDetail is not None or
            self.PackageOperationalDetail is not None or
            self.Label is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='AssociatedShipmentDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociatedShipmentDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedShipmentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='AssociatedShipmentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='AssociatedShipmentDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='AssociatedShipmentDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Sender is not None:
            self.Sender.export(outfile, level, namespace_, name_='Sender', pretty_print=pretty_print)
        if self.Recipient is not None:
            self.Recipient.export(outfile, level, namespace_, name_='Recipient', pretty_print=pretty_print)
        if self.ServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ServiceType>%s</ns:ServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceType), input_name='ServiceType')), eol_))
        if self.PackagingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackagingType>%s</ns:PackagingType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackagingType), input_name='PackagingType')), eol_))
        if self.TrackingId is not None:
            self.TrackingId.export(outfile, level, namespace_, name_='TrackingId', pretty_print=pretty_print)
        for CustomerReferences_ in self.CustomerReferences:
            CustomerReferences_.export(outfile, level, namespace_, name_='CustomerReferences', pretty_print=pretty_print)
        if self.ShipmentOperationalDetail is not None:
            self.ShipmentOperationalDetail.export(outfile, level, namespace_, name_='ShipmentOperationalDetail', pretty_print=pretty_print)
        if self.PackageOperationalDetail is not None:
            self.PackageOperationalDetail.export(outfile, level, namespace_, name_='PackageOperationalDetail', pretty_print=pretty_print)
        if self.Label is not None:
            self.Label.export(outfile, level, namespace_, name_='Label', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type AssociatedShipmentType
            self.validate_AssociatedShipmentType(self.Type)
        elif nodeName_ == 'Sender':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Sender = obj_
            obj_.original_tagname_ = 'Sender'
        elif nodeName_ == 'Recipient':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Recipient = obj_
            obj_.original_tagname_ = 'Recipient'
        elif nodeName_ == 'ServiceType':
            ServiceType_ = child_.text
            ServiceType_ = self.gds_validate_string(ServiceType_, node, 'ServiceType')
            self.ServiceType = ServiceType_
            # validate type ServiceType
            self.validate_ServiceType(self.ServiceType)
        elif nodeName_ == 'PackagingType':
            PackagingType_ = child_.text
            PackagingType_ = self.gds_validate_string(PackagingType_, node, 'PackagingType')
            self.PackagingType = PackagingType_
            # validate type PackagingType
            self.validate_PackagingType(self.PackagingType)
        elif nodeName_ == 'TrackingId':
            obj_ = TrackingId.factory()
            obj_.build(child_)
            self.TrackingId = obj_
            obj_.original_tagname_ = 'TrackingId'
        elif nodeName_ == 'CustomerReferences':
            obj_ = CustomerReference.factory()
            obj_.build(child_)
            self.CustomerReferences.append(obj_)
            obj_.original_tagname_ = 'CustomerReferences'
        elif nodeName_ == 'ShipmentOperationalDetail':
            obj_ = ShipmentOperationalDetail.factory()
            obj_.build(child_)
            self.ShipmentOperationalDetail = obj_
            obj_.original_tagname_ = 'ShipmentOperationalDetail'
        elif nodeName_ == 'PackageOperationalDetail':
            obj_ = PackageOperationalDetail.factory()
            obj_.build(child_)
            self.PackageOperationalDetail = obj_
            obj_.original_tagname_ = 'PackageOperationalDetail'
        elif nodeName_ == 'Label':
            obj_ = ShippingDocument.factory()
            obj_.build(child_)
            self.Label = obj_
            obj_.original_tagname_ = 'Label'
# end class AssociatedShipmentDetail


class BatteryClassificationDetail(GeneratedsSuper):
    """Describes attributes of a battery or cell that are used for
    classification purposes. Typically this structure would be used
    to allow customers to declare batteries or cells for which full
    dangerous goods documentation and procedures are not required."""
    subclass = None
    superclass = None
    def __init__(self, Material=None, Packing=None, RegulatorySubType=None):
        self.original_tagname_ = None
        self.Material = Material
        self.validate_BatteryMaterialType(self.Material)
        self.Packing = Packing
        self.validate_BatteryPackingType(self.Packing)
        self.RegulatorySubType = RegulatorySubType
        self.validate_BatteryRegulatorySubType(self.RegulatorySubType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BatteryClassificationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BatteryClassificationDetail.subclass:
            return BatteryClassificationDetail.subclass(*args_, **kwargs_)
        else:
            return BatteryClassificationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Material(self): return self.Material
    def set_Material(self, Material): self.Material = Material
    def get_Packing(self): return self.Packing
    def set_Packing(self, Packing): self.Packing = Packing
    def get_RegulatorySubType(self): return self.RegulatorySubType
    def set_RegulatorySubType(self, RegulatorySubType): self.RegulatorySubType = RegulatorySubType
    def validate_BatteryMaterialType(self, value):
        # Validate type BatteryMaterialType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['LITHIUM_ION', 'LITHIUM_METAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BatteryMaterialType' % {"value" : value.encode("utf-8")} )
    def validate_BatteryPackingType(self, value):
        # Validate type BatteryPackingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CONTAINED_IN_EQUIPMENT', 'PACKED_WITH_EQUIPMENT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BatteryPackingType' % {"value" : value.encode("utf-8")} )
    def validate_BatteryRegulatorySubType(self, value):
        # Validate type BatteryRegulatorySubType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['IATA_SECTION_II']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BatteryRegulatorySubType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Material is not None or
            self.Packing is not None or
            self.RegulatorySubType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='BatteryClassificationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BatteryClassificationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BatteryClassificationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='BatteryClassificationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='BatteryClassificationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='BatteryClassificationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Material is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Material>%s</ns:Material>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Material), input_name='Material')), eol_))
        if self.Packing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Packing>%s</ns:Packing>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Packing), input_name='Packing')), eol_))
        if self.RegulatorySubType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RegulatorySubType>%s</ns:RegulatorySubType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RegulatorySubType), input_name='RegulatorySubType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Material':
            Material_ = child_.text
            Material_ = self.gds_validate_string(Material_, node, 'Material')
            self.Material = Material_
            # validate type BatteryMaterialType
            self.validate_BatteryMaterialType(self.Material)
        elif nodeName_ == 'Packing':
            Packing_ = child_.text
            Packing_ = self.gds_validate_string(Packing_, node, 'Packing')
            self.Packing = Packing_
            # validate type BatteryPackingType
            self.validate_BatteryPackingType(self.Packing)
        elif nodeName_ == 'RegulatorySubType':
            RegulatorySubType_ = child_.text
            RegulatorySubType_ = self.gds_validate_string(RegulatorySubType_, node, 'RegulatorySubType')
            self.RegulatorySubType = RegulatorySubType_
            # validate type BatteryRegulatorySubType
            self.validate_BatteryRegulatorySubType(self.RegulatorySubType)
# end class BatteryClassificationDetail


class BinaryBarcode(GeneratedsSuper):
    """Each instance of this data type represents a barcode whose content
    must be represented as binary data (i.e. not ASCII text)."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_BinaryBarcodeType(self.Type)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BinaryBarcode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BinaryBarcode.subclass:
            return BinaryBarcode.subclass(*args_, **kwargs_)
        else:
            return BinaryBarcode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_BinaryBarcodeType(self, value):
        # Validate type BinaryBarcodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COMMON_2D']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BinaryBarcodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='BinaryBarcode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BinaryBarcode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BinaryBarcode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='BinaryBarcode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='BinaryBarcode'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='BinaryBarcode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_format_base64(self.Value, input_name='Value'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type BinaryBarcodeType
            self.validate_BinaryBarcodeType(self.Type)
        elif nodeName_ == 'Value':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Value')
            else:
                bval_ = None
            self.Value = bval_
# end class BinaryBarcode


class BrokerDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Broker=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_BrokerType(self.Type)
        self.Broker = Broker
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BrokerDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BrokerDetail.subclass:
            return BrokerDetail.subclass(*args_, **kwargs_)
        else:
            return BrokerDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Broker(self): return self.Broker
    def set_Broker(self, Broker): self.Broker = Broker
    def validate_BrokerType(self, value):
        # Validate type BrokerType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EXPORT', 'IMPORT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BrokerType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Broker is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='BrokerDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BrokerDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BrokerDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='BrokerDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='BrokerDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='BrokerDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Broker is not None:
            self.Broker.export(outfile, level, namespace_, name_='Broker', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type BrokerType
            self.validate_BrokerType(self.Type)
        elif nodeName_ == 'Broker':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Broker = obj_
            obj_.original_tagname_ = 'Broker'
# end class BrokerDetail


class CertificateOfOriginDetail(GeneratedsSuper):
    """The instructions indicating how to print the Certificate of Origin (
    e.g. whether or not to include the instructions, image type, etc
    ...)"""
    subclass = None
    superclass = None
    def __init__(self, DocumentFormat=None, CustomerImageUsages=None):
        self.original_tagname_ = None
        self.DocumentFormat = DocumentFormat
        if CustomerImageUsages is None:
            self.CustomerImageUsages = []
        else:
            self.CustomerImageUsages = CustomerImageUsages
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CertificateOfOriginDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CertificateOfOriginDetail.subclass:
            return CertificateOfOriginDetail.subclass(*args_, **kwargs_)
        else:
            return CertificateOfOriginDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentFormat(self): return self.DocumentFormat
    def set_DocumentFormat(self, DocumentFormat): self.DocumentFormat = DocumentFormat
    def get_CustomerImageUsages(self): return self.CustomerImageUsages
    def set_CustomerImageUsages(self, CustomerImageUsages): self.CustomerImageUsages = CustomerImageUsages
    def add_CustomerImageUsages(self, value): self.CustomerImageUsages.append(value)
    def insert_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages.insert(index, value)
    def replace_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages[index] = value
    def hasContent_(self):
        if (
            self.DocumentFormat is not None or
            self.CustomerImageUsages
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CertificateOfOriginDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CertificateOfOriginDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CertificateOfOriginDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CertificateOfOriginDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CertificateOfOriginDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CertificateOfOriginDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocumentFormat is not None:
            self.DocumentFormat.export(outfile, level, namespace_, name_='DocumentFormat', pretty_print=pretty_print)
        for CustomerImageUsages_ in self.CustomerImageUsages:
            CustomerImageUsages_.export(outfile, level, namespace_, name_='CustomerImageUsages', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocumentFormat':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.DocumentFormat = obj_
            obj_.original_tagname_ = 'DocumentFormat'
        elif nodeName_ == 'CustomerImageUsages':
            obj_ = CustomerImageUsage.factory()
            obj_.build(child_)
            self.CustomerImageUsages.append(obj_)
            obj_.original_tagname_ = 'CustomerImageUsages'
# end class CertificateOfOriginDetail


class ClientDetail(GeneratedsSuper):
    """Descriptive data for the client submitting a transaction."""
    subclass = None
    superclass = None
    def __init__(self, AccountNumber=None, MeterNumber=None, IntegratorId=None, Localization=None):
        self.original_tagname_ = None
        self.AccountNumber = AccountNumber
        self.MeterNumber = MeterNumber
        self.IntegratorId = IntegratorId
        self.Localization = Localization
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClientDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClientDetail.subclass:
            return ClientDetail.subclass(*args_, **kwargs_)
        else:
            return ClientDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccountNumber(self): return self.AccountNumber
    def set_AccountNumber(self, AccountNumber): self.AccountNumber = AccountNumber
    def get_MeterNumber(self): return self.MeterNumber
    def set_MeterNumber(self, MeterNumber): self.MeterNumber = MeterNumber
    def get_IntegratorId(self): return self.IntegratorId
    def set_IntegratorId(self, IntegratorId): self.IntegratorId = IntegratorId
    def get_Localization(self): return self.Localization
    def set_Localization(self, Localization): self.Localization = Localization
    def hasContent_(self):
        if (
            self.AccountNumber is not None or
            self.MeterNumber is not None or
            self.IntegratorId is not None or
            self.Localization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ClientDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClientDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClientDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ClientDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ClientDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ClientDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AccountNumber>%s</ns:AccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AccountNumber), input_name='AccountNumber')), eol_))
        if self.MeterNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:MeterNumber>%s</ns:MeterNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MeterNumber), input_name='MeterNumber')), eol_))
        if self.IntegratorId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:IntegratorId>%s</ns:IntegratorId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IntegratorId), input_name='IntegratorId')), eol_))
        if self.Localization is not None:
            self.Localization.export(outfile, level, namespace_, name_='Localization', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccountNumber':
            AccountNumber_ = child_.text
            AccountNumber_ = self.gds_validate_string(AccountNumber_, node, 'AccountNumber')
            self.AccountNumber = AccountNumber_
        elif nodeName_ == 'MeterNumber':
            MeterNumber_ = child_.text
            MeterNumber_ = self.gds_validate_string(MeterNumber_, node, 'MeterNumber')
            self.MeterNumber = MeterNumber_
        elif nodeName_ == 'IntegratorId':
            IntegratorId_ = child_.text
            IntegratorId_ = self.gds_validate_string(IntegratorId_, node, 'IntegratorId')
            self.IntegratorId = IntegratorId_
        elif nodeName_ == 'Localization':
            obj_ = Localization.factory()
            obj_.build(child_)
            self.Localization = obj_
            obj_.original_tagname_ = 'Localization'
# end class ClientDetail


class CodAddTransportationChargesDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RateTypeBasis=None, ChargeBasis=None, ChargeBasisLevel=None):
        self.original_tagname_ = None
        self.RateTypeBasis = RateTypeBasis
        self.validate_RateTypeBasisType(self.RateTypeBasis)
        self.ChargeBasis = ChargeBasis
        self.validate_CodAddTransportationChargeBasisType(self.ChargeBasis)
        self.ChargeBasisLevel = ChargeBasisLevel
        self.validate_ChargeBasisLevelType(self.ChargeBasisLevel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodAddTransportationChargesDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodAddTransportationChargesDetail.subclass:
            return CodAddTransportationChargesDetail.subclass(*args_, **kwargs_)
        else:
            return CodAddTransportationChargesDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RateTypeBasis(self): return self.RateTypeBasis
    def set_RateTypeBasis(self, RateTypeBasis): self.RateTypeBasis = RateTypeBasis
    def get_ChargeBasis(self): return self.ChargeBasis
    def set_ChargeBasis(self, ChargeBasis): self.ChargeBasis = ChargeBasis
    def get_ChargeBasisLevel(self): return self.ChargeBasisLevel
    def set_ChargeBasisLevel(self, ChargeBasisLevel): self.ChargeBasisLevel = ChargeBasisLevel
    def validate_RateTypeBasisType(self, value):
        # Validate type RateTypeBasisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACCOUNT', 'LIST']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateTypeBasisType' % {"value" : value.encode("utf-8")} )
    def validate_CodAddTransportationChargeBasisType(self, value):
        # Validate type CodAddTransportationChargeBasisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COD_SURCHARGE', 'NET_CHARGE', 'NET_FREIGHT', 'TOTAL_CUSTOMER_CHARGE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CodAddTransportationChargeBasisType' % {"value" : value.encode("utf-8")} )
    def validate_ChargeBasisLevelType(self, value):
        # Validate type ChargeBasisLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CURRENT_PACKAGE', 'SUM_OF_PACKAGES']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChargeBasisLevelType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RateTypeBasis is not None or
            self.ChargeBasis is not None or
            self.ChargeBasisLevel is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CodAddTransportationChargesDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CodAddTransportationChargesDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodAddTransportationChargesDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CodAddTransportationChargesDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CodAddTransportationChargesDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CodAddTransportationChargesDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RateTypeBasis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateTypeBasis>%s</ns:RateTypeBasis>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateTypeBasis), input_name='RateTypeBasis')), eol_))
        if self.ChargeBasis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ChargeBasis>%s</ns:ChargeBasis>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeBasis), input_name='ChargeBasis')), eol_))
        if self.ChargeBasisLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ChargeBasisLevel>%s</ns:ChargeBasisLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeBasisLevel), input_name='ChargeBasisLevel')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RateTypeBasis':
            RateTypeBasis_ = child_.text
            RateTypeBasis_ = self.gds_validate_string(RateTypeBasis_, node, 'RateTypeBasis')
            self.RateTypeBasis = RateTypeBasis_
            # validate type RateTypeBasisType
            self.validate_RateTypeBasisType(self.RateTypeBasis)
        elif nodeName_ == 'ChargeBasis':
            ChargeBasis_ = child_.text
            ChargeBasis_ = self.gds_validate_string(ChargeBasis_, node, 'ChargeBasis')
            self.ChargeBasis = ChargeBasis_
            # validate type CodAddTransportationChargeBasisType
            self.validate_CodAddTransportationChargeBasisType(self.ChargeBasis)
        elif nodeName_ == 'ChargeBasisLevel':
            ChargeBasisLevel_ = child_.text
            ChargeBasisLevel_ = self.gds_validate_string(ChargeBasisLevel_, node, 'ChargeBasisLevel')
            self.ChargeBasisLevel = ChargeBasisLevel_
            # validate type ChargeBasisLevelType
            self.validate_ChargeBasisLevelType(self.ChargeBasisLevel)
# end class CodAddTransportationChargesDetail


class CodDetail(GeneratedsSuper):
    """Descriptive data required for a FedEx COD (Collect-On-Delivery)
    shipment."""
    subclass = None
    superclass = None
    def __init__(self, CodCollectionAmount=None, AddTransportationChargesDetail=None, CollectionType=None, CodRecipient=None, FinancialInstitutionContactAndAddress=None, RemitToName=None, ReferenceIndicator=None, ReturnTrackingId=None):
        self.original_tagname_ = None
        self.CodCollectionAmount = CodCollectionAmount
        self.AddTransportationChargesDetail = AddTransportationChargesDetail
        self.CollectionType = CollectionType
        self.validate_CodCollectionType(self.CollectionType)
        self.CodRecipient = CodRecipient
        self.FinancialInstitutionContactAndAddress = FinancialInstitutionContactAndAddress
        self.RemitToName = RemitToName
        self.ReferenceIndicator = ReferenceIndicator
        self.validate_CodReturnReferenceIndicatorType(self.ReferenceIndicator)
        self.ReturnTrackingId = ReturnTrackingId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodDetail.subclass:
            return CodDetail.subclass(*args_, **kwargs_)
        else:
            return CodDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CodCollectionAmount(self): return self.CodCollectionAmount
    def set_CodCollectionAmount(self, CodCollectionAmount): self.CodCollectionAmount = CodCollectionAmount
    def get_AddTransportationChargesDetail(self): return self.AddTransportationChargesDetail
    def set_AddTransportationChargesDetail(self, AddTransportationChargesDetail): self.AddTransportationChargesDetail = AddTransportationChargesDetail
    def get_CollectionType(self): return self.CollectionType
    def set_CollectionType(self, CollectionType): self.CollectionType = CollectionType
    def get_CodRecipient(self): return self.CodRecipient
    def set_CodRecipient(self, CodRecipient): self.CodRecipient = CodRecipient
    def get_FinancialInstitutionContactAndAddress(self): return self.FinancialInstitutionContactAndAddress
    def set_FinancialInstitutionContactAndAddress(self, FinancialInstitutionContactAndAddress): self.FinancialInstitutionContactAndAddress = FinancialInstitutionContactAndAddress
    def get_RemitToName(self): return self.RemitToName
    def set_RemitToName(self, RemitToName): self.RemitToName = RemitToName
    def get_ReferenceIndicator(self): return self.ReferenceIndicator
    def set_ReferenceIndicator(self, ReferenceIndicator): self.ReferenceIndicator = ReferenceIndicator
    def get_ReturnTrackingId(self): return self.ReturnTrackingId
    def set_ReturnTrackingId(self, ReturnTrackingId): self.ReturnTrackingId = ReturnTrackingId
    def validate_CodCollectionType(self, value):
        # Validate type CodCollectionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ANY', 'CASH', 'COMPANY_CHECK', 'GUARANTEED_FUNDS', 'PERSONAL_CHECK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CodCollectionType' % {"value" : value.encode("utf-8")} )
    def validate_CodReturnReferenceIndicatorType(self, value):
        # Validate type CodReturnReferenceIndicatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INVOICE', 'PO', 'REFERENCE', 'TRACKING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CodReturnReferenceIndicatorType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CodCollectionAmount is not None or
            self.AddTransportationChargesDetail is not None or
            self.CollectionType is not None or
            self.CodRecipient is not None or
            self.FinancialInstitutionContactAndAddress is not None or
            self.RemitToName is not None or
            self.ReferenceIndicator is not None or
            self.ReturnTrackingId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CodDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CodDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CodDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CodDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CodDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CodCollectionAmount is not None:
            self.CodCollectionAmount.export(outfile, level, namespace_, name_='CodCollectionAmount', pretty_print=pretty_print)
        if self.AddTransportationChargesDetail is not None:
            self.AddTransportationChargesDetail.export(outfile, level, namespace_, name_='AddTransportationChargesDetail', pretty_print=pretty_print)
        if self.CollectionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CollectionType>%s</ns:CollectionType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CollectionType), input_name='CollectionType')), eol_))
        if self.CodRecipient is not None:
            self.CodRecipient.export(outfile, level, namespace_, name_='CodRecipient', pretty_print=pretty_print)
        if self.FinancialInstitutionContactAndAddress is not None:
            self.FinancialInstitutionContactAndAddress.export(outfile, level, namespace_, name_='FinancialInstitutionContactAndAddress', pretty_print=pretty_print)
        if self.RemitToName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RemitToName>%s</ns:RemitToName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RemitToName), input_name='RemitToName')), eol_))
        if self.ReferenceIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ReferenceIndicator>%s</ns:ReferenceIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceIndicator), input_name='ReferenceIndicator')), eol_))
        if self.ReturnTrackingId is not None:
            self.ReturnTrackingId.export(outfile, level, namespace_, name_='ReturnTrackingId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CodCollectionAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.CodCollectionAmount = obj_
            obj_.original_tagname_ = 'CodCollectionAmount'
        elif nodeName_ == 'AddTransportationChargesDetail':
            obj_ = CodAddTransportationChargesDetail.factory()
            obj_.build(child_)
            self.AddTransportationChargesDetail = obj_
            obj_.original_tagname_ = 'AddTransportationChargesDetail'
        elif nodeName_ == 'CollectionType':
            CollectionType_ = child_.text
            CollectionType_ = self.gds_validate_string(CollectionType_, node, 'CollectionType')
            self.CollectionType = CollectionType_
            # validate type CodCollectionType
            self.validate_CodCollectionType(self.CollectionType)
        elif nodeName_ == 'CodRecipient':
            obj_ = Party.factory()
            obj_.build(child_)
            self.CodRecipient = obj_
            obj_.original_tagname_ = 'CodRecipient'
        elif nodeName_ == 'FinancialInstitutionContactAndAddress':
            obj_ = ContactAndAddress.factory()
            obj_.build(child_)
            self.FinancialInstitutionContactAndAddress = obj_
            obj_.original_tagname_ = 'FinancialInstitutionContactAndAddress'
        elif nodeName_ == 'RemitToName':
            RemitToName_ = child_.text
            RemitToName_ = self.gds_validate_string(RemitToName_, node, 'RemitToName')
            self.RemitToName = RemitToName_
        elif nodeName_ == 'ReferenceIndicator':
            ReferenceIndicator_ = child_.text
            ReferenceIndicator_ = self.gds_validate_string(ReferenceIndicator_, node, 'ReferenceIndicator')
            self.ReferenceIndicator = ReferenceIndicator_
            # validate type CodReturnReferenceIndicatorType
            self.validate_CodReturnReferenceIndicatorType(self.ReferenceIndicator)
        elif nodeName_ == 'ReturnTrackingId':
            obj_ = TrackingId.factory()
            obj_.build(child_)
            self.ReturnTrackingId = obj_
            obj_.original_tagname_ = 'ReturnTrackingId'
# end class CodDetail


class CodReturnPackageDetail(GeneratedsSuper):
    """Specifies the information associated with a package that has COD
    special service in a ground shipment."""
    subclass = None
    superclass = None
    def __init__(self, CollectionAmount=None, AdjustmentType=None, Electronic=None, Barcodes=None, Label=None):
        self.original_tagname_ = None
        self.CollectionAmount = CollectionAmount
        self.AdjustmentType = AdjustmentType
        self.validate_CodAdjustmentType(self.AdjustmentType)
        self.Electronic = Electronic
        self.Barcodes = Barcodes
        self.Label = Label
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodReturnPackageDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodReturnPackageDetail.subclass:
            return CodReturnPackageDetail.subclass(*args_, **kwargs_)
        else:
            return CodReturnPackageDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CollectionAmount(self): return self.CollectionAmount
    def set_CollectionAmount(self, CollectionAmount): self.CollectionAmount = CollectionAmount
    def get_AdjustmentType(self): return self.AdjustmentType
    def set_AdjustmentType(self, AdjustmentType): self.AdjustmentType = AdjustmentType
    def get_Electronic(self): return self.Electronic
    def set_Electronic(self, Electronic): self.Electronic = Electronic
    def get_Barcodes(self): return self.Barcodes
    def set_Barcodes(self, Barcodes): self.Barcodes = Barcodes
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def validate_CodAdjustmentType(self, value):
        # Validate type CodAdjustmentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CHARGES_ADDED', 'NONE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CodAdjustmentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CollectionAmount is not None or
            self.AdjustmentType is not None or
            self.Electronic is not None or
            self.Barcodes is not None or
            self.Label is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CodReturnPackageDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CodReturnPackageDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodReturnPackageDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CodReturnPackageDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CodReturnPackageDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CodReturnPackageDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CollectionAmount is not None:
            self.CollectionAmount.export(outfile, level, namespace_, name_='CollectionAmount', pretty_print=pretty_print)
        if self.AdjustmentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AdjustmentType>%s</ns:AdjustmentType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AdjustmentType), input_name='AdjustmentType')), eol_))
        if self.Electronic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Electronic>%s</ns:Electronic>%s' % (self.gds_format_boolean(self.Electronic, input_name='Electronic'), eol_))
        if self.Barcodes is not None:
            self.Barcodes.export(outfile, level, namespace_, name_='Barcodes', pretty_print=pretty_print)
        if self.Label is not None:
            self.Label.export(outfile, level, namespace_, name_='Label', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CollectionAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.CollectionAmount = obj_
            obj_.original_tagname_ = 'CollectionAmount'
        elif nodeName_ == 'AdjustmentType':
            AdjustmentType_ = child_.text
            AdjustmentType_ = self.gds_validate_string(AdjustmentType_, node, 'AdjustmentType')
            self.AdjustmentType = AdjustmentType_
            # validate type CodAdjustmentType
            self.validate_CodAdjustmentType(self.AdjustmentType)
        elif nodeName_ == 'Electronic':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Electronic')
            self.Electronic = ival_
        elif nodeName_ == 'Barcodes':
            obj_ = PackageBarcodes.factory()
            obj_.build(child_)
            self.Barcodes = obj_
            obj_.original_tagname_ = 'Barcodes'
        elif nodeName_ == 'Label':
            obj_ = ShippingDocument.factory()
            obj_.build(child_)
            self.Label = obj_
            obj_.original_tagname_ = 'Label'
# end class CodReturnPackageDetail


class CommercialInvoice(GeneratedsSuper):
    """CommercialInvoice element is required for electronic upload of CI
    data. It will serve to create/transmit an Electronic Commercial
    Invoice through the FedEx Systems. Customers are responsible for
    printing their own Commercial Invoice.If you would likeFedEx to
    generate a Commercial Invoice and transmit it to Customs. for
    clearance purposes, you need to specify that in the
    ShippingDocumentSpecification element. If you would like a copy
    of the Commercial Invoice that FedEx generated returned to you
    in reply it needs to be specified in the
    ETDDetail/RequestedDocumentCopies element. Commercial Invoice
    support consists of maximum of 99 commodity line items."""
    subclass = None
    superclass = None
    def __init__(self, Comments=None, FreightCharge=None, TaxesOrMiscellaneousCharge=None, TaxesOrMiscellaneousChargeType=None, PackingCosts=None, HandlingCosts=None, SpecialInstructions=None, DeclarationStatement=None, PaymentTerms=None, Purpose=None, CustomerReferences=None, OriginatorName=None, TermsOfSale=None):
        self.original_tagname_ = None
        if Comments is None:
            self.Comments = []
        else:
            self.Comments = Comments
        self.FreightCharge = FreightCharge
        self.TaxesOrMiscellaneousCharge = TaxesOrMiscellaneousCharge
        self.TaxesOrMiscellaneousChargeType = TaxesOrMiscellaneousChargeType
        self.validate_TaxesOrMiscellaneousChargeType(self.TaxesOrMiscellaneousChargeType)
        self.PackingCosts = PackingCosts
        self.HandlingCosts = HandlingCosts
        self.SpecialInstructions = SpecialInstructions
        self.DeclarationStatement = DeclarationStatement
        self.PaymentTerms = PaymentTerms
        self.Purpose = Purpose
        self.validate_PurposeOfShipmentType(self.Purpose)
        if CustomerReferences is None:
            self.CustomerReferences = []
        else:
            self.CustomerReferences = CustomerReferences
        self.OriginatorName = OriginatorName
        self.TermsOfSale = TermsOfSale
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommercialInvoice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommercialInvoice.subclass:
            return CommercialInvoice.subclass(*args_, **kwargs_)
        else:
            return CommercialInvoice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comments(self): return self.Comments
    def set_Comments(self, Comments): self.Comments = Comments
    def add_Comments(self, value): self.Comments.append(value)
    def insert_Comments_at(self, index, value): self.Comments.insert(index, value)
    def replace_Comments_at(self, index, value): self.Comments[index] = value
    def get_FreightCharge(self): return self.FreightCharge
    def set_FreightCharge(self, FreightCharge): self.FreightCharge = FreightCharge
    def get_TaxesOrMiscellaneousCharge(self): return self.TaxesOrMiscellaneousCharge
    def set_TaxesOrMiscellaneousCharge(self, TaxesOrMiscellaneousCharge): self.TaxesOrMiscellaneousCharge = TaxesOrMiscellaneousCharge
    def get_TaxesOrMiscellaneousChargeType(self): return self.TaxesOrMiscellaneousChargeType
    def set_TaxesOrMiscellaneousChargeType(self, TaxesOrMiscellaneousChargeType): self.TaxesOrMiscellaneousChargeType = TaxesOrMiscellaneousChargeType
    def get_PackingCosts(self): return self.PackingCosts
    def set_PackingCosts(self, PackingCosts): self.PackingCosts = PackingCosts
    def get_HandlingCosts(self): return self.HandlingCosts
    def set_HandlingCosts(self, HandlingCosts): self.HandlingCosts = HandlingCosts
    def get_SpecialInstructions(self): return self.SpecialInstructions
    def set_SpecialInstructions(self, SpecialInstructions): self.SpecialInstructions = SpecialInstructions
    def get_DeclarationStatement(self): return self.DeclarationStatement
    def set_DeclarationStatement(self, DeclarationStatement): self.DeclarationStatement = DeclarationStatement
    def get_PaymentTerms(self): return self.PaymentTerms
    def set_PaymentTerms(self, PaymentTerms): self.PaymentTerms = PaymentTerms
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    def get_CustomerReferences(self): return self.CustomerReferences
    def set_CustomerReferences(self, CustomerReferences): self.CustomerReferences = CustomerReferences
    def add_CustomerReferences(self, value): self.CustomerReferences.append(value)
    def insert_CustomerReferences_at(self, index, value): self.CustomerReferences.insert(index, value)
    def replace_CustomerReferences_at(self, index, value): self.CustomerReferences[index] = value
    def get_OriginatorName(self): return self.OriginatorName
    def set_OriginatorName(self, OriginatorName): self.OriginatorName = OriginatorName
    def get_TermsOfSale(self): return self.TermsOfSale
    def set_TermsOfSale(self, TermsOfSale): self.TermsOfSale = TermsOfSale
    def validate_TaxesOrMiscellaneousChargeType(self, value):
        # Validate type TaxesOrMiscellaneousChargeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COMMISSIONS', 'DISCOUNTS', 'HANDLING_FEES', 'OTHER', 'ROYALTIES_AND_LICENSE_FEES', 'TAXES']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TaxesOrMiscellaneousChargeType' % {"value" : value.encode("utf-8")} )
    def validate_PurposeOfShipmentType(self, value):
        # Validate type PurposeOfShipmentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['GIFT', 'NOT_SOLD', 'PERSONAL_EFFECTS', 'REPAIR_AND_RETURN', 'SAMPLE', 'SOLD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PurposeOfShipmentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comments or
            self.FreightCharge is not None or
            self.TaxesOrMiscellaneousCharge is not None or
            self.TaxesOrMiscellaneousChargeType is not None or
            self.PackingCosts is not None or
            self.HandlingCosts is not None or
            self.SpecialInstructions is not None or
            self.DeclarationStatement is not None or
            self.PaymentTerms is not None or
            self.Purpose is not None or
            self.CustomerReferences or
            self.OriginatorName is not None or
            self.TermsOfSale is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CommercialInvoice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommercialInvoice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommercialInvoice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CommercialInvoice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CommercialInvoice'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CommercialInvoice', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comments_ in self.Comments:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Comments>%s</ns:Comments>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Comments_), input_name='Comments')), eol_))
        if self.FreightCharge is not None:
            self.FreightCharge.export(outfile, level, namespace_, name_='FreightCharge', pretty_print=pretty_print)
        if self.TaxesOrMiscellaneousCharge is not None:
            self.TaxesOrMiscellaneousCharge.export(outfile, level, namespace_, name_='TaxesOrMiscellaneousCharge', pretty_print=pretty_print)
        if self.TaxesOrMiscellaneousChargeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TaxesOrMiscellaneousChargeType>%s</ns:TaxesOrMiscellaneousChargeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxesOrMiscellaneousChargeType), input_name='TaxesOrMiscellaneousChargeType')), eol_))
        if self.PackingCosts is not None:
            self.PackingCosts.export(outfile, level, namespace_, name_='PackingCosts', pretty_print=pretty_print)
        if self.HandlingCosts is not None:
            self.HandlingCosts.export(outfile, level, namespace_, name_='HandlingCosts', pretty_print=pretty_print)
        if self.SpecialInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SpecialInstructions>%s</ns:SpecialInstructions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialInstructions), input_name='SpecialInstructions')), eol_))
        if self.DeclarationStatement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DeclarationStatement>%s</ns:DeclarationStatement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeclarationStatement), input_name='DeclarationStatement')), eol_))
        if self.PaymentTerms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PaymentTerms>%s</ns:PaymentTerms>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PaymentTerms), input_name='PaymentTerms')), eol_))
        if self.Purpose is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Purpose>%s</ns:Purpose>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Purpose), input_name='Purpose')), eol_))
        for CustomerReferences_ in self.CustomerReferences:
            CustomerReferences_.export(outfile, level, namespace_, name_='CustomerReferences', pretty_print=pretty_print)
        if self.OriginatorName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:OriginatorName>%s</ns:OriginatorName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginatorName), input_name='OriginatorName')), eol_))
        if self.TermsOfSale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TermsOfSale>%s</ns:TermsOfSale>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TermsOfSale), input_name='TermsOfSale')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comments':
            Comments_ = child_.text
            Comments_ = self.gds_validate_string(Comments_, node, 'Comments')
            self.Comments.append(Comments_)
        elif nodeName_ == 'FreightCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.FreightCharge = obj_
            obj_.original_tagname_ = 'FreightCharge'
        elif nodeName_ == 'TaxesOrMiscellaneousCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TaxesOrMiscellaneousCharge = obj_
            obj_.original_tagname_ = 'TaxesOrMiscellaneousCharge'
        elif nodeName_ == 'TaxesOrMiscellaneousChargeType':
            TaxesOrMiscellaneousChargeType_ = child_.text
            TaxesOrMiscellaneousChargeType_ = self.gds_validate_string(TaxesOrMiscellaneousChargeType_, node, 'TaxesOrMiscellaneousChargeType')
            self.TaxesOrMiscellaneousChargeType = TaxesOrMiscellaneousChargeType_
            # validate type TaxesOrMiscellaneousChargeType
            self.validate_TaxesOrMiscellaneousChargeType(self.TaxesOrMiscellaneousChargeType)
        elif nodeName_ == 'PackingCosts':
            obj_ = Money.factory()
            obj_.build(child_)
            self.PackingCosts = obj_
            obj_.original_tagname_ = 'PackingCosts'
        elif nodeName_ == 'HandlingCosts':
            obj_ = Money.factory()
            obj_.build(child_)
            self.HandlingCosts = obj_
            obj_.original_tagname_ = 'HandlingCosts'
        elif nodeName_ == 'SpecialInstructions':
            SpecialInstructions_ = child_.text
            SpecialInstructions_ = self.gds_validate_string(SpecialInstructions_, node, 'SpecialInstructions')
            self.SpecialInstructions = SpecialInstructions_
        elif nodeName_ == 'DeclarationStatement':
            DeclarationStatement_ = child_.text
            DeclarationStatement_ = self.gds_validate_string(DeclarationStatement_, node, 'DeclarationStatement')
            self.DeclarationStatement = DeclarationStatement_
        elif nodeName_ == 'PaymentTerms':
            PaymentTerms_ = child_.text
            PaymentTerms_ = self.gds_validate_string(PaymentTerms_, node, 'PaymentTerms')
            self.PaymentTerms = PaymentTerms_
        elif nodeName_ == 'Purpose':
            Purpose_ = child_.text
            Purpose_ = self.gds_validate_string(Purpose_, node, 'Purpose')
            self.Purpose = Purpose_
            # validate type PurposeOfShipmentType
            self.validate_PurposeOfShipmentType(self.Purpose)
        elif nodeName_ == 'CustomerReferences':
            obj_ = CustomerReference.factory()
            obj_.build(child_)
            self.CustomerReferences.append(obj_)
            obj_.original_tagname_ = 'CustomerReferences'
        elif nodeName_ == 'OriginatorName':
            OriginatorName_ = child_.text
            OriginatorName_ = self.gds_validate_string(OriginatorName_, node, 'OriginatorName')
            self.OriginatorName = OriginatorName_
        elif nodeName_ == 'TermsOfSale':
            TermsOfSale_ = child_.text
            TermsOfSale_ = self.gds_validate_string(TermsOfSale_, node, 'TermsOfSale')
            self.TermsOfSale = TermsOfSale_
# end class CommercialInvoice


class CommercialInvoiceDetail(GeneratedsSuper):
    """The instructions indicating how to print the Commercial Invoice(
    e.g. image type) Specifies characteristics of a shipping
    document to be produced."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, CustomerImageUsages=None):
        self.original_tagname_ = None
        self.Format = Format
        if CustomerImageUsages is None:
            self.CustomerImageUsages = []
        else:
            self.CustomerImageUsages = CustomerImageUsages
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommercialInvoiceDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommercialInvoiceDetail.subclass:
            return CommercialInvoiceDetail.subclass(*args_, **kwargs_)
        else:
            return CommercialInvoiceDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_CustomerImageUsages(self): return self.CustomerImageUsages
    def set_CustomerImageUsages(self, CustomerImageUsages): self.CustomerImageUsages = CustomerImageUsages
    def add_CustomerImageUsages(self, value): self.CustomerImageUsages.append(value)
    def insert_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages.insert(index, value)
    def replace_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages[index] = value
    def hasContent_(self):
        if (
            self.Format is not None or
            self.CustomerImageUsages
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CommercialInvoiceDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommercialInvoiceDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommercialInvoiceDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CommercialInvoiceDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CommercialInvoiceDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CommercialInvoiceDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            self.Format.export(outfile, level, namespace_, name_='Format', pretty_print=pretty_print)
        for CustomerImageUsages_ in self.CustomerImageUsages:
            CustomerImageUsages_.export(outfile, level, namespace_, name_='CustomerImageUsages', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
        elif nodeName_ == 'CustomerImageUsages':
            obj_ = CustomerImageUsage.factory()
            obj_.build(child_)
            self.CustomerImageUsages.append(obj_)
            obj_.original_tagname_ = 'CustomerImageUsages'
# end class CommercialInvoiceDetail


class Commodity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, NumberOfPieces=None, Description=None, Purpose=None, CountryOfManufacture=None, HarmonizedCode=None, Weight=None, Quantity=None, QuantityUnits=None, AdditionalMeasures=None, UnitPrice=None, CustomsValue=None, ExciseConditions=None, ExportLicenseNumber=None, ExportLicenseExpirationDate=None, CIMarksAndNumbers=None, PartNumber=None, NaftaDetail=None):
        self.original_tagname_ = None
        self.Name = Name
        self.NumberOfPieces = NumberOfPieces
        self.Description = Description
        self.Purpose = Purpose
        self.validate_CommodityPurposeType(self.Purpose)
        self.CountryOfManufacture = CountryOfManufacture
        self.HarmonizedCode = HarmonizedCode
        self.Weight = Weight
        self.Quantity = Quantity
        self.QuantityUnits = QuantityUnits
        if AdditionalMeasures is None:
            self.AdditionalMeasures = []
        else:
            self.AdditionalMeasures = AdditionalMeasures
        self.UnitPrice = UnitPrice
        self.CustomsValue = CustomsValue
        if ExciseConditions is None:
            self.ExciseConditions = []
        else:
            self.ExciseConditions = ExciseConditions
        self.ExportLicenseNumber = ExportLicenseNumber
        if isinstance(ExportLicenseExpirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ExportLicenseExpirationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ExportLicenseExpirationDate
        self.ExportLicenseExpirationDate = initvalue_
        self.CIMarksAndNumbers = CIMarksAndNumbers
        self.PartNumber = PartNumber
        self.NaftaDetail = NaftaDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Commodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Commodity.subclass:
            return Commodity.subclass(*args_, **kwargs_)
        else:
            return Commodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_NumberOfPieces(self): return self.NumberOfPieces
    def set_NumberOfPieces(self, NumberOfPieces): self.NumberOfPieces = NumberOfPieces
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    def get_CountryOfManufacture(self): return self.CountryOfManufacture
    def set_CountryOfManufacture(self, CountryOfManufacture): self.CountryOfManufacture = CountryOfManufacture
    def get_HarmonizedCode(self): return self.HarmonizedCode
    def set_HarmonizedCode(self, HarmonizedCode): self.HarmonizedCode = HarmonizedCode
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def get_QuantityUnits(self): return self.QuantityUnits
    def set_QuantityUnits(self, QuantityUnits): self.QuantityUnits = QuantityUnits
    def get_AdditionalMeasures(self): return self.AdditionalMeasures
    def set_AdditionalMeasures(self, AdditionalMeasures): self.AdditionalMeasures = AdditionalMeasures
    def add_AdditionalMeasures(self, value): self.AdditionalMeasures.append(value)
    def insert_AdditionalMeasures_at(self, index, value): self.AdditionalMeasures.insert(index, value)
    def replace_AdditionalMeasures_at(self, index, value): self.AdditionalMeasures[index] = value
    def get_UnitPrice(self): return self.UnitPrice
    def set_UnitPrice(self, UnitPrice): self.UnitPrice = UnitPrice
    def get_CustomsValue(self): return self.CustomsValue
    def set_CustomsValue(self, CustomsValue): self.CustomsValue = CustomsValue
    def get_ExciseConditions(self): return self.ExciseConditions
    def set_ExciseConditions(self, ExciseConditions): self.ExciseConditions = ExciseConditions
    def add_ExciseConditions(self, value): self.ExciseConditions.append(value)
    def insert_ExciseConditions_at(self, index, value): self.ExciseConditions.insert(index, value)
    def replace_ExciseConditions_at(self, index, value): self.ExciseConditions[index] = value
    def get_ExportLicenseNumber(self): return self.ExportLicenseNumber
    def set_ExportLicenseNumber(self, ExportLicenseNumber): self.ExportLicenseNumber = ExportLicenseNumber
    def get_ExportLicenseExpirationDate(self): return self.ExportLicenseExpirationDate
    def set_ExportLicenseExpirationDate(self, ExportLicenseExpirationDate): self.ExportLicenseExpirationDate = ExportLicenseExpirationDate
    def get_CIMarksAndNumbers(self): return self.CIMarksAndNumbers
    def set_CIMarksAndNumbers(self, CIMarksAndNumbers): self.CIMarksAndNumbers = CIMarksAndNumbers
    def get_PartNumber(self): return self.PartNumber
    def set_PartNumber(self, PartNumber): self.PartNumber = PartNumber
    def get_NaftaDetail(self): return self.NaftaDetail
    def set_NaftaDetail(self, NaftaDetail): self.NaftaDetail = NaftaDetail
    def validate_CommodityPurposeType(self, value):
        # Validate type CommodityPurposeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BUSINESS', 'CONSUMER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommodityPurposeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.NumberOfPieces is not None or
            self.Description is not None or
            self.Purpose is not None or
            self.CountryOfManufacture is not None or
            self.HarmonizedCode is not None or
            self.Weight is not None or
            self.Quantity is not None or
            self.QuantityUnits is not None or
            self.AdditionalMeasures or
            self.UnitPrice is not None or
            self.CustomsValue is not None or
            self.ExciseConditions or
            self.ExportLicenseNumber is not None or
            self.ExportLicenseExpirationDate is not None or
            self.CIMarksAndNumbers is not None or
            self.PartNumber is not None or
            self.NaftaDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Commodity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Commodity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Commodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Commodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Commodity'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Commodity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Name>%s</ns:Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.NumberOfPieces is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:NumberOfPieces>%s</ns:NumberOfPieces>%s' % (self.gds_format_integer(self.NumberOfPieces, input_name='NumberOfPieces'), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Purpose is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Purpose>%s</ns:Purpose>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Purpose), input_name='Purpose')), eol_))
        if self.CountryOfManufacture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CountryOfManufacture>%s</ns:CountryOfManufacture>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryOfManufacture), input_name='CountryOfManufacture')), eol_))
        if self.HarmonizedCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HarmonizedCode>%s</ns:HarmonizedCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HarmonizedCode), input_name='HarmonizedCode')), eol_))
        if self.Weight is not None:
            self.Weight.export(outfile, level, namespace_, name_='Weight', pretty_print=pretty_print)
        if self.Quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Quantity>%s</ns:Quantity>%s' % (self.gds_format_float(self.Quantity, input_name='Quantity'), eol_))
        if self.QuantityUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:QuantityUnits>%s</ns:QuantityUnits>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.QuantityUnits), input_name='QuantityUnits')), eol_))
        for AdditionalMeasures_ in self.AdditionalMeasures:
            AdditionalMeasures_.export(outfile, level, namespace_, name_='AdditionalMeasures', pretty_print=pretty_print)
        if self.UnitPrice is not None:
            self.UnitPrice.export(outfile, level, namespace_, name_='UnitPrice', pretty_print=pretty_print)
        if self.CustomsValue is not None:
            self.CustomsValue.export(outfile, level, namespace_, name_='CustomsValue', pretty_print=pretty_print)
        for ExciseConditions_ in self.ExciseConditions:
            ExciseConditions_.export(outfile, level, namespace_, name_='ExciseConditions', pretty_print=pretty_print)
        if self.ExportLicenseNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ExportLicenseNumber>%s</ns:ExportLicenseNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ExportLicenseNumber), input_name='ExportLicenseNumber')), eol_))
        if self.ExportLicenseExpirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ExportLicenseExpirationDate>%s</ns:ExportLicenseExpirationDate>%s' % (self.gds_format_date(self.ExportLicenseExpirationDate, input_name='ExportLicenseExpirationDate'), eol_))
        if self.CIMarksAndNumbers is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CIMarksAndNumbers>%s</ns:CIMarksAndNumbers>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CIMarksAndNumbers), input_name='CIMarksAndNumbers')), eol_))
        if self.PartNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PartNumber>%s</ns:PartNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PartNumber), input_name='PartNumber')), eol_))
        if self.NaftaDetail is not None:
            self.NaftaDetail.export(outfile, level, namespace_, name_='NaftaDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'NumberOfPieces':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfPieces')
            self.NumberOfPieces = ival_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Purpose':
            Purpose_ = child_.text
            Purpose_ = self.gds_validate_string(Purpose_, node, 'Purpose')
            self.Purpose = Purpose_
            # validate type CommodityPurposeType
            self.validate_CommodityPurposeType(self.Purpose)
        elif nodeName_ == 'CountryOfManufacture':
            CountryOfManufacture_ = child_.text
            CountryOfManufacture_ = self.gds_validate_string(CountryOfManufacture_, node, 'CountryOfManufacture')
            self.CountryOfManufacture = CountryOfManufacture_
        elif nodeName_ == 'HarmonizedCode':
            HarmonizedCode_ = child_.text
            HarmonizedCode_ = self.gds_validate_string(HarmonizedCode_, node, 'HarmonizedCode')
            self.HarmonizedCode = HarmonizedCode_
        elif nodeName_ == 'Weight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.Weight = obj_
            obj_.original_tagname_ = 'Weight'
        elif nodeName_ == 'Quantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Quantity')
            self.Quantity = fval_
        elif nodeName_ == 'QuantityUnits':
            QuantityUnits_ = child_.text
            QuantityUnits_ = self.gds_validate_string(QuantityUnits_, node, 'QuantityUnits')
            self.QuantityUnits = QuantityUnits_
        elif nodeName_ == 'AdditionalMeasures':
            obj_ = Measure.factory()
            obj_.build(child_)
            self.AdditionalMeasures.append(obj_)
            obj_.original_tagname_ = 'AdditionalMeasures'
        elif nodeName_ == 'UnitPrice':
            obj_ = Money.factory()
            obj_.build(child_)
            self.UnitPrice = obj_
            obj_.original_tagname_ = 'UnitPrice'
        elif nodeName_ == 'CustomsValue':
            obj_ = Money.factory()
            obj_.build(child_)
            self.CustomsValue = obj_
            obj_.original_tagname_ = 'CustomsValue'
        elif nodeName_ == 'ExciseConditions':
            obj_ = EdtExciseCondition.factory()
            obj_.build(child_)
            self.ExciseConditions.append(obj_)
            obj_.original_tagname_ = 'ExciseConditions'
        elif nodeName_ == 'ExportLicenseNumber':
            ExportLicenseNumber_ = child_.text
            ExportLicenseNumber_ = self.gds_validate_string(ExportLicenseNumber_, node, 'ExportLicenseNumber')
            self.ExportLicenseNumber = ExportLicenseNumber_
        elif nodeName_ == 'ExportLicenseExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ExportLicenseExpirationDate = dval_
        elif nodeName_ == 'CIMarksAndNumbers':
            CIMarksAndNumbers_ = child_.text
            CIMarksAndNumbers_ = self.gds_validate_string(CIMarksAndNumbers_, node, 'CIMarksAndNumbers')
            self.CIMarksAndNumbers = CIMarksAndNumbers_
        elif nodeName_ == 'PartNumber':
            PartNumber_ = child_.text
            PartNumber_ = self.gds_validate_string(PartNumber_, node, 'PartNumber')
            self.PartNumber = PartNumber_
        elif nodeName_ == 'NaftaDetail':
            obj_ = NaftaCommodityDetail.factory()
            obj_.build(child_)
            self.NaftaDetail = obj_
            obj_.original_tagname_ = 'NaftaDetail'
# end class Commodity


class CompletedCodDetail(GeneratedsSuper):
    """Specifies the results of processing for the COD special service."""
    subclass = None
    superclass = None
    def __init__(self, CollectionAmount=None, AdjustmentType=None):
        self.original_tagname_ = None
        self.CollectionAmount = CollectionAmount
        self.AdjustmentType = AdjustmentType
        self.validate_CodAdjustmentType(self.AdjustmentType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedCodDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedCodDetail.subclass:
            return CompletedCodDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedCodDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CollectionAmount(self): return self.CollectionAmount
    def set_CollectionAmount(self, CollectionAmount): self.CollectionAmount = CollectionAmount
    def get_AdjustmentType(self): return self.AdjustmentType
    def set_AdjustmentType(self, AdjustmentType): self.AdjustmentType = AdjustmentType
    def validate_CodAdjustmentType(self, value):
        # Validate type CodAdjustmentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CHARGES_ADDED', 'NONE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CodAdjustmentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CollectionAmount is not None or
            self.AdjustmentType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedCodDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedCodDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedCodDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedCodDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedCodDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedCodDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CollectionAmount is not None:
            self.CollectionAmount.export(outfile, level, namespace_, name_='CollectionAmount', pretty_print=pretty_print)
        if self.AdjustmentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AdjustmentType>%s</ns:AdjustmentType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AdjustmentType), input_name='AdjustmentType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CollectionAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.CollectionAmount = obj_
            obj_.original_tagname_ = 'CollectionAmount'
        elif nodeName_ == 'AdjustmentType':
            AdjustmentType_ = child_.text
            AdjustmentType_ = self.gds_validate_string(AdjustmentType_, node, 'AdjustmentType')
            self.AdjustmentType = AdjustmentType_
            # validate type CodAdjustmentType
            self.validate_CodAdjustmentType(self.AdjustmentType)
# end class CompletedCodDetail


class CompletedEtdDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FolderId=None, Type=None, UploadDocumentReferenceDetails=None):
        self.original_tagname_ = None
        self.FolderId = FolderId
        self.Type = Type
        self.validate_CompletedEtdType(self.Type)
        if UploadDocumentReferenceDetails is None:
            self.UploadDocumentReferenceDetails = []
        else:
            self.UploadDocumentReferenceDetails = UploadDocumentReferenceDetails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedEtdDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedEtdDetail.subclass:
            return CompletedEtdDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedEtdDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FolderId(self): return self.FolderId
    def set_FolderId(self, FolderId): self.FolderId = FolderId
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_UploadDocumentReferenceDetails(self): return self.UploadDocumentReferenceDetails
    def set_UploadDocumentReferenceDetails(self, UploadDocumentReferenceDetails): self.UploadDocumentReferenceDetails = UploadDocumentReferenceDetails
    def add_UploadDocumentReferenceDetails(self, value): self.UploadDocumentReferenceDetails.append(value)
    def insert_UploadDocumentReferenceDetails_at(self, index, value): self.UploadDocumentReferenceDetails.insert(index, value)
    def replace_UploadDocumentReferenceDetails_at(self, index, value): self.UploadDocumentReferenceDetails[index] = value
    def validate_CompletedEtdType(self, value):
        # Validate type CompletedEtdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ELECTRONIC_DOCUMENTS_ONLY', 'ELECTRONIC_DOCUMENTS_WITH_ORIGINALS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CompletedEtdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FolderId is not None or
            self.Type is not None or
            self.UploadDocumentReferenceDetails
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedEtdDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedEtdDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedEtdDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedEtdDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedEtdDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedEtdDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FolderId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FolderId>%s</ns:FolderId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FolderId), input_name='FolderId')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        for UploadDocumentReferenceDetails_ in self.UploadDocumentReferenceDetails:
            UploadDocumentReferenceDetails_.export(outfile, level, namespace_, name_='UploadDocumentReferenceDetails', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FolderId':
            FolderId_ = child_.text
            FolderId_ = self.gds_validate_string(FolderId_, node, 'FolderId')
            self.FolderId = FolderId_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type CompletedEtdType
            self.validate_CompletedEtdType(self.Type)
        elif nodeName_ == 'UploadDocumentReferenceDetails':
            obj_ = UploadDocumentReferenceDetail.factory()
            obj_.build(child_)
            self.UploadDocumentReferenceDetails.append(obj_)
            obj_.original_tagname_ = 'UploadDocumentReferenceDetails'
# end class CompletedEtdDetail


class CompletedHazardousPackageDetail(GeneratedsSuper):
    """Completed package-level hazardous commodity information for a single
    package."""
    subclass = None
    superclass = None
    def __init__(self, ReferenceId=None, Accessibility=None, CargoAircraftOnly=None, Regulation=None, RadioactiveTransportIndex=None, LabelType=None, Containers=None):
        self.original_tagname_ = None
        self.ReferenceId = ReferenceId
        self.Accessibility = Accessibility
        self.validate_DangerousGoodsAccessibilityType(self.Accessibility)
        self.CargoAircraftOnly = CargoAircraftOnly
        self.Regulation = Regulation
        self.validate_HazardousCommodityRegulationType(self.Regulation)
        self.RadioactiveTransportIndex = RadioactiveTransportIndex
        self.LabelType = LabelType
        self.validate_RadioactiveLabelType(self.LabelType)
        if Containers is None:
            self.Containers = []
        else:
            self.Containers = Containers
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedHazardousPackageDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedHazardousPackageDetail.subclass:
            return CompletedHazardousPackageDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedHazardousPackageDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReferenceId(self): return self.ReferenceId
    def set_ReferenceId(self, ReferenceId): self.ReferenceId = ReferenceId
    def get_Accessibility(self): return self.Accessibility
    def set_Accessibility(self, Accessibility): self.Accessibility = Accessibility
    def get_CargoAircraftOnly(self): return self.CargoAircraftOnly
    def set_CargoAircraftOnly(self, CargoAircraftOnly): self.CargoAircraftOnly = CargoAircraftOnly
    def get_Regulation(self): return self.Regulation
    def set_Regulation(self, Regulation): self.Regulation = Regulation
    def get_RadioactiveTransportIndex(self): return self.RadioactiveTransportIndex
    def set_RadioactiveTransportIndex(self, RadioactiveTransportIndex): self.RadioactiveTransportIndex = RadioactiveTransportIndex
    def get_LabelType(self): return self.LabelType
    def set_LabelType(self, LabelType): self.LabelType = LabelType
    def get_Containers(self): return self.Containers
    def set_Containers(self, Containers): self.Containers = Containers
    def add_Containers(self, value): self.Containers.append(value)
    def insert_Containers_at(self, index, value): self.Containers.insert(index, value)
    def replace_Containers_at(self, index, value): self.Containers[index] = value
    def validate_DangerousGoodsAccessibilityType(self, value):
        # Validate type DangerousGoodsAccessibilityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACCESSIBLE', 'INACCESSIBLE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DangerousGoodsAccessibilityType' % {"value" : value.encode("utf-8")} )
    def validate_HazardousCommodityRegulationType(self, value):
        # Validate type HazardousCommodityRegulationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADR', 'DOT', 'IATA', 'ORMD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityRegulationType' % {"value" : value.encode("utf-8")} )
    def validate_RadioactiveLabelType(self, value):
        # Validate type RadioactiveLabelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['III_YELLOW', 'II_YELLOW', 'I_WHITE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RadioactiveLabelType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ReferenceId is not None or
            self.Accessibility is not None or
            self.CargoAircraftOnly is not None or
            self.Regulation is not None or
            self.RadioactiveTransportIndex is not None or
            self.LabelType is not None or
            self.Containers
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedHazardousPackageDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedHazardousPackageDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedHazardousPackageDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedHazardousPackageDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedHazardousPackageDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedHazardousPackageDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReferenceId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ReferenceId>%s</ns:ReferenceId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceId), input_name='ReferenceId')), eol_))
        if self.Accessibility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Accessibility>%s</ns:Accessibility>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Accessibility), input_name='Accessibility')), eol_))
        if self.CargoAircraftOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CargoAircraftOnly>%s</ns:CargoAircraftOnly>%s' % (self.gds_format_boolean(self.CargoAircraftOnly, input_name='CargoAircraftOnly'), eol_))
        if self.Regulation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Regulation>%s</ns:Regulation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Regulation), input_name='Regulation')), eol_))
        if self.RadioactiveTransportIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RadioactiveTransportIndex>%s</ns:RadioactiveTransportIndex>%s' % (self.gds_format_float(self.RadioactiveTransportIndex, input_name='RadioactiveTransportIndex'), eol_))
        if self.LabelType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelType>%s</ns:LabelType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelType), input_name='LabelType')), eol_))
        for Containers_ in self.Containers:
            Containers_.export(outfile, level, namespace_, name_='Containers', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReferenceId':
            ReferenceId_ = child_.text
            ReferenceId_ = self.gds_validate_string(ReferenceId_, node, 'ReferenceId')
            self.ReferenceId = ReferenceId_
        elif nodeName_ == 'Accessibility':
            Accessibility_ = child_.text
            Accessibility_ = self.gds_validate_string(Accessibility_, node, 'Accessibility')
            self.Accessibility = Accessibility_
            # validate type DangerousGoodsAccessibilityType
            self.validate_DangerousGoodsAccessibilityType(self.Accessibility)
        elif nodeName_ == 'CargoAircraftOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CargoAircraftOnly')
            self.CargoAircraftOnly = ival_
        elif nodeName_ == 'Regulation':
            Regulation_ = child_.text
            Regulation_ = self.gds_validate_string(Regulation_, node, 'Regulation')
            self.Regulation = Regulation_
            # validate type HazardousCommodityRegulationType
            self.validate_HazardousCommodityRegulationType(self.Regulation)
        elif nodeName_ == 'RadioactiveTransportIndex':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'RadioactiveTransportIndex')
            self.RadioactiveTransportIndex = fval_
        elif nodeName_ == 'LabelType':
            LabelType_ = child_.text
            LabelType_ = self.gds_validate_string(LabelType_, node, 'LabelType')
            self.LabelType = LabelType_
            # validate type RadioactiveLabelType
            self.validate_RadioactiveLabelType(self.LabelType)
        elif nodeName_ == 'Containers':
            obj_ = ValidatedHazardousContainer.factory()
            obj_.build(child_)
            self.Containers.append(obj_)
            obj_.original_tagname_ = 'Containers'
# end class CompletedHazardousPackageDetail


class CompletedHazardousShipmentDetail(GeneratedsSuper):
    """Computed shipment level hazardous commodity information."""
    subclass = None
    superclass = None
    def __init__(self, HazardousSummaryDetail=None, DryIceDetail=None, AdrLicense=None):
        self.original_tagname_ = None
        self.HazardousSummaryDetail = HazardousSummaryDetail
        self.DryIceDetail = DryIceDetail
        self.AdrLicense = AdrLicense
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedHazardousShipmentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedHazardousShipmentDetail.subclass:
            return CompletedHazardousShipmentDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedHazardousShipmentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HazardousSummaryDetail(self): return self.HazardousSummaryDetail
    def set_HazardousSummaryDetail(self, HazardousSummaryDetail): self.HazardousSummaryDetail = HazardousSummaryDetail
    def get_DryIceDetail(self): return self.DryIceDetail
    def set_DryIceDetail(self, DryIceDetail): self.DryIceDetail = DryIceDetail
    def get_AdrLicense(self): return self.AdrLicense
    def set_AdrLicense(self, AdrLicense): self.AdrLicense = AdrLicense
    def hasContent_(self):
        if (
            self.HazardousSummaryDetail is not None or
            self.DryIceDetail is not None or
            self.AdrLicense is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedHazardousShipmentDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedHazardousShipmentDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedHazardousShipmentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedHazardousShipmentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedHazardousShipmentDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedHazardousShipmentDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HazardousSummaryDetail is not None:
            self.HazardousSummaryDetail.export(outfile, level, namespace_, name_='HazardousSummaryDetail', pretty_print=pretty_print)
        if self.DryIceDetail is not None:
            self.DryIceDetail.export(outfile, level, namespace_, name_='DryIceDetail', pretty_print=pretty_print)
        if self.AdrLicense is not None:
            self.AdrLicense.export(outfile, level, namespace_, name_='AdrLicense', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HazardousSummaryDetail':
            obj_ = CompletedHazardousSummaryDetail.factory()
            obj_.build(child_)
            self.HazardousSummaryDetail = obj_
            obj_.original_tagname_ = 'HazardousSummaryDetail'
        elif nodeName_ == 'DryIceDetail':
            obj_ = ShipmentDryIceDetail.factory()
            obj_.build(child_)
            self.DryIceDetail = obj_
            obj_.original_tagname_ = 'DryIceDetail'
        elif nodeName_ == 'AdrLicense':
            obj_ = AdrLicenseDetail.factory()
            obj_.build(child_)
            self.AdrLicense = obj_
            obj_.original_tagname_ = 'AdrLicense'
# end class CompletedHazardousShipmentDetail


class CompletedHazardousSummaryDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SmallQuantityExceptionPackageCount=None):
        self.original_tagname_ = None
        self.SmallQuantityExceptionPackageCount = SmallQuantityExceptionPackageCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedHazardousSummaryDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedHazardousSummaryDetail.subclass:
            return CompletedHazardousSummaryDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedHazardousSummaryDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SmallQuantityExceptionPackageCount(self): return self.SmallQuantityExceptionPackageCount
    def set_SmallQuantityExceptionPackageCount(self, SmallQuantityExceptionPackageCount): self.SmallQuantityExceptionPackageCount = SmallQuantityExceptionPackageCount
    def hasContent_(self):
        if (
            self.SmallQuantityExceptionPackageCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedHazardousSummaryDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedHazardousSummaryDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedHazardousSummaryDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedHazardousSummaryDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedHazardousSummaryDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedHazardousSummaryDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SmallQuantityExceptionPackageCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SmallQuantityExceptionPackageCount>%s</ns:SmallQuantityExceptionPackageCount>%s' % (self.gds_format_integer(self.SmallQuantityExceptionPackageCount, input_name='SmallQuantityExceptionPackageCount'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SmallQuantityExceptionPackageCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SmallQuantityExceptionPackageCount')
            self.SmallQuantityExceptionPackageCount = ival_
# end class CompletedHazardousSummaryDetail


class CompletedHoldAtLocationDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HoldingLocation=None, HoldingLocationType=None):
        self.original_tagname_ = None
        self.HoldingLocation = HoldingLocation
        self.HoldingLocationType = HoldingLocationType
        self.validate_FedExLocationType(self.HoldingLocationType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedHoldAtLocationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedHoldAtLocationDetail.subclass:
            return CompletedHoldAtLocationDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedHoldAtLocationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HoldingLocation(self): return self.HoldingLocation
    def set_HoldingLocation(self, HoldingLocation): self.HoldingLocation = HoldingLocation
    def get_HoldingLocationType(self): return self.HoldingLocationType
    def set_HoldingLocationType(self, HoldingLocationType): self.HoldingLocationType = HoldingLocationType
    def validate_FedExLocationType(self, value):
        # Validate type FedExLocationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEDEX_EXPRESS_STATION', 'FEDEX_FACILITY', 'FEDEX_FREIGHT_SERVICE_CENTER', 'FEDEX_GROUND_TERMINAL', 'FEDEX_HOME_DELIVERY_STATION', 'FEDEX_OFFICE', 'FEDEX_SHIPSITE', 'FEDEX_SMART_POST_HUB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FedExLocationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.HoldingLocation is not None or
            self.HoldingLocationType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedHoldAtLocationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedHoldAtLocationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedHoldAtLocationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedHoldAtLocationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedHoldAtLocationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedHoldAtLocationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HoldingLocation is not None:
            self.HoldingLocation.export(outfile, level, namespace_, name_='HoldingLocation', pretty_print=pretty_print)
        if self.HoldingLocationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HoldingLocationType>%s</ns:HoldingLocationType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HoldingLocationType), input_name='HoldingLocationType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HoldingLocation':
            obj_ = ContactAndAddress.factory()
            obj_.build(child_)
            self.HoldingLocation = obj_
            obj_.original_tagname_ = 'HoldingLocation'
        elif nodeName_ == 'HoldingLocationType':
            HoldingLocationType_ = child_.text
            HoldingLocationType_ = self.gds_validate_string(HoldingLocationType_, node, 'HoldingLocationType')
            self.HoldingLocationType = HoldingLocationType_
            # validate type FedExLocationType
            self.validate_FedExLocationType(self.HoldingLocationType)
# end class CompletedHoldAtLocationDetail


class CompletedPackageDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SequenceNumber=None, TrackingIds=None, GroupNumber=None, OversizeClass=None, PackageRating=None, OperationalDetail=None, Label=None, PackageDocuments=None, CodReturnDetail=None, SignatureOption=None, DryIceWeight=None, HazardousPackageDetail=None):
        self.original_tagname_ = None
        self.SequenceNumber = SequenceNumber
        if TrackingIds is None:
            self.TrackingIds = []
        else:
            self.TrackingIds = TrackingIds
        self.GroupNumber = GroupNumber
        self.OversizeClass = OversizeClass
        self.validate_OversizeClassType(self.OversizeClass)
        self.PackageRating = PackageRating
        self.OperationalDetail = OperationalDetail
        self.Label = Label
        if PackageDocuments is None:
            self.PackageDocuments = []
        else:
            self.PackageDocuments = PackageDocuments
        self.CodReturnDetail = CodReturnDetail
        self.SignatureOption = SignatureOption
        self.validate_SignatureOptionType(self.SignatureOption)
        self.DryIceWeight = DryIceWeight
        self.HazardousPackageDetail = HazardousPackageDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedPackageDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedPackageDetail.subclass:
            return CompletedPackageDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedPackageDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SequenceNumber(self): return self.SequenceNumber
    def set_SequenceNumber(self, SequenceNumber): self.SequenceNumber = SequenceNumber
    def get_TrackingIds(self): return self.TrackingIds
    def set_TrackingIds(self, TrackingIds): self.TrackingIds = TrackingIds
    def add_TrackingIds(self, value): self.TrackingIds.append(value)
    def insert_TrackingIds_at(self, index, value): self.TrackingIds.insert(index, value)
    def replace_TrackingIds_at(self, index, value): self.TrackingIds[index] = value
    def get_GroupNumber(self): return self.GroupNumber
    def set_GroupNumber(self, GroupNumber): self.GroupNumber = GroupNumber
    def get_OversizeClass(self): return self.OversizeClass
    def set_OversizeClass(self, OversizeClass): self.OversizeClass = OversizeClass
    def get_PackageRating(self): return self.PackageRating
    def set_PackageRating(self, PackageRating): self.PackageRating = PackageRating
    def get_OperationalDetail(self): return self.OperationalDetail
    def set_OperationalDetail(self, OperationalDetail): self.OperationalDetail = OperationalDetail
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_PackageDocuments(self): return self.PackageDocuments
    def set_PackageDocuments(self, PackageDocuments): self.PackageDocuments = PackageDocuments
    def add_PackageDocuments(self, value): self.PackageDocuments.append(value)
    def insert_PackageDocuments_at(self, index, value): self.PackageDocuments.insert(index, value)
    def replace_PackageDocuments_at(self, index, value): self.PackageDocuments[index] = value
    def get_CodReturnDetail(self): return self.CodReturnDetail
    def set_CodReturnDetail(self, CodReturnDetail): self.CodReturnDetail = CodReturnDetail
    def get_SignatureOption(self): return self.SignatureOption
    def set_SignatureOption(self, SignatureOption): self.SignatureOption = SignatureOption
    def get_DryIceWeight(self): return self.DryIceWeight
    def set_DryIceWeight(self, DryIceWeight): self.DryIceWeight = DryIceWeight
    def get_HazardousPackageDetail(self): return self.HazardousPackageDetail
    def set_HazardousPackageDetail(self, HazardousPackageDetail): self.HazardousPackageDetail = HazardousPackageDetail
    def validate_OversizeClassType(self, value):
        # Validate type OversizeClassType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['OVERSIZE_1', 'OVERSIZE_2', 'OVERSIZE_3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OversizeClassType' % {"value" : value.encode("utf-8")} )
    def validate_SignatureOptionType(self, value):
        # Validate type SignatureOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADULT', 'DIRECT', 'INDIRECT', 'NO_SIGNATURE_REQUIRED', 'SERVICE_DEFAULT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SignatureOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SequenceNumber is not None or
            self.TrackingIds or
            self.GroupNumber is not None or
            self.OversizeClass is not None or
            self.PackageRating is not None or
            self.OperationalDetail is not None or
            self.Label is not None or
            self.PackageDocuments or
            self.CodReturnDetail is not None or
            self.SignatureOption is not None or
            self.DryIceWeight is not None or
            self.HazardousPackageDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedPackageDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedPackageDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedPackageDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedPackageDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedPackageDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedPackageDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SequenceNumber>%s</ns:SequenceNumber>%s' % (self.gds_format_integer(self.SequenceNumber, input_name='SequenceNumber'), eol_))
        for TrackingIds_ in self.TrackingIds:
            TrackingIds_.export(outfile, level, namespace_, name_='TrackingIds', pretty_print=pretty_print)
        if self.GroupNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:GroupNumber>%s</ns:GroupNumber>%s' % (self.gds_format_integer(self.GroupNumber, input_name='GroupNumber'), eol_))
        if self.OversizeClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:OversizeClass>%s</ns:OversizeClass>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OversizeClass), input_name='OversizeClass')), eol_))
        if self.PackageRating is not None:
            self.PackageRating.export(outfile, level, namespace_, name_='PackageRating', pretty_print=pretty_print)
        if self.OperationalDetail is not None:
            self.OperationalDetail.export(outfile, level, namespace_, name_='OperationalDetail', pretty_print=pretty_print)
        if self.Label is not None:
            self.Label.export(outfile, level, namespace_, name_='Label', pretty_print=pretty_print)
        for PackageDocuments_ in self.PackageDocuments:
            PackageDocuments_.export(outfile, level, namespace_, name_='PackageDocuments', pretty_print=pretty_print)
        if self.CodReturnDetail is not None:
            self.CodReturnDetail.export(outfile, level, namespace_, name_='CodReturnDetail', pretty_print=pretty_print)
        if self.SignatureOption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SignatureOption>%s</ns:SignatureOption>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SignatureOption), input_name='SignatureOption')), eol_))
        if self.DryIceWeight is not None:
            self.DryIceWeight.export(outfile, level, namespace_, name_='DryIceWeight', pretty_print=pretty_print)
        if self.HazardousPackageDetail is not None:
            self.HazardousPackageDetail.export(outfile, level, namespace_, name_='HazardousPackageDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SequenceNumber')
            self.SequenceNumber = ival_
        elif nodeName_ == 'TrackingIds':
            obj_ = TrackingId.factory()
            obj_.build(child_)
            self.TrackingIds.append(obj_)
            obj_.original_tagname_ = 'TrackingIds'
        elif nodeName_ == 'GroupNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'GroupNumber')
            self.GroupNumber = ival_
        elif nodeName_ == 'OversizeClass':
            OversizeClass_ = child_.text
            OversizeClass_ = self.gds_validate_string(OversizeClass_, node, 'OversizeClass')
            self.OversizeClass = OversizeClass_
            # validate type OversizeClassType
            self.validate_OversizeClassType(self.OversizeClass)
        elif nodeName_ == 'PackageRating':
            obj_ = PackageRating.factory()
            obj_.build(child_)
            self.PackageRating = obj_
            obj_.original_tagname_ = 'PackageRating'
        elif nodeName_ == 'OperationalDetail':
            obj_ = PackageOperationalDetail.factory()
            obj_.build(child_)
            self.OperationalDetail = obj_
            obj_.original_tagname_ = 'OperationalDetail'
        elif nodeName_ == 'Label':
            obj_ = ShippingDocument.factory()
            obj_.build(child_)
            self.Label = obj_
            obj_.original_tagname_ = 'Label'
        elif nodeName_ == 'PackageDocuments':
            obj_ = ShippingDocument.factory()
            obj_.build(child_)
            self.PackageDocuments.append(obj_)
            obj_.original_tagname_ = 'PackageDocuments'
        elif nodeName_ == 'CodReturnDetail':
            obj_ = CodReturnPackageDetail.factory()
            obj_.build(child_)
            self.CodReturnDetail = obj_
            obj_.original_tagname_ = 'CodReturnDetail'
        elif nodeName_ == 'SignatureOption':
            SignatureOption_ = child_.text
            SignatureOption_ = self.gds_validate_string(SignatureOption_, node, 'SignatureOption')
            self.SignatureOption = SignatureOption_
            # validate type SignatureOptionType
            self.validate_SignatureOptionType(self.SignatureOption)
        elif nodeName_ == 'DryIceWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.DryIceWeight = obj_
            obj_.original_tagname_ = 'DryIceWeight'
        elif nodeName_ == 'HazardousPackageDetail':
            obj_ = CompletedHazardousPackageDetail.factory()
            obj_.build(child_)
            self.HazardousPackageDetail = obj_
            obj_.original_tagname_ = 'HazardousPackageDetail'
# end class CompletedPackageDetail


class CompletedShipmentDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UsDomestic=None, CarrierCode=None, MasterTrackingId=None, ServiceTypeDescription=None, PackagingDescription=None, OperationalDetail=None, AccessDetail=None, TagDetail=None, SmartPostDetail=None, HazardousShipmentDetail=None, ShipmentRating=None, CompletedHoldAtLocationDetail=None, ExportComplianceStatement=None, DocumentRequirements=None, CompletedEtdDetail=None, ShipmentDocuments=None, AssociatedShipments=None, CompletedCodDetail=None, CompletedPackageDetails=None):
        self.original_tagname_ = None
        self.UsDomestic = UsDomestic
        self.CarrierCode = CarrierCode
        self.validate_CarrierCodeType(self.CarrierCode)
        self.MasterTrackingId = MasterTrackingId
        self.ServiceTypeDescription = ServiceTypeDescription
        self.PackagingDescription = PackagingDescription
        self.OperationalDetail = OperationalDetail
        self.AccessDetail = AccessDetail
        self.TagDetail = TagDetail
        self.SmartPostDetail = SmartPostDetail
        self.HazardousShipmentDetail = HazardousShipmentDetail
        self.ShipmentRating = ShipmentRating
        self.CompletedHoldAtLocationDetail = CompletedHoldAtLocationDetail
        self.ExportComplianceStatement = ExportComplianceStatement
        self.DocumentRequirements = DocumentRequirements
        self.CompletedEtdDetail = CompletedEtdDetail
        if ShipmentDocuments is None:
            self.ShipmentDocuments = []
        else:
            self.ShipmentDocuments = ShipmentDocuments
        if AssociatedShipments is None:
            self.AssociatedShipments = []
        else:
            self.AssociatedShipments = AssociatedShipments
        self.CompletedCodDetail = CompletedCodDetail
        if CompletedPackageDetails is None:
            self.CompletedPackageDetails = []
        else:
            self.CompletedPackageDetails = CompletedPackageDetails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedShipmentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedShipmentDetail.subclass:
            return CompletedShipmentDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedShipmentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UsDomestic(self): return self.UsDomestic
    def set_UsDomestic(self, UsDomestic): self.UsDomestic = UsDomestic
    def get_CarrierCode(self): return self.CarrierCode
    def set_CarrierCode(self, CarrierCode): self.CarrierCode = CarrierCode
    def get_MasterTrackingId(self): return self.MasterTrackingId
    def set_MasterTrackingId(self, MasterTrackingId): self.MasterTrackingId = MasterTrackingId
    def get_ServiceTypeDescription(self): return self.ServiceTypeDescription
    def set_ServiceTypeDescription(self, ServiceTypeDescription): self.ServiceTypeDescription = ServiceTypeDescription
    def get_PackagingDescription(self): return self.PackagingDescription
    def set_PackagingDescription(self, PackagingDescription): self.PackagingDescription = PackagingDescription
    def get_OperationalDetail(self): return self.OperationalDetail
    def set_OperationalDetail(self, OperationalDetail): self.OperationalDetail = OperationalDetail
    def get_AccessDetail(self): return self.AccessDetail
    def set_AccessDetail(self, AccessDetail): self.AccessDetail = AccessDetail
    def get_TagDetail(self): return self.TagDetail
    def set_TagDetail(self, TagDetail): self.TagDetail = TagDetail
    def get_SmartPostDetail(self): return self.SmartPostDetail
    def set_SmartPostDetail(self, SmartPostDetail): self.SmartPostDetail = SmartPostDetail
    def get_HazardousShipmentDetail(self): return self.HazardousShipmentDetail
    def set_HazardousShipmentDetail(self, HazardousShipmentDetail): self.HazardousShipmentDetail = HazardousShipmentDetail
    def get_ShipmentRating(self): return self.ShipmentRating
    def set_ShipmentRating(self, ShipmentRating): self.ShipmentRating = ShipmentRating
    def get_CompletedHoldAtLocationDetail(self): return self.CompletedHoldAtLocationDetail
    def set_CompletedHoldAtLocationDetail(self, CompletedHoldAtLocationDetail): self.CompletedHoldAtLocationDetail = CompletedHoldAtLocationDetail
    def get_ExportComplianceStatement(self): return self.ExportComplianceStatement
    def set_ExportComplianceStatement(self, ExportComplianceStatement): self.ExportComplianceStatement = ExportComplianceStatement
    def get_DocumentRequirements(self): return self.DocumentRequirements
    def set_DocumentRequirements(self, DocumentRequirements): self.DocumentRequirements = DocumentRequirements
    def get_CompletedEtdDetail(self): return self.CompletedEtdDetail
    def set_CompletedEtdDetail(self, CompletedEtdDetail): self.CompletedEtdDetail = CompletedEtdDetail
    def get_ShipmentDocuments(self): return self.ShipmentDocuments
    def set_ShipmentDocuments(self, ShipmentDocuments): self.ShipmentDocuments = ShipmentDocuments
    def add_ShipmentDocuments(self, value): self.ShipmentDocuments.append(value)
    def insert_ShipmentDocuments_at(self, index, value): self.ShipmentDocuments.insert(index, value)
    def replace_ShipmentDocuments_at(self, index, value): self.ShipmentDocuments[index] = value
    def get_AssociatedShipments(self): return self.AssociatedShipments
    def set_AssociatedShipments(self, AssociatedShipments): self.AssociatedShipments = AssociatedShipments
    def add_AssociatedShipments(self, value): self.AssociatedShipments.append(value)
    def insert_AssociatedShipments_at(self, index, value): self.AssociatedShipments.insert(index, value)
    def replace_AssociatedShipments_at(self, index, value): self.AssociatedShipments[index] = value
    def get_CompletedCodDetail(self): return self.CompletedCodDetail
    def set_CompletedCodDetail(self, CompletedCodDetail): self.CompletedCodDetail = CompletedCodDetail
    def get_CompletedPackageDetails(self): return self.CompletedPackageDetails
    def set_CompletedPackageDetails(self, CompletedPackageDetails): self.CompletedPackageDetails = CompletedPackageDetails
    def add_CompletedPackageDetails(self, value): self.CompletedPackageDetails.append(value)
    def insert_CompletedPackageDetails_at(self, index, value): self.CompletedPackageDetails.insert(index, value)
    def replace_CompletedPackageDetails_at(self, index, value): self.CompletedPackageDetails[index] = value
    def validate_CarrierCodeType(self, value):
        # Validate type CarrierCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FDXC', 'FDXE', 'FDXG', 'FXCC', 'FXFR', 'FXSP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CarrierCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.UsDomestic is not None or
            self.CarrierCode is not None or
            self.MasterTrackingId is not None or
            self.ServiceTypeDescription is not None or
            self.PackagingDescription is not None or
            self.OperationalDetail is not None or
            self.AccessDetail is not None or
            self.TagDetail is not None or
            self.SmartPostDetail is not None or
            self.HazardousShipmentDetail is not None or
            self.ShipmentRating is not None or
            self.CompletedHoldAtLocationDetail is not None or
            self.ExportComplianceStatement is not None or
            self.DocumentRequirements is not None or
            self.CompletedEtdDetail is not None or
            self.ShipmentDocuments or
            self.AssociatedShipments or
            self.CompletedCodDetail is not None or
            self.CompletedPackageDetails
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedShipmentDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedShipmentDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedShipmentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedShipmentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedShipmentDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedShipmentDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UsDomestic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:UsDomestic>%s</ns:UsDomestic>%s' % (self.gds_format_boolean(self.UsDomestic, input_name='UsDomestic'), eol_))
        if self.CarrierCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CarrierCode>%s</ns:CarrierCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CarrierCode), input_name='CarrierCode')), eol_))
        if self.MasterTrackingId is not None:
            self.MasterTrackingId.export(outfile, level, namespace_, name_='MasterTrackingId', pretty_print=pretty_print)
        if self.ServiceTypeDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ServiceTypeDescription>%s</ns:ServiceTypeDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceTypeDescription), input_name='ServiceTypeDescription')), eol_))
        if self.PackagingDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackagingDescription>%s</ns:PackagingDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackagingDescription), input_name='PackagingDescription')), eol_))
        if self.OperationalDetail is not None:
            self.OperationalDetail.export(outfile, level, namespace_, name_='OperationalDetail', pretty_print=pretty_print)
        if self.AccessDetail is not None:
            self.AccessDetail.export(outfile, level, namespace_, name_='AccessDetail', pretty_print=pretty_print)
        if self.TagDetail is not None:
            self.TagDetail.export(outfile, level, namespace_, name_='TagDetail', pretty_print=pretty_print)
        if self.SmartPostDetail is not None:
            self.SmartPostDetail.export(outfile, level, namespace_, name_='SmartPostDetail', pretty_print=pretty_print)
        if self.HazardousShipmentDetail is not None:
            self.HazardousShipmentDetail.export(outfile, level, namespace_, name_='HazardousShipmentDetail', pretty_print=pretty_print)
        if self.ShipmentRating is not None:
            self.ShipmentRating.export(outfile, level, namespace_, name_='ShipmentRating', pretty_print=pretty_print)
        if self.CompletedHoldAtLocationDetail is not None:
            self.CompletedHoldAtLocationDetail.export(outfile, level, namespace_, name_='CompletedHoldAtLocationDetail', pretty_print=pretty_print)
        if self.ExportComplianceStatement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ExportComplianceStatement>%s</ns:ExportComplianceStatement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ExportComplianceStatement), input_name='ExportComplianceStatement')), eol_))
        if self.DocumentRequirements is not None:
            self.DocumentRequirements.export(outfile, level, namespace_, name_='DocumentRequirements', pretty_print=pretty_print)
        if self.CompletedEtdDetail is not None:
            self.CompletedEtdDetail.export(outfile, level, namespace_, name_='CompletedEtdDetail', pretty_print=pretty_print)
        for ShipmentDocuments_ in self.ShipmentDocuments:
            ShipmentDocuments_.export(outfile, level, namespace_, name_='ShipmentDocuments', pretty_print=pretty_print)
        for AssociatedShipments_ in self.AssociatedShipments:
            AssociatedShipments_.export(outfile, level, namespace_, name_='AssociatedShipments', pretty_print=pretty_print)
        if self.CompletedCodDetail is not None:
            self.CompletedCodDetail.export(outfile, level, namespace_, name_='CompletedCodDetail', pretty_print=pretty_print)
        for CompletedPackageDetails_ in self.CompletedPackageDetails:
            CompletedPackageDetails_.export(outfile, level, namespace_, name_='CompletedPackageDetails', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UsDomestic':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'UsDomestic')
            self.UsDomestic = ival_
        elif nodeName_ == 'CarrierCode':
            CarrierCode_ = child_.text
            CarrierCode_ = self.gds_validate_string(CarrierCode_, node, 'CarrierCode')
            self.CarrierCode = CarrierCode_
            # validate type CarrierCodeType
            self.validate_CarrierCodeType(self.CarrierCode)
        elif nodeName_ == 'MasterTrackingId':
            obj_ = TrackingId.factory()
            obj_.build(child_)
            self.MasterTrackingId = obj_
            obj_.original_tagname_ = 'MasterTrackingId'
        elif nodeName_ == 'ServiceTypeDescription':
            ServiceTypeDescription_ = child_.text
            ServiceTypeDescription_ = self.gds_validate_string(ServiceTypeDescription_, node, 'ServiceTypeDescription')
            self.ServiceTypeDescription = ServiceTypeDescription_
        elif nodeName_ == 'PackagingDescription':
            PackagingDescription_ = child_.text
            PackagingDescription_ = self.gds_validate_string(PackagingDescription_, node, 'PackagingDescription')
            self.PackagingDescription = PackagingDescription_
        elif nodeName_ == 'OperationalDetail':
            obj_ = ShipmentOperationalDetail.factory()
            obj_.build(child_)
            self.OperationalDetail = obj_
            obj_.original_tagname_ = 'OperationalDetail'
        elif nodeName_ == 'AccessDetail':
            obj_ = PendingShipmentAccessDetail.factory()
            obj_.build(child_)
            self.AccessDetail = obj_
            obj_.original_tagname_ = 'AccessDetail'
        elif nodeName_ == 'TagDetail':
            obj_ = CompletedTagDetail.factory()
            obj_.build(child_)
            self.TagDetail = obj_
            obj_.original_tagname_ = 'TagDetail'
        elif nodeName_ == 'SmartPostDetail':
            obj_ = CompletedSmartPostDetail.factory()
            obj_.build(child_)
            self.SmartPostDetail = obj_
            obj_.original_tagname_ = 'SmartPostDetail'
        elif nodeName_ == 'HazardousShipmentDetail':
            obj_ = CompletedHazardousShipmentDetail.factory()
            obj_.build(child_)
            self.HazardousShipmentDetail = obj_
            obj_.original_tagname_ = 'HazardousShipmentDetail'
        elif nodeName_ == 'ShipmentRating':
            obj_ = ShipmentRating.factory()
            obj_.build(child_)
            self.ShipmentRating = obj_
            obj_.original_tagname_ = 'ShipmentRating'
        elif nodeName_ == 'CompletedHoldAtLocationDetail':
            obj_ = CompletedHoldAtLocationDetail.factory()
            obj_.build(child_)
            self.CompletedHoldAtLocationDetail = obj_
            obj_.original_tagname_ = 'CompletedHoldAtLocationDetail'
        elif nodeName_ == 'ExportComplianceStatement':
            ExportComplianceStatement_ = child_.text
            ExportComplianceStatement_ = self.gds_validate_string(ExportComplianceStatement_, node, 'ExportComplianceStatement')
            self.ExportComplianceStatement = ExportComplianceStatement_
        elif nodeName_ == 'DocumentRequirements':
            obj_ = DocumentRequirementsDetail.factory()
            obj_.build(child_)
            self.DocumentRequirements = obj_
            obj_.original_tagname_ = 'DocumentRequirements'
        elif nodeName_ == 'CompletedEtdDetail':
            obj_ = CompletedEtdDetail.factory()
            obj_.build(child_)
            self.CompletedEtdDetail = obj_
            obj_.original_tagname_ = 'CompletedEtdDetail'
        elif nodeName_ == 'ShipmentDocuments':
            obj_ = ShippingDocument.factory()
            obj_.build(child_)
            self.ShipmentDocuments.append(obj_)
            obj_.original_tagname_ = 'ShipmentDocuments'
        elif nodeName_ == 'AssociatedShipments':
            obj_ = AssociatedShipmentDetail.factory()
            obj_.build(child_)
            self.AssociatedShipments.append(obj_)
            obj_.original_tagname_ = 'AssociatedShipments'
        elif nodeName_ == 'CompletedCodDetail':
            obj_ = CompletedCodDetail.factory()
            obj_.build(child_)
            self.CompletedCodDetail = obj_
            obj_.original_tagname_ = 'CompletedCodDetail'
        elif nodeName_ == 'CompletedPackageDetails':
            obj_ = CompletedPackageDetail.factory()
            obj_.build(child_)
            self.CompletedPackageDetails.append(obj_)
            obj_.original_tagname_ = 'CompletedPackageDetails'
# end class CompletedShipmentDetail


class CompletedSmartPostDetail(GeneratedsSuper):
    """Provides reply information specific to SmartPost shipments."""
    subclass = None
    superclass = None
    def __init__(self, PickUpCarrier=None, Machinable=None):
        self.original_tagname_ = None
        self.PickUpCarrier = PickUpCarrier
        self.validate_CarrierCodeType(self.PickUpCarrier)
        self.Machinable = Machinable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedSmartPostDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedSmartPostDetail.subclass:
            return CompletedSmartPostDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedSmartPostDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PickUpCarrier(self): return self.PickUpCarrier
    def set_PickUpCarrier(self, PickUpCarrier): self.PickUpCarrier = PickUpCarrier
    def get_Machinable(self): return self.Machinable
    def set_Machinable(self, Machinable): self.Machinable = Machinable
    def validate_CarrierCodeType(self, value):
        # Validate type CarrierCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FDXC', 'FDXE', 'FDXG', 'FXCC', 'FXFR', 'FXSP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CarrierCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PickUpCarrier is not None or
            self.Machinable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedSmartPostDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedSmartPostDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedSmartPostDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedSmartPostDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedSmartPostDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedSmartPostDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PickUpCarrier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PickUpCarrier>%s</ns:PickUpCarrier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickUpCarrier), input_name='PickUpCarrier')), eol_))
        if self.Machinable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Machinable>%s</ns:Machinable>%s' % (self.gds_format_boolean(self.Machinable, input_name='Machinable'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PickUpCarrier':
            PickUpCarrier_ = child_.text
            PickUpCarrier_ = self.gds_validate_string(PickUpCarrier_, node, 'PickUpCarrier')
            self.PickUpCarrier = PickUpCarrier_
            # validate type CarrierCodeType
            self.validate_CarrierCodeType(self.PickUpCarrier)
        elif nodeName_ == 'Machinable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Machinable')
            self.Machinable = ival_
# end class CompletedSmartPostDetail


class CompletedTagDetail(GeneratedsSuper):
    """Provides reply information specific to a tag request."""
    subclass = None
    superclass = None
    def __init__(self, ConfirmationNumber=None, AccessTime=None, CutoffTime=None, Location=None, DeliveryCommitment=None, DispatchDate=None):
        self.original_tagname_ = None
        self.ConfirmationNumber = ConfirmationNumber
        self.AccessTime = AccessTime
        if isinstance(CutoffTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CutoffTime, '%H:%M:%S').time()
        else:
            initvalue_ = CutoffTime
        self.CutoffTime = initvalue_
        self.Location = Location
        if isinstance(DeliveryCommitment, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DeliveryCommitment, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DeliveryCommitment
        self.DeliveryCommitment = initvalue_
        if isinstance(DispatchDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DispatchDate, '%Y-%m-%d').date()
        else:
            initvalue_ = DispatchDate
        self.DispatchDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletedTagDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletedTagDetail.subclass:
            return CompletedTagDetail.subclass(*args_, **kwargs_)
        else:
            return CompletedTagDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConfirmationNumber(self): return self.ConfirmationNumber
    def set_ConfirmationNumber(self, ConfirmationNumber): self.ConfirmationNumber = ConfirmationNumber
    def get_AccessTime(self): return self.AccessTime
    def set_AccessTime(self, AccessTime): self.AccessTime = AccessTime
    def get_CutoffTime(self): return self.CutoffTime
    def set_CutoffTime(self, CutoffTime): self.CutoffTime = CutoffTime
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DeliveryCommitment(self): return self.DeliveryCommitment
    def set_DeliveryCommitment(self, DeliveryCommitment): self.DeliveryCommitment = DeliveryCommitment
    def get_DispatchDate(self): return self.DispatchDate
    def set_DispatchDate(self, DispatchDate): self.DispatchDate = DispatchDate
    def hasContent_(self):
        if (
            self.ConfirmationNumber is not None or
            self.AccessTime is not None or
            self.CutoffTime is not None or
            self.Location is not None or
            self.DeliveryCommitment is not None or
            self.DispatchDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CompletedTagDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletedTagDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompletedTagDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CompletedTagDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CompletedTagDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CompletedTagDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConfirmationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ConfirmationNumber>%s</ns:ConfirmationNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConfirmationNumber), input_name='ConfirmationNumber')), eol_))
        if self.AccessTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AccessTime>%s</ns:AccessTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AccessTime), input_name='AccessTime')), eol_))
        if self.CutoffTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CutoffTime>%s</ns:CutoffTime>%s' % (self.gds_format_time(self.CutoffTime, input_name='CutoffTime'), eol_))
        if self.Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Location>%s</ns:Location>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Location), input_name='Location')), eol_))
        if self.DeliveryCommitment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DeliveryCommitment>%s</ns:DeliveryCommitment>%s' % (self.gds_format_datetime(self.DeliveryCommitment, input_name='DeliveryCommitment'), eol_))
        if self.DispatchDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DispatchDate>%s</ns:DispatchDate>%s' % (self.gds_format_date(self.DispatchDate, input_name='DispatchDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConfirmationNumber':
            ConfirmationNumber_ = child_.text
            ConfirmationNumber_ = self.gds_validate_string(ConfirmationNumber_, node, 'ConfirmationNumber')
            self.ConfirmationNumber = ConfirmationNumber_
        elif nodeName_ == 'AccessTime':
            AccessTime_ = child_.text
            AccessTime_ = self.gds_validate_string(AccessTime_, node, 'AccessTime')
            self.AccessTime = AccessTime_
        elif nodeName_ == 'CutoffTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.CutoffTime = dval_
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location = Location_
        elif nodeName_ == 'DeliveryCommitment':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DeliveryCommitment = dval_
        elif nodeName_ == 'DispatchDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DispatchDate = dval_
# end class CompletedTagDetail


class ConfigurableLabelReferenceEntry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZoneNumber=None, Header=None, DataField=None, LiteralValue=None):
        self.original_tagname_ = None
        self.ZoneNumber = ZoneNumber
        self.Header = Header
        self.DataField = DataField
        self.LiteralValue = LiteralValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConfigurableLabelReferenceEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConfigurableLabelReferenceEntry.subclass:
            return ConfigurableLabelReferenceEntry.subclass(*args_, **kwargs_)
        else:
            return ConfigurableLabelReferenceEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZoneNumber(self): return self.ZoneNumber
    def set_ZoneNumber(self, ZoneNumber): self.ZoneNumber = ZoneNumber
    def get_Header(self): return self.Header
    def set_Header(self, Header): self.Header = Header
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def get_LiteralValue(self): return self.LiteralValue
    def set_LiteralValue(self, LiteralValue): self.LiteralValue = LiteralValue
    def hasContent_(self):
        if (
            self.ZoneNumber is not None or
            self.Header is not None or
            self.DataField is not None or
            self.LiteralValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ConfigurableLabelReferenceEntry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConfigurableLabelReferenceEntry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigurableLabelReferenceEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ConfigurableLabelReferenceEntry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ConfigurableLabelReferenceEntry'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ConfigurableLabelReferenceEntry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ZoneNumber>%s</ns:ZoneNumber>%s' % (self.gds_format_integer(self.ZoneNumber, input_name='ZoneNumber'), eol_))
        if self.Header is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Header>%s</ns:Header>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Header), input_name='Header')), eol_))
        if self.DataField is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DataField>%s</ns:DataField>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataField), input_name='DataField')), eol_))
        if self.LiteralValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LiteralValue>%s</ns:LiteralValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LiteralValue), input_name='LiteralValue')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZoneNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ZoneNumber')
            self.ZoneNumber = ival_
        elif nodeName_ == 'Header':
            Header_ = child_.text
            Header_ = self.gds_validate_string(Header_, node, 'Header')
            self.Header = Header_
        elif nodeName_ == 'DataField':
            DataField_ = child_.text
            DataField_ = self.gds_validate_string(DataField_, node, 'DataField')
            self.DataField = DataField_
        elif nodeName_ == 'LiteralValue':
            LiteralValue_ = child_.text
            LiteralValue_ = self.gds_validate_string(LiteralValue_, node, 'LiteralValue')
            self.LiteralValue = LiteralValue_
# end class ConfigurableLabelReferenceEntry


class Contact(GeneratedsSuper):
    """The descriptive data for a point-of-contact person."""
    subclass = None
    superclass = None
    def __init__(self, ContactId=None, PersonName=None, Title=None, CompanyName=None, PhoneNumber=None, PhoneExtension=None, TollFreePhoneNumber=None, PagerNumber=None, FaxNumber=None, EMailAddress=None):
        self.original_tagname_ = None
        self.ContactId = ContactId
        self.PersonName = PersonName
        self.Title = Title
        self.CompanyName = CompanyName
        self.PhoneNumber = PhoneNumber
        self.PhoneExtension = PhoneExtension
        self.TollFreePhoneNumber = TollFreePhoneNumber
        self.PagerNumber = PagerNumber
        self.FaxNumber = FaxNumber
        self.EMailAddress = EMailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Contact)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Contact.subclass:
            return Contact.subclass(*args_, **kwargs_)
        else:
            return Contact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactId(self): return self.ContactId
    def set_ContactId(self, ContactId): self.ContactId = ContactId
    def get_PersonName(self): return self.PersonName
    def set_PersonName(self, PersonName): self.PersonName = PersonName
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_CompanyName(self): return self.CompanyName
    def set_CompanyName(self, CompanyName): self.CompanyName = CompanyName
    def get_PhoneNumber(self): return self.PhoneNumber
    def set_PhoneNumber(self, PhoneNumber): self.PhoneNumber = PhoneNumber
    def get_PhoneExtension(self): return self.PhoneExtension
    def set_PhoneExtension(self, PhoneExtension): self.PhoneExtension = PhoneExtension
    def get_TollFreePhoneNumber(self): return self.TollFreePhoneNumber
    def set_TollFreePhoneNumber(self, TollFreePhoneNumber): self.TollFreePhoneNumber = TollFreePhoneNumber
    def get_PagerNumber(self): return self.PagerNumber
    def set_PagerNumber(self, PagerNumber): self.PagerNumber = PagerNumber
    def get_FaxNumber(self): return self.FaxNumber
    def set_FaxNumber(self, FaxNumber): self.FaxNumber = FaxNumber
    def get_EMailAddress(self): return self.EMailAddress
    def set_EMailAddress(self, EMailAddress): self.EMailAddress = EMailAddress
    def hasContent_(self):
        if (
            self.ContactId is not None or
            self.PersonName is not None or
            self.Title is not None or
            self.CompanyName is not None or
            self.PhoneNumber is not None or
            self.PhoneExtension is not None or
            self.TollFreePhoneNumber is not None or
            self.PagerNumber is not None or
            self.FaxNumber is not None or
            self.EMailAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Contact', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Contact')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Contact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Contact', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Contact'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Contact', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ContactId>%s</ns:ContactId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ContactId), input_name='ContactId')), eol_))
        if self.PersonName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PersonName>%s</ns:PersonName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PersonName), input_name='PersonName')), eol_))
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Title>%s</ns:Title>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')), eol_))
        if self.CompanyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CompanyName>%s</ns:CompanyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompanyName), input_name='CompanyName')), eol_))
        if self.PhoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PhoneNumber>%s</ns:PhoneNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PhoneNumber), input_name='PhoneNumber')), eol_))
        if self.PhoneExtension is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PhoneExtension>%s</ns:PhoneExtension>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PhoneExtension), input_name='PhoneExtension')), eol_))
        if self.TollFreePhoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TollFreePhoneNumber>%s</ns:TollFreePhoneNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TollFreePhoneNumber), input_name='TollFreePhoneNumber')), eol_))
        if self.PagerNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PagerNumber>%s</ns:PagerNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PagerNumber), input_name='PagerNumber')), eol_))
        if self.FaxNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FaxNumber>%s</ns:FaxNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FaxNumber), input_name='FaxNumber')), eol_))
        if self.EMailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EMailAddress>%s</ns:EMailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EMailAddress), input_name='EMailAddress')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactId':
            ContactId_ = child_.text
            ContactId_ = self.gds_validate_string(ContactId_, node, 'ContactId')
            self.ContactId = ContactId_
        elif nodeName_ == 'PersonName':
            PersonName_ = child_.text
            PersonName_ = self.gds_validate_string(PersonName_, node, 'PersonName')
            self.PersonName = PersonName_
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'CompanyName':
            CompanyName_ = child_.text
            CompanyName_ = self.gds_validate_string(CompanyName_, node, 'CompanyName')
            self.CompanyName = CompanyName_
        elif nodeName_ == 'PhoneNumber':
            PhoneNumber_ = child_.text
            PhoneNumber_ = self.gds_validate_string(PhoneNumber_, node, 'PhoneNumber')
            self.PhoneNumber = PhoneNumber_
        elif nodeName_ == 'PhoneExtension':
            PhoneExtension_ = child_.text
            PhoneExtension_ = self.gds_validate_string(PhoneExtension_, node, 'PhoneExtension')
            self.PhoneExtension = PhoneExtension_
        elif nodeName_ == 'TollFreePhoneNumber':
            TollFreePhoneNumber_ = child_.text
            TollFreePhoneNumber_ = self.gds_validate_string(TollFreePhoneNumber_, node, 'TollFreePhoneNumber')
            self.TollFreePhoneNumber = TollFreePhoneNumber_
        elif nodeName_ == 'PagerNumber':
            PagerNumber_ = child_.text
            PagerNumber_ = self.gds_validate_string(PagerNumber_, node, 'PagerNumber')
            self.PagerNumber = PagerNumber_
        elif nodeName_ == 'FaxNumber':
            FaxNumber_ = child_.text
            FaxNumber_ = self.gds_validate_string(FaxNumber_, node, 'FaxNumber')
            self.FaxNumber = FaxNumber_
        elif nodeName_ == 'EMailAddress':
            EMailAddress_ = child_.text
            EMailAddress_ = self.gds_validate_string(EMailAddress_, node, 'EMailAddress')
            self.EMailAddress = EMailAddress_
# end class Contact


class ContactAndAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Contact=None, Address=None):
        self.original_tagname_ = None
        self.Contact = Contact
        self.Address = Address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactAndAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactAndAddress.subclass:
            return ContactAndAddress.subclass(*args_, **kwargs_)
        else:
            return ContactAndAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def hasContent_(self):
        if (
            self.Contact is not None or
            self.Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ContactAndAddress', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContactAndAddress')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactAndAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ContactAndAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ContactAndAddress'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ContactAndAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Contact is not None:
            self.Contact.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.Contact = obj_
            obj_.original_tagname_ = 'Contact'
        elif nodeName_ == 'Address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
# end class ContactAndAddress


class ContentRecord(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PartNumber=None, ItemNumber=None, ReceivedQuantity=None, Description=None):
        self.original_tagname_ = None
        self.PartNumber = PartNumber
        self.ItemNumber = ItemNumber
        self.ReceivedQuantity = ReceivedQuantity
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContentRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContentRecord.subclass:
            return ContentRecord.subclass(*args_, **kwargs_)
        else:
            return ContentRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartNumber(self): return self.PartNumber
    def set_PartNumber(self, PartNumber): self.PartNumber = PartNumber
    def get_ItemNumber(self): return self.ItemNumber
    def set_ItemNumber(self, ItemNumber): self.ItemNumber = ItemNumber
    def get_ReceivedQuantity(self): return self.ReceivedQuantity
    def set_ReceivedQuantity(self, ReceivedQuantity): self.ReceivedQuantity = ReceivedQuantity
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.PartNumber is not None or
            self.ItemNumber is not None or
            self.ReceivedQuantity is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ContentRecord', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContentRecord')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContentRecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ContentRecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ContentRecord'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ContentRecord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PartNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PartNumber>%s</ns:PartNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PartNumber), input_name='PartNumber')), eol_))
        if self.ItemNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ItemNumber>%s</ns:ItemNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ItemNumber), input_name='ItemNumber')), eol_))
        if self.ReceivedQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ReceivedQuantity>%s</ns:ReceivedQuantity>%s' % (self.gds_format_integer(self.ReceivedQuantity, input_name='ReceivedQuantity'), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartNumber':
            PartNumber_ = child_.text
            PartNumber_ = self.gds_validate_string(PartNumber_, node, 'PartNumber')
            self.PartNumber = PartNumber_
        elif nodeName_ == 'ItemNumber':
            ItemNumber_ = child_.text
            ItemNumber_ = self.gds_validate_string(ItemNumber_, node, 'ItemNumber')
            self.ItemNumber = ItemNumber_
        elif nodeName_ == 'ReceivedQuantity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ReceivedQuantity')
            self.ReceivedQuantity = ival_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class ContentRecord


class CurrencyExchangeRate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FromCurrency=None, IntoCurrency=None, Rate=None):
        self.original_tagname_ = None
        self.FromCurrency = FromCurrency
        self.IntoCurrency = IntoCurrency
        self.Rate = Rate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CurrencyExchangeRate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CurrencyExchangeRate.subclass:
            return CurrencyExchangeRate.subclass(*args_, **kwargs_)
        else:
            return CurrencyExchangeRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FromCurrency(self): return self.FromCurrency
    def set_FromCurrency(self, FromCurrency): self.FromCurrency = FromCurrency
    def get_IntoCurrency(self): return self.IntoCurrency
    def set_IntoCurrency(self, IntoCurrency): self.IntoCurrency = IntoCurrency
    def get_Rate(self): return self.Rate
    def set_Rate(self, Rate): self.Rate = Rate
    def hasContent_(self):
        if (
            self.FromCurrency is not None or
            self.IntoCurrency is not None or
            self.Rate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CurrencyExchangeRate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CurrencyExchangeRate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrencyExchangeRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CurrencyExchangeRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CurrencyExchangeRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CurrencyExchangeRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FromCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FromCurrency>%s</ns:FromCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FromCurrency), input_name='FromCurrency')), eol_))
        if self.IntoCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:IntoCurrency>%s</ns:IntoCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IntoCurrency), input_name='IntoCurrency')), eol_))
        if self.Rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Rate>%s</ns:Rate>%s' % (self.gds_format_float(self.Rate, input_name='Rate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FromCurrency':
            FromCurrency_ = child_.text
            FromCurrency_ = self.gds_validate_string(FromCurrency_, node, 'FromCurrency')
            self.FromCurrency = FromCurrency_
        elif nodeName_ == 'IntoCurrency':
            IntoCurrency_ = child_.text
            IntoCurrency_ = self.gds_validate_string(IntoCurrency_, node, 'IntoCurrency')
            self.IntoCurrency = IntoCurrency_
        elif nodeName_ == 'Rate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Rate')
            self.Rate = fval_
# end class CurrencyExchangeRate


class CustomDeliveryWindowDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, RequestTime=None, RequestRange=None, RequestDate=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_CustomDeliveryWindowType(self.Type)
        if isinstance(RequestTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RequestTime, '%H:%M:%S').time()
        else:
            initvalue_ = RequestTime
        self.RequestTime = initvalue_
        self.RequestRange = RequestRange
        if isinstance(RequestDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(RequestDate, '%Y-%m-%d').date()
        else:
            initvalue_ = RequestDate
        self.RequestDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomDeliveryWindowDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomDeliveryWindowDetail.subclass:
            return CustomDeliveryWindowDetail.subclass(*args_, **kwargs_)
        else:
            return CustomDeliveryWindowDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_RequestTime(self): return self.RequestTime
    def set_RequestTime(self, RequestTime): self.RequestTime = RequestTime
    def get_RequestRange(self): return self.RequestRange
    def set_RequestRange(self, RequestRange): self.RequestRange = RequestRange
    def get_RequestDate(self): return self.RequestDate
    def set_RequestDate(self, RequestDate): self.RequestDate = RequestDate
    def validate_CustomDeliveryWindowType(self, value):
        # Validate type CustomDeliveryWindowType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AFTER', 'BEFORE', 'BETWEEN', 'ON']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomDeliveryWindowType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.RequestTime is not None or
            self.RequestRange is not None or
            self.RequestDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomDeliveryWindowDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomDeliveryWindowDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomDeliveryWindowDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomDeliveryWindowDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomDeliveryWindowDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomDeliveryWindowDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.RequestTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RequestTime>%s</ns:RequestTime>%s' % (self.gds_format_time(self.RequestTime, input_name='RequestTime'), eol_))
        if self.RequestRange is not None:
            self.RequestRange.export(outfile, level, namespace_, name_='RequestRange', pretty_print=pretty_print)
        if self.RequestDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RequestDate>%s</ns:RequestDate>%s' % (self.gds_format_date(self.RequestDate, input_name='RequestDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type CustomDeliveryWindowType
            self.validate_CustomDeliveryWindowType(self.Type)
        elif nodeName_ == 'RequestTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.RequestTime = dval_
        elif nodeName_ == 'RequestRange':
            obj_ = DateRange.factory()
            obj_.build(child_)
            self.RequestRange = obj_
            obj_.original_tagname_ = 'RequestRange'
        elif nodeName_ == 'RequestDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.RequestDate = dval_
# end class CustomDeliveryWindowDetail


class CustomDocumentDetail(GeneratedsSuper):
    """Data required to produce a custom-specified document, either at
    shipment or package level."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, LabelPrintingOrientation=None, LabelRotation=None, SpecificationId=None, CustomDocumentIdentifier=None, DocTabContent=None, CustomContent=None):
        self.original_tagname_ = None
        self.Format = Format
        self.LabelPrintingOrientation = LabelPrintingOrientation
        self.validate_LabelPrintingOrientationType(self.LabelPrintingOrientation)
        self.LabelRotation = LabelRotation
        self.validate_LabelRotationType(self.LabelRotation)
        self.SpecificationId = SpecificationId
        self.CustomDocumentIdentifier = CustomDocumentIdentifier
        self.DocTabContent = DocTabContent
        self.CustomContent = CustomContent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomDocumentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomDocumentDetail.subclass:
            return CustomDocumentDetail.subclass(*args_, **kwargs_)
        else:
            return CustomDocumentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_LabelPrintingOrientation(self): return self.LabelPrintingOrientation
    def set_LabelPrintingOrientation(self, LabelPrintingOrientation): self.LabelPrintingOrientation = LabelPrintingOrientation
    def get_LabelRotation(self): return self.LabelRotation
    def set_LabelRotation(self, LabelRotation): self.LabelRotation = LabelRotation
    def get_SpecificationId(self): return self.SpecificationId
    def set_SpecificationId(self, SpecificationId): self.SpecificationId = SpecificationId
    def get_CustomDocumentIdentifier(self): return self.CustomDocumentIdentifier
    def set_CustomDocumentIdentifier(self, CustomDocumentIdentifier): self.CustomDocumentIdentifier = CustomDocumentIdentifier
    def get_DocTabContent(self): return self.DocTabContent
    def set_DocTabContent(self, DocTabContent): self.DocTabContent = DocTabContent
    def get_CustomContent(self): return self.CustomContent
    def set_CustomContent(self, CustomContent): self.CustomContent = CustomContent
    def validate_LabelPrintingOrientationType(self, value):
        # Validate type LabelPrintingOrientationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BOTTOM_EDGE_OF_TEXT_FIRST', 'TOP_EDGE_OF_TEXT_FIRST']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LabelPrintingOrientationType' % {"value" : value.encode("utf-8")} )
    def validate_LabelRotationType(self, value):
        # Validate type LabelRotationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['LEFT', 'NONE', 'RIGHT', 'UPSIDE_DOWN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LabelRotationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Format is not None or
            self.LabelPrintingOrientation is not None or
            self.LabelRotation is not None or
            self.SpecificationId is not None or
            self.CustomDocumentIdentifier is not None or
            self.DocTabContent is not None or
            self.CustomContent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomDocumentDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomDocumentDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomDocumentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomDocumentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomDocumentDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomDocumentDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            self.Format.export(outfile, level, namespace_, name_='Format', pretty_print=pretty_print)
        if self.LabelPrintingOrientation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelPrintingOrientation>%s</ns:LabelPrintingOrientation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelPrintingOrientation), input_name='LabelPrintingOrientation')), eol_))
        if self.LabelRotation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelRotation>%s</ns:LabelRotation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelRotation), input_name='LabelRotation')), eol_))
        if self.SpecificationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SpecificationId>%s</ns:SpecificationId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecificationId), input_name='SpecificationId')), eol_))
        if self.CustomDocumentIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomDocumentIdentifier>%s</ns:CustomDocumentIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomDocumentIdentifier), input_name='CustomDocumentIdentifier')), eol_))
        if self.DocTabContent is not None:
            self.DocTabContent.export(outfile, level, namespace_, name_='DocTabContent', pretty_print=pretty_print)
        if self.CustomContent is not None:
            self.CustomContent.export(outfile, level, namespace_, name_='CustomContent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
        elif nodeName_ == 'LabelPrintingOrientation':
            LabelPrintingOrientation_ = child_.text
            LabelPrintingOrientation_ = self.gds_validate_string(LabelPrintingOrientation_, node, 'LabelPrintingOrientation')
            self.LabelPrintingOrientation = LabelPrintingOrientation_
            # validate type LabelPrintingOrientationType
            self.validate_LabelPrintingOrientationType(self.LabelPrintingOrientation)
        elif nodeName_ == 'LabelRotation':
            LabelRotation_ = child_.text
            LabelRotation_ = self.gds_validate_string(LabelRotation_, node, 'LabelRotation')
            self.LabelRotation = LabelRotation_
            # validate type LabelRotationType
            self.validate_LabelRotationType(self.LabelRotation)
        elif nodeName_ == 'SpecificationId':
            SpecificationId_ = child_.text
            SpecificationId_ = self.gds_validate_string(SpecificationId_, node, 'SpecificationId')
            self.SpecificationId = SpecificationId_
        elif nodeName_ == 'CustomDocumentIdentifier':
            CustomDocumentIdentifier_ = child_.text
            CustomDocumentIdentifier_ = self.gds_validate_string(CustomDocumentIdentifier_, node, 'CustomDocumentIdentifier')
            self.CustomDocumentIdentifier = CustomDocumentIdentifier_
        elif nodeName_ == 'DocTabContent':
            obj_ = DocTabContent.factory()
            obj_.build(child_)
            self.DocTabContent = obj_
            obj_.original_tagname_ = 'DocTabContent'
        elif nodeName_ == 'CustomContent':
            obj_ = CustomLabelDetail.factory()
            obj_.build(child_)
            self.CustomContent = obj_
            obj_.original_tagname_ = 'CustomContent'
# end class CustomDocumentDetail


class CustomLabelBarcodeEntry(GeneratedsSuper):
    """Constructed string, based on format and zero or more data fields,
    printed in specified barcode symbology."""
    subclass = None
    superclass = None
    def __init__(self, Position=None, Format=None, DataFields=None, BarHeight=None, ThinBarWidth=None, BarcodeSymbology=None):
        self.original_tagname_ = None
        self.Position = Position
        self.Format = Format
        if DataFields is None:
            self.DataFields = []
        else:
            self.DataFields = DataFields
        self.BarHeight = BarHeight
        self.ThinBarWidth = ThinBarWidth
        self.BarcodeSymbology = BarcodeSymbology
        self.validate_BarcodeSymbologyType(self.BarcodeSymbology)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomLabelBarcodeEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomLabelBarcodeEntry.subclass:
            return CustomLabelBarcodeEntry.subclass(*args_, **kwargs_)
        else:
            return CustomLabelBarcodeEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_DataFields(self): return self.DataFields
    def set_DataFields(self, DataFields): self.DataFields = DataFields
    def add_DataFields(self, value): self.DataFields.append(value)
    def insert_DataFields_at(self, index, value): self.DataFields.insert(index, value)
    def replace_DataFields_at(self, index, value): self.DataFields[index] = value
    def get_BarHeight(self): return self.BarHeight
    def set_BarHeight(self, BarHeight): self.BarHeight = BarHeight
    def get_ThinBarWidth(self): return self.ThinBarWidth
    def set_ThinBarWidth(self, ThinBarWidth): self.ThinBarWidth = ThinBarWidth
    def get_BarcodeSymbology(self): return self.BarcodeSymbology
    def set_BarcodeSymbology(self, BarcodeSymbology): self.BarcodeSymbology = BarcodeSymbology
    def validate_BarcodeSymbologyType(self, value):
        # Validate type BarcodeSymbologyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CODABAR', 'CODE128', 'CODE128B', 'CODE128C', 'CODE128_WIDEBAR', 'CODE39', 'CODE93', 'I2OF5', 'PDF417', 'POSTNET', 'QR_CODE', 'UCC128']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BarcodeSymbologyType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Position is not None or
            self.Format is not None or
            self.DataFields or
            self.BarHeight is not None or
            self.ThinBarWidth is not None or
            self.BarcodeSymbology is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomLabelBarcodeEntry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomLabelBarcodeEntry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomLabelBarcodeEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomLabelBarcodeEntry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomLabelBarcodeEntry'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomLabelBarcodeEntry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Format>%s</ns:Format>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Format), input_name='Format')), eol_))
        for DataFields_ in self.DataFields:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DataFields>%s</ns:DataFields>%s' % (self.gds_encode(self.gds_format_string(quote_xml(DataFields_), input_name='DataFields')), eol_))
        if self.BarHeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:BarHeight>%s</ns:BarHeight>%s' % (self.gds_format_integer(self.BarHeight, input_name='BarHeight'), eol_))
        if self.ThinBarWidth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ThinBarWidth>%s</ns:ThinBarWidth>%s' % (self.gds_format_integer(self.ThinBarWidth, input_name='ThinBarWidth'), eol_))
        if self.BarcodeSymbology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:BarcodeSymbology>%s</ns:BarcodeSymbology>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BarcodeSymbology), input_name='BarcodeSymbology')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Position':
            obj_ = CustomLabelPosition.factory()
            obj_.build(child_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'DataFields':
            DataFields_ = child_.text
            DataFields_ = self.gds_validate_string(DataFields_, node, 'DataFields')
            self.DataFields.append(DataFields_)
        elif nodeName_ == 'BarHeight':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BarHeight')
            self.BarHeight = ival_
        elif nodeName_ == 'ThinBarWidth':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ThinBarWidth')
            self.ThinBarWidth = ival_
        elif nodeName_ == 'BarcodeSymbology':
            BarcodeSymbology_ = child_.text
            BarcodeSymbology_ = self.gds_validate_string(BarcodeSymbology_, node, 'BarcodeSymbology')
            self.BarcodeSymbology = BarcodeSymbology_
            # validate type BarcodeSymbologyType
            self.validate_BarcodeSymbologyType(self.BarcodeSymbology)
# end class CustomLabelBarcodeEntry


class CustomLabelBoxEntry(GeneratedsSuper):
    """Solid (filled) rectangular area on label."""
    subclass = None
    superclass = None
    def __init__(self, TopLeftCorner=None, BottomRightCorner=None):
        self.original_tagname_ = None
        self.TopLeftCorner = TopLeftCorner
        self.BottomRightCorner = BottomRightCorner
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomLabelBoxEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomLabelBoxEntry.subclass:
            return CustomLabelBoxEntry.subclass(*args_, **kwargs_)
        else:
            return CustomLabelBoxEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopLeftCorner(self): return self.TopLeftCorner
    def set_TopLeftCorner(self, TopLeftCorner): self.TopLeftCorner = TopLeftCorner
    def get_BottomRightCorner(self): return self.BottomRightCorner
    def set_BottomRightCorner(self, BottomRightCorner): self.BottomRightCorner = BottomRightCorner
    def hasContent_(self):
        if (
            self.TopLeftCorner is not None or
            self.BottomRightCorner is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomLabelBoxEntry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomLabelBoxEntry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomLabelBoxEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomLabelBoxEntry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomLabelBoxEntry'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomLabelBoxEntry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TopLeftCorner is not None:
            self.TopLeftCorner.export(outfile, level, namespace_, name_='TopLeftCorner', pretty_print=pretty_print)
        if self.BottomRightCorner is not None:
            self.BottomRightCorner.export(outfile, level, namespace_, name_='BottomRightCorner', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopLeftCorner':
            obj_ = CustomLabelPosition.factory()
            obj_.build(child_)
            self.TopLeftCorner = obj_
            obj_.original_tagname_ = 'TopLeftCorner'
        elif nodeName_ == 'BottomRightCorner':
            obj_ = CustomLabelPosition.factory()
            obj_.build(child_)
            self.BottomRightCorner = obj_
            obj_.original_tagname_ = 'BottomRightCorner'
# end class CustomLabelBoxEntry


class CustomLabelDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CoordinateUnits=None, TextEntries=None, GraphicEntries=None, BoxEntries=None, TextBoxEntries=None, BarcodeEntries=None):
        self.original_tagname_ = None
        self.CoordinateUnits = CoordinateUnits
        self.validate_CustomLabelCoordinateUnits(self.CoordinateUnits)
        if TextEntries is None:
            self.TextEntries = []
        else:
            self.TextEntries = TextEntries
        if GraphicEntries is None:
            self.GraphicEntries = []
        else:
            self.GraphicEntries = GraphicEntries
        if BoxEntries is None:
            self.BoxEntries = []
        else:
            self.BoxEntries = BoxEntries
        if TextBoxEntries is None:
            self.TextBoxEntries = []
        else:
            self.TextBoxEntries = TextBoxEntries
        if BarcodeEntries is None:
            self.BarcodeEntries = []
        else:
            self.BarcodeEntries = BarcodeEntries
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomLabelDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomLabelDetail.subclass:
            return CustomLabelDetail.subclass(*args_, **kwargs_)
        else:
            return CustomLabelDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CoordinateUnits(self): return self.CoordinateUnits
    def set_CoordinateUnits(self, CoordinateUnits): self.CoordinateUnits = CoordinateUnits
    def get_TextEntries(self): return self.TextEntries
    def set_TextEntries(self, TextEntries): self.TextEntries = TextEntries
    def add_TextEntries(self, value): self.TextEntries.append(value)
    def insert_TextEntries_at(self, index, value): self.TextEntries.insert(index, value)
    def replace_TextEntries_at(self, index, value): self.TextEntries[index] = value
    def get_GraphicEntries(self): return self.GraphicEntries
    def set_GraphicEntries(self, GraphicEntries): self.GraphicEntries = GraphicEntries
    def add_GraphicEntries(self, value): self.GraphicEntries.append(value)
    def insert_GraphicEntries_at(self, index, value): self.GraphicEntries.insert(index, value)
    def replace_GraphicEntries_at(self, index, value): self.GraphicEntries[index] = value
    def get_BoxEntries(self): return self.BoxEntries
    def set_BoxEntries(self, BoxEntries): self.BoxEntries = BoxEntries
    def add_BoxEntries(self, value): self.BoxEntries.append(value)
    def insert_BoxEntries_at(self, index, value): self.BoxEntries.insert(index, value)
    def replace_BoxEntries_at(self, index, value): self.BoxEntries[index] = value
    def get_TextBoxEntries(self): return self.TextBoxEntries
    def set_TextBoxEntries(self, TextBoxEntries): self.TextBoxEntries = TextBoxEntries
    def add_TextBoxEntries(self, value): self.TextBoxEntries.append(value)
    def insert_TextBoxEntries_at(self, index, value): self.TextBoxEntries.insert(index, value)
    def replace_TextBoxEntries_at(self, index, value): self.TextBoxEntries[index] = value
    def get_BarcodeEntries(self): return self.BarcodeEntries
    def set_BarcodeEntries(self, BarcodeEntries): self.BarcodeEntries = BarcodeEntries
    def add_BarcodeEntries(self, value): self.BarcodeEntries.append(value)
    def insert_BarcodeEntries_at(self, index, value): self.BarcodeEntries.insert(index, value)
    def replace_BarcodeEntries_at(self, index, value): self.BarcodeEntries[index] = value
    def validate_CustomLabelCoordinateUnits(self, value):
        # Validate type CustomLabelCoordinateUnits, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MILS', 'PIXELS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomLabelCoordinateUnits' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CoordinateUnits is not None or
            self.TextEntries or
            self.GraphicEntries or
            self.BoxEntries or
            self.TextBoxEntries or
            self.BarcodeEntries
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomLabelDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomLabelDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomLabelDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomLabelDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomLabelDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomLabelDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CoordinateUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CoordinateUnits>%s</ns:CoordinateUnits>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CoordinateUnits), input_name='CoordinateUnits')), eol_))
        for TextEntries_ in self.TextEntries:
            TextEntries_.export(outfile, level, namespace_, name_='TextEntries', pretty_print=pretty_print)
        for GraphicEntries_ in self.GraphicEntries:
            GraphicEntries_.export(outfile, level, namespace_, name_='GraphicEntries', pretty_print=pretty_print)
        for BoxEntries_ in self.BoxEntries:
            BoxEntries_.export(outfile, level, namespace_, name_='BoxEntries', pretty_print=pretty_print)
        for TextBoxEntries_ in self.TextBoxEntries:
            TextBoxEntries_.export(outfile, level, namespace_, name_='TextBoxEntries', pretty_print=pretty_print)
        for BarcodeEntries_ in self.BarcodeEntries:
            BarcodeEntries_.export(outfile, level, namespace_, name_='BarcodeEntries', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CoordinateUnits':
            CoordinateUnits_ = child_.text
            CoordinateUnits_ = self.gds_validate_string(CoordinateUnits_, node, 'CoordinateUnits')
            self.CoordinateUnits = CoordinateUnits_
            # validate type CustomLabelCoordinateUnits
            self.validate_CustomLabelCoordinateUnits(self.CoordinateUnits)
        elif nodeName_ == 'TextEntries':
            obj_ = CustomLabelTextEntry.factory()
            obj_.build(child_)
            self.TextEntries.append(obj_)
            obj_.original_tagname_ = 'TextEntries'
        elif nodeName_ == 'GraphicEntries':
            obj_ = CustomLabelGraphicEntry.factory()
            obj_.build(child_)
            self.GraphicEntries.append(obj_)
            obj_.original_tagname_ = 'GraphicEntries'
        elif nodeName_ == 'BoxEntries':
            obj_ = CustomLabelBoxEntry.factory()
            obj_.build(child_)
            self.BoxEntries.append(obj_)
            obj_.original_tagname_ = 'BoxEntries'
        elif nodeName_ == 'TextBoxEntries':
            obj_ = CustomLabelTextBoxEntry.factory()
            obj_.build(child_)
            self.TextBoxEntries.append(obj_)
            obj_.original_tagname_ = 'TextBoxEntries'
        elif nodeName_ == 'BarcodeEntries':
            obj_ = CustomLabelBarcodeEntry.factory()
            obj_.build(child_)
            self.BarcodeEntries.append(obj_)
            obj_.original_tagname_ = 'BarcodeEntries'
# end class CustomLabelDetail


class CustomLabelGraphicEntry(GeneratedsSuper):
    """Image to be included from printer's memory, or from a local file for
    offline clients."""
    subclass = None
    superclass = None
    def __init__(self, Position=None, PrinterGraphicId=None, FileGraphicFullName=None):
        self.original_tagname_ = None
        self.Position = Position
        self.PrinterGraphicId = PrinterGraphicId
        self.FileGraphicFullName = FileGraphicFullName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomLabelGraphicEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomLabelGraphicEntry.subclass:
            return CustomLabelGraphicEntry.subclass(*args_, **kwargs_)
        else:
            return CustomLabelGraphicEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_PrinterGraphicId(self): return self.PrinterGraphicId
    def set_PrinterGraphicId(self, PrinterGraphicId): self.PrinterGraphicId = PrinterGraphicId
    def get_FileGraphicFullName(self): return self.FileGraphicFullName
    def set_FileGraphicFullName(self, FileGraphicFullName): self.FileGraphicFullName = FileGraphicFullName
    def hasContent_(self):
        if (
            self.Position is not None or
            self.PrinterGraphicId is not None or
            self.FileGraphicFullName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomLabelGraphicEntry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomLabelGraphicEntry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomLabelGraphicEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomLabelGraphicEntry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomLabelGraphicEntry'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomLabelGraphicEntry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.PrinterGraphicId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PrinterGraphicId>%s</ns:PrinterGraphicId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PrinterGraphicId), input_name='PrinterGraphicId')), eol_))
        if self.FileGraphicFullName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FileGraphicFullName>%s</ns:FileGraphicFullName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FileGraphicFullName), input_name='FileGraphicFullName')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Position':
            obj_ = CustomLabelPosition.factory()
            obj_.build(child_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'PrinterGraphicId':
            PrinterGraphicId_ = child_.text
            PrinterGraphicId_ = self.gds_validate_string(PrinterGraphicId_, node, 'PrinterGraphicId')
            self.PrinterGraphicId = PrinterGraphicId_
        elif nodeName_ == 'FileGraphicFullName':
            FileGraphicFullName_ = child_.text
            FileGraphicFullName_ = self.gds_validate_string(FileGraphicFullName_, node, 'FileGraphicFullName')
            self.FileGraphicFullName = FileGraphicFullName_
# end class CustomLabelGraphicEntry


class CustomLabelPosition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X=None, Y=None):
        self.original_tagname_ = None
        self.X = X
        self.Y = Y
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomLabelPosition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomLabelPosition.subclass:
            return CustomLabelPosition.subclass(*args_, **kwargs_)
        else:
            return CustomLabelPosition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomLabelPosition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomLabelPosition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomLabelPosition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomLabelPosition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomLabelPosition'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomLabelPosition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:X>%s</ns:X>%s' % (self.gds_format_integer(self.X, input_name='X'), eol_))
        if self.Y is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Y>%s</ns:Y>%s' % (self.gds_format_integer(self.Y, input_name='Y'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'X')
            self.X = ival_
        elif nodeName_ == 'Y':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Y')
            self.Y = ival_
# end class CustomLabelPosition


class CustomLabelTextBoxEntry(GeneratedsSuper):
    """Constructed string, based on format and zero or more data fields,
    printed in specified printer font (for thermal labels) or
    generic font/size (for plain paper labels)."""
    subclass = None
    superclass = None
    def __init__(self, TopLeftCorner=None, BottomRightCorner=None, Position=None, Format=None, DataFields=None, ThermalFontId=None, FontName=None, FontSize=None, Rotation=None):
        self.original_tagname_ = None
        self.TopLeftCorner = TopLeftCorner
        self.BottomRightCorner = BottomRightCorner
        self.Position = Position
        self.Format = Format
        if DataFields is None:
            self.DataFields = []
        else:
            self.DataFields = DataFields
        self.ThermalFontId = ThermalFontId
        self.FontName = FontName
        self.FontSize = FontSize
        self.Rotation = Rotation
        self.validate_RotationType(self.Rotation)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomLabelTextBoxEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomLabelTextBoxEntry.subclass:
            return CustomLabelTextBoxEntry.subclass(*args_, **kwargs_)
        else:
            return CustomLabelTextBoxEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TopLeftCorner(self): return self.TopLeftCorner
    def set_TopLeftCorner(self, TopLeftCorner): self.TopLeftCorner = TopLeftCorner
    def get_BottomRightCorner(self): return self.BottomRightCorner
    def set_BottomRightCorner(self, BottomRightCorner): self.BottomRightCorner = BottomRightCorner
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_DataFields(self): return self.DataFields
    def set_DataFields(self, DataFields): self.DataFields = DataFields
    def add_DataFields(self, value): self.DataFields.append(value)
    def insert_DataFields_at(self, index, value): self.DataFields.insert(index, value)
    def replace_DataFields_at(self, index, value): self.DataFields[index] = value
    def get_ThermalFontId(self): return self.ThermalFontId
    def set_ThermalFontId(self, ThermalFontId): self.ThermalFontId = ThermalFontId
    def get_FontName(self): return self.FontName
    def set_FontName(self, FontName): self.FontName = FontName
    def get_FontSize(self): return self.FontSize
    def set_FontSize(self, FontSize): self.FontSize = FontSize
    def get_Rotation(self): return self.Rotation
    def set_Rotation(self, Rotation): self.Rotation = Rotation
    def validate_RotationType(self, value):
        # Validate type RotationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['LEFT', 'NONE', 'RIGHT', 'UPSIDE_DOWN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RotationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TopLeftCorner is not None or
            self.BottomRightCorner is not None or
            self.Position is not None or
            self.Format is not None or
            self.DataFields or
            self.ThermalFontId is not None or
            self.FontName is not None or
            self.FontSize is not None or
            self.Rotation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomLabelTextBoxEntry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomLabelTextBoxEntry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomLabelTextBoxEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomLabelTextBoxEntry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomLabelTextBoxEntry'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomLabelTextBoxEntry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TopLeftCorner is not None:
            self.TopLeftCorner.export(outfile, level, namespace_, name_='TopLeftCorner', pretty_print=pretty_print)
        if self.BottomRightCorner is not None:
            self.BottomRightCorner.export(outfile, level, namespace_, name_='BottomRightCorner', pretty_print=pretty_print)
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Format>%s</ns:Format>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Format), input_name='Format')), eol_))
        for DataFields_ in self.DataFields:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DataFields>%s</ns:DataFields>%s' % (self.gds_encode(self.gds_format_string(quote_xml(DataFields_), input_name='DataFields')), eol_))
        if self.ThermalFontId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ThermalFontId>%s</ns:ThermalFontId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ThermalFontId), input_name='ThermalFontId')), eol_))
        if self.FontName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FontName>%s</ns:FontName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FontName), input_name='FontName')), eol_))
        if self.FontSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FontSize>%s</ns:FontSize>%s' % (self.gds_format_integer(self.FontSize, input_name='FontSize'), eol_))
        if self.Rotation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Rotation>%s</ns:Rotation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Rotation), input_name='Rotation')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TopLeftCorner':
            obj_ = CustomLabelPosition.factory()
            obj_.build(child_)
            self.TopLeftCorner = obj_
            obj_.original_tagname_ = 'TopLeftCorner'
        elif nodeName_ == 'BottomRightCorner':
            obj_ = CustomLabelPosition.factory()
            obj_.build(child_)
            self.BottomRightCorner = obj_
            obj_.original_tagname_ = 'BottomRightCorner'
        elif nodeName_ == 'Position':
            obj_ = CustomLabelPosition.factory()
            obj_.build(child_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'DataFields':
            DataFields_ = child_.text
            DataFields_ = self.gds_validate_string(DataFields_, node, 'DataFields')
            self.DataFields.append(DataFields_)
        elif nodeName_ == 'ThermalFontId':
            ThermalFontId_ = child_.text
            ThermalFontId_ = self.gds_validate_string(ThermalFontId_, node, 'ThermalFontId')
            self.ThermalFontId = ThermalFontId_
        elif nodeName_ == 'FontName':
            FontName_ = child_.text
            FontName_ = self.gds_validate_string(FontName_, node, 'FontName')
            self.FontName = FontName_
        elif nodeName_ == 'FontSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'FontSize')
            self.FontSize = ival_
        elif nodeName_ == 'Rotation':
            Rotation_ = child_.text
            Rotation_ = self.gds_validate_string(Rotation_, node, 'Rotation')
            self.Rotation = Rotation_
            # validate type RotationType
            self.validate_RotationType(self.Rotation)
# end class CustomLabelTextBoxEntry


class CustomLabelTextEntry(GeneratedsSuper):
    """Constructed string, based on format and zero or more data fields,
    printed in specified printer font (for thermal labels) or
    generic font/size (for plain paper labels)."""
    subclass = None
    superclass = None
    def __init__(self, Position=None, Format=None, DataFields=None, ThermalFontId=None, FontName=None, FontSize=None, Rotation=None):
        self.original_tagname_ = None
        self.Position = Position
        self.Format = Format
        if DataFields is None:
            self.DataFields = []
        else:
            self.DataFields = DataFields
        self.ThermalFontId = ThermalFontId
        self.FontName = FontName
        self.FontSize = FontSize
        self.Rotation = Rotation
        self.validate_RotationType(self.Rotation)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomLabelTextEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomLabelTextEntry.subclass:
            return CustomLabelTextEntry.subclass(*args_, **kwargs_)
        else:
            return CustomLabelTextEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_DataFields(self): return self.DataFields
    def set_DataFields(self, DataFields): self.DataFields = DataFields
    def add_DataFields(self, value): self.DataFields.append(value)
    def insert_DataFields_at(self, index, value): self.DataFields.insert(index, value)
    def replace_DataFields_at(self, index, value): self.DataFields[index] = value
    def get_ThermalFontId(self): return self.ThermalFontId
    def set_ThermalFontId(self, ThermalFontId): self.ThermalFontId = ThermalFontId
    def get_FontName(self): return self.FontName
    def set_FontName(self, FontName): self.FontName = FontName
    def get_FontSize(self): return self.FontSize
    def set_FontSize(self, FontSize): self.FontSize = FontSize
    def get_Rotation(self): return self.Rotation
    def set_Rotation(self, Rotation): self.Rotation = Rotation
    def validate_RotationType(self, value):
        # Validate type RotationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['LEFT', 'NONE', 'RIGHT', 'UPSIDE_DOWN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RotationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Position is not None or
            self.Format is not None or
            self.DataFields or
            self.ThermalFontId is not None or
            self.FontName is not None or
            self.FontSize is not None or
            self.Rotation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomLabelTextEntry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomLabelTextEntry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomLabelTextEntry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomLabelTextEntry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomLabelTextEntry'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomLabelTextEntry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.Format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Format>%s</ns:Format>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Format), input_name='Format')), eol_))
        for DataFields_ in self.DataFields:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DataFields>%s</ns:DataFields>%s' % (self.gds_encode(self.gds_format_string(quote_xml(DataFields_), input_name='DataFields')), eol_))
        if self.ThermalFontId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ThermalFontId>%s</ns:ThermalFontId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ThermalFontId), input_name='ThermalFontId')), eol_))
        if self.FontName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FontName>%s</ns:FontName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FontName), input_name='FontName')), eol_))
        if self.FontSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FontSize>%s</ns:FontSize>%s' % (self.gds_format_integer(self.FontSize, input_name='FontSize'), eol_))
        if self.Rotation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Rotation>%s</ns:Rotation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Rotation), input_name='Rotation')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Position':
            obj_ = CustomLabelPosition.factory()
            obj_.build(child_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format = Format_
        elif nodeName_ == 'DataFields':
            DataFields_ = child_.text
            DataFields_ = self.gds_validate_string(DataFields_, node, 'DataFields')
            self.DataFields.append(DataFields_)
        elif nodeName_ == 'ThermalFontId':
            ThermalFontId_ = child_.text
            ThermalFontId_ = self.gds_validate_string(ThermalFontId_, node, 'ThermalFontId')
            self.ThermalFontId = ThermalFontId_
        elif nodeName_ == 'FontName':
            FontName_ = child_.text
            FontName_ = self.gds_validate_string(FontName_, node, 'FontName')
            self.FontName = FontName_
        elif nodeName_ == 'FontSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'FontSize')
            self.FontSize = ival_
        elif nodeName_ == 'Rotation':
            Rotation_ = child_.text
            Rotation_ = self.gds_validate_string(Rotation_, node, 'Rotation')
            self.Rotation = Rotation_
            # validate type RotationType
            self.validate_RotationType(self.Rotation)
# end class CustomLabelTextEntry


class CustomerImageUsage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Id=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_CustomerImageUsageType(self.Type)
        self.Id = Id
        self.validate_ImageId(self.Id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerImageUsage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerImageUsage.subclass:
            return CustomerImageUsage.subclass(*args_, **kwargs_)
        else:
            return CustomerImageUsage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def validate_CustomerImageUsageType(self, value):
        # Validate type CustomerImageUsageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['LETTER_HEAD', 'SIGNATURE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomerImageUsageType' % {"value" : value.encode("utf-8")} )
    def validate_ImageId(self, value):
        # Validate type ImageId, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['IMAGE_1', 'IMAGE_2', 'IMAGE_3', 'IMAGE_4', 'IMAGE_5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ImageId' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomerImageUsage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerImageUsage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerImageUsage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomerImageUsage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomerImageUsage'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomerImageUsage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Id>%s</ns:Id>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type CustomerImageUsageType
            self.validate_CustomerImageUsageType(self.Type)
        elif nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
            # validate type ImageId
            self.validate_ImageId(self.Id)
# end class CustomerImageUsage


class CustomerReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomerReferenceType=None, Value=None):
        self.original_tagname_ = None
        self.CustomerReferenceType = CustomerReferenceType
        self.validate_CustomerReferenceType(self.CustomerReferenceType)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerReference.subclass:
            return CustomerReference.subclass(*args_, **kwargs_)
        else:
            return CustomerReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerReferenceType(self): return self.CustomerReferenceType
    def set_CustomerReferenceType(self, CustomerReferenceType): self.CustomerReferenceType = CustomerReferenceType
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_CustomerReferenceType(self, value):
        # Validate type CustomerReferenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUSTOMER_REFERENCE', 'DEPARTMENT_NUMBER', 'INTRACOUNTRY_REGULATORY_REFERENCE', 'INVOICE_NUMBER', 'P_O_NUMBER', 'RMA_ASSOCIATION', 'SHIPMENT_INTEGRITY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomerReferenceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CustomerReferenceType is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomerReference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomerReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomerReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomerReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerReferenceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomerReferenceType>%s</ns:CustomerReferenceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerReferenceType), input_name='CustomerReferenceType')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerReferenceType':
            CustomerReferenceType_ = child_.text
            CustomerReferenceType_ = self.gds_validate_string(CustomerReferenceType_, node, 'CustomerReferenceType')
            self.CustomerReferenceType = CustomerReferenceType_
            # validate type CustomerReferenceType
            self.validate_CustomerReferenceType(self.CustomerReferenceType)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class CustomerReference


class CustomerSpecifiedLabelDetail(GeneratedsSuper):
    """Allows customer-specified control of label content."""
    subclass = None
    superclass = None
    def __init__(self, DocTabContent=None, CustomContentPosition=None, CustomContent=None, ConfigurableReferenceEntries=None, MaskedData=None, SecondaryBarcode=None, TermsAndConditionsLocalization=None, RegulatoryLabels=None, AdditionalLabels=None, AirWaybillSuppressionCount=None):
        self.original_tagname_ = None
        self.DocTabContent = DocTabContent
        self.CustomContentPosition = CustomContentPosition
        self.validate_RelativeVerticalPositionType(self.CustomContentPosition)
        self.CustomContent = CustomContent
        if ConfigurableReferenceEntries is None:
            self.ConfigurableReferenceEntries = []
        else:
            self.ConfigurableReferenceEntries = ConfigurableReferenceEntries
        if MaskedData is None:
            self.MaskedData = []
        else:
            self.MaskedData = MaskedData
        self.SecondaryBarcode = SecondaryBarcode
        self.validate_SecondaryBarcodeType(self.SecondaryBarcode)
        self.TermsAndConditionsLocalization = TermsAndConditionsLocalization
        if RegulatoryLabels is None:
            self.RegulatoryLabels = []
        else:
            self.RegulatoryLabels = RegulatoryLabels
        if AdditionalLabels is None:
            self.AdditionalLabels = []
        else:
            self.AdditionalLabels = AdditionalLabels
        self.AirWaybillSuppressionCount = AirWaybillSuppressionCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerSpecifiedLabelDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerSpecifiedLabelDetail.subclass:
            return CustomerSpecifiedLabelDetail.subclass(*args_, **kwargs_)
        else:
            return CustomerSpecifiedLabelDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocTabContent(self): return self.DocTabContent
    def set_DocTabContent(self, DocTabContent): self.DocTabContent = DocTabContent
    def get_CustomContentPosition(self): return self.CustomContentPosition
    def set_CustomContentPosition(self, CustomContentPosition): self.CustomContentPosition = CustomContentPosition
    def get_CustomContent(self): return self.CustomContent
    def set_CustomContent(self, CustomContent): self.CustomContent = CustomContent
    def get_ConfigurableReferenceEntries(self): return self.ConfigurableReferenceEntries
    def set_ConfigurableReferenceEntries(self, ConfigurableReferenceEntries): self.ConfigurableReferenceEntries = ConfigurableReferenceEntries
    def add_ConfigurableReferenceEntries(self, value): self.ConfigurableReferenceEntries.append(value)
    def insert_ConfigurableReferenceEntries_at(self, index, value): self.ConfigurableReferenceEntries.insert(index, value)
    def replace_ConfigurableReferenceEntries_at(self, index, value): self.ConfigurableReferenceEntries[index] = value
    def get_MaskedData(self): return self.MaskedData
    def set_MaskedData(self, MaskedData): self.MaskedData = MaskedData
    def add_MaskedData(self, value): self.MaskedData.append(value)
    def insert_MaskedData_at(self, index, value): self.MaskedData.insert(index, value)
    def replace_MaskedData_at(self, index, value): self.MaskedData[index] = value
    def get_SecondaryBarcode(self): return self.SecondaryBarcode
    def set_SecondaryBarcode(self, SecondaryBarcode): self.SecondaryBarcode = SecondaryBarcode
    def get_TermsAndConditionsLocalization(self): return self.TermsAndConditionsLocalization
    def set_TermsAndConditionsLocalization(self, TermsAndConditionsLocalization): self.TermsAndConditionsLocalization = TermsAndConditionsLocalization
    def get_RegulatoryLabels(self): return self.RegulatoryLabels
    def set_RegulatoryLabels(self, RegulatoryLabels): self.RegulatoryLabels = RegulatoryLabels
    def add_RegulatoryLabels(self, value): self.RegulatoryLabels.append(value)
    def insert_RegulatoryLabels_at(self, index, value): self.RegulatoryLabels.insert(index, value)
    def replace_RegulatoryLabels_at(self, index, value): self.RegulatoryLabels[index] = value
    def get_AdditionalLabels(self): return self.AdditionalLabels
    def set_AdditionalLabels(self, AdditionalLabels): self.AdditionalLabels = AdditionalLabels
    def add_AdditionalLabels(self, value): self.AdditionalLabels.append(value)
    def insert_AdditionalLabels_at(self, index, value): self.AdditionalLabels.insert(index, value)
    def replace_AdditionalLabels_at(self, index, value): self.AdditionalLabels[index] = value
    def get_AirWaybillSuppressionCount(self): return self.AirWaybillSuppressionCount
    def set_AirWaybillSuppressionCount(self, AirWaybillSuppressionCount): self.AirWaybillSuppressionCount = AirWaybillSuppressionCount
    def validate_RelativeVerticalPositionType(self, value):
        # Validate type RelativeVerticalPositionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ABOVE', 'BELOW']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RelativeVerticalPositionType' % {"value" : value.encode("utf-8")} )
    def validate_LabelMaskableDataType(self, value):
        # Validate type LabelMaskableDataType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUSTOMS_VALUE', 'DUTIES_AND_TAXES_PAYOR_ACCOUNT_NUMBER', 'SECONDARY_BARCODE', 'SHIPPER_ACCOUNT_NUMBER', 'TERMS_AND_CONDITIONS', 'TRANSPORTATION_CHARGES_PAYOR_ACCOUNT_NUMBER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LabelMaskableDataType' % {"value" : value.encode("utf-8")} )
    def validate_SecondaryBarcodeType(self, value):
        # Validate type SecondaryBarcodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COMMON_2D', 'NONE', 'SSCC_18', 'USPS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SecondaryBarcodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DocTabContent is not None or
            self.CustomContentPosition is not None or
            self.CustomContent is not None or
            self.ConfigurableReferenceEntries or
            self.MaskedData or
            self.SecondaryBarcode is not None or
            self.TermsAndConditionsLocalization is not None or
            self.RegulatoryLabels or
            self.AdditionalLabels or
            self.AirWaybillSuppressionCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomerSpecifiedLabelDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerSpecifiedLabelDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerSpecifiedLabelDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomerSpecifiedLabelDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomerSpecifiedLabelDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomerSpecifiedLabelDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocTabContent is not None:
            self.DocTabContent.export(outfile, level, namespace_, name_='DocTabContent', pretty_print=pretty_print)
        if self.CustomContentPosition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomContentPosition>%s</ns:CustomContentPosition>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomContentPosition), input_name='CustomContentPosition')), eol_))
        if self.CustomContent is not None:
            self.CustomContent.export(outfile, level, namespace_, name_='CustomContent', pretty_print=pretty_print)
        for ConfigurableReferenceEntries_ in self.ConfigurableReferenceEntries:
            ConfigurableReferenceEntries_.export(outfile, level, namespace_, name_='ConfigurableReferenceEntries', pretty_print=pretty_print)
        for MaskedData_ in self.MaskedData:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:MaskedData>%s</ns:MaskedData>%s' % (self.gds_encode(self.gds_format_string(quote_xml(MaskedData_), input_name='MaskedData')), eol_))
        if self.SecondaryBarcode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SecondaryBarcode>%s</ns:SecondaryBarcode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SecondaryBarcode), input_name='SecondaryBarcode')), eol_))
        if self.TermsAndConditionsLocalization is not None:
            self.TermsAndConditionsLocalization.export(outfile, level, namespace_, name_='TermsAndConditionsLocalization', pretty_print=pretty_print)
        for RegulatoryLabels_ in self.RegulatoryLabels:
            RegulatoryLabels_.export(outfile, level, namespace_, name_='RegulatoryLabels', pretty_print=pretty_print)
        for AdditionalLabels_ in self.AdditionalLabels:
            AdditionalLabels_.export(outfile, level, namespace_, name_='AdditionalLabels', pretty_print=pretty_print)
        if self.AirWaybillSuppressionCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AirWaybillSuppressionCount>%s</ns:AirWaybillSuppressionCount>%s' % (self.gds_format_integer(self.AirWaybillSuppressionCount, input_name='AirWaybillSuppressionCount'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocTabContent':
            obj_ = DocTabContent.factory()
            obj_.build(child_)
            self.DocTabContent = obj_
            obj_.original_tagname_ = 'DocTabContent'
        elif nodeName_ == 'CustomContentPosition':
            CustomContentPosition_ = child_.text
            CustomContentPosition_ = self.gds_validate_string(CustomContentPosition_, node, 'CustomContentPosition')
            self.CustomContentPosition = CustomContentPosition_
            # validate type RelativeVerticalPositionType
            self.validate_RelativeVerticalPositionType(self.CustomContentPosition)
        elif nodeName_ == 'CustomContent':
            obj_ = CustomLabelDetail.factory()
            obj_.build(child_)
            self.CustomContent = obj_
            obj_.original_tagname_ = 'CustomContent'
        elif nodeName_ == 'ConfigurableReferenceEntries':
            obj_ = ConfigurableLabelReferenceEntry.factory()
            obj_.build(child_)
            self.ConfigurableReferenceEntries.append(obj_)
            obj_.original_tagname_ = 'ConfigurableReferenceEntries'
        elif nodeName_ == 'MaskedData':
            MaskedData_ = child_.text
            MaskedData_ = self.gds_validate_string(MaskedData_, node, 'MaskedData')
            self.MaskedData.append(MaskedData_)
            # validate type LabelMaskableDataType
            self.validate_LabelMaskableDataType(self.MaskedData[-1])
        elif nodeName_ == 'SecondaryBarcode':
            SecondaryBarcode_ = child_.text
            SecondaryBarcode_ = self.gds_validate_string(SecondaryBarcode_, node, 'SecondaryBarcode')
            self.SecondaryBarcode = SecondaryBarcode_
            # validate type SecondaryBarcodeType
            self.validate_SecondaryBarcodeType(self.SecondaryBarcode)
        elif nodeName_ == 'TermsAndConditionsLocalization':
            obj_ = Localization.factory()
            obj_.build(child_)
            self.TermsAndConditionsLocalization = obj_
            obj_.original_tagname_ = 'TermsAndConditionsLocalization'
        elif nodeName_ == 'RegulatoryLabels':
            obj_ = RegulatoryLabelContentDetail.factory()
            obj_.build(child_)
            self.RegulatoryLabels.append(obj_)
            obj_.original_tagname_ = 'RegulatoryLabels'
        elif nodeName_ == 'AdditionalLabels':
            obj_ = AdditionalLabelsDetail.factory()
            obj_.build(child_)
            self.AdditionalLabels.append(obj_)
            obj_.original_tagname_ = 'AdditionalLabels'
        elif nodeName_ == 'AirWaybillSuppressionCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'AirWaybillSuppressionCount')
            self.AirWaybillSuppressionCount = ival_
# end class CustomerSpecifiedLabelDetail


class CustomsClearanceDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Brokers=None, ClearanceBrokerage=None, CustomsOptions=None, ImporterOfRecord=None, RecipientCustomsId=None, DutiesPayment=None, DocumentContent=None, CustomsValue=None, FreightOnValue=None, InsuranceCharges=None, PartiesToTransactionAreRelated=None, CommercialInvoice=None, Commodities=None, ExportDetail=None, RegulatoryControls=None, DeclarationStatementDetail=None):
        self.original_tagname_ = None
        if Brokers is None:
            self.Brokers = []
        else:
            self.Brokers = Brokers
        self.ClearanceBrokerage = ClearanceBrokerage
        self.validate_ClearanceBrokerageType(self.ClearanceBrokerage)
        self.CustomsOptions = CustomsOptions
        self.ImporterOfRecord = ImporterOfRecord
        self.RecipientCustomsId = RecipientCustomsId
        self.DutiesPayment = DutiesPayment
        self.DocumentContent = DocumentContent
        self.validate_InternationalDocumentContentType(self.DocumentContent)
        self.CustomsValue = CustomsValue
        self.FreightOnValue = FreightOnValue
        self.validate_FreightOnValueType(self.FreightOnValue)
        self.InsuranceCharges = InsuranceCharges
        self.PartiesToTransactionAreRelated = PartiesToTransactionAreRelated
        self.CommercialInvoice = CommercialInvoice
        if Commodities is None:
            self.Commodities = []
        else:
            self.Commodities = Commodities
        self.ExportDetail = ExportDetail
        if RegulatoryControls is None:
            self.RegulatoryControls = []
        else:
            self.RegulatoryControls = RegulatoryControls
        self.DeclarationStatementDetail = DeclarationStatementDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomsClearanceDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomsClearanceDetail.subclass:
            return CustomsClearanceDetail.subclass(*args_, **kwargs_)
        else:
            return CustomsClearanceDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Brokers(self): return self.Brokers
    def set_Brokers(self, Brokers): self.Brokers = Brokers
    def add_Brokers(self, value): self.Brokers.append(value)
    def insert_Brokers_at(self, index, value): self.Brokers.insert(index, value)
    def replace_Brokers_at(self, index, value): self.Brokers[index] = value
    def get_ClearanceBrokerage(self): return self.ClearanceBrokerage
    def set_ClearanceBrokerage(self, ClearanceBrokerage): self.ClearanceBrokerage = ClearanceBrokerage
    def get_CustomsOptions(self): return self.CustomsOptions
    def set_CustomsOptions(self, CustomsOptions): self.CustomsOptions = CustomsOptions
    def get_ImporterOfRecord(self): return self.ImporterOfRecord
    def set_ImporterOfRecord(self, ImporterOfRecord): self.ImporterOfRecord = ImporterOfRecord
    def get_RecipientCustomsId(self): return self.RecipientCustomsId
    def set_RecipientCustomsId(self, RecipientCustomsId): self.RecipientCustomsId = RecipientCustomsId
    def get_DutiesPayment(self): return self.DutiesPayment
    def set_DutiesPayment(self, DutiesPayment): self.DutiesPayment = DutiesPayment
    def get_DocumentContent(self): return self.DocumentContent
    def set_DocumentContent(self, DocumentContent): self.DocumentContent = DocumentContent
    def get_CustomsValue(self): return self.CustomsValue
    def set_CustomsValue(self, CustomsValue): self.CustomsValue = CustomsValue
    def get_FreightOnValue(self): return self.FreightOnValue
    def set_FreightOnValue(self, FreightOnValue): self.FreightOnValue = FreightOnValue
    def get_InsuranceCharges(self): return self.InsuranceCharges
    def set_InsuranceCharges(self, InsuranceCharges): self.InsuranceCharges = InsuranceCharges
    def get_PartiesToTransactionAreRelated(self): return self.PartiesToTransactionAreRelated
    def set_PartiesToTransactionAreRelated(self, PartiesToTransactionAreRelated): self.PartiesToTransactionAreRelated = PartiesToTransactionAreRelated
    def get_CommercialInvoice(self): return self.CommercialInvoice
    def set_CommercialInvoice(self, CommercialInvoice): self.CommercialInvoice = CommercialInvoice
    def get_Commodities(self): return self.Commodities
    def set_Commodities(self, Commodities): self.Commodities = Commodities
    def add_Commodities(self, value): self.Commodities.append(value)
    def insert_Commodities_at(self, index, value): self.Commodities.insert(index, value)
    def replace_Commodities_at(self, index, value): self.Commodities[index] = value
    def get_ExportDetail(self): return self.ExportDetail
    def set_ExportDetail(self, ExportDetail): self.ExportDetail = ExportDetail
    def get_RegulatoryControls(self): return self.RegulatoryControls
    def set_RegulatoryControls(self, RegulatoryControls): self.RegulatoryControls = RegulatoryControls
    def add_RegulatoryControls(self, value): self.RegulatoryControls.append(value)
    def insert_RegulatoryControls_at(self, index, value): self.RegulatoryControls.insert(index, value)
    def replace_RegulatoryControls_at(self, index, value): self.RegulatoryControls[index] = value
    def get_DeclarationStatementDetail(self): return self.DeclarationStatementDetail
    def set_DeclarationStatementDetail(self, DeclarationStatementDetail): self.DeclarationStatementDetail = DeclarationStatementDetail
    def validate_ClearanceBrokerageType(self, value):
        # Validate type ClearanceBrokerageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BROKER_INCLUSIVE', 'BROKER_INCLUSIVE_NON_RESIDENT_IMPORTER', 'BROKER_SELECT', 'BROKER_SELECT_NON_RESIDENT_IMPORTER', 'BROKER_UNASSIGNED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ClearanceBrokerageType' % {"value" : value.encode("utf-8")} )
    def validate_InternationalDocumentContentType(self, value):
        # Validate type InternationalDocumentContentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DERIVED', 'DOCUMENTS_ONLY', 'NON_DOCUMENTS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InternationalDocumentContentType' % {"value" : value.encode("utf-8")} )
    def validate_FreightOnValueType(self, value):
        # Validate type FreightOnValueType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CARRIER_RISK', 'OWN_RISK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightOnValueType' % {"value" : value.encode("utf-8")} )
    def validate_RegulatoryControlType(self, value):
        # Validate type RegulatoryControlType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FOOD_OR_PERISHABLE', 'NAFTA', 'NOT_APPLICABLE_FOR_LOW_CUSTOMS_VALUE_EXCEPTION', 'NOT_IN_FREE_CIRCULATION']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RegulatoryControlType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Brokers or
            self.ClearanceBrokerage is not None or
            self.CustomsOptions is not None or
            self.ImporterOfRecord is not None or
            self.RecipientCustomsId is not None or
            self.DutiesPayment is not None or
            self.DocumentContent is not None or
            self.CustomsValue is not None or
            self.FreightOnValue is not None or
            self.InsuranceCharges is not None or
            self.PartiesToTransactionAreRelated is not None or
            self.CommercialInvoice is not None or
            self.Commodities or
            self.ExportDetail is not None or
            self.RegulatoryControls or
            self.DeclarationStatementDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomsClearanceDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomsClearanceDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomsClearanceDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomsClearanceDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomsClearanceDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomsClearanceDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Brokers_ in self.Brokers:
            Brokers_.export(outfile, level, namespace_, name_='Brokers', pretty_print=pretty_print)
        if self.ClearanceBrokerage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ClearanceBrokerage>%s</ns:ClearanceBrokerage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ClearanceBrokerage), input_name='ClearanceBrokerage')), eol_))
        if self.CustomsOptions is not None:
            self.CustomsOptions.export(outfile, level, namespace_, name_='CustomsOptions', pretty_print=pretty_print)
        if self.ImporterOfRecord is not None:
            self.ImporterOfRecord.export(outfile, level, namespace_, name_='ImporterOfRecord', pretty_print=pretty_print)
        if self.RecipientCustomsId is not None:
            self.RecipientCustomsId.export(outfile, level, namespace_, name_='RecipientCustomsId', pretty_print=pretty_print)
        if self.DutiesPayment is not None:
            self.DutiesPayment.export(outfile, level, namespace_, name_='DutiesPayment', pretty_print=pretty_print)
        if self.DocumentContent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DocumentContent>%s</ns:DocumentContent>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocumentContent), input_name='DocumentContent')), eol_))
        if self.CustomsValue is not None:
            self.CustomsValue.export(outfile, level, namespace_, name_='CustomsValue', pretty_print=pretty_print)
        if self.FreightOnValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FreightOnValue>%s</ns:FreightOnValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FreightOnValue), input_name='FreightOnValue')), eol_))
        if self.InsuranceCharges is not None:
            self.InsuranceCharges.export(outfile, level, namespace_, name_='InsuranceCharges', pretty_print=pretty_print)
        if self.PartiesToTransactionAreRelated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PartiesToTransactionAreRelated>%s</ns:PartiesToTransactionAreRelated>%s' % (self.gds_format_boolean(self.PartiesToTransactionAreRelated, input_name='PartiesToTransactionAreRelated'), eol_))
        if self.CommercialInvoice is not None:
            self.CommercialInvoice.export(outfile, level, namespace_, name_='CommercialInvoice', pretty_print=pretty_print)
        for Commodities_ in self.Commodities:
            Commodities_.export(outfile, level, namespace_, name_='Commodities', pretty_print=pretty_print)
        if self.ExportDetail is not None:
            self.ExportDetail.export(outfile, level, namespace_, name_='ExportDetail', pretty_print=pretty_print)
        for RegulatoryControls_ in self.RegulatoryControls:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RegulatoryControls>%s</ns:RegulatoryControls>%s' % (self.gds_encode(self.gds_format_string(quote_xml(RegulatoryControls_), input_name='RegulatoryControls')), eol_))
        if self.DeclarationStatementDetail is not None:
            self.DeclarationStatementDetail.export(outfile, level, namespace_, name_='DeclarationStatementDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Brokers':
            obj_ = BrokerDetail.factory()
            obj_.build(child_)
            self.Brokers.append(obj_)
            obj_.original_tagname_ = 'Brokers'
        elif nodeName_ == 'ClearanceBrokerage':
            ClearanceBrokerage_ = child_.text
            ClearanceBrokerage_ = self.gds_validate_string(ClearanceBrokerage_, node, 'ClearanceBrokerage')
            self.ClearanceBrokerage = ClearanceBrokerage_
            # validate type ClearanceBrokerageType
            self.validate_ClearanceBrokerageType(self.ClearanceBrokerage)
        elif nodeName_ == 'CustomsOptions':
            obj_ = CustomsOptionDetail.factory()
            obj_.build(child_)
            self.CustomsOptions = obj_
            obj_.original_tagname_ = 'CustomsOptions'
        elif nodeName_ == 'ImporterOfRecord':
            obj_ = Party.factory()
            obj_.build(child_)
            self.ImporterOfRecord = obj_
            obj_.original_tagname_ = 'ImporterOfRecord'
        elif nodeName_ == 'RecipientCustomsId':
            obj_ = RecipientCustomsId.factory()
            obj_.build(child_)
            self.RecipientCustomsId = obj_
            obj_.original_tagname_ = 'RecipientCustomsId'
        elif nodeName_ == 'DutiesPayment':
            obj_ = Payment.factory()
            obj_.build(child_)
            self.DutiesPayment = obj_
            obj_.original_tagname_ = 'DutiesPayment'
        elif nodeName_ == 'DocumentContent':
            DocumentContent_ = child_.text
            DocumentContent_ = self.gds_validate_string(DocumentContent_, node, 'DocumentContent')
            self.DocumentContent = DocumentContent_
            # validate type InternationalDocumentContentType
            self.validate_InternationalDocumentContentType(self.DocumentContent)
        elif nodeName_ == 'CustomsValue':
            obj_ = Money.factory()
            obj_.build(child_)
            self.CustomsValue = obj_
            obj_.original_tagname_ = 'CustomsValue'
        elif nodeName_ == 'FreightOnValue':
            FreightOnValue_ = child_.text
            FreightOnValue_ = self.gds_validate_string(FreightOnValue_, node, 'FreightOnValue')
            self.FreightOnValue = FreightOnValue_
            # validate type FreightOnValueType
            self.validate_FreightOnValueType(self.FreightOnValue)
        elif nodeName_ == 'InsuranceCharges':
            obj_ = Money.factory()
            obj_.build(child_)
            self.InsuranceCharges = obj_
            obj_.original_tagname_ = 'InsuranceCharges'
        elif nodeName_ == 'PartiesToTransactionAreRelated':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PartiesToTransactionAreRelated')
            self.PartiesToTransactionAreRelated = ival_
        elif nodeName_ == 'CommercialInvoice':
            obj_ = CommercialInvoice.factory()
            obj_.build(child_)
            self.CommercialInvoice = obj_
            obj_.original_tagname_ = 'CommercialInvoice'
        elif nodeName_ == 'Commodities':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.Commodities.append(obj_)
            obj_.original_tagname_ = 'Commodities'
        elif nodeName_ == 'ExportDetail':
            obj_ = ExportDetail.factory()
            obj_.build(child_)
            self.ExportDetail = obj_
            obj_.original_tagname_ = 'ExportDetail'
        elif nodeName_ == 'RegulatoryControls':
            RegulatoryControls_ = child_.text
            RegulatoryControls_ = self.gds_validate_string(RegulatoryControls_, node, 'RegulatoryControls')
            self.RegulatoryControls.append(RegulatoryControls_)
            # validate type RegulatoryControlType
            self.validate_RegulatoryControlType(self.RegulatoryControls[-1])
        elif nodeName_ == 'DeclarationStatementDetail':
            obj_ = CustomsDeclarationStatementDetail.factory()
            obj_.build(child_)
            self.DeclarationStatementDetail = obj_
            obj_.original_tagname_ = 'DeclarationStatementDetail'
# end class CustomsClearanceDetail


class CustomsDeclarationStatementDetail(GeneratedsSuper):
    """This provides the information necessary to identify the different
    statements, declarations, acts, and/or certifications that apply
    to this shipment."""
    subclass = None
    superclass = None
    def __init__(self, Types=None, NaftaLowValueStatementDetail=None):
        self.original_tagname_ = None
        if Types is None:
            self.Types = []
        else:
            self.Types = Types
        self.NaftaLowValueStatementDetail = NaftaLowValueStatementDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomsDeclarationStatementDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomsDeclarationStatementDetail.subclass:
            return CustomsDeclarationStatementDetail.subclass(*args_, **kwargs_)
        else:
            return CustomsDeclarationStatementDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Types(self): return self.Types
    def set_Types(self, Types): self.Types = Types
    def add_Types(self, value): self.Types.append(value)
    def insert_Types_at(self, index, value): self.Types.insert(index, value)
    def replace_Types_at(self, index, value): self.Types[index] = value
    def get_NaftaLowValueStatementDetail(self): return self.NaftaLowValueStatementDetail
    def set_NaftaLowValueStatementDetail(self, NaftaLowValueStatementDetail): self.NaftaLowValueStatementDetail = NaftaLowValueStatementDetail
    def validate_CustomsDeclarationStatementType(self, value):
        # Validate type CustomsDeclarationStatementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NAFTA_LOW_VALUE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomsDeclarationStatementType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Types or
            self.NaftaLowValueStatementDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomsDeclarationStatementDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomsDeclarationStatementDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomsDeclarationStatementDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomsDeclarationStatementDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomsDeclarationStatementDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomsDeclarationStatementDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Types_ in self.Types:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:domain>%s</ns:domain>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Types_), input_name='domain')), eol_))
        if self.NaftaLowValueStatementDetail is not None:
            self.NaftaLowValueStatementDetail.export(outfile, level, namespace_, name_='NaftaLowValueStatementDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domain':
            Types_ = child_.text
            Types_ = self.gds_validate_string(Types_, node, 'domain')
            self.Types.append(Types_)
            # validate type CustomsDeclarationStatementType
            self.validate_CustomsDeclarationStatementType(self.Types[-1])
        elif nodeName_ == 'NaftaLowValueStatementDetail':
            obj_ = NaftaLowValueStatementDetail.factory()
            obj_.build(child_)
            self.NaftaLowValueStatementDetail = obj_
            obj_.original_tagname_ = 'NaftaLowValueStatementDetail'
# end class CustomsDeclarationStatementDetail


class CustomsOptionDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Description=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_CustomsOptionType(self.Type)
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomsOptionDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomsOptionDetail.subclass:
            return CustomsOptionDetail.subclass(*args_, **kwargs_)
        else:
            return CustomsOptionDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def validate_CustomsOptionType(self, value):
        # Validate type CustomsOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COURTESY_RETURN_LABEL', 'EXHIBITION_TRADE_SHOW', 'FAULTY_ITEM', 'FOLLOWING_REPAIR', 'FOR_REPAIR', 'ITEM_FOR_LOAN', 'OTHER', 'REJECTED', 'REPLACEMENT', 'TRIAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomsOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='CustomsOptionDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomsOptionDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomsOptionDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='CustomsOptionDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='CustomsOptionDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='CustomsOptionDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type CustomsOptionType
            self.validate_CustomsOptionType(self.Type)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class CustomsOptionDetail


class DangerousGoodsContainer(GeneratedsSuper):
    """Describes an approved container used to package dangerous goods
    commodities. This does not describe any individual inner
    receptacles that may be within this container."""
    subclass = None
    superclass = None
    def __init__(self, PackingType=None, ContainerType=None, RadioactiveContainerClass=None, NumberOfContainers=None, HazardousCommodities=None):
        self.original_tagname_ = None
        self.PackingType = PackingType
        self.validate_HazardousContainerPackingType(self.PackingType)
        self.ContainerType = ContainerType
        self.RadioactiveContainerClass = RadioactiveContainerClass
        self.validate_RadioactiveContainerClassType(self.RadioactiveContainerClass)
        self.NumberOfContainers = NumberOfContainers
        if HazardousCommodities is None:
            self.HazardousCommodities = []
        else:
            self.HazardousCommodities = HazardousCommodities
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DangerousGoodsContainer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DangerousGoodsContainer.subclass:
            return DangerousGoodsContainer.subclass(*args_, **kwargs_)
        else:
            return DangerousGoodsContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PackingType(self): return self.PackingType
    def set_PackingType(self, PackingType): self.PackingType = PackingType
    def get_ContainerType(self): return self.ContainerType
    def set_ContainerType(self, ContainerType): self.ContainerType = ContainerType
    def get_RadioactiveContainerClass(self): return self.RadioactiveContainerClass
    def set_RadioactiveContainerClass(self, RadioactiveContainerClass): self.RadioactiveContainerClass = RadioactiveContainerClass
    def get_NumberOfContainers(self): return self.NumberOfContainers
    def set_NumberOfContainers(self, NumberOfContainers): self.NumberOfContainers = NumberOfContainers
    def get_HazardousCommodities(self): return self.HazardousCommodities
    def set_HazardousCommodities(self, HazardousCommodities): self.HazardousCommodities = HazardousCommodities
    def add_HazardousCommodities(self, value): self.HazardousCommodities.append(value)
    def insert_HazardousCommodities_at(self, index, value): self.HazardousCommodities.insert(index, value)
    def replace_HazardousCommodities_at(self, index, value): self.HazardousCommodities[index] = value
    def validate_HazardousContainerPackingType(self, value):
        # Validate type HazardousContainerPackingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ALL_PACKED_IN_ONE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousContainerPackingType' % {"value" : value.encode("utf-8")} )
    def validate_RadioactiveContainerClassType(self, value):
        # Validate type RadioactiveContainerClassType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EXCEPTED_PACKAGE', 'INDUSTRIAL_IP1', 'INDUSTRIAL_IP2', 'INDUSTRIAL_IP3', 'TYPE_A', 'TYPE_B_M', 'TYPE_B_U', 'TYPE_C']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RadioactiveContainerClassType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PackingType is not None or
            self.ContainerType is not None or
            self.RadioactiveContainerClass is not None or
            self.NumberOfContainers is not None or
            self.HazardousCommodities
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DangerousGoodsContainer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DangerousGoodsContainer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DangerousGoodsContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DangerousGoodsContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DangerousGoodsContainer'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DangerousGoodsContainer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PackingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackingType>%s</ns:PackingType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackingType), input_name='PackingType')), eol_))
        if self.ContainerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ContainerType>%s</ns:ContainerType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ContainerType), input_name='ContainerType')), eol_))
        if self.RadioactiveContainerClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RadioactiveContainerClass>%s</ns:RadioactiveContainerClass>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RadioactiveContainerClass), input_name='RadioactiveContainerClass')), eol_))
        if self.NumberOfContainers is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:NumberOfContainers>%s</ns:NumberOfContainers>%s' % (self.gds_format_integer(self.NumberOfContainers, input_name='NumberOfContainers'), eol_))
        for HazardousCommodities_ in self.HazardousCommodities:
            HazardousCommodities_.export(outfile, level, namespace_, name_='HazardousCommodities', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PackingType':
            PackingType_ = child_.text
            PackingType_ = self.gds_validate_string(PackingType_, node, 'PackingType')
            self.PackingType = PackingType_
            # validate type HazardousContainerPackingType
            self.validate_HazardousContainerPackingType(self.PackingType)
        elif nodeName_ == 'ContainerType':
            ContainerType_ = child_.text
            ContainerType_ = self.gds_validate_string(ContainerType_, node, 'ContainerType')
            self.ContainerType = ContainerType_
        elif nodeName_ == 'RadioactiveContainerClass':
            RadioactiveContainerClass_ = child_.text
            RadioactiveContainerClass_ = self.gds_validate_string(RadioactiveContainerClass_, node, 'RadioactiveContainerClass')
            self.RadioactiveContainerClass = RadioactiveContainerClass_
            # validate type RadioactiveContainerClassType
            self.validate_RadioactiveContainerClassType(self.RadioactiveContainerClass)
        elif nodeName_ == 'NumberOfContainers':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfContainers')
            self.NumberOfContainers = ival_
        elif nodeName_ == 'HazardousCommodities':
            obj_ = HazardousCommodityContent.factory()
            obj_.build(child_)
            self.HazardousCommodities.append(obj_)
            obj_.original_tagname_ = 'HazardousCommodities'
# end class DangerousGoodsContainer


class DangerousGoodsDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UploadedTrackingNumber=None, Regulation=None, Accessibility=None, CargoAircraftOnly=None, Options=None, PackingOption=None, ReferenceId=None, Containers=None, Packaging=None, Signatory=None, EmergencyContactNumber=None, Offeror=None, InfectiousSubstanceResponsibleContact=None, AdditionalHandling=None, RadioactivityDetail=None):
        self.original_tagname_ = None
        self.UploadedTrackingNumber = UploadedTrackingNumber
        self.Regulation = Regulation
        self.validate_HazardousCommodityRegulationType(self.Regulation)
        self.Accessibility = Accessibility
        self.validate_DangerousGoodsAccessibilityType(self.Accessibility)
        self.CargoAircraftOnly = CargoAircraftOnly
        if Options is None:
            self.Options = []
        else:
            self.Options = Options
        self.PackingOption = PackingOption
        self.validate_DangerousGoodsPackingOptionType(self.PackingOption)
        self.ReferenceId = ReferenceId
        if Containers is None:
            self.Containers = []
        else:
            self.Containers = Containers
        self.Packaging = Packaging
        self.Signatory = Signatory
        self.EmergencyContactNumber = EmergencyContactNumber
        self.Offeror = Offeror
        self.InfectiousSubstanceResponsibleContact = InfectiousSubstanceResponsibleContact
        self.AdditionalHandling = AdditionalHandling
        self.RadioactivityDetail = RadioactivityDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DangerousGoodsDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DangerousGoodsDetail.subclass:
            return DangerousGoodsDetail.subclass(*args_, **kwargs_)
        else:
            return DangerousGoodsDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UploadedTrackingNumber(self): return self.UploadedTrackingNumber
    def set_UploadedTrackingNumber(self, UploadedTrackingNumber): self.UploadedTrackingNumber = UploadedTrackingNumber
    def get_Regulation(self): return self.Regulation
    def set_Regulation(self, Regulation): self.Regulation = Regulation
    def get_Accessibility(self): return self.Accessibility
    def set_Accessibility(self, Accessibility): self.Accessibility = Accessibility
    def get_CargoAircraftOnly(self): return self.CargoAircraftOnly
    def set_CargoAircraftOnly(self, CargoAircraftOnly): self.CargoAircraftOnly = CargoAircraftOnly
    def get_Options(self): return self.Options
    def set_Options(self, Options): self.Options = Options
    def add_Options(self, value): self.Options.append(value)
    def insert_Options_at(self, index, value): self.Options.insert(index, value)
    def replace_Options_at(self, index, value): self.Options[index] = value
    def get_PackingOption(self): return self.PackingOption
    def set_PackingOption(self, PackingOption): self.PackingOption = PackingOption
    def get_ReferenceId(self): return self.ReferenceId
    def set_ReferenceId(self, ReferenceId): self.ReferenceId = ReferenceId
    def get_Containers(self): return self.Containers
    def set_Containers(self, Containers): self.Containers = Containers
    def add_Containers(self, value): self.Containers.append(value)
    def insert_Containers_at(self, index, value): self.Containers.insert(index, value)
    def replace_Containers_at(self, index, value): self.Containers[index] = value
    def get_Packaging(self): return self.Packaging
    def set_Packaging(self, Packaging): self.Packaging = Packaging
    def get_Signatory(self): return self.Signatory
    def set_Signatory(self, Signatory): self.Signatory = Signatory
    def get_EmergencyContactNumber(self): return self.EmergencyContactNumber
    def set_EmergencyContactNumber(self, EmergencyContactNumber): self.EmergencyContactNumber = EmergencyContactNumber
    def get_Offeror(self): return self.Offeror
    def set_Offeror(self, Offeror): self.Offeror = Offeror
    def get_InfectiousSubstanceResponsibleContact(self): return self.InfectiousSubstanceResponsibleContact
    def set_InfectiousSubstanceResponsibleContact(self, InfectiousSubstanceResponsibleContact): self.InfectiousSubstanceResponsibleContact = InfectiousSubstanceResponsibleContact
    def get_AdditionalHandling(self): return self.AdditionalHandling
    def set_AdditionalHandling(self, AdditionalHandling): self.AdditionalHandling = AdditionalHandling
    def get_RadioactivityDetail(self): return self.RadioactivityDetail
    def set_RadioactivityDetail(self, RadioactivityDetail): self.RadioactivityDetail = RadioactivityDetail
    def validate_HazardousCommodityRegulationType(self, value):
        # Validate type HazardousCommodityRegulationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADR', 'DOT', 'IATA', 'ORMD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityRegulationType' % {"value" : value.encode("utf-8")} )
    def validate_DangerousGoodsAccessibilityType(self, value):
        # Validate type DangerousGoodsAccessibilityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACCESSIBLE', 'INACCESSIBLE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DangerousGoodsAccessibilityType' % {"value" : value.encode("utf-8")} )
    def validate_HazardousCommodityOptionType(self, value):
        # Validate type HazardousCommodityOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BATTERY', 'HAZARDOUS_MATERIALS', 'LIMITED_QUANTITIES_COMMODITIES', 'ORM_D', 'REPORTABLE_QUANTITIES', 'SMALL_QUANTITY_EXCEPTION']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityOptionType' % {"value" : value.encode("utf-8")} )
    def validate_DangerousGoodsPackingOptionType(self, value):
        # Validate type DangerousGoodsPackingOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['OVERPACK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DangerousGoodsPackingOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.UploadedTrackingNumber is not None or
            self.Regulation is not None or
            self.Accessibility is not None or
            self.CargoAircraftOnly is not None or
            self.Options or
            self.PackingOption is not None or
            self.ReferenceId is not None or
            self.Containers or
            self.Packaging is not None or
            self.Signatory is not None or
            self.EmergencyContactNumber is not None or
            self.Offeror is not None or
            self.InfectiousSubstanceResponsibleContact is not None or
            self.AdditionalHandling is not None or
            self.RadioactivityDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DangerousGoodsDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DangerousGoodsDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DangerousGoodsDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DangerousGoodsDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DangerousGoodsDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DangerousGoodsDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UploadedTrackingNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:UploadedTrackingNumber>%s</ns:UploadedTrackingNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UploadedTrackingNumber), input_name='UploadedTrackingNumber')), eol_))
        if self.Regulation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Regulation>%s</ns:Regulation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Regulation), input_name='Regulation')), eol_))
        if self.Accessibility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Accessibility>%s</ns:Accessibility>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Accessibility), input_name='Accessibility')), eol_))
        if self.CargoAircraftOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CargoAircraftOnly>%s</ns:CargoAircraftOnly>%s' % (self.gds_format_boolean(self.CargoAircraftOnly, input_name='CargoAircraftOnly'), eol_))
        for Options_ in self.Options:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Options>%s</ns:Options>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Options_), input_name='Options')), eol_))
        if self.PackingOption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackingOption>%s</ns:PackingOption>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackingOption), input_name='PackingOption')), eol_))
        if self.ReferenceId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ReferenceId>%s</ns:ReferenceId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceId), input_name='ReferenceId')), eol_))
        for Containers_ in self.Containers:
            Containers_.export(outfile, level, namespace_, name_='Containers', pretty_print=pretty_print)
        if self.Packaging is not None:
            self.Packaging.export(outfile, level, namespace_, name_='Packaging', pretty_print=pretty_print)
        if self.Signatory is not None:
            self.Signatory.export(outfile, level, namespace_, name_='Signatory', pretty_print=pretty_print)
        if self.EmergencyContactNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EmergencyContactNumber>%s</ns:EmergencyContactNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EmergencyContactNumber), input_name='EmergencyContactNumber')), eol_))
        if self.Offeror is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Offeror>%s</ns:Offeror>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Offeror), input_name='Offeror')), eol_))
        if self.InfectiousSubstanceResponsibleContact is not None:
            self.InfectiousSubstanceResponsibleContact.export(outfile, level, namespace_, name_='InfectiousSubstanceResponsibleContact', pretty_print=pretty_print)
        if self.AdditionalHandling is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AdditionalHandling>%s</ns:AdditionalHandling>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AdditionalHandling), input_name='AdditionalHandling')), eol_))
        if self.RadioactivityDetail is not None:
            self.RadioactivityDetail.export(outfile, level, namespace_, name_='RadioactivityDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UploadedTrackingNumber':
            UploadedTrackingNumber_ = child_.text
            UploadedTrackingNumber_ = self.gds_validate_string(UploadedTrackingNumber_, node, 'UploadedTrackingNumber')
            self.UploadedTrackingNumber = UploadedTrackingNumber_
        elif nodeName_ == 'Regulation':
            Regulation_ = child_.text
            Regulation_ = self.gds_validate_string(Regulation_, node, 'Regulation')
            self.Regulation = Regulation_
            # validate type HazardousCommodityRegulationType
            self.validate_HazardousCommodityRegulationType(self.Regulation)
        elif nodeName_ == 'Accessibility':
            Accessibility_ = child_.text
            Accessibility_ = self.gds_validate_string(Accessibility_, node, 'Accessibility')
            self.Accessibility = Accessibility_
            # validate type DangerousGoodsAccessibilityType
            self.validate_DangerousGoodsAccessibilityType(self.Accessibility)
        elif nodeName_ == 'CargoAircraftOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CargoAircraftOnly')
            self.CargoAircraftOnly = ival_
        elif nodeName_ == 'Options':
            Options_ = child_.text
            Options_ = self.gds_validate_string(Options_, node, 'Options')
            self.Options.append(Options_)
            # validate type HazardousCommodityOptionType
            self.validate_HazardousCommodityOptionType(self.Options[-1])
        elif nodeName_ == 'PackingOption':
            PackingOption_ = child_.text
            PackingOption_ = self.gds_validate_string(PackingOption_, node, 'PackingOption')
            self.PackingOption = PackingOption_
            # validate type DangerousGoodsPackingOptionType
            self.validate_DangerousGoodsPackingOptionType(self.PackingOption)
        elif nodeName_ == 'ReferenceId':
            ReferenceId_ = child_.text
            ReferenceId_ = self.gds_validate_string(ReferenceId_, node, 'ReferenceId')
            self.ReferenceId = ReferenceId_
        elif nodeName_ == 'Containers':
            obj_ = DangerousGoodsContainer.factory()
            obj_.build(child_)
            self.Containers.append(obj_)
            obj_.original_tagname_ = 'Containers'
        elif nodeName_ == 'Packaging':
            obj_ = HazardousCommodityPackagingDetail.factory()
            obj_.build(child_)
            self.Packaging = obj_
            obj_.original_tagname_ = 'Packaging'
        elif nodeName_ == 'Signatory':
            obj_ = DangerousGoodsSignatory.factory()
            obj_.build(child_)
            self.Signatory = obj_
            obj_.original_tagname_ = 'Signatory'
        elif nodeName_ == 'EmergencyContactNumber':
            EmergencyContactNumber_ = child_.text
            EmergencyContactNumber_ = self.gds_validate_string(EmergencyContactNumber_, node, 'EmergencyContactNumber')
            self.EmergencyContactNumber = EmergencyContactNumber_
        elif nodeName_ == 'Offeror':
            Offeror_ = child_.text
            Offeror_ = self.gds_validate_string(Offeror_, node, 'Offeror')
            self.Offeror = Offeror_
        elif nodeName_ == 'InfectiousSubstanceResponsibleContact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.InfectiousSubstanceResponsibleContact = obj_
            obj_.original_tagname_ = 'InfectiousSubstanceResponsibleContact'
        elif nodeName_ == 'AdditionalHandling':
            AdditionalHandling_ = child_.text
            AdditionalHandling_ = self.gds_validate_string(AdditionalHandling_, node, 'AdditionalHandling')
            self.AdditionalHandling = AdditionalHandling_
        elif nodeName_ == 'RadioactivityDetail':
            obj_ = RadioactivityDetail.factory()
            obj_.build(child_)
            self.RadioactivityDetail = obj_
            obj_.original_tagname_ = 'RadioactivityDetail'
# end class DangerousGoodsDetail


class DangerousGoodsShippersDeclarationDetail(GeneratedsSuper):
    """The instructions indicating how to print the 1421c form for
    dangerous goods shipment."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, CustomerImageUsages=None):
        self.original_tagname_ = None
        self.Format = Format
        if CustomerImageUsages is None:
            self.CustomerImageUsages = []
        else:
            self.CustomerImageUsages = CustomerImageUsages
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DangerousGoodsShippersDeclarationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DangerousGoodsShippersDeclarationDetail.subclass:
            return DangerousGoodsShippersDeclarationDetail.subclass(*args_, **kwargs_)
        else:
            return DangerousGoodsShippersDeclarationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_CustomerImageUsages(self): return self.CustomerImageUsages
    def set_CustomerImageUsages(self, CustomerImageUsages): self.CustomerImageUsages = CustomerImageUsages
    def add_CustomerImageUsages(self, value): self.CustomerImageUsages.append(value)
    def insert_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages.insert(index, value)
    def replace_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages[index] = value
    def hasContent_(self):
        if (
            self.Format is not None or
            self.CustomerImageUsages
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DangerousGoodsShippersDeclarationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DangerousGoodsShippersDeclarationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DangerousGoodsShippersDeclarationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DangerousGoodsShippersDeclarationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DangerousGoodsShippersDeclarationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DangerousGoodsShippersDeclarationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            self.Format.export(outfile, level, namespace_, name_='Format', pretty_print=pretty_print)
        for CustomerImageUsages_ in self.CustomerImageUsages:
            CustomerImageUsages_.export(outfile, level, namespace_, name_='CustomerImageUsages', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
        elif nodeName_ == 'CustomerImageUsages':
            obj_ = CustomerImageUsage.factory()
            obj_.build(child_)
            self.CustomerImageUsages.append(obj_)
            obj_.original_tagname_ = 'CustomerImageUsages'
# end class DangerousGoodsShippersDeclarationDetail


class DangerousGoodsSignatory(GeneratedsSuper):
    """Specifies that name, title and place of the signatory responsible
    for the dangerous goods shipment."""
    subclass = None
    superclass = None
    def __init__(self, ContactName=None, Title=None, Place=None):
        self.original_tagname_ = None
        self.ContactName = ContactName
        self.Title = Title
        self.Place = Place
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DangerousGoodsSignatory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DangerousGoodsSignatory.subclass:
            return DangerousGoodsSignatory.subclass(*args_, **kwargs_)
        else:
            return DangerousGoodsSignatory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactName(self): return self.ContactName
    def set_ContactName(self, ContactName): self.ContactName = ContactName
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Place(self): return self.Place
    def set_Place(self, Place): self.Place = Place
    def hasContent_(self):
        if (
            self.ContactName is not None or
            self.Title is not None or
            self.Place is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DangerousGoodsSignatory', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DangerousGoodsSignatory')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DangerousGoodsSignatory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DangerousGoodsSignatory', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DangerousGoodsSignatory'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DangerousGoodsSignatory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ContactName>%s</ns:ContactName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ContactName), input_name='ContactName')), eol_))
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Title>%s</ns:Title>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Title), input_name='Title')), eol_))
        if self.Place is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Place>%s</ns:Place>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Place), input_name='Place')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactName':
            ContactName_ = child_.text
            ContactName_ = self.gds_validate_string(ContactName_, node, 'ContactName')
            self.ContactName = ContactName_
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'Place':
            Place_ = child_.text
            Place_ = self.gds_validate_string(Place_, node, 'Place')
            self.Place = Place_
# end class DangerousGoodsSignatory


class DateRange(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Begins=None, Ends=None):
        self.original_tagname_ = None
        if isinstance(Begins, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Begins, '%Y-%m-%d').date()
        else:
            initvalue_ = Begins
        self.Begins = initvalue_
        if isinstance(Ends, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Ends, '%Y-%m-%d').date()
        else:
            initvalue_ = Ends
        self.Ends = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateRange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateRange.subclass:
            return DateRange.subclass(*args_, **kwargs_)
        else:
            return DateRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Begins(self): return self.Begins
    def set_Begins(self, Begins): self.Begins = Begins
    def get_Ends(self): return self.Ends
    def set_Ends(self, Ends): self.Ends = Ends
    def hasContent_(self):
        if (
            self.Begins is not None or
            self.Ends is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DateRange', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateRange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DateRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DateRange'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DateRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Begins is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Begins>%s</ns:Begins>%s' % (self.gds_format_date(self.Begins, input_name='Begins'), eol_))
        if self.Ends is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Ends>%s</ns:Ends>%s' % (self.gds_format_date(self.Ends, input_name='Ends'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Begins':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Begins = dval_
        elif nodeName_ == 'Ends':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Ends = dval_
# end class DateRange


class DeleteShipmentRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAuthenticationDetail=None, ClientDetail=None, TransactionDetail=None, Version=None, ShipTimestamp=None, TrackingId=None, DeletionControl=None):
        self.original_tagname_ = None
        self.WebAuthenticationDetail = WebAuthenticationDetail
        self.ClientDetail = ClientDetail
        self.TransactionDetail = TransactionDetail
        self.Version = Version
        if isinstance(ShipTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ShipTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ShipTimestamp
        self.ShipTimestamp = initvalue_
        self.TrackingId = TrackingId
        self.DeletionControl = DeletionControl
        self.validate_DeletionControlType(self.DeletionControl)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeleteShipmentRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeleteShipmentRequest.subclass:
            return DeleteShipmentRequest.subclass(*args_, **kwargs_)
        else:
            return DeleteShipmentRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAuthenticationDetail(self): return self.WebAuthenticationDetail
    def set_WebAuthenticationDetail(self, WebAuthenticationDetail): self.WebAuthenticationDetail = WebAuthenticationDetail
    def get_ClientDetail(self): return self.ClientDetail
    def set_ClientDetail(self, ClientDetail): self.ClientDetail = ClientDetail
    def get_TransactionDetail(self): return self.TransactionDetail
    def set_TransactionDetail(self, TransactionDetail): self.TransactionDetail = TransactionDetail
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_ShipTimestamp(self): return self.ShipTimestamp
    def set_ShipTimestamp(self, ShipTimestamp): self.ShipTimestamp = ShipTimestamp
    def get_TrackingId(self): return self.TrackingId
    def set_TrackingId(self, TrackingId): self.TrackingId = TrackingId
    def get_DeletionControl(self): return self.DeletionControl
    def set_DeletionControl(self, DeletionControl): self.DeletionControl = DeletionControl
    def validate_DeletionControlType(self, value):
        # Validate type DeletionControlType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DELETE_ALL_PACKAGES', 'DELETE_ENTIRE_CONSOLIDATION', 'DELETE_ONE_PACKAGE', 'LEGACY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeletionControlType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.WebAuthenticationDetail is not None or
            self.ClientDetail is not None or
            self.TransactionDetail is not None or
            self.Version is not None or
            self.ShipTimestamp is not None or
            self.TrackingId is not None or
            self.DeletionControl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DeleteShipmentRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeleteShipmentRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeleteShipmentRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DeleteShipmentRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DeleteShipmentRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DeleteShipmentRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WebAuthenticationDetail is not None:
            self.WebAuthenticationDetail.export(outfile, level, namespace_, name_='WebAuthenticationDetail', pretty_print=pretty_print)
        if self.ClientDetail is not None:
            self.ClientDetail.export(outfile, level, namespace_, name_='ClientDetail', pretty_print=pretty_print)
        if self.TransactionDetail is not None:
            self.TransactionDetail.export(outfile, level, namespace_, name_='TransactionDetail', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.ShipTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ShipTimestamp>%s</ns:ShipTimestamp>%s' % (self.gds_format_datetime(self.ShipTimestamp, input_name='ShipTimestamp'), eol_))
        if self.TrackingId is not None:
            self.TrackingId.export(outfile, level, namespace_, name_='TrackingId', pretty_print=pretty_print)
        if self.DeletionControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DeletionControl>%s</ns:DeletionControl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeletionControl), input_name='DeletionControl')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAuthenticationDetail':
            obj_ = WebAuthenticationDetail.factory()
            obj_.build(child_)
            self.WebAuthenticationDetail = obj_
            obj_.original_tagname_ = 'WebAuthenticationDetail'
        elif nodeName_ == 'ClientDetail':
            obj_ = ClientDetail.factory()
            obj_.build(child_)
            self.ClientDetail = obj_
            obj_.original_tagname_ = 'ClientDetail'
        elif nodeName_ == 'TransactionDetail':
            obj_ = TransactionDetail.factory()
            obj_.build(child_)
            self.TransactionDetail = obj_
            obj_.original_tagname_ = 'TransactionDetail'
        elif nodeName_ == 'Version':
            obj_ = VersionId.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'ShipTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ShipTimestamp = dval_
        elif nodeName_ == 'TrackingId':
            obj_ = TrackingId.factory()
            obj_.build(child_)
            self.TrackingId = obj_
            obj_.original_tagname_ = 'TrackingId'
        elif nodeName_ == 'DeletionControl':
            DeletionControl_ = child_.text
            DeletionControl_ = self.gds_validate_string(DeletionControl_, node, 'DeletionControl')
            self.DeletionControl = DeletionControl_
            # validate type DeletionControlType
            self.validate_DeletionControlType(self.DeletionControl)
# end class DeleteShipmentRequest


class DeleteTagRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAuthenticationDetail=None, ClientDetail=None, TransactionDetail=None, Version=None, DispatchLocationId=None, DispatchDate=None, Payment=None, ConfirmationNumber=None):
        self.original_tagname_ = None
        self.WebAuthenticationDetail = WebAuthenticationDetail
        self.ClientDetail = ClientDetail
        self.TransactionDetail = TransactionDetail
        self.Version = Version
        self.DispatchLocationId = DispatchLocationId
        if isinstance(DispatchDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DispatchDate, '%Y-%m-%d').date()
        else:
            initvalue_ = DispatchDate
        self.DispatchDate = initvalue_
        self.Payment = Payment
        self.ConfirmationNumber = ConfirmationNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeleteTagRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeleteTagRequest.subclass:
            return DeleteTagRequest.subclass(*args_, **kwargs_)
        else:
            return DeleteTagRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAuthenticationDetail(self): return self.WebAuthenticationDetail
    def set_WebAuthenticationDetail(self, WebAuthenticationDetail): self.WebAuthenticationDetail = WebAuthenticationDetail
    def get_ClientDetail(self): return self.ClientDetail
    def set_ClientDetail(self, ClientDetail): self.ClientDetail = ClientDetail
    def get_TransactionDetail(self): return self.TransactionDetail
    def set_TransactionDetail(self, TransactionDetail): self.TransactionDetail = TransactionDetail
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_DispatchLocationId(self): return self.DispatchLocationId
    def set_DispatchLocationId(self, DispatchLocationId): self.DispatchLocationId = DispatchLocationId
    def get_DispatchDate(self): return self.DispatchDate
    def set_DispatchDate(self, DispatchDate): self.DispatchDate = DispatchDate
    def get_Payment(self): return self.Payment
    def set_Payment(self, Payment): self.Payment = Payment
    def get_ConfirmationNumber(self): return self.ConfirmationNumber
    def set_ConfirmationNumber(self, ConfirmationNumber): self.ConfirmationNumber = ConfirmationNumber
    def hasContent_(self):
        if (
            self.WebAuthenticationDetail is not None or
            self.ClientDetail is not None or
            self.TransactionDetail is not None or
            self.Version is not None or
            self.DispatchLocationId is not None or
            self.DispatchDate is not None or
            self.Payment is not None or
            self.ConfirmationNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DeleteTagRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeleteTagRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeleteTagRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DeleteTagRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DeleteTagRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DeleteTagRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WebAuthenticationDetail is not None:
            self.WebAuthenticationDetail.export(outfile, level, namespace_, name_='WebAuthenticationDetail', pretty_print=pretty_print)
        if self.ClientDetail is not None:
            self.ClientDetail.export(outfile, level, namespace_, name_='ClientDetail', pretty_print=pretty_print)
        if self.TransactionDetail is not None:
            self.TransactionDetail.export(outfile, level, namespace_, name_='TransactionDetail', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.DispatchLocationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DispatchLocationId>%s</ns:DispatchLocationId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DispatchLocationId), input_name='DispatchLocationId')), eol_))
        if self.DispatchDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DispatchDate>%s</ns:DispatchDate>%s' % (self.gds_format_date(self.DispatchDate, input_name='DispatchDate'), eol_))
        if self.Payment is not None:
            self.Payment.export(outfile, level, namespace_, name_='Payment', pretty_print=pretty_print)
        if self.ConfirmationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ConfirmationNumber>%s</ns:ConfirmationNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConfirmationNumber), input_name='ConfirmationNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAuthenticationDetail':
            obj_ = WebAuthenticationDetail.factory()
            obj_.build(child_)
            self.WebAuthenticationDetail = obj_
            obj_.original_tagname_ = 'WebAuthenticationDetail'
        elif nodeName_ == 'ClientDetail':
            obj_ = ClientDetail.factory()
            obj_.build(child_)
            self.ClientDetail = obj_
            obj_.original_tagname_ = 'ClientDetail'
        elif nodeName_ == 'TransactionDetail':
            obj_ = TransactionDetail.factory()
            obj_.build(child_)
            self.TransactionDetail = obj_
            obj_.original_tagname_ = 'TransactionDetail'
        elif nodeName_ == 'Version':
            obj_ = VersionId.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'DispatchLocationId':
            DispatchLocationId_ = child_.text
            DispatchLocationId_ = self.gds_validate_string(DispatchLocationId_, node, 'DispatchLocationId')
            self.DispatchLocationId = DispatchLocationId_
        elif nodeName_ == 'DispatchDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DispatchDate = dval_
        elif nodeName_ == 'Payment':
            obj_ = Payment.factory()
            obj_.build(child_)
            self.Payment = obj_
            obj_.original_tagname_ = 'Payment'
        elif nodeName_ == 'ConfirmationNumber':
            ConfirmationNumber_ = child_.text
            ConfirmationNumber_ = self.gds_validate_string(ConfirmationNumber_, node, 'ConfirmationNumber')
            self.ConfirmationNumber = ConfirmationNumber_
# end class DeleteTagRequest


class DeliveryOnInvoiceAcceptanceDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Recipient=None, TrackingId=None):
        self.original_tagname_ = None
        self.Recipient = Recipient
        self.TrackingId = TrackingId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryOnInvoiceAcceptanceDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryOnInvoiceAcceptanceDetail.subclass:
            return DeliveryOnInvoiceAcceptanceDetail.subclass(*args_, **kwargs_)
        else:
            return DeliveryOnInvoiceAcceptanceDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Recipient(self): return self.Recipient
    def set_Recipient(self, Recipient): self.Recipient = Recipient
    def get_TrackingId(self): return self.TrackingId
    def set_TrackingId(self, TrackingId): self.TrackingId = TrackingId
    def hasContent_(self):
        if (
            self.Recipient is not None or
            self.TrackingId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DeliveryOnInvoiceAcceptanceDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeliveryOnInvoiceAcceptanceDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryOnInvoiceAcceptanceDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DeliveryOnInvoiceAcceptanceDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DeliveryOnInvoiceAcceptanceDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DeliveryOnInvoiceAcceptanceDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Recipient is not None:
            self.Recipient.export(outfile, level, namespace_, name_='Recipient', pretty_print=pretty_print)
        if self.TrackingId is not None:
            self.TrackingId.export(outfile, level, namespace_, name_='TrackingId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Recipient':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Recipient = obj_
            obj_.original_tagname_ = 'Recipient'
        elif nodeName_ == 'TrackingId':
            obj_ = TrackingId.factory()
            obj_.build(child_)
            self.TrackingId = obj_
            obj_.original_tagname_ = 'TrackingId'
# end class DeliveryOnInvoiceAcceptanceDetail


class DestinationControlDetail(GeneratedsSuper):
    """Data required to complete the Destionation Control Statement for US
    exports."""
    subclass = None
    superclass = None
    def __init__(self, StatementTypes=None, DestinationCountries=None, EndUser=None):
        self.original_tagname_ = None
        if StatementTypes is None:
            self.StatementTypes = []
        else:
            self.StatementTypes = StatementTypes
        self.DestinationCountries = DestinationCountries
        self.EndUser = EndUser
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DestinationControlDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DestinationControlDetail.subclass:
            return DestinationControlDetail.subclass(*args_, **kwargs_)
        else:
            return DestinationControlDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StatementTypes(self): return self.StatementTypes
    def set_StatementTypes(self, StatementTypes): self.StatementTypes = StatementTypes
    def add_StatementTypes(self, value): self.StatementTypes.append(value)
    def insert_StatementTypes_at(self, index, value): self.StatementTypes.insert(index, value)
    def replace_StatementTypes_at(self, index, value): self.StatementTypes[index] = value
    def get_DestinationCountries(self): return self.DestinationCountries
    def set_DestinationCountries(self, DestinationCountries): self.DestinationCountries = DestinationCountries
    def get_EndUser(self): return self.EndUser
    def set_EndUser(self, EndUser): self.EndUser = EndUser
    def validate_DestinationControlStatementType(self, value):
        # Validate type DestinationControlStatementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEPARTMENT_OF_COMMERCE', 'DEPARTMENT_OF_STATE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DestinationControlStatementType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.StatementTypes or
            self.DestinationCountries is not None or
            self.EndUser is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DestinationControlDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DestinationControlDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestinationControlDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DestinationControlDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DestinationControlDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DestinationControlDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StatementTypes_ in self.StatementTypes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:StatementTypes>%s</ns:StatementTypes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(StatementTypes_), input_name='StatementTypes')), eol_))
        if self.DestinationCountries is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DestinationCountries>%s</ns:DestinationCountries>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationCountries), input_name='DestinationCountries')), eol_))
        if self.EndUser is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EndUser>%s</ns:EndUser>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EndUser), input_name='EndUser')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StatementTypes':
            StatementTypes_ = child_.text
            StatementTypes_ = self.gds_validate_string(StatementTypes_, node, 'StatementTypes')
            self.StatementTypes.append(StatementTypes_)
            # validate type DestinationControlStatementType
            self.validate_DestinationControlStatementType(self.StatementTypes[-1])
        elif nodeName_ == 'DestinationCountries':
            DestinationCountries_ = child_.text
            DestinationCountries_ = self.gds_validate_string(DestinationCountries_, node, 'DestinationCountries')
            self.DestinationCountries = DestinationCountries_
        elif nodeName_ == 'EndUser':
            EndUser_ = child_.text
            EndUser_ = self.gds_validate_string(EndUser_, node, 'EndUser')
            self.EndUser = EndUser_
# end class DestinationControlDetail


class Dimensions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Length=None, Width=None, Height=None, Units=None):
        self.original_tagname_ = None
        self.Length = Length
        self.Width = Width
        self.Height = Height
        self.Units = Units
        self.validate_LinearUnits(self.Units)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Dimensions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Dimensions.subclass:
            return Dimensions.subclass(*args_, **kwargs_)
        else:
            return Dimensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def validate_LinearUnits(self, value):
        # Validate type LinearUnits, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CM', 'IN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LinearUnits' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Length is not None or
            self.Width is not None or
            self.Height is not None or
            self.Units is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Dimensions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Dimensions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Dimensions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Dimensions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Dimensions'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Dimensions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Length>%s</ns:Length>%s' % (self.gds_format_integer(self.Length, input_name='Length'), eol_))
        if self.Width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Width>%s</ns:Width>%s' % (self.gds_format_integer(self.Width, input_name='Width'), eol_))
        if self.Height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Height>%s</ns:Height>%s' % (self.gds_format_integer(self.Height, input_name='Height'), eol_))
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Units>%s</ns:Units>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Units), input_name='Units')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Length')
            self.Length = ival_
        elif nodeName_ == 'Width':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Width')
            self.Width = ival_
        elif nodeName_ == 'Height':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Height')
            self.Height = ival_
        elif nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
            # validate type LinearUnits
            self.validate_LinearUnits(self.Units)
# end class Dimensions


class DocTabContent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DocTabContentType=None, Zone001=None, Barcoded=None):
        self.original_tagname_ = None
        self.DocTabContentType = DocTabContentType
        self.validate_DocTabContentType(self.DocTabContentType)
        self.Zone001 = Zone001
        self.Barcoded = Barcoded
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocTabContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocTabContent.subclass:
            return DocTabContent.subclass(*args_, **kwargs_)
        else:
            return DocTabContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocTabContentType(self): return self.DocTabContentType
    def set_DocTabContentType(self, DocTabContentType): self.DocTabContentType = DocTabContentType
    def get_Zone001(self): return self.Zone001
    def set_Zone001(self, Zone001): self.Zone001 = Zone001
    def get_Barcoded(self): return self.Barcoded
    def set_Barcoded(self, Barcoded): self.Barcoded = Barcoded
    def validate_DocTabContentType(self, value):
        # Validate type DocTabContentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BARCODED', 'CUSTOM', 'MINIMUM', 'STANDARD', 'ZONE001']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocTabContentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DocTabContentType is not None or
            self.Zone001 is not None or
            self.Barcoded is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DocTabContent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocTabContent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocTabContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DocTabContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DocTabContent'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DocTabContent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocTabContentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DocTabContentType>%s</ns:DocTabContentType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocTabContentType), input_name='DocTabContentType')), eol_))
        if self.Zone001 is not None:
            self.Zone001.export(outfile, level, namespace_, name_='Zone001', pretty_print=pretty_print)
        if self.Barcoded is not None:
            self.Barcoded.export(outfile, level, namespace_, name_='Barcoded', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocTabContentType':
            DocTabContentType_ = child_.text
            DocTabContentType_ = self.gds_validate_string(DocTabContentType_, node, 'DocTabContentType')
            self.DocTabContentType = DocTabContentType_
            # validate type DocTabContentType
            self.validate_DocTabContentType(self.DocTabContentType)
        elif nodeName_ == 'Zone001':
            obj_ = DocTabContentZone001.factory()
            obj_.build(child_)
            self.Zone001 = obj_
            obj_.original_tagname_ = 'Zone001'
        elif nodeName_ == 'Barcoded':
            obj_ = DocTabContentBarcoded.factory()
            obj_.build(child_)
            self.Barcoded = obj_
            obj_.original_tagname_ = 'Barcoded'
# end class DocTabContent


class DocTabContentBarcoded(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Symbology=None, Specification=None):
        self.original_tagname_ = None
        self.Symbology = Symbology
        self.validate_BarcodeSymbologyType(self.Symbology)
        self.Specification = Specification
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocTabContentBarcoded)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocTabContentBarcoded.subclass:
            return DocTabContentBarcoded.subclass(*args_, **kwargs_)
        else:
            return DocTabContentBarcoded(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Symbology(self): return self.Symbology
    def set_Symbology(self, Symbology): self.Symbology = Symbology
    def get_Specification(self): return self.Specification
    def set_Specification(self, Specification): self.Specification = Specification
    def validate_BarcodeSymbologyType(self, value):
        # Validate type BarcodeSymbologyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CODABAR', 'CODE128', 'CODE128B', 'CODE128C', 'CODE128_WIDEBAR', 'CODE39', 'CODE93', 'I2OF5', 'PDF417', 'POSTNET', 'QR_CODE', 'UCC128']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BarcodeSymbologyType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Symbology is not None or
            self.Specification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DocTabContentBarcoded', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocTabContentBarcoded')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocTabContentBarcoded')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DocTabContentBarcoded', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DocTabContentBarcoded'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DocTabContentBarcoded', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Symbology is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Symbology>%s</ns:Symbology>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Symbology), input_name='Symbology')), eol_))
        if self.Specification is not None:
            self.Specification.export(outfile, level, namespace_, name_='Specification', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Symbology':
            Symbology_ = child_.text
            Symbology_ = self.gds_validate_string(Symbology_, node, 'Symbology')
            self.Symbology = Symbology_
            # validate type BarcodeSymbologyType
            self.validate_BarcodeSymbologyType(self.Symbology)
        elif nodeName_ == 'Specification':
            obj_ = DocTabZoneSpecification.factory()
            obj_.build(child_)
            self.Specification = obj_
            obj_.original_tagname_ = 'Specification'
# end class DocTabContentBarcoded


class DocTabContentZone001(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DocTabZoneSpecifications=None):
        self.original_tagname_ = None
        if DocTabZoneSpecifications is None:
            self.DocTabZoneSpecifications = []
        else:
            self.DocTabZoneSpecifications = DocTabZoneSpecifications
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocTabContentZone001)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocTabContentZone001.subclass:
            return DocTabContentZone001.subclass(*args_, **kwargs_)
        else:
            return DocTabContentZone001(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocTabZoneSpecifications(self): return self.DocTabZoneSpecifications
    def set_DocTabZoneSpecifications(self, DocTabZoneSpecifications): self.DocTabZoneSpecifications = DocTabZoneSpecifications
    def add_DocTabZoneSpecifications(self, value): self.DocTabZoneSpecifications.append(value)
    def insert_DocTabZoneSpecifications_at(self, index, value): self.DocTabZoneSpecifications.insert(index, value)
    def replace_DocTabZoneSpecifications_at(self, index, value): self.DocTabZoneSpecifications[index] = value
    def hasContent_(self):
        if (
            self.DocTabZoneSpecifications
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DocTabContentZone001', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocTabContentZone001')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocTabContentZone001')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DocTabContentZone001', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DocTabContentZone001'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DocTabContentZone001', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DocTabZoneSpecifications_ in self.DocTabZoneSpecifications:
            DocTabZoneSpecifications_.export(outfile, level, namespace_, name_='DocTabZoneSpecifications', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocTabZoneSpecifications':
            obj_ = DocTabZoneSpecification.factory()
            obj_.build(child_)
            self.DocTabZoneSpecifications.append(obj_)
            obj_.original_tagname_ = 'DocTabZoneSpecifications'
# end class DocTabContentZone001


class DocTabZoneSpecification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ZoneNumber=None, Header=None, DataField=None, LiteralValue=None, Justification=None):
        self.original_tagname_ = None
        self.ZoneNumber = ZoneNumber
        self.Header = Header
        self.DataField = DataField
        self.LiteralValue = LiteralValue
        self.Justification = Justification
        self.validate_DocTabZoneJustificationType(self.Justification)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocTabZoneSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocTabZoneSpecification.subclass:
            return DocTabZoneSpecification.subclass(*args_, **kwargs_)
        else:
            return DocTabZoneSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ZoneNumber(self): return self.ZoneNumber
    def set_ZoneNumber(self, ZoneNumber): self.ZoneNumber = ZoneNumber
    def get_Header(self): return self.Header
    def set_Header(self, Header): self.Header = Header
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def get_LiteralValue(self): return self.LiteralValue
    def set_LiteralValue(self, LiteralValue): self.LiteralValue = LiteralValue
    def get_Justification(self): return self.Justification
    def set_Justification(self, Justification): self.Justification = Justification
    def validate_DocTabZoneJustificationType(self, value):
        # Validate type DocTabZoneJustificationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['LEFT', 'RIGHT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocTabZoneJustificationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ZoneNumber is not None or
            self.Header is not None or
            self.DataField is not None or
            self.LiteralValue is not None or
            self.Justification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DocTabZoneSpecification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocTabZoneSpecification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocTabZoneSpecification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DocTabZoneSpecification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DocTabZoneSpecification'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DocTabZoneSpecification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ZoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ZoneNumber>%s</ns:ZoneNumber>%s' % (self.gds_format_integer(self.ZoneNumber, input_name='ZoneNumber'), eol_))
        if self.Header is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Header>%s</ns:Header>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Header), input_name='Header')), eol_))
        if self.DataField is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DataField>%s</ns:DataField>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataField), input_name='DataField')), eol_))
        if self.LiteralValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LiteralValue>%s</ns:LiteralValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LiteralValue), input_name='LiteralValue')), eol_))
        if self.Justification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Justification>%s</ns:Justification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Justification), input_name='Justification')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ZoneNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ZoneNumber')
            self.ZoneNumber = ival_
        elif nodeName_ == 'Header':
            Header_ = child_.text
            Header_ = self.gds_validate_string(Header_, node, 'Header')
            self.Header = Header_
        elif nodeName_ == 'DataField':
            DataField_ = child_.text
            DataField_ = self.gds_validate_string(DataField_, node, 'DataField')
            self.DataField = DataField_
        elif nodeName_ == 'LiteralValue':
            LiteralValue_ = child_.text
            LiteralValue_ = self.gds_validate_string(LiteralValue_, node, 'LiteralValue')
            self.LiteralValue = LiteralValue_
        elif nodeName_ == 'Justification':
            Justification_ = child_.text
            Justification_ = self.gds_validate_string(Justification_, node, 'Justification')
            self.Justification = Justification_
            # validate type DocTabZoneJustificationType
            self.validate_DocTabZoneJustificationType(self.Justification)
# end class DocTabZoneSpecification


class DocumentFormatOptionsRequested(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Options=None):
        self.original_tagname_ = None
        if Options is None:
            self.Options = []
        else:
            self.Options = Options
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentFormatOptionsRequested)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentFormatOptionsRequested.subclass:
            return DocumentFormatOptionsRequested.subclass(*args_, **kwargs_)
        else:
            return DocumentFormatOptionsRequested(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Options(self): return self.Options
    def set_Options(self, Options): self.Options = Options
    def add_Options(self, value): self.Options.append(value)
    def insert_Options_at(self, index, value): self.Options.insert(index, value)
    def replace_Options_at(self, index, value): self.Options[index] = value
    def validate_DocumentFormatOptionType(self, value):
        # Validate type DocumentFormatOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SUPPRESS_ADDITIONAL_LANGUAGES']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocumentFormatOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Options
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DocumentFormatOptionsRequested', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentFormatOptionsRequested')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentFormatOptionsRequested')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DocumentFormatOptionsRequested', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DocumentFormatOptionsRequested'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DocumentFormatOptionsRequested', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Options_ in self.Options:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Options>%s</ns:Options>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Options_), input_name='Options')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Options':
            Options_ = child_.text
            Options_ = self.gds_validate_string(Options_, node, 'Options')
            self.Options.append(Options_)
            # validate type DocumentFormatOptionType
            self.validate_DocumentFormatOptionType(self.Options[-1])
# end class DocumentFormatOptionsRequested


class DocumentGenerationDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, MinimumCopiesRequired=None, Letterhead=None, ElectronicSignature=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_EnterpriseDocumentType(self.Type)
        self.MinimumCopiesRequired = MinimumCopiesRequired
        self.Letterhead = Letterhead
        self.validate_RequirementType(self.Letterhead)
        self.ElectronicSignature = ElectronicSignature
        self.validate_RequirementType(self.ElectronicSignature)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentGenerationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentGenerationDetail.subclass:
            return DocumentGenerationDetail.subclass(*args_, **kwargs_)
        else:
            return DocumentGenerationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_MinimumCopiesRequired(self): return self.MinimumCopiesRequired
    def set_MinimumCopiesRequired(self, MinimumCopiesRequired): self.MinimumCopiesRequired = MinimumCopiesRequired
    def get_Letterhead(self): return self.Letterhead
    def set_Letterhead(self, Letterhead): self.Letterhead = Letterhead
    def get_ElectronicSignature(self): return self.ElectronicSignature
    def set_ElectronicSignature(self, ElectronicSignature): self.ElectronicSignature = ElectronicSignature
    def validate_EnterpriseDocumentType(self, value):
        # Validate type EnterpriseDocumentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AIR_WAYBILL', 'CERTIFICATE_OF_ORIGIN', 'COMMERCIAL_INVOICE', 'NAFTA_CERTIFICATE_OF_ORIGIN', 'PRO_FORMA_INVOICE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnterpriseDocumentType' % {"value" : value.encode("utf-8")} )
    def validate_RequirementType(self, value):
        # Validate type RequirementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['OPTIONAL', 'PROHIBITED', 'REQUIRED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequirementType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.MinimumCopiesRequired is not None or
            self.Letterhead is not None or
            self.ElectronicSignature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DocumentGenerationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentGenerationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentGenerationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DocumentGenerationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DocumentGenerationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DocumentGenerationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.MinimumCopiesRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:MinimumCopiesRequired>%s</ns:MinimumCopiesRequired>%s' % (self.gds_format_integer(self.MinimumCopiesRequired, input_name='MinimumCopiesRequired'), eol_))
        if self.Letterhead is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Letterhead>%s</ns:Letterhead>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Letterhead), input_name='Letterhead')), eol_))
        if self.ElectronicSignature is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ElectronicSignature>%s</ns:ElectronicSignature>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ElectronicSignature), input_name='ElectronicSignature')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type EnterpriseDocumentType
            self.validate_EnterpriseDocumentType(self.Type)
        elif nodeName_ == 'MinimumCopiesRequired':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MinimumCopiesRequired')
            self.MinimumCopiesRequired = ival_
        elif nodeName_ == 'Letterhead':
            Letterhead_ = child_.text
            Letterhead_ = self.gds_validate_string(Letterhead_, node, 'Letterhead')
            self.Letterhead = Letterhead_
            # validate type RequirementType
            self.validate_RequirementType(self.Letterhead)
        elif nodeName_ == 'ElectronicSignature':
            ElectronicSignature_ = child_.text
            ElectronicSignature_ = self.gds_validate_string(ElectronicSignature_, node, 'ElectronicSignature')
            self.ElectronicSignature = ElectronicSignature_
            # validate type RequirementType
            self.validate_RequirementType(self.ElectronicSignature)
# end class DocumentGenerationDetail


class DocumentRequirementsDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RequiredDocuments=None, GenerationDetails=None, ProhibitedDocuments=None):
        self.original_tagname_ = None
        if RequiredDocuments is None:
            self.RequiredDocuments = []
        else:
            self.RequiredDocuments = RequiredDocuments
        if GenerationDetails is None:
            self.GenerationDetails = []
        else:
            self.GenerationDetails = GenerationDetails
        if ProhibitedDocuments is None:
            self.ProhibitedDocuments = []
        else:
            self.ProhibitedDocuments = ProhibitedDocuments
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentRequirementsDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentRequirementsDetail.subclass:
            return DocumentRequirementsDetail.subclass(*args_, **kwargs_)
        else:
            return DocumentRequirementsDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RequiredDocuments(self): return self.RequiredDocuments
    def set_RequiredDocuments(self, RequiredDocuments): self.RequiredDocuments = RequiredDocuments
    def add_RequiredDocuments(self, value): self.RequiredDocuments.append(value)
    def insert_RequiredDocuments_at(self, index, value): self.RequiredDocuments.insert(index, value)
    def replace_RequiredDocuments_at(self, index, value): self.RequiredDocuments[index] = value
    def get_GenerationDetails(self): return self.GenerationDetails
    def set_GenerationDetails(self, GenerationDetails): self.GenerationDetails = GenerationDetails
    def add_GenerationDetails(self, value): self.GenerationDetails.append(value)
    def insert_GenerationDetails_at(self, index, value): self.GenerationDetails.insert(index, value)
    def replace_GenerationDetails_at(self, index, value): self.GenerationDetails[index] = value
    def get_ProhibitedDocuments(self): return self.ProhibitedDocuments
    def set_ProhibitedDocuments(self, ProhibitedDocuments): self.ProhibitedDocuments = ProhibitedDocuments
    def add_ProhibitedDocuments(self, value): self.ProhibitedDocuments.append(value)
    def insert_ProhibitedDocuments_at(self, index, value): self.ProhibitedDocuments.insert(index, value)
    def replace_ProhibitedDocuments_at(self, index, value): self.ProhibitedDocuments[index] = value
    def validate_RequiredDocumentType(self, value):
        # Validate type RequiredDocumentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AIR_WAYBILL', 'CERTIFICATE_OF_ORIGIN', 'COMMERCIAL_INVOICE', 'COMMERCIAL_OR_PRO_FORMA_INVOICE', 'NAFTA_CERTIFICATE_OF_ORIGIN', 'PRO_FORMA_INVOICE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequiredDocumentType' % {"value" : value.encode("utf-8")} )
    def validate_EnterpriseDocumentType(self, value):
        # Validate type EnterpriseDocumentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AIR_WAYBILL', 'CERTIFICATE_OF_ORIGIN', 'COMMERCIAL_INVOICE', 'NAFTA_CERTIFICATE_OF_ORIGIN', 'PRO_FORMA_INVOICE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EnterpriseDocumentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RequiredDocuments or
            self.GenerationDetails or
            self.ProhibitedDocuments
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='DocumentRequirementsDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentRequirementsDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentRequirementsDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='DocumentRequirementsDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='DocumentRequirementsDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='DocumentRequirementsDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RequiredDocuments_ in self.RequiredDocuments:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RequiredDocuments>%s</ns:RequiredDocuments>%s' % (self.gds_encode(self.gds_format_string(quote_xml(RequiredDocuments_), input_name='RequiredDocuments')), eol_))
        for GenerationDetails_ in self.GenerationDetails:
            GenerationDetails_.export(outfile, level, namespace_, name_='GenerationDetails', pretty_print=pretty_print)
        for ProhibitedDocuments_ in self.ProhibitedDocuments:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ProhibitedDocuments>%s</ns:ProhibitedDocuments>%s' % (self.gds_encode(self.gds_format_string(quote_xml(ProhibitedDocuments_), input_name='ProhibitedDocuments')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RequiredDocuments':
            RequiredDocuments_ = child_.text
            RequiredDocuments_ = self.gds_validate_string(RequiredDocuments_, node, 'RequiredDocuments')
            self.RequiredDocuments.append(RequiredDocuments_)
            # validate type RequiredDocumentType
            self.validate_RequiredDocumentType(self.RequiredDocuments[-1])
        elif nodeName_ == 'GenerationDetails':
            obj_ = DocumentGenerationDetail.factory()
            obj_.build(child_)
            self.GenerationDetails.append(obj_)
            obj_.original_tagname_ = 'GenerationDetails'
        elif nodeName_ == 'ProhibitedDocuments':
            ProhibitedDocuments_ = child_.text
            ProhibitedDocuments_ = self.gds_validate_string(ProhibitedDocuments_, node, 'ProhibitedDocuments')
            self.ProhibitedDocuments.append(ProhibitedDocuments_)
            # validate type EnterpriseDocumentType
            self.validate_EnterpriseDocumentType(self.ProhibitedDocuments[-1])
# end class DocumentRequirementsDetail


class EMailDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EmailAddress=None, Name=None):
        self.original_tagname_ = None
        self.EmailAddress = EmailAddress
        self.Name = Name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EMailDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EMailDetail.subclass:
            return EMailDetail.subclass(*args_, **kwargs_)
        else:
            return EMailDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EmailAddress(self): return self.EmailAddress
    def set_EmailAddress(self, EmailAddress): self.EmailAddress = EmailAddress
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (
            self.EmailAddress is not None or
            self.Name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='EMailDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EMailDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EMailDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='EMailDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='EMailDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='EMailDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EmailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EmailAddress>%s</ns:EmailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EmailAddress), input_name='EmailAddress')), eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Name>%s</ns:Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EmailAddress':
            EmailAddress_ = child_.text
            EmailAddress_ = self.gds_validate_string(EmailAddress_, node, 'EmailAddress')
            self.EmailAddress = EmailAddress_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
# end class EMailDetail


class EMailLabelDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Message=None, Recipients=None):
        self.original_tagname_ = None
        self.Message = Message
        if Recipients is None:
            self.Recipients = []
        else:
            self.Recipients = Recipients
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EMailLabelDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EMailLabelDetail.subclass:
            return EMailLabelDetail.subclass(*args_, **kwargs_)
        else:
            return EMailLabelDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Message(self): return self.Message
    def set_Message(self, Message): self.Message = Message
    def get_Recipients(self): return self.Recipients
    def set_Recipients(self, Recipients): self.Recipients = Recipients
    def add_Recipients(self, value): self.Recipients.append(value)
    def insert_Recipients_at(self, index, value): self.Recipients.insert(index, value)
    def replace_Recipients_at(self, index, value): self.Recipients[index] = value
    def hasContent_(self):
        if (
            self.Message is not None or
            self.Recipients
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='EMailLabelDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EMailLabelDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EMailLabelDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='EMailLabelDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='EMailLabelDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='EMailLabelDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Message is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Message>%s</ns:Message>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Message), input_name='Message')), eol_))
        for Recipients_ in self.Recipients:
            Recipients_.export(outfile, level, namespace_, name_='Recipients', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Message':
            Message_ = child_.text
            Message_ = self.gds_validate_string(Message_, node, 'Message')
            self.Message = Message_
        elif nodeName_ == 'Recipients':
            obj_ = EMailRecipient.factory()
            obj_.build(child_)
            self.Recipients.append(obj_)
            obj_.original_tagname_ = 'Recipients'
# end class EMailLabelDetail


class EMailRecipient(GeneratedsSuper):
    """Information describing the address of of the email recipient, role
    of the email recipient and languages that are requested to be
    supported."""
    subclass = None
    superclass = None
    def __init__(self, EmailAddress=None, Role=None, OptionsRequested=None, Localization=None):
        self.original_tagname_ = None
        self.EmailAddress = EmailAddress
        self.Role = Role
        self.validate_AccessorRoleType(self.Role)
        self.OptionsRequested = OptionsRequested
        self.Localization = Localization
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EMailRecipient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EMailRecipient.subclass:
            return EMailRecipient.subclass(*args_, **kwargs_)
        else:
            return EMailRecipient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EmailAddress(self): return self.EmailAddress
    def set_EmailAddress(self, EmailAddress): self.EmailAddress = EmailAddress
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def get_OptionsRequested(self): return self.OptionsRequested
    def set_OptionsRequested(self, OptionsRequested): self.OptionsRequested = OptionsRequested
    def get_Localization(self): return self.Localization
    def set_Localization(self, Localization): self.Localization = Localization
    def validate_AccessorRoleType(self, value):
        # Validate type AccessorRoleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SHIPMENT_COMPLETOR', 'SHIPMENT_INITIATOR']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AccessorRoleType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EmailAddress is not None or
            self.Role is not None or
            self.OptionsRequested is not None or
            self.Localization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='EMailRecipient', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EMailRecipient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EMailRecipient')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='EMailRecipient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='EMailRecipient'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='EMailRecipient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EmailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EmailAddress>%s</ns:EmailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EmailAddress), input_name='EmailAddress')), eol_))
        if self.Role is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Role>%s</ns:Role>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Role), input_name='Role')), eol_))
        if self.OptionsRequested is not None:
            self.OptionsRequested.export(outfile, level, namespace_, name_='OptionsRequested', pretty_print=pretty_print)
        if self.Localization is not None:
            self.Localization.export(outfile, level, namespace_, name_='Localization', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EmailAddress':
            EmailAddress_ = child_.text
            EmailAddress_ = self.gds_validate_string(EmailAddress_, node, 'EmailAddress')
            self.EmailAddress = EmailAddress_
        elif nodeName_ == 'Role':
            Role_ = child_.text
            Role_ = self.gds_validate_string(Role_, node, 'Role')
            self.Role = Role_
            # validate type AccessorRoleType
            self.validate_AccessorRoleType(self.Role)
        elif nodeName_ == 'OptionsRequested':
            obj_ = EmailOptionsRequested.factory()
            obj_.build(child_)
            self.OptionsRequested = obj_
            obj_.original_tagname_ = 'OptionsRequested'
        elif nodeName_ == 'Localization':
            obj_ = Localization.factory()
            obj_.build(child_)
            self.Localization = obj_
            obj_.original_tagname_ = 'Localization'
# end class EMailRecipient


class EdtCommodityTax(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HarmonizedCode=None, Taxes=None):
        self.original_tagname_ = None
        self.HarmonizedCode = HarmonizedCode
        if Taxes is None:
            self.Taxes = []
        else:
            self.Taxes = Taxes
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EdtCommodityTax)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EdtCommodityTax.subclass:
            return EdtCommodityTax.subclass(*args_, **kwargs_)
        else:
            return EdtCommodityTax(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HarmonizedCode(self): return self.HarmonizedCode
    def set_HarmonizedCode(self, HarmonizedCode): self.HarmonizedCode = HarmonizedCode
    def get_Taxes(self): return self.Taxes
    def set_Taxes(self, Taxes): self.Taxes = Taxes
    def add_Taxes(self, value): self.Taxes.append(value)
    def insert_Taxes_at(self, index, value): self.Taxes.insert(index, value)
    def replace_Taxes_at(self, index, value): self.Taxes[index] = value
    def hasContent_(self):
        if (
            self.HarmonizedCode is not None or
            self.Taxes
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='EdtCommodityTax', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EdtCommodityTax')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EdtCommodityTax')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='EdtCommodityTax', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='EdtCommodityTax'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='EdtCommodityTax', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HarmonizedCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HarmonizedCode>%s</ns:HarmonizedCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HarmonizedCode), input_name='HarmonizedCode')), eol_))
        for Taxes_ in self.Taxes:
            Taxes_.export(outfile, level, namespace_, name_='Taxes', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HarmonizedCode':
            HarmonizedCode_ = child_.text
            HarmonizedCode_ = self.gds_validate_string(HarmonizedCode_, node, 'HarmonizedCode')
            self.HarmonizedCode = HarmonizedCode_
        elif nodeName_ == 'Taxes':
            obj_ = EdtTaxDetail.factory()
            obj_.build(child_)
            self.Taxes.append(obj_)
            obj_.original_tagname_ = 'Taxes'
# end class EdtCommodityTax


class EdtExciseCondition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Category=None, Value=None):
        self.original_tagname_ = None
        self.Category = Category
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EdtExciseCondition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EdtExciseCondition.subclass:
            return EdtExciseCondition.subclass(*args_, **kwargs_)
        else:
            return EdtExciseCondition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Category is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='EdtExciseCondition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EdtExciseCondition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EdtExciseCondition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='EdtExciseCondition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='EdtExciseCondition'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='EdtExciseCondition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Category>%s</ns:Category>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Category), input_name='Category')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Category':
            Category_ = child_.text
            Category_ = self.gds_validate_string(Category_, node, 'Category')
            self.Category = Category_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class EdtExciseCondition


class EdtTaxDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxType=None, EffectiveDate=None, Name=None, TaxableValue=None, Description=None, Formula=None, Amount=None):
        self.original_tagname_ = None
        self.TaxType = TaxType
        self.validate_EdtTaxType(self.TaxType)
        if isinstance(EffectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EffectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EffectiveDate
        self.EffectiveDate = initvalue_
        self.Name = Name
        self.TaxableValue = TaxableValue
        self.Description = Description
        self.Formula = Formula
        self.Amount = Amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EdtTaxDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EdtTaxDetail.subclass:
            return EdtTaxDetail.subclass(*args_, **kwargs_)
        else:
            return EdtTaxDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxType(self): return self.TaxType
    def set_TaxType(self, TaxType): self.TaxType = TaxType
    def get_EffectiveDate(self): return self.EffectiveDate
    def set_EffectiveDate(self, EffectiveDate): self.EffectiveDate = EffectiveDate
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_TaxableValue(self): return self.TaxableValue
    def set_TaxableValue(self, TaxableValue): self.TaxableValue = TaxableValue
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Formula(self): return self.Formula
    def set_Formula(self, Formula): self.Formula = Formula
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def validate_EdtTaxType(self, value):
        # Validate type EdtTaxType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADDITIONAL_TAXES', 'CONSULAR_INVOICE_FEE', 'CUSTOMS_SURCHARGES', 'DUTY', 'EXCISE_TAX', 'FOREIGN_EXCHANGE_TAX', 'GENERAL_SALES_TAX', 'IMPORT_LICENSE_FEE', 'INTERNAL_ADDITIONAL_TAXES', 'INTERNAL_SENSITIVE_PRODUCTS_TAX', 'OTHER', 'SENSITIVE_PRODUCTS_TAX', 'STAMP_TAX', 'STATISTICAL_TAX', 'TRANSPORT_FACILITIES_TAX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EdtTaxType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TaxType is not None or
            self.EffectiveDate is not None or
            self.Name is not None or
            self.TaxableValue is not None or
            self.Description is not None or
            self.Formula is not None or
            self.Amount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='EdtTaxDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EdtTaxDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EdtTaxDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='EdtTaxDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='EdtTaxDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='EdtTaxDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TaxType>%s</ns:TaxType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxType), input_name='TaxType')), eol_))
        if self.EffectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EffectiveDate>%s</ns:EffectiveDate>%s' % (self.gds_format_date(self.EffectiveDate, input_name='EffectiveDate'), eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Name>%s</ns:Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.TaxableValue is not None:
            self.TaxableValue.export(outfile, level, namespace_, name_='TaxableValue', pretty_print=pretty_print)
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Formula is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Formula>%s</ns:Formula>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Formula), input_name='Formula')), eol_))
        if self.Amount is not None:
            self.Amount.export(outfile, level, namespace_, name_='Amount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxType':
            TaxType_ = child_.text
            TaxType_ = self.gds_validate_string(TaxType_, node, 'TaxType')
            self.TaxType = TaxType_
            # validate type EdtTaxType
            self.validate_EdtTaxType(self.TaxType)
        elif nodeName_ == 'EffectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EffectiveDate = dval_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'TaxableValue':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TaxableValue = obj_
            obj_.original_tagname_ = 'TaxableValue'
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Formula':
            Formula_ = child_.text
            Formula_ = self.gds_validate_string(Formula_, node, 'Formula')
            self.Formula = Formula_
        elif nodeName_ == 'Amount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.Amount = obj_
            obj_.original_tagname_ = 'Amount'
# end class EdtTaxDetail


class EmailOptionsRequested(GeneratedsSuper):
    """Specifies how to apply the localization detail to the current
    context."""
    subclass = None
    superclass = None
    def __init__(self, Options=None):
        self.original_tagname_ = None
        if Options is None:
            self.Options = []
        else:
            self.Options = Options
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmailOptionsRequested)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmailOptionsRequested.subclass:
            return EmailOptionsRequested.subclass(*args_, **kwargs_)
        else:
            return EmailOptionsRequested(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Options(self): return self.Options
    def set_Options(self, Options): self.Options = Options
    def add_Options(self, value): self.Options.append(value)
    def insert_Options_at(self, index, value): self.Options.insert(index, value)
    def replace_Options_at(self, index, value): self.Options[index] = value
    def validate_EmailOptionType(self, value):
        # Validate type EmailOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SUPPRESS_ACCESS_EMAILS', 'SUPPRESS_ADDITIONAL_LANGUAGES']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EmailOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Options
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='EmailOptionsRequested', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EmailOptionsRequested')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmailOptionsRequested')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='EmailOptionsRequested', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='EmailOptionsRequested'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='EmailOptionsRequested', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Options_ in self.Options:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Options>%s</ns:Options>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Options_), input_name='Options')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Options':
            Options_ = child_.text
            Options_ = self.gds_validate_string(Options_, node, 'Options')
            self.Options.append(Options_)
            # validate type EmailOptionType
            self.validate_EmailOptionType(self.Options[-1])
# end class EmailOptionsRequested


class EtdDetail(GeneratedsSuper):
    """Electronic Trade document references used with the ETD special
    service."""
    subclass = None
    superclass = None
    def __init__(self, Attributes=None, RequestedDocumentCopies=None, DocumentReferences=None):
        self.original_tagname_ = None
        if Attributes is None:
            self.Attributes = []
        else:
            self.Attributes = Attributes
        if RequestedDocumentCopies is None:
            self.RequestedDocumentCopies = []
        else:
            self.RequestedDocumentCopies = RequestedDocumentCopies
        if DocumentReferences is None:
            self.DocumentReferences = []
        else:
            self.DocumentReferences = DocumentReferences
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EtdDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EtdDetail.subclass:
            return EtdDetail.subclass(*args_, **kwargs_)
        else:
            return EtdDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attributes(self): return self.Attributes
    def set_Attributes(self, Attributes): self.Attributes = Attributes
    def add_Attributes(self, value): self.Attributes.append(value)
    def insert_Attributes_at(self, index, value): self.Attributes.insert(index, value)
    def replace_Attributes_at(self, index, value): self.Attributes[index] = value
    def get_RequestedDocumentCopies(self): return self.RequestedDocumentCopies
    def set_RequestedDocumentCopies(self, RequestedDocumentCopies): self.RequestedDocumentCopies = RequestedDocumentCopies
    def add_RequestedDocumentCopies(self, value): self.RequestedDocumentCopies.append(value)
    def insert_RequestedDocumentCopies_at(self, index, value): self.RequestedDocumentCopies.insert(index, value)
    def replace_RequestedDocumentCopies_at(self, index, value): self.RequestedDocumentCopies[index] = value
    def get_DocumentReferences(self): return self.DocumentReferences
    def set_DocumentReferences(self, DocumentReferences): self.DocumentReferences = DocumentReferences
    def add_DocumentReferences(self, value): self.DocumentReferences.append(value)
    def insert_DocumentReferences_at(self, index, value): self.DocumentReferences.insert(index, value)
    def replace_DocumentReferences_at(self, index, value): self.DocumentReferences[index] = value
    def validate_EtdAttributeType(self, value):
        # Validate type EtdAttributeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['POST_SHIPMENT_UPLOAD_REQUESTED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EtdAttributeType' % {"value" : value.encode("utf-8")} )
    def validate_RequestedShippingDocumentType(self, value):
        # Validate type RequestedShippingDocumentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CERTIFICATE_OF_ORIGIN', 'COMMERCIAL_INVOICE', 'CUSTOMER_SPECIFIED_LABELS', 'CUSTOM_PACKAGE_DOCUMENT', 'CUSTOM_SHIPMENT_DOCUMENT', 'DANGEROUS_GOODS_SHIPPERS_DECLARATION', 'EXPORT_DECLARATION', 'FREIGHT_ADDRESS_LABEL', 'GENERAL_AGENCY_AGREEMENT', 'LABEL', 'NAFTA_CERTIFICATE_OF_ORIGIN', 'OP_900', 'PRO_FORMA_INVOICE', 'RETURN_INSTRUCTIONS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestedShippingDocumentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Attributes or
            self.RequestedDocumentCopies or
            self.DocumentReferences
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='EtdDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EtdDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EtdDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='EtdDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='EtdDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='EtdDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attributes_ in self.Attributes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Attributes>%s</ns:Attributes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Attributes_), input_name='Attributes')), eol_))
        for RequestedDocumentCopies_ in self.RequestedDocumentCopies:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RequestedDocumentCopies>%s</ns:RequestedDocumentCopies>%s' % (self.gds_encode(self.gds_format_string(quote_xml(RequestedDocumentCopies_), input_name='RequestedDocumentCopies')), eol_))
        for DocumentReferences_ in self.DocumentReferences:
            DocumentReferences_.export(outfile, level, namespace_, name_='DocumentReferences', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attributes':
            Attributes_ = child_.text
            Attributes_ = self.gds_validate_string(Attributes_, node, 'Attributes')
            self.Attributes.append(Attributes_)
            # validate type EtdAttributeType
            self.validate_EtdAttributeType(self.Attributes[-1])
        elif nodeName_ == 'RequestedDocumentCopies':
            RequestedDocumentCopies_ = child_.text
            RequestedDocumentCopies_ = self.gds_validate_string(RequestedDocumentCopies_, node, 'RequestedDocumentCopies')
            self.RequestedDocumentCopies.append(RequestedDocumentCopies_)
            # validate type RequestedShippingDocumentType
            self.validate_RequestedShippingDocumentType(self.RequestedDocumentCopies[-1])
        elif nodeName_ == 'DocumentReferences':
            obj_ = UploadDocumentReferenceDetail.factory()
            obj_.build(child_)
            self.DocumentReferences.append(obj_)
            obj_.original_tagname_ = 'DocumentReferences'
# end class EtdDetail


class ExportDeclarationDetail(GeneratedsSuper):
    """The instructions indicating how to print the Export Declaration."""
    subclass = None
    superclass = None
    def __init__(self, DocumentFormat=None, CustomerImageUsages=None):
        self.original_tagname_ = None
        self.DocumentFormat = DocumentFormat
        if CustomerImageUsages is None:
            self.CustomerImageUsages = []
        else:
            self.CustomerImageUsages = CustomerImageUsages
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExportDeclarationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExportDeclarationDetail.subclass:
            return ExportDeclarationDetail.subclass(*args_, **kwargs_)
        else:
            return ExportDeclarationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentFormat(self): return self.DocumentFormat
    def set_DocumentFormat(self, DocumentFormat): self.DocumentFormat = DocumentFormat
    def get_CustomerImageUsages(self): return self.CustomerImageUsages
    def set_CustomerImageUsages(self, CustomerImageUsages): self.CustomerImageUsages = CustomerImageUsages
    def add_CustomerImageUsages(self, value): self.CustomerImageUsages.append(value)
    def insert_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages.insert(index, value)
    def replace_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages[index] = value
    def hasContent_(self):
        if (
            self.DocumentFormat is not None or
            self.CustomerImageUsages
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ExportDeclarationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExportDeclarationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExportDeclarationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ExportDeclarationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ExportDeclarationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ExportDeclarationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocumentFormat is not None:
            self.DocumentFormat.export(outfile, level, namespace_, name_='DocumentFormat', pretty_print=pretty_print)
        for CustomerImageUsages_ in self.CustomerImageUsages:
            CustomerImageUsages_.export(outfile, level, namespace_, name_='CustomerImageUsages', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocumentFormat':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.DocumentFormat = obj_
            obj_.original_tagname_ = 'DocumentFormat'
        elif nodeName_ == 'CustomerImageUsages':
            obj_ = CustomerImageUsage.factory()
            obj_.build(child_)
            self.CustomerImageUsages.append(obj_)
            obj_.original_tagname_ = 'CustomerImageUsages'
# end class ExportDeclarationDetail


class ExportDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, B13AFilingOption=None, ExportComplianceStatement=None, PermitNumber=None, DestinationControlDetail=None):
        self.original_tagname_ = None
        self.B13AFilingOption = B13AFilingOption
        self.validate_B13AFilingOptionType(self.B13AFilingOption)
        self.ExportComplianceStatement = ExportComplianceStatement
        self.PermitNumber = PermitNumber
        self.DestinationControlDetail = DestinationControlDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExportDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExportDetail.subclass:
            return ExportDetail.subclass(*args_, **kwargs_)
        else:
            return ExportDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_B13AFilingOption(self): return self.B13AFilingOption
    def set_B13AFilingOption(self, B13AFilingOption): self.B13AFilingOption = B13AFilingOption
    def get_ExportComplianceStatement(self): return self.ExportComplianceStatement
    def set_ExportComplianceStatement(self, ExportComplianceStatement): self.ExportComplianceStatement = ExportComplianceStatement
    def get_PermitNumber(self): return self.PermitNumber
    def set_PermitNumber(self, PermitNumber): self.PermitNumber = PermitNumber
    def get_DestinationControlDetail(self): return self.DestinationControlDetail
    def set_DestinationControlDetail(self, DestinationControlDetail): self.DestinationControlDetail = DestinationControlDetail
    def validate_B13AFilingOptionType(self, value):
        # Validate type B13AFilingOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEDEX_TO_STAMP', 'FILED_ELECTRONICALLY', 'MANUALLY_ATTACHED', 'NOT_REQUIRED', 'SUMMARY_REPORTING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on B13AFilingOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.B13AFilingOption is not None or
            self.ExportComplianceStatement is not None or
            self.PermitNumber is not None or
            self.DestinationControlDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ExportDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExportDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExportDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ExportDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ExportDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ExportDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.B13AFilingOption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:B13AFilingOption>%s</ns:B13AFilingOption>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.B13AFilingOption), input_name='B13AFilingOption')), eol_))
        if self.ExportComplianceStatement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ExportComplianceStatement>%s</ns:ExportComplianceStatement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ExportComplianceStatement), input_name='ExportComplianceStatement')), eol_))
        if self.PermitNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PermitNumber>%s</ns:PermitNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PermitNumber), input_name='PermitNumber')), eol_))
        if self.DestinationControlDetail is not None:
            self.DestinationControlDetail.export(outfile, level, namespace_, name_='DestinationControlDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'B13AFilingOption':
            B13AFilingOption_ = child_.text
            B13AFilingOption_ = self.gds_validate_string(B13AFilingOption_, node, 'B13AFilingOption')
            self.B13AFilingOption = B13AFilingOption_
            # validate type B13AFilingOptionType
            self.validate_B13AFilingOptionType(self.B13AFilingOption)
        elif nodeName_ == 'ExportComplianceStatement':
            ExportComplianceStatement_ = child_.text
            ExportComplianceStatement_ = self.gds_validate_string(ExportComplianceStatement_, node, 'ExportComplianceStatement')
            self.ExportComplianceStatement = ExportComplianceStatement_
        elif nodeName_ == 'PermitNumber':
            PermitNumber_ = child_.text
            PermitNumber_ = self.gds_validate_string(PermitNumber_, node, 'PermitNumber')
            self.PermitNumber = PermitNumber_
        elif nodeName_ == 'DestinationControlDetail':
            obj_ = DestinationControlDetail.factory()
            obj_.build(child_)
            self.DestinationControlDetail = obj_
            obj_.original_tagname_ = 'DestinationControlDetail'
# end class ExportDetail


class ExpressFreightDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PackingListEnclosed=None, ShippersLoadAndCount=None, BookingConfirmationNumber=None):
        self.original_tagname_ = None
        self.PackingListEnclosed = PackingListEnclosed
        self.ShippersLoadAndCount = ShippersLoadAndCount
        self.BookingConfirmationNumber = BookingConfirmationNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExpressFreightDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExpressFreightDetail.subclass:
            return ExpressFreightDetail.subclass(*args_, **kwargs_)
        else:
            return ExpressFreightDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PackingListEnclosed(self): return self.PackingListEnclosed
    def set_PackingListEnclosed(self, PackingListEnclosed): self.PackingListEnclosed = PackingListEnclosed
    def get_ShippersLoadAndCount(self): return self.ShippersLoadAndCount
    def set_ShippersLoadAndCount(self, ShippersLoadAndCount): self.ShippersLoadAndCount = ShippersLoadAndCount
    def get_BookingConfirmationNumber(self): return self.BookingConfirmationNumber
    def set_BookingConfirmationNumber(self, BookingConfirmationNumber): self.BookingConfirmationNumber = BookingConfirmationNumber
    def hasContent_(self):
        if (
            self.PackingListEnclosed is not None or
            self.ShippersLoadAndCount is not None or
            self.BookingConfirmationNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ExpressFreightDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExpressFreightDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExpressFreightDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ExpressFreightDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ExpressFreightDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ExpressFreightDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PackingListEnclosed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackingListEnclosed>%s</ns:PackingListEnclosed>%s' % (self.gds_format_boolean(self.PackingListEnclosed, input_name='PackingListEnclosed'), eol_))
        if self.ShippersLoadAndCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ShippersLoadAndCount>%s</ns:ShippersLoadAndCount>%s' % (self.gds_format_integer(self.ShippersLoadAndCount, input_name='ShippersLoadAndCount'), eol_))
        if self.BookingConfirmationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:BookingConfirmationNumber>%s</ns:BookingConfirmationNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BookingConfirmationNumber), input_name='BookingConfirmationNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PackingListEnclosed':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PackingListEnclosed')
            self.PackingListEnclosed = ival_
        elif nodeName_ == 'ShippersLoadAndCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ShippersLoadAndCount')
            self.ShippersLoadAndCount = ival_
        elif nodeName_ == 'BookingConfirmationNumber':
            BookingConfirmationNumber_ = child_.text
            BookingConfirmationNumber_ = self.gds_validate_string(BookingConfirmationNumber_, node, 'BookingConfirmationNumber')
            self.BookingConfirmationNumber = BookingConfirmationNumber_
# end class ExpressFreightDetail


class FreightAddressLabelDetail(GeneratedsSuper):
    """Data required to produce the Freight handling-unit-level address
    labels. Note that the number of UNIQUE labels (the N as in 1 of
    N, 2 of N, etc.) is determined by total handling units."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, Copies=None, StartingPosition=None, DocTabContent=None, CustomContentPosition=None, CustomContent=None):
        self.original_tagname_ = None
        self.Format = Format
        self.Copies = Copies
        self.StartingPosition = StartingPosition
        self.validate_PageQuadrantType(self.StartingPosition)
        self.DocTabContent = DocTabContent
        self.CustomContentPosition = CustomContentPosition
        self.validate_RelativeVerticalPositionType(self.CustomContentPosition)
        self.CustomContent = CustomContent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightAddressLabelDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightAddressLabelDetail.subclass:
            return FreightAddressLabelDetail.subclass(*args_, **kwargs_)
        else:
            return FreightAddressLabelDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_Copies(self): return self.Copies
    def set_Copies(self, Copies): self.Copies = Copies
    def get_StartingPosition(self): return self.StartingPosition
    def set_StartingPosition(self, StartingPosition): self.StartingPosition = StartingPosition
    def get_DocTabContent(self): return self.DocTabContent
    def set_DocTabContent(self, DocTabContent): self.DocTabContent = DocTabContent
    def get_CustomContentPosition(self): return self.CustomContentPosition
    def set_CustomContentPosition(self, CustomContentPosition): self.CustomContentPosition = CustomContentPosition
    def get_CustomContent(self): return self.CustomContent
    def set_CustomContent(self, CustomContent): self.CustomContent = CustomContent
    def validate_PageQuadrantType(self, value):
        # Validate type PageQuadrantType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BOTTOM_LEFT', 'BOTTOM_RIGHT', 'TOP_LEFT', 'TOP_RIGHT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PageQuadrantType' % {"value" : value.encode("utf-8")} )
    def validate_RelativeVerticalPositionType(self, value):
        # Validate type RelativeVerticalPositionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ABOVE', 'BELOW']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RelativeVerticalPositionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Format is not None or
            self.Copies is not None or
            self.StartingPosition is not None or
            self.DocTabContent is not None or
            self.CustomContentPosition is not None or
            self.CustomContent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='FreightAddressLabelDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightAddressLabelDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightAddressLabelDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='FreightAddressLabelDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='FreightAddressLabelDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='FreightAddressLabelDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            self.Format.export(outfile, level, namespace_, name_='Format', pretty_print=pretty_print)
        if self.Copies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Copies>%s</ns:Copies>%s' % (self.gds_format_integer(self.Copies, input_name='Copies'), eol_))
        if self.StartingPosition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:StartingPosition>%s</ns:StartingPosition>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StartingPosition), input_name='StartingPosition')), eol_))
        if self.DocTabContent is not None:
            self.DocTabContent.export(outfile, level, namespace_, name_='DocTabContent', pretty_print=pretty_print)
        if self.CustomContentPosition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomContentPosition>%s</ns:CustomContentPosition>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomContentPosition), input_name='CustomContentPosition')), eol_))
        if self.CustomContent is not None:
            self.CustomContent.export(outfile, level, namespace_, name_='CustomContent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
        elif nodeName_ == 'Copies':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Copies')
            self.Copies = ival_
        elif nodeName_ == 'StartingPosition':
            StartingPosition_ = child_.text
            StartingPosition_ = self.gds_validate_string(StartingPosition_, node, 'StartingPosition')
            self.StartingPosition = StartingPosition_
            # validate type PageQuadrantType
            self.validate_PageQuadrantType(self.StartingPosition)
        elif nodeName_ == 'DocTabContent':
            obj_ = DocTabContent.factory()
            obj_.build(child_)
            self.DocTabContent = obj_
            obj_.original_tagname_ = 'DocTabContent'
        elif nodeName_ == 'CustomContentPosition':
            CustomContentPosition_ = child_.text
            CustomContentPosition_ = self.gds_validate_string(CustomContentPosition_, node, 'CustomContentPosition')
            self.CustomContentPosition = CustomContentPosition_
            # validate type RelativeVerticalPositionType
            self.validate_RelativeVerticalPositionType(self.CustomContentPosition)
        elif nodeName_ == 'CustomContent':
            obj_ = CustomLabelDetail.factory()
            obj_.build(child_)
            self.CustomContent = obj_
            obj_.original_tagname_ = 'CustomContent'
# end class FreightAddressLabelDetail


class FreightBaseCharge(GeneratedsSuper):
    """Individual charge which contributes to the total base charge for the
    shipment."""
    subclass = None
    superclass = None
    def __init__(self, FreightClass=None, RatedAsClass=None, NmfcCode=None, Description=None, Weight=None, ChargeRate=None, ChargeBasis=None, ExtendedAmount=None):
        self.original_tagname_ = None
        self.FreightClass = FreightClass
        self.validate_FreightClassType(self.FreightClass)
        self.RatedAsClass = RatedAsClass
        self.validate_FreightClassType(self.RatedAsClass)
        self.NmfcCode = NmfcCode
        self.Description = Description
        self.Weight = Weight
        self.ChargeRate = ChargeRate
        self.ChargeBasis = ChargeBasis
        self.validate_FreightChargeBasisType(self.ChargeBasis)
        self.ExtendedAmount = ExtendedAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightBaseCharge)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightBaseCharge.subclass:
            return FreightBaseCharge.subclass(*args_, **kwargs_)
        else:
            return FreightBaseCharge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreightClass(self): return self.FreightClass
    def set_FreightClass(self, FreightClass): self.FreightClass = FreightClass
    def get_RatedAsClass(self): return self.RatedAsClass
    def set_RatedAsClass(self, RatedAsClass): self.RatedAsClass = RatedAsClass
    def get_NmfcCode(self): return self.NmfcCode
    def set_NmfcCode(self, NmfcCode): self.NmfcCode = NmfcCode
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_ChargeRate(self): return self.ChargeRate
    def set_ChargeRate(self, ChargeRate): self.ChargeRate = ChargeRate
    def get_ChargeBasis(self): return self.ChargeBasis
    def set_ChargeBasis(self, ChargeBasis): self.ChargeBasis = ChargeBasis
    def get_ExtendedAmount(self): return self.ExtendedAmount
    def set_ExtendedAmount(self, ExtendedAmount): self.ExtendedAmount = ExtendedAmount
    def validate_FreightClassType(self, value):
        # Validate type FreightClassType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CLASS_050', 'CLASS_055', 'CLASS_060', 'CLASS_065', 'CLASS_070', 'CLASS_077_5', 'CLASS_085', 'CLASS_092_5', 'CLASS_100', 'CLASS_110', 'CLASS_125', 'CLASS_150', 'CLASS_175', 'CLASS_200', 'CLASS_250', 'CLASS_300', 'CLASS_400', 'CLASS_500']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightClassType' % {"value" : value.encode("utf-8")} )
    def validate_FreightChargeBasisType(self, value):
        # Validate type FreightChargeBasisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CWT', 'FLAT', 'MINIMUM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightChargeBasisType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FreightClass is not None or
            self.RatedAsClass is not None or
            self.NmfcCode is not None or
            self.Description is not None or
            self.Weight is not None or
            self.ChargeRate is not None or
            self.ChargeBasis is not None or
            self.ExtendedAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='FreightBaseCharge', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightBaseCharge')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightBaseCharge')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='FreightBaseCharge', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='FreightBaseCharge'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='FreightBaseCharge', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FreightClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FreightClass>%s</ns:FreightClass>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FreightClass), input_name='FreightClass')), eol_))
        if self.RatedAsClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RatedAsClass>%s</ns:RatedAsClass>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RatedAsClass), input_name='RatedAsClass')), eol_))
        if self.NmfcCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:NmfcCode>%s</ns:NmfcCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NmfcCode), input_name='NmfcCode')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Weight is not None:
            self.Weight.export(outfile, level, namespace_, name_='Weight', pretty_print=pretty_print)
        if self.ChargeRate is not None:
            self.ChargeRate.export(outfile, level, namespace_, name_='ChargeRate', pretty_print=pretty_print)
        if self.ChargeBasis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ChargeBasis>%s</ns:ChargeBasis>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeBasis), input_name='ChargeBasis')), eol_))
        if self.ExtendedAmount is not None:
            self.ExtendedAmount.export(outfile, level, namespace_, name_='ExtendedAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreightClass':
            FreightClass_ = child_.text
            FreightClass_ = self.gds_validate_string(FreightClass_, node, 'FreightClass')
            self.FreightClass = FreightClass_
            # validate type FreightClassType
            self.validate_FreightClassType(self.FreightClass)
        elif nodeName_ == 'RatedAsClass':
            RatedAsClass_ = child_.text
            RatedAsClass_ = self.gds_validate_string(RatedAsClass_, node, 'RatedAsClass')
            self.RatedAsClass = RatedAsClass_
            # validate type FreightClassType
            self.validate_FreightClassType(self.RatedAsClass)
        elif nodeName_ == 'NmfcCode':
            NmfcCode_ = child_.text
            NmfcCode_ = self.gds_validate_string(NmfcCode_, node, 'NmfcCode')
            self.NmfcCode = NmfcCode_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Weight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.Weight = obj_
            obj_.original_tagname_ = 'Weight'
        elif nodeName_ == 'ChargeRate':
            obj_ = Money.factory()
            obj_.build(child_)
            self.ChargeRate = obj_
            obj_.original_tagname_ = 'ChargeRate'
        elif nodeName_ == 'ChargeBasis':
            ChargeBasis_ = child_.text
            ChargeBasis_ = self.gds_validate_string(ChargeBasis_, node, 'ChargeBasis')
            self.ChargeBasis = ChargeBasis_
            # validate type FreightChargeBasisType
            self.validate_FreightChargeBasisType(self.ChargeBasis)
        elif nodeName_ == 'ExtendedAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.ExtendedAmount = obj_
            obj_.original_tagname_ = 'ExtendedAmount'
# end class FreightBaseCharge


class FreightGuaranteeDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Date=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_FreightGuaranteeType(self.Type)
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightGuaranteeDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightGuaranteeDetail.subclass:
            return FreightGuaranteeDetail.subclass(*args_, **kwargs_)
        else:
            return FreightGuaranteeDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def validate_FreightGuaranteeType(self, value):
        # Validate type FreightGuaranteeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['GUARANTEED_DATE', 'GUARANTEED_MORNING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightGuaranteeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='FreightGuaranteeDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightGuaranteeDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightGuaranteeDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='FreightGuaranteeDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='FreightGuaranteeDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='FreightGuaranteeDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Date>%s</ns:Date>%s' % (self.gds_format_date(self.Date, input_name='Date'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type FreightGuaranteeType
            self.validate_FreightGuaranteeType(self.Type)
        elif nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
# end class FreightGuaranteeDetail


class FreightRateDetail(GeneratedsSuper):
    """Rate data specific to FedEx Freight or FedEx National Freight
    services."""
    subclass = None
    superclass = None
    def __init__(self, QuoteNumber=None, QuoteType=None, BaseChargeCalculation=None, BaseCharges=None, Notations=None):
        self.original_tagname_ = None
        self.QuoteNumber = QuoteNumber
        self.QuoteType = QuoteType
        self.validate_FreightRateQuoteType(self.QuoteType)
        self.BaseChargeCalculation = BaseChargeCalculation
        self.validate_FreightBaseChargeCalculationType(self.BaseChargeCalculation)
        if BaseCharges is None:
            self.BaseCharges = []
        else:
            self.BaseCharges = BaseCharges
        if Notations is None:
            self.Notations = []
        else:
            self.Notations = Notations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightRateDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightRateDetail.subclass:
            return FreightRateDetail.subclass(*args_, **kwargs_)
        else:
            return FreightRateDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QuoteNumber(self): return self.QuoteNumber
    def set_QuoteNumber(self, QuoteNumber): self.QuoteNumber = QuoteNumber
    def get_QuoteType(self): return self.QuoteType
    def set_QuoteType(self, QuoteType): self.QuoteType = QuoteType
    def get_BaseChargeCalculation(self): return self.BaseChargeCalculation
    def set_BaseChargeCalculation(self, BaseChargeCalculation): self.BaseChargeCalculation = BaseChargeCalculation
    def get_BaseCharges(self): return self.BaseCharges
    def set_BaseCharges(self, BaseCharges): self.BaseCharges = BaseCharges
    def add_BaseCharges(self, value): self.BaseCharges.append(value)
    def insert_BaseCharges_at(self, index, value): self.BaseCharges.insert(index, value)
    def replace_BaseCharges_at(self, index, value): self.BaseCharges[index] = value
    def get_Notations(self): return self.Notations
    def set_Notations(self, Notations): self.Notations = Notations
    def add_Notations(self, value): self.Notations.append(value)
    def insert_Notations_at(self, index, value): self.Notations.insert(index, value)
    def replace_Notations_at(self, index, value): self.Notations[index] = value
    def validate_FreightRateQuoteType(self, value):
        # Validate type FreightRateQuoteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AUTOMATED', 'MANUAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightRateQuoteType' % {"value" : value.encode("utf-8")} )
    def validate_FreightBaseChargeCalculationType(self, value):
        # Validate type FreightBaseChargeCalculationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BEYOND', 'LINE_ITEMS', 'UNIT_PRICING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightBaseChargeCalculationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.QuoteNumber is not None or
            self.QuoteType is not None or
            self.BaseChargeCalculation is not None or
            self.BaseCharges or
            self.Notations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='FreightRateDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightRateDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightRateDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='FreightRateDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='FreightRateDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='FreightRateDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.QuoteNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:QuoteNumber>%s</ns:QuoteNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.QuoteNumber), input_name='QuoteNumber')), eol_))
        if self.QuoteType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:QuoteType>%s</ns:QuoteType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.QuoteType), input_name='QuoteType')), eol_))
        if self.BaseChargeCalculation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:BaseChargeCalculation>%s</ns:BaseChargeCalculation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BaseChargeCalculation), input_name='BaseChargeCalculation')), eol_))
        for BaseCharges_ in self.BaseCharges:
            BaseCharges_.export(outfile, level, namespace_, name_='BaseCharges', pretty_print=pretty_print)
        for Notations_ in self.Notations:
            Notations_.export(outfile, level, namespace_, name_='Notations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QuoteNumber':
            QuoteNumber_ = child_.text
            QuoteNumber_ = self.gds_validate_string(QuoteNumber_, node, 'QuoteNumber')
            self.QuoteNumber = QuoteNumber_
        elif nodeName_ == 'QuoteType':
            QuoteType_ = child_.text
            QuoteType_ = self.gds_validate_string(QuoteType_, node, 'QuoteType')
            self.QuoteType = QuoteType_
            # validate type FreightRateQuoteType
            self.validate_FreightRateQuoteType(self.QuoteType)
        elif nodeName_ == 'BaseChargeCalculation':
            BaseChargeCalculation_ = child_.text
            BaseChargeCalculation_ = self.gds_validate_string(BaseChargeCalculation_, node, 'BaseChargeCalculation')
            self.BaseChargeCalculation = BaseChargeCalculation_
            # validate type FreightBaseChargeCalculationType
            self.validate_FreightBaseChargeCalculationType(self.BaseChargeCalculation)
        elif nodeName_ == 'BaseCharges':
            obj_ = FreightBaseCharge.factory()
            obj_.build(child_)
            self.BaseCharges.append(obj_)
            obj_.original_tagname_ = 'BaseCharges'
        elif nodeName_ == 'Notations':
            obj_ = FreightRateNotation.factory()
            obj_.build(child_)
            self.Notations.append(obj_)
            obj_.original_tagname_ = 'Notations'
# end class FreightRateDetail


class FreightRateNotation(GeneratedsSuper):
    """Additional non-monetary data returned with Freight rates."""
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightRateNotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightRateNotation.subclass:
            return FreightRateNotation.subclass(*args_, **kwargs_)
        else:
            return FreightRateNotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='FreightRateNotation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightRateNotation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightRateNotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='FreightRateNotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='FreightRateNotation'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='FreightRateNotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Code>%s</ns:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class FreightRateNotation


class FreightShipmentDetail(GeneratedsSuper):
    """Data applicable to shipments using FEDEX_FREIGHT_ECONOMY and
    FEDEX_FREIGHT_PRIORITY services."""
    subclass = None
    superclass = None
    def __init__(self, FedExFreightAccountNumber=None, FedExFreightBillingContactAndAddress=None, AlternateBilling=None, PrintedReferences=None, Role=None, CollectTermsType=None, DeclaredValuePerUnit=None, DeclaredValueUnits=None, LiabilityCoverageDetail=None, Coupons=None, TotalHandlingUnits=None, ClientDiscountPercent=None, PalletWeight=None, ShipmentDimensions=None, Comment=None, SpecialServicePayments=None, HazardousMaterialsEmergencyContactNumber=None, HazardousMaterialsOfferor=None, LineItems=None):
        self.original_tagname_ = None
        self.FedExFreightAccountNumber = FedExFreightAccountNumber
        self.FedExFreightBillingContactAndAddress = FedExFreightBillingContactAndAddress
        self.AlternateBilling = AlternateBilling
        if PrintedReferences is None:
            self.PrintedReferences = []
        else:
            self.PrintedReferences = PrintedReferences
        self.Role = Role
        self.validate_FreightShipmentRoleType(self.Role)
        self.CollectTermsType = CollectTermsType
        self.validate_FreightCollectTermsType(self.CollectTermsType)
        self.DeclaredValuePerUnit = DeclaredValuePerUnit
        self.DeclaredValueUnits = DeclaredValueUnits
        self.LiabilityCoverageDetail = LiabilityCoverageDetail
        if Coupons is None:
            self.Coupons = []
        else:
            self.Coupons = Coupons
        self.TotalHandlingUnits = TotalHandlingUnits
        self.ClientDiscountPercent = ClientDiscountPercent
        self.PalletWeight = PalletWeight
        self.ShipmentDimensions = ShipmentDimensions
        self.Comment = Comment
        if SpecialServicePayments is None:
            self.SpecialServicePayments = []
        else:
            self.SpecialServicePayments = SpecialServicePayments
        self.HazardousMaterialsEmergencyContactNumber = HazardousMaterialsEmergencyContactNumber
        self.HazardousMaterialsOfferor = HazardousMaterialsOfferor
        if LineItems is None:
            self.LineItems = []
        else:
            self.LineItems = LineItems
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightShipmentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightShipmentDetail.subclass:
            return FreightShipmentDetail.subclass(*args_, **kwargs_)
        else:
            return FreightShipmentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FedExFreightAccountNumber(self): return self.FedExFreightAccountNumber
    def set_FedExFreightAccountNumber(self, FedExFreightAccountNumber): self.FedExFreightAccountNumber = FedExFreightAccountNumber
    def get_FedExFreightBillingContactAndAddress(self): return self.FedExFreightBillingContactAndAddress
    def set_FedExFreightBillingContactAndAddress(self, FedExFreightBillingContactAndAddress): self.FedExFreightBillingContactAndAddress = FedExFreightBillingContactAndAddress
    def get_AlternateBilling(self): return self.AlternateBilling
    def set_AlternateBilling(self, AlternateBilling): self.AlternateBilling = AlternateBilling
    def get_PrintedReferences(self): return self.PrintedReferences
    def set_PrintedReferences(self, PrintedReferences): self.PrintedReferences = PrintedReferences
    def add_PrintedReferences(self, value): self.PrintedReferences.append(value)
    def insert_PrintedReferences_at(self, index, value): self.PrintedReferences.insert(index, value)
    def replace_PrintedReferences_at(self, index, value): self.PrintedReferences[index] = value
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def get_CollectTermsType(self): return self.CollectTermsType
    def set_CollectTermsType(self, CollectTermsType): self.CollectTermsType = CollectTermsType
    def get_DeclaredValuePerUnit(self): return self.DeclaredValuePerUnit
    def set_DeclaredValuePerUnit(self, DeclaredValuePerUnit): self.DeclaredValuePerUnit = DeclaredValuePerUnit
    def get_DeclaredValueUnits(self): return self.DeclaredValueUnits
    def set_DeclaredValueUnits(self, DeclaredValueUnits): self.DeclaredValueUnits = DeclaredValueUnits
    def get_LiabilityCoverageDetail(self): return self.LiabilityCoverageDetail
    def set_LiabilityCoverageDetail(self, LiabilityCoverageDetail): self.LiabilityCoverageDetail = LiabilityCoverageDetail
    def get_Coupons(self): return self.Coupons
    def set_Coupons(self, Coupons): self.Coupons = Coupons
    def add_Coupons(self, value): self.Coupons.append(value)
    def insert_Coupons_at(self, index, value): self.Coupons.insert(index, value)
    def replace_Coupons_at(self, index, value): self.Coupons[index] = value
    def get_TotalHandlingUnits(self): return self.TotalHandlingUnits
    def set_TotalHandlingUnits(self, TotalHandlingUnits): self.TotalHandlingUnits = TotalHandlingUnits
    def get_ClientDiscountPercent(self): return self.ClientDiscountPercent
    def set_ClientDiscountPercent(self, ClientDiscountPercent): self.ClientDiscountPercent = ClientDiscountPercent
    def get_PalletWeight(self): return self.PalletWeight
    def set_PalletWeight(self, PalletWeight): self.PalletWeight = PalletWeight
    def get_ShipmentDimensions(self): return self.ShipmentDimensions
    def set_ShipmentDimensions(self, ShipmentDimensions): self.ShipmentDimensions = ShipmentDimensions
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_SpecialServicePayments(self): return self.SpecialServicePayments
    def set_SpecialServicePayments(self, SpecialServicePayments): self.SpecialServicePayments = SpecialServicePayments
    def add_SpecialServicePayments(self, value): self.SpecialServicePayments.append(value)
    def insert_SpecialServicePayments_at(self, index, value): self.SpecialServicePayments.insert(index, value)
    def replace_SpecialServicePayments_at(self, index, value): self.SpecialServicePayments[index] = value
    def get_HazardousMaterialsEmergencyContactNumber(self): return self.HazardousMaterialsEmergencyContactNumber
    def set_HazardousMaterialsEmergencyContactNumber(self, HazardousMaterialsEmergencyContactNumber): self.HazardousMaterialsEmergencyContactNumber = HazardousMaterialsEmergencyContactNumber
    def get_HazardousMaterialsOfferor(self): return self.HazardousMaterialsOfferor
    def set_HazardousMaterialsOfferor(self, HazardousMaterialsOfferor): self.HazardousMaterialsOfferor = HazardousMaterialsOfferor
    def get_LineItems(self): return self.LineItems
    def set_LineItems(self, LineItems): self.LineItems = LineItems
    def add_LineItems(self, value): self.LineItems.append(value)
    def insert_LineItems_at(self, index, value): self.LineItems.insert(index, value)
    def replace_LineItems_at(self, index, value): self.LineItems[index] = value
    def validate_FreightShipmentRoleType(self, value):
        # Validate type FreightShipmentRoleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CONSIGNEE', 'SHIPPER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightShipmentRoleType' % {"value" : value.encode("utf-8")} )
    def validate_FreightCollectTermsType(self, value):
        # Validate type FreightCollectTermsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NON_RECOURSE_SHIPPER_SIGNED', 'STANDARD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightCollectTermsType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FedExFreightAccountNumber is not None or
            self.FedExFreightBillingContactAndAddress is not None or
            self.AlternateBilling is not None or
            self.PrintedReferences or
            self.Role is not None or
            self.CollectTermsType is not None or
            self.DeclaredValuePerUnit is not None or
            self.DeclaredValueUnits is not None or
            self.LiabilityCoverageDetail is not None or
            self.Coupons or
            self.TotalHandlingUnits is not None or
            self.ClientDiscountPercent is not None or
            self.PalletWeight is not None or
            self.ShipmentDimensions is not None or
            self.Comment is not None or
            self.SpecialServicePayments or
            self.HazardousMaterialsEmergencyContactNumber is not None or
            self.HazardousMaterialsOfferor is not None or
            self.LineItems
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='FreightShipmentDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightShipmentDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightShipmentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='FreightShipmentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='FreightShipmentDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='FreightShipmentDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FedExFreightAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FedExFreightAccountNumber>%s</ns:FedExFreightAccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FedExFreightAccountNumber), input_name='FedExFreightAccountNumber')), eol_))
        if self.FedExFreightBillingContactAndAddress is not None:
            self.FedExFreightBillingContactAndAddress.export(outfile, level, namespace_, name_='FedExFreightBillingContactAndAddress', pretty_print=pretty_print)
        if self.AlternateBilling is not None:
            self.AlternateBilling.export(outfile, level, namespace_, name_='AlternateBilling', pretty_print=pretty_print)
        for PrintedReferences_ in self.PrintedReferences:
            PrintedReferences_.export(outfile, level, namespace_, name_='PrintedReferences', pretty_print=pretty_print)
        if self.Role is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Role>%s</ns:Role>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Role), input_name='Role')), eol_))
        if self.CollectTermsType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CollectTermsType>%s</ns:CollectTermsType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CollectTermsType), input_name='CollectTermsType')), eol_))
        if self.DeclaredValuePerUnit is not None:
            self.DeclaredValuePerUnit.export(outfile, level, namespace_, name_='DeclaredValuePerUnit', pretty_print=pretty_print)
        if self.DeclaredValueUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DeclaredValueUnits>%s</ns:DeclaredValueUnits>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeclaredValueUnits), input_name='DeclaredValueUnits')), eol_))
        if self.LiabilityCoverageDetail is not None:
            self.LiabilityCoverageDetail.export(outfile, level, namespace_, name_='LiabilityCoverageDetail', pretty_print=pretty_print)
        for Coupons_ in self.Coupons:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Coupons>%s</ns:Coupons>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Coupons_), input_name='Coupons')), eol_))
        if self.TotalHandlingUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TotalHandlingUnits>%s</ns:TotalHandlingUnits>%s' % (self.gds_format_integer(self.TotalHandlingUnits, input_name='TotalHandlingUnits'), eol_))
        if self.ClientDiscountPercent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ClientDiscountPercent>%s</ns:ClientDiscountPercent>%s' % (self.gds_format_float(self.ClientDiscountPercent, input_name='ClientDiscountPercent'), eol_))
        if self.PalletWeight is not None:
            self.PalletWeight.export(outfile, level, namespace_, name_='PalletWeight', pretty_print=pretty_print)
        if self.ShipmentDimensions is not None:
            self.ShipmentDimensions.export(outfile, level, namespace_, name_='ShipmentDimensions', pretty_print=pretty_print)
        if self.Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Comment>%s</ns:Comment>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Comment), input_name='Comment')), eol_))
        for SpecialServicePayments_ in self.SpecialServicePayments:
            SpecialServicePayments_.export(outfile, level, namespace_, name_='SpecialServicePayments', pretty_print=pretty_print)
        if self.HazardousMaterialsEmergencyContactNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HazardousMaterialsEmergencyContactNumber>%s</ns:HazardousMaterialsEmergencyContactNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HazardousMaterialsEmergencyContactNumber), input_name='HazardousMaterialsEmergencyContactNumber')), eol_))
        if self.HazardousMaterialsOfferor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HazardousMaterialsOfferor>%s</ns:HazardousMaterialsOfferor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HazardousMaterialsOfferor), input_name='HazardousMaterialsOfferor')), eol_))
        for LineItems_ in self.LineItems:
            LineItems_.export(outfile, level, namespace_, name_='LineItems', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FedExFreightAccountNumber':
            FedExFreightAccountNumber_ = child_.text
            FedExFreightAccountNumber_ = self.gds_validate_string(FedExFreightAccountNumber_, node, 'FedExFreightAccountNumber')
            self.FedExFreightAccountNumber = FedExFreightAccountNumber_
        elif nodeName_ == 'FedExFreightBillingContactAndAddress':
            obj_ = ContactAndAddress.factory()
            obj_.build(child_)
            self.FedExFreightBillingContactAndAddress = obj_
            obj_.original_tagname_ = 'FedExFreightBillingContactAndAddress'
        elif nodeName_ == 'AlternateBilling':
            obj_ = Party.factory()
            obj_.build(child_)
            self.AlternateBilling = obj_
            obj_.original_tagname_ = 'AlternateBilling'
        elif nodeName_ == 'PrintedReferences':
            obj_ = PrintedReference.factory()
            obj_.build(child_)
            self.PrintedReferences.append(obj_)
            obj_.original_tagname_ = 'PrintedReferences'
        elif nodeName_ == 'Role':
            Role_ = child_.text
            Role_ = self.gds_validate_string(Role_, node, 'Role')
            self.Role = Role_
            # validate type FreightShipmentRoleType
            self.validate_FreightShipmentRoleType(self.Role)
        elif nodeName_ == 'CollectTermsType':
            CollectTermsType_ = child_.text
            CollectTermsType_ = self.gds_validate_string(CollectTermsType_, node, 'CollectTermsType')
            self.CollectTermsType = CollectTermsType_
            # validate type FreightCollectTermsType
            self.validate_FreightCollectTermsType(self.CollectTermsType)
        elif nodeName_ == 'DeclaredValuePerUnit':
            obj_ = Money.factory()
            obj_.build(child_)
            self.DeclaredValuePerUnit = obj_
            obj_.original_tagname_ = 'DeclaredValuePerUnit'
        elif nodeName_ == 'DeclaredValueUnits':
            DeclaredValueUnits_ = child_.text
            DeclaredValueUnits_ = self.gds_validate_string(DeclaredValueUnits_, node, 'DeclaredValueUnits')
            self.DeclaredValueUnits = DeclaredValueUnits_
        elif nodeName_ == 'LiabilityCoverageDetail':
            obj_ = LiabilityCoverageDetail.factory()
            obj_.build(child_)
            self.LiabilityCoverageDetail = obj_
            obj_.original_tagname_ = 'LiabilityCoverageDetail'
        elif nodeName_ == 'Coupons':
            Coupons_ = child_.text
            Coupons_ = self.gds_validate_string(Coupons_, node, 'Coupons')
            self.Coupons.append(Coupons_)
        elif nodeName_ == 'TotalHandlingUnits':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'TotalHandlingUnits')
            self.TotalHandlingUnits = ival_
        elif nodeName_ == 'ClientDiscountPercent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ClientDiscountPercent')
            self.ClientDiscountPercent = fval_
        elif nodeName_ == 'PalletWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.PalletWeight = obj_
            obj_.original_tagname_ = 'PalletWeight'
        elif nodeName_ == 'ShipmentDimensions':
            obj_ = Dimensions.factory()
            obj_.build(child_)
            self.ShipmentDimensions = obj_
            obj_.original_tagname_ = 'ShipmentDimensions'
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment = Comment_
        elif nodeName_ == 'SpecialServicePayments':
            obj_ = FreightSpecialServicePayment.factory()
            obj_.build(child_)
            self.SpecialServicePayments.append(obj_)
            obj_.original_tagname_ = 'SpecialServicePayments'
        elif nodeName_ == 'HazardousMaterialsEmergencyContactNumber':
            HazardousMaterialsEmergencyContactNumber_ = child_.text
            HazardousMaterialsEmergencyContactNumber_ = self.gds_validate_string(HazardousMaterialsEmergencyContactNumber_, node, 'HazardousMaterialsEmergencyContactNumber')
            self.HazardousMaterialsEmergencyContactNumber = HazardousMaterialsEmergencyContactNumber_
        elif nodeName_ == 'HazardousMaterialsOfferor':
            HazardousMaterialsOfferor_ = child_.text
            HazardousMaterialsOfferor_ = self.gds_validate_string(HazardousMaterialsOfferor_, node, 'HazardousMaterialsOfferor')
            self.HazardousMaterialsOfferor = HazardousMaterialsOfferor_
        elif nodeName_ == 'LineItems':
            obj_ = FreightShipmentLineItem.factory()
            obj_.build(child_)
            self.LineItems.append(obj_)
            obj_.original_tagname_ = 'LineItems'
# end class FreightShipmentDetail


class FreightShipmentLineItem(GeneratedsSuper):
    """Description of an individual commodity or class of content in a
    shipment."""
    subclass = None
    superclass = None
    def __init__(self, FreightClass=None, ClassProvidedByCustomer=None, HandlingUnits=None, Packaging=None, Pieces=None, NmfcCode=None, HazardousMaterials=None, PurchaseOrderNumber=None, Description=None, Weight=None, Dimensions=None, Volume=None):
        self.original_tagname_ = None
        self.FreightClass = FreightClass
        self.validate_FreightClassType(self.FreightClass)
        self.ClassProvidedByCustomer = ClassProvidedByCustomer
        self.HandlingUnits = HandlingUnits
        self.Packaging = Packaging
        self.validate_PhysicalPackagingType(self.Packaging)
        self.Pieces = Pieces
        self.NmfcCode = NmfcCode
        self.HazardousMaterials = HazardousMaterials
        self.validate_HazardousCommodityOptionType(self.HazardousMaterials)
        self.PurchaseOrderNumber = PurchaseOrderNumber
        self.Description = Description
        self.Weight = Weight
        self.Dimensions = Dimensions
        self.Volume = Volume
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightShipmentLineItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightShipmentLineItem.subclass:
            return FreightShipmentLineItem.subclass(*args_, **kwargs_)
        else:
            return FreightShipmentLineItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreightClass(self): return self.FreightClass
    def set_FreightClass(self, FreightClass): self.FreightClass = FreightClass
    def get_ClassProvidedByCustomer(self): return self.ClassProvidedByCustomer
    def set_ClassProvidedByCustomer(self, ClassProvidedByCustomer): self.ClassProvidedByCustomer = ClassProvidedByCustomer
    def get_HandlingUnits(self): return self.HandlingUnits
    def set_HandlingUnits(self, HandlingUnits): self.HandlingUnits = HandlingUnits
    def get_Packaging(self): return self.Packaging
    def set_Packaging(self, Packaging): self.Packaging = Packaging
    def get_Pieces(self): return self.Pieces
    def set_Pieces(self, Pieces): self.Pieces = Pieces
    def get_NmfcCode(self): return self.NmfcCode
    def set_NmfcCode(self, NmfcCode): self.NmfcCode = NmfcCode
    def get_HazardousMaterials(self): return self.HazardousMaterials
    def set_HazardousMaterials(self, HazardousMaterials): self.HazardousMaterials = HazardousMaterials
    def get_PurchaseOrderNumber(self): return self.PurchaseOrderNumber
    def set_PurchaseOrderNumber(self, PurchaseOrderNumber): self.PurchaseOrderNumber = PurchaseOrderNumber
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_Dimensions(self): return self.Dimensions
    def set_Dimensions(self, Dimensions): self.Dimensions = Dimensions
    def get_Volume(self): return self.Volume
    def set_Volume(self, Volume): self.Volume = Volume
    def validate_FreightClassType(self, value):
        # Validate type FreightClassType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CLASS_050', 'CLASS_055', 'CLASS_060', 'CLASS_065', 'CLASS_070', 'CLASS_077_5', 'CLASS_085', 'CLASS_092_5', 'CLASS_100', 'CLASS_110', 'CLASS_125', 'CLASS_150', 'CLASS_175', 'CLASS_200', 'CLASS_250', 'CLASS_300', 'CLASS_400', 'CLASS_500']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightClassType' % {"value" : value.encode("utf-8")} )
    def validate_PhysicalPackagingType(self, value):
        # Validate type PhysicalPackagingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BAG', 'BARREL', 'BASKET', 'BOX', 'BUCKET', 'BUNDLE', 'CARTON', 'CASE', 'CONTAINER', 'CRATE', 'CYLINDER', 'DRUM', 'ENVELOPE', 'HAMPER', 'OTHER', 'PAIL', 'PALLET', 'PIECE', 'REEL', 'ROLL', 'SKID', 'TANK', 'TUBE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PhysicalPackagingType' % {"value" : value.encode("utf-8")} )
    def validate_HazardousCommodityOptionType(self, value):
        # Validate type HazardousCommodityOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BATTERY', 'HAZARDOUS_MATERIALS', 'LIMITED_QUANTITIES_COMMODITIES', 'ORM_D', 'REPORTABLE_QUANTITIES', 'SMALL_QUANTITY_EXCEPTION']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FreightClass is not None or
            self.ClassProvidedByCustomer is not None or
            self.HandlingUnits is not None or
            self.Packaging is not None or
            self.Pieces is not None or
            self.NmfcCode is not None or
            self.HazardousMaterials is not None or
            self.PurchaseOrderNumber is not None or
            self.Description is not None or
            self.Weight is not None or
            self.Dimensions is not None or
            self.Volume is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='FreightShipmentLineItem', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightShipmentLineItem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightShipmentLineItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='FreightShipmentLineItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='FreightShipmentLineItem'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='FreightShipmentLineItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FreightClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FreightClass>%s</ns:FreightClass>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FreightClass), input_name='FreightClass')), eol_))
        if self.ClassProvidedByCustomer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ClassProvidedByCustomer>%s</ns:ClassProvidedByCustomer>%s' % (self.gds_format_boolean(self.ClassProvidedByCustomer, input_name='ClassProvidedByCustomer'), eol_))
        if self.HandlingUnits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HandlingUnits>%s</ns:HandlingUnits>%s' % (self.gds_format_integer(self.HandlingUnits, input_name='HandlingUnits'), eol_))
        if self.Packaging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Packaging>%s</ns:Packaging>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Packaging), input_name='Packaging')), eol_))
        if self.Pieces is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Pieces>%s</ns:Pieces>%s' % (self.gds_format_integer(self.Pieces, input_name='Pieces'), eol_))
        if self.NmfcCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:NmfcCode>%s</ns:NmfcCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NmfcCode), input_name='NmfcCode')), eol_))
        if self.HazardousMaterials is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HazardousMaterials>%s</ns:HazardousMaterials>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HazardousMaterials), input_name='HazardousMaterials')), eol_))
        if self.PurchaseOrderNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PurchaseOrderNumber>%s</ns:PurchaseOrderNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PurchaseOrderNumber), input_name='PurchaseOrderNumber')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Weight is not None:
            self.Weight.export(outfile, level, namespace_, name_='Weight', pretty_print=pretty_print)
        if self.Dimensions is not None:
            self.Dimensions.export(outfile, level, namespace_, name_='Dimensions', pretty_print=pretty_print)
        if self.Volume is not None:
            self.Volume.export(outfile, level, namespace_, name_='Volume', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreightClass':
            FreightClass_ = child_.text
            FreightClass_ = self.gds_validate_string(FreightClass_, node, 'FreightClass')
            self.FreightClass = FreightClass_
            # validate type FreightClassType
            self.validate_FreightClassType(self.FreightClass)
        elif nodeName_ == 'ClassProvidedByCustomer':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ClassProvidedByCustomer')
            self.ClassProvidedByCustomer = ival_
        elif nodeName_ == 'HandlingUnits':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'HandlingUnits')
            self.HandlingUnits = ival_
        elif nodeName_ == 'Packaging':
            Packaging_ = child_.text
            Packaging_ = self.gds_validate_string(Packaging_, node, 'Packaging')
            self.Packaging = Packaging_
            # validate type PhysicalPackagingType
            self.validate_PhysicalPackagingType(self.Packaging)
        elif nodeName_ == 'Pieces':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Pieces')
            self.Pieces = ival_
        elif nodeName_ == 'NmfcCode':
            NmfcCode_ = child_.text
            NmfcCode_ = self.gds_validate_string(NmfcCode_, node, 'NmfcCode')
            self.NmfcCode = NmfcCode_
        elif nodeName_ == 'HazardousMaterials':
            HazardousMaterials_ = child_.text
            HazardousMaterials_ = self.gds_validate_string(HazardousMaterials_, node, 'HazardousMaterials')
            self.HazardousMaterials = HazardousMaterials_
            # validate type HazardousCommodityOptionType
            self.validate_HazardousCommodityOptionType(self.HazardousMaterials)
        elif nodeName_ == 'PurchaseOrderNumber':
            PurchaseOrderNumber_ = child_.text
            PurchaseOrderNumber_ = self.gds_validate_string(PurchaseOrderNumber_, node, 'PurchaseOrderNumber')
            self.PurchaseOrderNumber = PurchaseOrderNumber_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Weight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.Weight = obj_
            obj_.original_tagname_ = 'Weight'
        elif nodeName_ == 'Dimensions':
            obj_ = Dimensions.factory()
            obj_.build(child_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'Dimensions'
        elif nodeName_ == 'Volume':
            obj_ = Volume.factory()
            obj_.build(child_)
            self.Volume = obj_
            obj_.original_tagname_ = 'Volume'
# end class FreightShipmentLineItem


class FreightSpecialServicePayment(GeneratedsSuper):
    """Specifies which party will be responsible for payment of any
    surcharges for Freight special services for which split billing
    is allowed."""
    subclass = None
    superclass = None
    def __init__(self, SpecialService=None, PaymentType=None):
        self.original_tagname_ = None
        self.SpecialService = SpecialService
        self.validate_ShipmentSpecialServiceType(self.SpecialService)
        self.PaymentType = PaymentType
        self.validate_FreightShipmentRoleType(self.PaymentType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightSpecialServicePayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightSpecialServicePayment.subclass:
            return FreightSpecialServicePayment.subclass(*args_, **kwargs_)
        else:
            return FreightSpecialServicePayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialService(self): return self.SpecialService
    def set_SpecialService(self, SpecialService): self.SpecialService = SpecialService
    def get_PaymentType(self): return self.PaymentType
    def set_PaymentType(self, PaymentType): self.PaymentType = PaymentType
    def validate_ShipmentSpecialServiceType(self, value):
        # Validate type ShipmentSpecialServiceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BROKER_SELECT_OPTION', 'CALL_BEFORE_DELIVERY', 'COD', 'CUSTOM_DELIVERY_WINDOW', 'CUT_FLOWERS', 'DANGEROUS_GOODS', 'DELIVERY_ON_INVOICE_ACCEPTANCE', 'DO_NOT_BREAK_DOWN_PALLETS', 'DO_NOT_STACK_PALLETS', 'DRY_ICE', 'EAST_COAST_SPECIAL', 'ELECTRONIC_TRADE_DOCUMENTS', 'EVENT_NOTIFICATION', 'EXCLUDE_FROM_CONSOLIDATION', 'EXTREME_LENGTH', 'FEDEX_ONE_RATE', 'FOOD', 'FREIGHT_GUARANTEE', 'FREIGHT_TO_COLLECT', 'FUTURE_DAY_SHIPMENT', 'HOLD_AT_LOCATION', 'HOME_DELIVERY_PREMIUM', 'INSIDE_DELIVERY', 'INSIDE_PICKUP', 'INTERNATIONAL_CONTROLLED_EXPORT_SERVICE', 'INTERNATIONAL_TRAFFIC_IN_ARMS_REGULATIONS', 'LIFTGATE_DELIVERY', 'LIFTGATE_PICKUP', 'LIMITED_ACCESS_DELIVERY', 'LIMITED_ACCESS_PICKUP', 'PENDING_SHIPMENT', 'PHARMACY_DELIVERY', 'POISON', 'PROTECTION_FROM_FREEZING', 'RETURNS_CLEARANCE', 'RETURN_SHIPMENT', 'SATURDAY_DELIVERY', 'SATURDAY_PICKUP', 'THIRD_PARTY_CONSIGNEE', 'TOP_LOAD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShipmentSpecialServiceType' % {"value" : value.encode("utf-8")} )
    def validate_FreightShipmentRoleType(self, value):
        # Validate type FreightShipmentRoleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CONSIGNEE', 'SHIPPER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FreightShipmentRoleType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SpecialService is not None or
            self.PaymentType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='FreightSpecialServicePayment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightSpecialServicePayment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightSpecialServicePayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='FreightSpecialServicePayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='FreightSpecialServicePayment'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='FreightSpecialServicePayment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecialService is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SpecialService>%s</ns:SpecialService>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialService), input_name='SpecialService')), eol_))
        if self.PaymentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PaymentType>%s</ns:PaymentType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PaymentType), input_name='PaymentType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialService':
            SpecialService_ = child_.text
            SpecialService_ = self.gds_validate_string(SpecialService_, node, 'SpecialService')
            self.SpecialService = SpecialService_
            # validate type ShipmentSpecialServiceType
            self.validate_ShipmentSpecialServiceType(self.SpecialService)
        elif nodeName_ == 'PaymentType':
            PaymentType_ = child_.text
            PaymentType_ = self.gds_validate_string(PaymentType_, node, 'PaymentType')
            self.PaymentType = PaymentType_
            # validate type FreightShipmentRoleType
            self.validate_FreightShipmentRoleType(self.PaymentType)
# end class FreightSpecialServicePayment


class GeneralAgencyAgreementDetail(GeneratedsSuper):
    """Data required to produce a General Agency Agreement document.
    Remaining content (business data) to be defined once
    requirements have been completed."""
    subclass = None
    superclass = None
    def __init__(self, Format=None):
        self.original_tagname_ = None
        self.Format = Format
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralAgencyAgreementDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralAgencyAgreementDetail.subclass:
            return GeneralAgencyAgreementDetail.subclass(*args_, **kwargs_)
        else:
            return GeneralAgencyAgreementDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def hasContent_(self):
        if (
            self.Format is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='GeneralAgencyAgreementDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralAgencyAgreementDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneralAgencyAgreementDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='GeneralAgencyAgreementDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='GeneralAgencyAgreementDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='GeneralAgencyAgreementDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            self.Format.export(outfile, level, namespace_, name_='Format', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
# end class GeneralAgencyAgreementDetail


class HazardousCommodityContent(GeneratedsSuper):
    """Documents the kind and quantity of an individual hazardous commodity
    in a package."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Quantity=None, InnerReceptacles=None, Options=None, RadionuclideDetail=None, NetExplosiveDetail=None):
        self.original_tagname_ = None
        self.Description = Description
        self.Quantity = Quantity
        if InnerReceptacles is None:
            self.InnerReceptacles = []
        else:
            self.InnerReceptacles = InnerReceptacles
        self.Options = Options
        self.RadionuclideDetail = RadionuclideDetail
        self.NetExplosiveDetail = NetExplosiveDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HazardousCommodityContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HazardousCommodityContent.subclass:
            return HazardousCommodityContent.subclass(*args_, **kwargs_)
        else:
            return HazardousCommodityContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def get_InnerReceptacles(self): return self.InnerReceptacles
    def set_InnerReceptacles(self, InnerReceptacles): self.InnerReceptacles = InnerReceptacles
    def add_InnerReceptacles(self, value): self.InnerReceptacles.append(value)
    def insert_InnerReceptacles_at(self, index, value): self.InnerReceptacles.insert(index, value)
    def replace_InnerReceptacles_at(self, index, value): self.InnerReceptacles[index] = value
    def get_Options(self): return self.Options
    def set_Options(self, Options): self.Options = Options
    def get_RadionuclideDetail(self): return self.RadionuclideDetail
    def set_RadionuclideDetail(self, RadionuclideDetail): self.RadionuclideDetail = RadionuclideDetail
    def get_NetExplosiveDetail(self): return self.NetExplosiveDetail
    def set_NetExplosiveDetail(self, NetExplosiveDetail): self.NetExplosiveDetail = NetExplosiveDetail
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Quantity is not None or
            self.InnerReceptacles or
            self.Options is not None or
            self.RadionuclideDetail is not None or
            self.NetExplosiveDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='HazardousCommodityContent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HazardousCommodityContent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HazardousCommodityContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='HazardousCommodityContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='HazardousCommodityContent'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='HazardousCommodityContent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_, name_='Quantity', pretty_print=pretty_print)
        for InnerReceptacles_ in self.InnerReceptacles:
            InnerReceptacles_.export(outfile, level, namespace_, name_='InnerReceptacles', pretty_print=pretty_print)
        if self.Options is not None:
            self.Options.export(outfile, level, namespace_, name_='Options', pretty_print=pretty_print)
        if self.RadionuclideDetail is not None:
            self.RadionuclideDetail.export(outfile, level, namespace_, name_='RadionuclideDetail', pretty_print=pretty_print)
        if self.NetExplosiveDetail is not None:
            self.NetExplosiveDetail.export(outfile, level, namespace_, name_='NetExplosiveDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = HazardousCommodityDescription.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Quantity':
            obj_ = HazardousCommodityQuantityDetail.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'InnerReceptacles':
            obj_ = HazardousCommodityInnerReceptacleDetail.factory()
            obj_.build(child_)
            self.InnerReceptacles.append(obj_)
            obj_.original_tagname_ = 'InnerReceptacles'
        elif nodeName_ == 'Options':
            obj_ = HazardousCommodityOptionDetail.factory()
            obj_.build(child_)
            self.Options = obj_
            obj_.original_tagname_ = 'Options'
        elif nodeName_ == 'RadionuclideDetail':
            obj_ = RadionuclideDetail.factory()
            obj_.build(child_)
            self.RadionuclideDetail = obj_
            obj_.original_tagname_ = 'RadionuclideDetail'
        elif nodeName_ == 'NetExplosiveDetail':
            obj_ = NetExplosiveDetail.factory()
            obj_.build(child_)
            self.NetExplosiveDetail = obj_
            obj_.original_tagname_ = 'NetExplosiveDetail'
# end class HazardousCommodityContent


class HazardousCommodityDescription(GeneratedsSuper):
    """Identifies and describes an individual hazardous commodity."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, SequenceNumber=None, PackingGroup=None, PackingDetails=None, ReportableQuantity=None, ProperShippingName=None, TechnicalName=None, Percentage=None, HazardClass=None, SubsidiaryClasses=None, LabelText=None, ProcessingOptions=None, Authorization=None):
        self.original_tagname_ = None
        self.Id = Id
        self.SequenceNumber = SequenceNumber
        self.PackingGroup = PackingGroup
        self.validate_HazardousCommodityPackingGroupType(self.PackingGroup)
        self.PackingDetails = PackingDetails
        self.ReportableQuantity = ReportableQuantity
        self.ProperShippingName = ProperShippingName
        self.TechnicalName = TechnicalName
        self.Percentage = Percentage
        self.HazardClass = HazardClass
        if SubsidiaryClasses is None:
            self.SubsidiaryClasses = []
        else:
            self.SubsidiaryClasses = SubsidiaryClasses
        self.LabelText = LabelText
        if ProcessingOptions is None:
            self.ProcessingOptions = []
        else:
            self.ProcessingOptions = ProcessingOptions
        self.Authorization = Authorization
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HazardousCommodityDescription)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HazardousCommodityDescription.subclass:
            return HazardousCommodityDescription.subclass(*args_, **kwargs_)
        else:
            return HazardousCommodityDescription(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_SequenceNumber(self): return self.SequenceNumber
    def set_SequenceNumber(self, SequenceNumber): self.SequenceNumber = SequenceNumber
    def get_PackingGroup(self): return self.PackingGroup
    def set_PackingGroup(self, PackingGroup): self.PackingGroup = PackingGroup
    def get_PackingDetails(self): return self.PackingDetails
    def set_PackingDetails(self, PackingDetails): self.PackingDetails = PackingDetails
    def get_ReportableQuantity(self): return self.ReportableQuantity
    def set_ReportableQuantity(self, ReportableQuantity): self.ReportableQuantity = ReportableQuantity
    def get_ProperShippingName(self): return self.ProperShippingName
    def set_ProperShippingName(self, ProperShippingName): self.ProperShippingName = ProperShippingName
    def get_TechnicalName(self): return self.TechnicalName
    def set_TechnicalName(self, TechnicalName): self.TechnicalName = TechnicalName
    def get_Percentage(self): return self.Percentage
    def set_Percentage(self, Percentage): self.Percentage = Percentage
    def get_HazardClass(self): return self.HazardClass
    def set_HazardClass(self, HazardClass): self.HazardClass = HazardClass
    def get_SubsidiaryClasses(self): return self.SubsidiaryClasses
    def set_SubsidiaryClasses(self, SubsidiaryClasses): self.SubsidiaryClasses = SubsidiaryClasses
    def add_SubsidiaryClasses(self, value): self.SubsidiaryClasses.append(value)
    def insert_SubsidiaryClasses_at(self, index, value): self.SubsidiaryClasses.insert(index, value)
    def replace_SubsidiaryClasses_at(self, index, value): self.SubsidiaryClasses[index] = value
    def get_LabelText(self): return self.LabelText
    def set_LabelText(self, LabelText): self.LabelText = LabelText
    def get_ProcessingOptions(self): return self.ProcessingOptions
    def set_ProcessingOptions(self, ProcessingOptions): self.ProcessingOptions = ProcessingOptions
    def add_ProcessingOptions(self, value): self.ProcessingOptions.append(value)
    def insert_ProcessingOptions_at(self, index, value): self.ProcessingOptions.insert(index, value)
    def replace_ProcessingOptions_at(self, index, value): self.ProcessingOptions[index] = value
    def get_Authorization(self): return self.Authorization
    def set_Authorization(self, Authorization): self.Authorization = Authorization
    def validate_HazardousCommodityPackingGroupType(self, value):
        # Validate type HazardousCommodityPackingGroupType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEFAULT', 'I', 'II', 'III']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityPackingGroupType' % {"value" : value.encode("utf-8")} )
    def validate_HazardousCommodityDescriptionProcessingOptionType(self, value):
        # Validate type HazardousCommodityDescriptionProcessingOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INCLUDE_SPECIAL_PROVISIONS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityDescriptionProcessingOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Id is not None or
            self.SequenceNumber is not None or
            self.PackingGroup is not None or
            self.PackingDetails is not None or
            self.ReportableQuantity is not None or
            self.ProperShippingName is not None or
            self.TechnicalName is not None or
            self.Percentage is not None or
            self.HazardClass is not None or
            self.SubsidiaryClasses or
            self.LabelText is not None or
            self.ProcessingOptions or
            self.Authorization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='HazardousCommodityDescription', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HazardousCommodityDescription')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HazardousCommodityDescription')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='HazardousCommodityDescription', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='HazardousCommodityDescription'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='HazardousCommodityDescription', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Id>%s</ns:Id>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), eol_))
        if self.SequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SequenceNumber>%s</ns:SequenceNumber>%s' % (self.gds_format_integer(self.SequenceNumber, input_name='SequenceNumber'), eol_))
        if self.PackingGroup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackingGroup>%s</ns:PackingGroup>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackingGroup), input_name='PackingGroup')), eol_))
        if self.PackingDetails is not None:
            self.PackingDetails.export(outfile, level, namespace_, name_='PackingDetails', pretty_print=pretty_print)
        if self.ReportableQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ReportableQuantity>%s</ns:ReportableQuantity>%s' % (self.gds_format_boolean(self.ReportableQuantity, input_name='ReportableQuantity'), eol_))
        if self.ProperShippingName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ProperShippingName>%s</ns:ProperShippingName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProperShippingName), input_name='ProperShippingName')), eol_))
        if self.TechnicalName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TechnicalName>%s</ns:TechnicalName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TechnicalName), input_name='TechnicalName')), eol_))
        if self.Percentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Percentage>%s</ns:Percentage>%s' % (self.gds_format_float(self.Percentage, input_name='Percentage'), eol_))
        if self.HazardClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HazardClass>%s</ns:HazardClass>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HazardClass), input_name='HazardClass')), eol_))
        for SubsidiaryClasses_ in self.SubsidiaryClasses:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SubsidiaryClasses>%s</ns:SubsidiaryClasses>%s' % (self.gds_encode(self.gds_format_string(quote_xml(SubsidiaryClasses_), input_name='SubsidiaryClasses')), eol_))
        if self.LabelText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelText>%s</ns:LabelText>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelText), input_name='LabelText')), eol_))
        for ProcessingOptions_ in self.ProcessingOptions:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ProcessingOptions>%s</ns:ProcessingOptions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(ProcessingOptions_), input_name='ProcessingOptions')), eol_))
        if self.Authorization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Authorization>%s</ns:Authorization>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Authorization), input_name='Authorization')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'SequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SequenceNumber')
            self.SequenceNumber = ival_
        elif nodeName_ == 'PackingGroup':
            PackingGroup_ = child_.text
            PackingGroup_ = self.gds_validate_string(PackingGroup_, node, 'PackingGroup')
            self.PackingGroup = PackingGroup_
            # validate type HazardousCommodityPackingGroupType
            self.validate_HazardousCommodityPackingGroupType(self.PackingGroup)
        elif nodeName_ == 'PackingDetails':
            obj_ = HazardousCommodityPackingDetail.factory()
            obj_.build(child_)
            self.PackingDetails = obj_
            obj_.original_tagname_ = 'PackingDetails'
        elif nodeName_ == 'ReportableQuantity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ReportableQuantity')
            self.ReportableQuantity = ival_
        elif nodeName_ == 'ProperShippingName':
            ProperShippingName_ = child_.text
            ProperShippingName_ = self.gds_validate_string(ProperShippingName_, node, 'ProperShippingName')
            self.ProperShippingName = ProperShippingName_
        elif nodeName_ == 'TechnicalName':
            TechnicalName_ = child_.text
            TechnicalName_ = self.gds_validate_string(TechnicalName_, node, 'TechnicalName')
            self.TechnicalName = TechnicalName_
        elif nodeName_ == 'Percentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Percentage')
            self.Percentage = fval_
        elif nodeName_ == 'HazardClass':
            HazardClass_ = child_.text
            HazardClass_ = self.gds_validate_string(HazardClass_, node, 'HazardClass')
            self.HazardClass = HazardClass_
        elif nodeName_ == 'SubsidiaryClasses':
            SubsidiaryClasses_ = child_.text
            SubsidiaryClasses_ = self.gds_validate_string(SubsidiaryClasses_, node, 'SubsidiaryClasses')
            self.SubsidiaryClasses.append(SubsidiaryClasses_)
        elif nodeName_ == 'LabelText':
            LabelText_ = child_.text
            LabelText_ = self.gds_validate_string(LabelText_, node, 'LabelText')
            self.LabelText = LabelText_
        elif nodeName_ == 'ProcessingOptions':
            ProcessingOptions_ = child_.text
            ProcessingOptions_ = self.gds_validate_string(ProcessingOptions_, node, 'ProcessingOptions')
            self.ProcessingOptions.append(ProcessingOptions_)
            # validate type HazardousCommodityDescriptionProcessingOptionType
            self.validate_HazardousCommodityDescriptionProcessingOptionType(self.ProcessingOptions[-1])
        elif nodeName_ == 'Authorization':
            Authorization_ = child_.text
            Authorization_ = self.gds_validate_string(Authorization_, node, 'Authorization')
            self.Authorization = Authorization_
# end class HazardousCommodityDescription


class HazardousCommodityInnerReceptacleDetail(GeneratedsSuper):
    """This describes information about the inner receptacles for the
    hazardous commodity in a particular dangerous goods container."""
    subclass = None
    superclass = None
    def __init__(self, Quantity=None):
        self.original_tagname_ = None
        self.Quantity = Quantity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HazardousCommodityInnerReceptacleDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HazardousCommodityInnerReceptacleDetail.subclass:
            return HazardousCommodityInnerReceptacleDetail.subclass(*args_, **kwargs_)
        else:
            return HazardousCommodityInnerReceptacleDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def hasContent_(self):
        if (
            self.Quantity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='HazardousCommodityInnerReceptacleDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HazardousCommodityInnerReceptacleDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HazardousCommodityInnerReceptacleDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='HazardousCommodityInnerReceptacleDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='HazardousCommodityInnerReceptacleDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='HazardousCommodityInnerReceptacleDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_, name_='Quantity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Quantity':
            obj_ = HazardousCommodityQuantityDetail.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
# end class HazardousCommodityInnerReceptacleDetail


class HazardousCommodityOptionDetail(GeneratedsSuper):
    """Customer-provided specifications for handling individual
    commodities."""
    subclass = None
    superclass = None
    def __init__(self, LabelTextOption=None, CustomerSuppliedLabelText=None):
        self.original_tagname_ = None
        self.LabelTextOption = LabelTextOption
        self.validate_HazardousCommodityLabelTextOptionType(self.LabelTextOption)
        self.CustomerSuppliedLabelText = CustomerSuppliedLabelText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HazardousCommodityOptionDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HazardousCommodityOptionDetail.subclass:
            return HazardousCommodityOptionDetail.subclass(*args_, **kwargs_)
        else:
            return HazardousCommodityOptionDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LabelTextOption(self): return self.LabelTextOption
    def set_LabelTextOption(self, LabelTextOption): self.LabelTextOption = LabelTextOption
    def get_CustomerSuppliedLabelText(self): return self.CustomerSuppliedLabelText
    def set_CustomerSuppliedLabelText(self, CustomerSuppliedLabelText): self.CustomerSuppliedLabelText = CustomerSuppliedLabelText
    def validate_HazardousCommodityLabelTextOptionType(self, value):
        # Validate type HazardousCommodityLabelTextOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['APPEND', 'OVERRIDE', 'STANDARD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityLabelTextOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LabelTextOption is not None or
            self.CustomerSuppliedLabelText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='HazardousCommodityOptionDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HazardousCommodityOptionDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HazardousCommodityOptionDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='HazardousCommodityOptionDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='HazardousCommodityOptionDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='HazardousCommodityOptionDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LabelTextOption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelTextOption>%s</ns:LabelTextOption>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelTextOption), input_name='LabelTextOption')), eol_))
        if self.CustomerSuppliedLabelText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomerSuppliedLabelText>%s</ns:CustomerSuppliedLabelText>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerSuppliedLabelText), input_name='CustomerSuppliedLabelText')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LabelTextOption':
            LabelTextOption_ = child_.text
            LabelTextOption_ = self.gds_validate_string(LabelTextOption_, node, 'LabelTextOption')
            self.LabelTextOption = LabelTextOption_
            # validate type HazardousCommodityLabelTextOptionType
            self.validate_HazardousCommodityLabelTextOptionType(self.LabelTextOption)
        elif nodeName_ == 'CustomerSuppliedLabelText':
            CustomerSuppliedLabelText_ = child_.text
            CustomerSuppliedLabelText_ = self.gds_validate_string(CustomerSuppliedLabelText_, node, 'CustomerSuppliedLabelText')
            self.CustomerSuppliedLabelText = CustomerSuppliedLabelText_
# end class HazardousCommodityOptionDetail


class HazardousCommodityPackagingDetail(GeneratedsSuper):
    """Identifies number and type of packaging units for hazardous
    commodities."""
    subclass = None
    superclass = None
    def __init__(self, Count=None, Units=None):
        self.original_tagname_ = None
        self.Count = Count
        self.Units = Units
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HazardousCommodityPackagingDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HazardousCommodityPackagingDetail.subclass:
            return HazardousCommodityPackagingDetail.subclass(*args_, **kwargs_)
        else:
            return HazardousCommodityPackagingDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Count(self): return self.Count
    def set_Count(self, Count): self.Count = Count
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def hasContent_(self):
        if (
            self.Count is not None or
            self.Units is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='HazardousCommodityPackagingDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HazardousCommodityPackagingDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HazardousCommodityPackagingDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='HazardousCommodityPackagingDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='HazardousCommodityPackagingDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='HazardousCommodityPackagingDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Count>%s</ns:Count>%s' % (self.gds_format_integer(self.Count, input_name='Count'), eol_))
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Units>%s</ns:Units>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Units), input_name='Units')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Count')
            self.Count = ival_
        elif nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
# end class HazardousCommodityPackagingDetail


class HazardousCommodityPackingDetail(GeneratedsSuper):
    """Specifies documentation and limits for validation of an individual
    packing group/category."""
    subclass = None
    superclass = None
    def __init__(self, CargoAircraftOnly=None, PackingInstructions=None):
        self.original_tagname_ = None
        self.CargoAircraftOnly = CargoAircraftOnly
        self.PackingInstructions = PackingInstructions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HazardousCommodityPackingDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HazardousCommodityPackingDetail.subclass:
            return HazardousCommodityPackingDetail.subclass(*args_, **kwargs_)
        else:
            return HazardousCommodityPackingDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CargoAircraftOnly(self): return self.CargoAircraftOnly
    def set_CargoAircraftOnly(self, CargoAircraftOnly): self.CargoAircraftOnly = CargoAircraftOnly
    def get_PackingInstructions(self): return self.PackingInstructions
    def set_PackingInstructions(self, PackingInstructions): self.PackingInstructions = PackingInstructions
    def hasContent_(self):
        if (
            self.CargoAircraftOnly is not None or
            self.PackingInstructions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='HazardousCommodityPackingDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HazardousCommodityPackingDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HazardousCommodityPackingDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='HazardousCommodityPackingDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='HazardousCommodityPackingDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='HazardousCommodityPackingDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CargoAircraftOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CargoAircraftOnly>%s</ns:CargoAircraftOnly>%s' % (self.gds_format_boolean(self.CargoAircraftOnly, input_name='CargoAircraftOnly'), eol_))
        if self.PackingInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackingInstructions>%s</ns:PackingInstructions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackingInstructions), input_name='PackingInstructions')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CargoAircraftOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CargoAircraftOnly')
            self.CargoAircraftOnly = ival_
        elif nodeName_ == 'PackingInstructions':
            PackingInstructions_ = child_.text
            PackingInstructions_ = self.gds_validate_string(PackingInstructions_, node, 'PackingInstructions')
            self.PackingInstructions = PackingInstructions_
# end class HazardousCommodityPackingDetail


class HazardousCommodityQuantityDetail(GeneratedsSuper):
    """Identifies amount and units for quantity of hazardous commodities."""
    subclass = None
    superclass = None
    def __init__(self, Amount=None, Units=None, QuantityType=None):
        self.original_tagname_ = None
        self.Amount = Amount
        self.Units = Units
        self.QuantityType = QuantityType
        self.validate_HazardousCommodityQuantityType(self.QuantityType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HazardousCommodityQuantityDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HazardousCommodityQuantityDetail.subclass:
            return HazardousCommodityQuantityDetail.subclass(*args_, **kwargs_)
        else:
            return HazardousCommodityQuantityDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_QuantityType(self): return self.QuantityType
    def set_QuantityType(self, QuantityType): self.QuantityType = QuantityType
    def validate_HazardousCommodityQuantityType(self, value):
        # Validate type HazardousCommodityQuantityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['GROSS', 'NET']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityQuantityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Amount is not None or
            self.Units is not None or
            self.QuantityType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='HazardousCommodityQuantityDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HazardousCommodityQuantityDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HazardousCommodityQuantityDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='HazardousCommodityQuantityDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='HazardousCommodityQuantityDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='HazardousCommodityQuantityDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Amount>%s</ns:Amount>%s' % (self.gds_format_float(self.Amount, input_name='Amount'), eol_))
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Units>%s</ns:Units>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Units), input_name='Units')), eol_))
        if self.QuantityType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:QuantityType>%s</ns:QuantityType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.QuantityType), input_name='QuantityType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Amount')
            self.Amount = fval_
        elif nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
        elif nodeName_ == 'QuantityType':
            QuantityType_ = child_.text
            QuantityType_ = self.gds_validate_string(QuantityType_, node, 'QuantityType')
            self.QuantityType = QuantityType_
            # validate type HazardousCommodityQuantityType
            self.validate_HazardousCommodityQuantityType(self.QuantityType)
# end class HazardousCommodityQuantityDetail


class HoldAtLocationDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PhoneNumber=None, LocationContactAndAddress=None, LocationType=None):
        self.original_tagname_ = None
        self.PhoneNumber = PhoneNumber
        self.LocationContactAndAddress = LocationContactAndAddress
        self.LocationType = LocationType
        self.validate_FedExLocationType(self.LocationType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HoldAtLocationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HoldAtLocationDetail.subclass:
            return HoldAtLocationDetail.subclass(*args_, **kwargs_)
        else:
            return HoldAtLocationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PhoneNumber(self): return self.PhoneNumber
    def set_PhoneNumber(self, PhoneNumber): self.PhoneNumber = PhoneNumber
    def get_LocationContactAndAddress(self): return self.LocationContactAndAddress
    def set_LocationContactAndAddress(self, LocationContactAndAddress): self.LocationContactAndAddress = LocationContactAndAddress
    def get_LocationType(self): return self.LocationType
    def set_LocationType(self, LocationType): self.LocationType = LocationType
    def validate_FedExLocationType(self, value):
        # Validate type FedExLocationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEDEX_EXPRESS_STATION', 'FEDEX_FACILITY', 'FEDEX_FREIGHT_SERVICE_CENTER', 'FEDEX_GROUND_TERMINAL', 'FEDEX_HOME_DELIVERY_STATION', 'FEDEX_OFFICE', 'FEDEX_SHIPSITE', 'FEDEX_SMART_POST_HUB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FedExLocationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PhoneNumber is not None or
            self.LocationContactAndAddress is not None or
            self.LocationType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='HoldAtLocationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HoldAtLocationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HoldAtLocationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='HoldAtLocationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='HoldAtLocationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='HoldAtLocationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PhoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PhoneNumber>%s</ns:PhoneNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PhoneNumber), input_name='PhoneNumber')), eol_))
        if self.LocationContactAndAddress is not None:
            self.LocationContactAndAddress.export(outfile, level, namespace_, name_='LocationContactAndAddress', pretty_print=pretty_print)
        if self.LocationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LocationType>%s</ns:LocationType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationType), input_name='LocationType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PhoneNumber':
            PhoneNumber_ = child_.text
            PhoneNumber_ = self.gds_validate_string(PhoneNumber_, node, 'PhoneNumber')
            self.PhoneNumber = PhoneNumber_
        elif nodeName_ == 'LocationContactAndAddress':
            obj_ = ContactAndAddress.factory()
            obj_.build(child_)
            self.LocationContactAndAddress = obj_
            obj_.original_tagname_ = 'LocationContactAndAddress'
        elif nodeName_ == 'LocationType':
            LocationType_ = child_.text
            LocationType_ = self.gds_validate_string(LocationType_, node, 'LocationType')
            self.LocationType = LocationType_
            # validate type FedExLocationType
            self.validate_FedExLocationType(self.LocationType)
# end class HoldAtLocationDetail


class HomeDeliveryPremiumDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HomeDeliveryPremiumType=None, Date=None, PhoneNumber=None):
        self.original_tagname_ = None
        self.HomeDeliveryPremiumType = HomeDeliveryPremiumType
        self.validate_HomeDeliveryPremiumType(self.HomeDeliveryPremiumType)
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.PhoneNumber = PhoneNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HomeDeliveryPremiumDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HomeDeliveryPremiumDetail.subclass:
            return HomeDeliveryPremiumDetail.subclass(*args_, **kwargs_)
        else:
            return HomeDeliveryPremiumDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HomeDeliveryPremiumType(self): return self.HomeDeliveryPremiumType
    def set_HomeDeliveryPremiumType(self, HomeDeliveryPremiumType): self.HomeDeliveryPremiumType = HomeDeliveryPremiumType
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_PhoneNumber(self): return self.PhoneNumber
    def set_PhoneNumber(self, PhoneNumber): self.PhoneNumber = PhoneNumber
    def validate_HomeDeliveryPremiumType(self, value):
        # Validate type HomeDeliveryPremiumType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['APPOINTMENT', 'DATE_CERTAIN', 'EVENING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HomeDeliveryPremiumType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.HomeDeliveryPremiumType is not None or
            self.Date is not None or
            self.PhoneNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='HomeDeliveryPremiumDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HomeDeliveryPremiumDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HomeDeliveryPremiumDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='HomeDeliveryPremiumDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='HomeDeliveryPremiumDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='HomeDeliveryPremiumDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HomeDeliveryPremiumType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HomeDeliveryPremiumType>%s</ns:HomeDeliveryPremiumType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HomeDeliveryPremiumType), input_name='HomeDeliveryPremiumType')), eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Date>%s</ns:Date>%s' % (self.gds_format_date(self.Date, input_name='Date'), eol_))
        if self.PhoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PhoneNumber>%s</ns:PhoneNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PhoneNumber), input_name='PhoneNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HomeDeliveryPremiumType':
            HomeDeliveryPremiumType_ = child_.text
            HomeDeliveryPremiumType_ = self.gds_validate_string(HomeDeliveryPremiumType_, node, 'HomeDeliveryPremiumType')
            self.HomeDeliveryPremiumType = HomeDeliveryPremiumType_
            # validate type HomeDeliveryPremiumType
            self.validate_HomeDeliveryPremiumType(self.HomeDeliveryPremiumType)
        elif nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
        elif nodeName_ == 'PhoneNumber':
            PhoneNumber_ = child_.text
            PhoneNumber_ = self.gds_validate_string(PhoneNumber_, node, 'PhoneNumber')
            self.PhoneNumber = PhoneNumber_
# end class HomeDeliveryPremiumDetail


class InternationalControlledExportDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, ForeignTradeZoneCode=None, EntryNumber=None, LicenseOrPermitNumber=None, LicenseOrPermitExpirationDate=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_InternationalControlledExportType(self.Type)
        self.ForeignTradeZoneCode = ForeignTradeZoneCode
        self.EntryNumber = EntryNumber
        self.LicenseOrPermitNumber = LicenseOrPermitNumber
        if isinstance(LicenseOrPermitExpirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(LicenseOrPermitExpirationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = LicenseOrPermitExpirationDate
        self.LicenseOrPermitExpirationDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InternationalControlledExportDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InternationalControlledExportDetail.subclass:
            return InternationalControlledExportDetail.subclass(*args_, **kwargs_)
        else:
            return InternationalControlledExportDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ForeignTradeZoneCode(self): return self.ForeignTradeZoneCode
    def set_ForeignTradeZoneCode(self, ForeignTradeZoneCode): self.ForeignTradeZoneCode = ForeignTradeZoneCode
    def get_EntryNumber(self): return self.EntryNumber
    def set_EntryNumber(self, EntryNumber): self.EntryNumber = EntryNumber
    def get_LicenseOrPermitNumber(self): return self.LicenseOrPermitNumber
    def set_LicenseOrPermitNumber(self, LicenseOrPermitNumber): self.LicenseOrPermitNumber = LicenseOrPermitNumber
    def get_LicenseOrPermitExpirationDate(self): return self.LicenseOrPermitExpirationDate
    def set_LicenseOrPermitExpirationDate(self, LicenseOrPermitExpirationDate): self.LicenseOrPermitExpirationDate = LicenseOrPermitExpirationDate
    def validate_InternationalControlledExportType(self, value):
        # Validate type InternationalControlledExportType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEA_036', 'DEA_236', 'DEA_486', 'DSP_05', 'DSP_61', 'DSP_73', 'DSP_85', 'DSP_94', 'DSP_LICENSE_AGREEMENT', 'FROM_FOREIGN_TRADE_ZONE', 'WAREHOUSE_WITHDRAWAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InternationalControlledExportType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.ForeignTradeZoneCode is not None or
            self.EntryNumber is not None or
            self.LicenseOrPermitNumber is not None or
            self.LicenseOrPermitExpirationDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='InternationalControlledExportDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InternationalControlledExportDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InternationalControlledExportDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='InternationalControlledExportDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='InternationalControlledExportDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='InternationalControlledExportDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.ForeignTradeZoneCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ForeignTradeZoneCode>%s</ns:ForeignTradeZoneCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ForeignTradeZoneCode), input_name='ForeignTradeZoneCode')), eol_))
        if self.EntryNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EntryNumber>%s</ns:EntryNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EntryNumber), input_name='EntryNumber')), eol_))
        if self.LicenseOrPermitNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LicenseOrPermitNumber>%s</ns:LicenseOrPermitNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LicenseOrPermitNumber), input_name='LicenseOrPermitNumber')), eol_))
        if self.LicenseOrPermitExpirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LicenseOrPermitExpirationDate>%s</ns:LicenseOrPermitExpirationDate>%s' % (self.gds_format_date(self.LicenseOrPermitExpirationDate, input_name='LicenseOrPermitExpirationDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type InternationalControlledExportType
            self.validate_InternationalControlledExportType(self.Type)
        elif nodeName_ == 'ForeignTradeZoneCode':
            ForeignTradeZoneCode_ = child_.text
            ForeignTradeZoneCode_ = self.gds_validate_string(ForeignTradeZoneCode_, node, 'ForeignTradeZoneCode')
            self.ForeignTradeZoneCode = ForeignTradeZoneCode_
        elif nodeName_ == 'EntryNumber':
            EntryNumber_ = child_.text
            EntryNumber_ = self.gds_validate_string(EntryNumber_, node, 'EntryNumber')
            self.EntryNumber = EntryNumber_
        elif nodeName_ == 'LicenseOrPermitNumber':
            LicenseOrPermitNumber_ = child_.text
            LicenseOrPermitNumber_ = self.gds_validate_string(LicenseOrPermitNumber_, node, 'LicenseOrPermitNumber')
            self.LicenseOrPermitNumber = LicenseOrPermitNumber_
        elif nodeName_ == 'LicenseOrPermitExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.LicenseOrPermitExpirationDate = dval_
# end class InternationalControlledExportDetail


class InternationalTrafficInArmsRegulationsDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LicenseOrExemptionNumber=None):
        self.original_tagname_ = None
        self.LicenseOrExemptionNumber = LicenseOrExemptionNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InternationalTrafficInArmsRegulationsDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InternationalTrafficInArmsRegulationsDetail.subclass:
            return InternationalTrafficInArmsRegulationsDetail.subclass(*args_, **kwargs_)
        else:
            return InternationalTrafficInArmsRegulationsDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LicenseOrExemptionNumber(self): return self.LicenseOrExemptionNumber
    def set_LicenseOrExemptionNumber(self, LicenseOrExemptionNumber): self.LicenseOrExemptionNumber = LicenseOrExemptionNumber
    def hasContent_(self):
        if (
            self.LicenseOrExemptionNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='InternationalTrafficInArmsRegulationsDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InternationalTrafficInArmsRegulationsDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InternationalTrafficInArmsRegulationsDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='InternationalTrafficInArmsRegulationsDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='InternationalTrafficInArmsRegulationsDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='InternationalTrafficInArmsRegulationsDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LicenseOrExemptionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LicenseOrExemptionNumber>%s</ns:LicenseOrExemptionNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LicenseOrExemptionNumber), input_name='LicenseOrExemptionNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LicenseOrExemptionNumber':
            LicenseOrExemptionNumber_ = child_.text
            LicenseOrExemptionNumber_ = self.gds_validate_string(LicenseOrExemptionNumber_, node, 'LicenseOrExemptionNumber')
            self.LicenseOrExemptionNumber = LicenseOrExemptionNumber_
# end class InternationalTrafficInArmsRegulationsDetail


class LabelSpecification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Dispositions=None, LabelFormatType=None, ImageType=None, LabelStockType=None, LabelPrintingOrientation=None, LabelOrder=None, PrintedLabelOrigin=None, CustomerSpecifiedDetail=None):
        self.original_tagname_ = None
        if Dispositions is None:
            self.Dispositions = []
        else:
            self.Dispositions = Dispositions
        self.LabelFormatType = LabelFormatType
        self.validate_LabelFormatType(self.LabelFormatType)
        self.ImageType = ImageType
        self.validate_ShippingDocumentImageType(self.ImageType)
        self.LabelStockType = LabelStockType
        self.validate_LabelStockType(self.LabelStockType)
        self.LabelPrintingOrientation = LabelPrintingOrientation
        self.validate_LabelPrintingOrientationType(self.LabelPrintingOrientation)
        self.LabelOrder = LabelOrder
        self.validate_LabelOrderType(self.LabelOrder)
        self.PrintedLabelOrigin = PrintedLabelOrigin
        self.CustomerSpecifiedDetail = CustomerSpecifiedDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LabelSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LabelSpecification.subclass:
            return LabelSpecification.subclass(*args_, **kwargs_)
        else:
            return LabelSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dispositions(self): return self.Dispositions
    def set_Dispositions(self, Dispositions): self.Dispositions = Dispositions
    def add_Dispositions(self, value): self.Dispositions.append(value)
    def insert_Dispositions_at(self, index, value): self.Dispositions.insert(index, value)
    def replace_Dispositions_at(self, index, value): self.Dispositions[index] = value
    def get_LabelFormatType(self): return self.LabelFormatType
    def set_LabelFormatType(self, LabelFormatType): self.LabelFormatType = LabelFormatType
    def get_ImageType(self): return self.ImageType
    def set_ImageType(self, ImageType): self.ImageType = ImageType
    def get_LabelStockType(self): return self.LabelStockType
    def set_LabelStockType(self, LabelStockType): self.LabelStockType = LabelStockType
    def get_LabelPrintingOrientation(self): return self.LabelPrintingOrientation
    def set_LabelPrintingOrientation(self, LabelPrintingOrientation): self.LabelPrintingOrientation = LabelPrintingOrientation
    def get_LabelOrder(self): return self.LabelOrder
    def set_LabelOrder(self, LabelOrder): self.LabelOrder = LabelOrder
    def get_PrintedLabelOrigin(self): return self.PrintedLabelOrigin
    def set_PrintedLabelOrigin(self, PrintedLabelOrigin): self.PrintedLabelOrigin = PrintedLabelOrigin
    def get_CustomerSpecifiedDetail(self): return self.CustomerSpecifiedDetail
    def set_CustomerSpecifiedDetail(self, CustomerSpecifiedDetail): self.CustomerSpecifiedDetail = CustomerSpecifiedDetail
    def validate_LabelFormatType(self, value):
        # Validate type LabelFormatType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COMMON2D', 'FEDEX_FREIGHT_STRAIGHT_BILL_OF_LADING', 'LABEL_DATA_ONLY', 'VICS_BILL_OF_LADING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LabelFormatType' % {"value" : value.encode("utf-8")} )
    def validate_ShippingDocumentImageType(self, value):
        # Validate type ShippingDocumentImageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DOC', 'EPL2', 'PDF', 'PNG', 'RTF', 'TEXT', 'ZPLII']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentImageType' % {"value" : value.encode("utf-8")} )
    def validate_LabelStockType(self, value):
        # Validate type LabelStockType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PAPER_4X6', 'PAPER_4X8', 'PAPER_4X9', 'PAPER_7X4.75', 'PAPER_8.5X11_BOTTOM_HALF_LABEL', 'PAPER_8.5X11_TOP_HALF_LABEL', 'PAPER_LETTER', 'STOCK_4X6', 'STOCK_4X6.75_LEADING_DOC_TAB', 'STOCK_4X6.75_TRAILING_DOC_TAB', 'STOCK_4X8', 'STOCK_4X9_LEADING_DOC_TAB', 'STOCK_4X9_TRAILING_DOC_TAB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LabelStockType' % {"value" : value.encode("utf-8")} )
    def validate_LabelPrintingOrientationType(self, value):
        # Validate type LabelPrintingOrientationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BOTTOM_EDGE_OF_TEXT_FIRST', 'TOP_EDGE_OF_TEXT_FIRST']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LabelPrintingOrientationType' % {"value" : value.encode("utf-8")} )
    def validate_LabelOrderType(self, value):
        # Validate type LabelOrderType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SHIPPING_LABEL_FIRST', 'SHIPPING_LABEL_LAST']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LabelOrderType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Dispositions or
            self.LabelFormatType is not None or
            self.ImageType is not None or
            self.LabelStockType is not None or
            self.LabelPrintingOrientation is not None or
            self.LabelOrder is not None or
            self.PrintedLabelOrigin is not None or
            self.CustomerSpecifiedDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='LabelSpecification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LabelSpecification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LabelSpecification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='LabelSpecification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='LabelSpecification'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='LabelSpecification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Dispositions_ in self.Dispositions:
            Dispositions_.export(outfile, level, namespace_, name_='Dispositions', pretty_print=pretty_print)
        if self.LabelFormatType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelFormatType>%s</ns:LabelFormatType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelFormatType), input_name='LabelFormatType')), eol_))
        if self.ImageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ImageType>%s</ns:ImageType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ImageType), input_name='ImageType')), eol_))
        if self.LabelStockType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelStockType>%s</ns:LabelStockType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelStockType), input_name='LabelStockType')), eol_))
        if self.LabelPrintingOrientation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelPrintingOrientation>%s</ns:LabelPrintingOrientation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelPrintingOrientation), input_name='LabelPrintingOrientation')), eol_))
        if self.LabelOrder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelOrder>%s</ns:LabelOrder>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelOrder), input_name='LabelOrder')), eol_))
        if self.PrintedLabelOrigin is not None:
            self.PrintedLabelOrigin.export(outfile, level, namespace_, name_='PrintedLabelOrigin', pretty_print=pretty_print)
        if self.CustomerSpecifiedDetail is not None:
            self.CustomerSpecifiedDetail.export(outfile, level, namespace_, name_='CustomerSpecifiedDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dispositions':
            obj_ = ShippingDocumentDispositionDetail.factory()
            obj_.build(child_)
            self.Dispositions.append(obj_)
            obj_.original_tagname_ = 'Dispositions'
        elif nodeName_ == 'LabelFormatType':
            LabelFormatType_ = child_.text
            LabelFormatType_ = self.gds_validate_string(LabelFormatType_, node, 'LabelFormatType')
            self.LabelFormatType = LabelFormatType_
            # validate type LabelFormatType
            self.validate_LabelFormatType(self.LabelFormatType)
        elif nodeName_ == 'ImageType':
            ImageType_ = child_.text
            ImageType_ = self.gds_validate_string(ImageType_, node, 'ImageType')
            self.ImageType = ImageType_
            # validate type ShippingDocumentImageType
            self.validate_ShippingDocumentImageType(self.ImageType)
        elif nodeName_ == 'LabelStockType':
            LabelStockType_ = child_.text
            LabelStockType_ = self.gds_validate_string(LabelStockType_, node, 'LabelStockType')
            self.LabelStockType = LabelStockType_
            # validate type LabelStockType
            self.validate_LabelStockType(self.LabelStockType)
        elif nodeName_ == 'LabelPrintingOrientation':
            LabelPrintingOrientation_ = child_.text
            LabelPrintingOrientation_ = self.gds_validate_string(LabelPrintingOrientation_, node, 'LabelPrintingOrientation')
            self.LabelPrintingOrientation = LabelPrintingOrientation_
            # validate type LabelPrintingOrientationType
            self.validate_LabelPrintingOrientationType(self.LabelPrintingOrientation)
        elif nodeName_ == 'LabelOrder':
            LabelOrder_ = child_.text
            LabelOrder_ = self.gds_validate_string(LabelOrder_, node, 'LabelOrder')
            self.LabelOrder = LabelOrder_
            # validate type LabelOrderType
            self.validate_LabelOrderType(self.LabelOrder)
        elif nodeName_ == 'PrintedLabelOrigin':
            obj_ = ContactAndAddress.factory()
            obj_.build(child_)
            self.PrintedLabelOrigin = obj_
            obj_.original_tagname_ = 'PrintedLabelOrigin'
        elif nodeName_ == 'CustomerSpecifiedDetail':
            obj_ = CustomerSpecifiedLabelDetail.factory()
            obj_.build(child_)
            self.CustomerSpecifiedDetail = obj_
            obj_.original_tagname_ = 'CustomerSpecifiedDetail'
# end class LabelSpecification


class LiabilityCoverageDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CoverageType=None, CoverageAmount=None):
        self.original_tagname_ = None
        self.CoverageType = CoverageType
        self.validate_LiabilityCoverageType(self.CoverageType)
        self.CoverageAmount = CoverageAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LiabilityCoverageDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LiabilityCoverageDetail.subclass:
            return LiabilityCoverageDetail.subclass(*args_, **kwargs_)
        else:
            return LiabilityCoverageDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CoverageType(self): return self.CoverageType
    def set_CoverageType(self, CoverageType): self.CoverageType = CoverageType
    def get_CoverageAmount(self): return self.CoverageAmount
    def set_CoverageAmount(self, CoverageAmount): self.CoverageAmount = CoverageAmount
    def validate_LiabilityCoverageType(self, value):
        # Validate type LiabilityCoverageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NEW', 'USED_OR_RECONDITIONED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LiabilityCoverageType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CoverageType is not None or
            self.CoverageAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='LiabilityCoverageDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LiabilityCoverageDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LiabilityCoverageDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='LiabilityCoverageDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='LiabilityCoverageDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='LiabilityCoverageDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CoverageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CoverageType>%s</ns:CoverageType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CoverageType), input_name='CoverageType')), eol_))
        if self.CoverageAmount is not None:
            self.CoverageAmount.export(outfile, level, namespace_, name_='CoverageAmount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CoverageType':
            CoverageType_ = child_.text
            CoverageType_ = self.gds_validate_string(CoverageType_, node, 'CoverageType')
            self.CoverageType = CoverageType_
            # validate type LiabilityCoverageType
            self.validate_LiabilityCoverageType(self.CoverageType)
        elif nodeName_ == 'CoverageAmount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.CoverageAmount = obj_
            obj_.original_tagname_ = 'CoverageAmount'
# end class LiabilityCoverageDetail


class LicenseOrPermitDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Number=None, EffectiveDate=None, ExpirationDate=None):
        self.original_tagname_ = None
        self.Number = Number
        if isinstance(EffectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EffectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EffectiveDate
        self.EffectiveDate = initvalue_
        if isinstance(ExpirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ExpirationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ExpirationDate
        self.ExpirationDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LicenseOrPermitDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LicenseOrPermitDetail.subclass:
            return LicenseOrPermitDetail.subclass(*args_, **kwargs_)
        else:
            return LicenseOrPermitDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def get_EffectiveDate(self): return self.EffectiveDate
    def set_EffectiveDate(self, EffectiveDate): self.EffectiveDate = EffectiveDate
    def get_ExpirationDate(self): return self.ExpirationDate
    def set_ExpirationDate(self, ExpirationDate): self.ExpirationDate = ExpirationDate
    def hasContent_(self):
        if (
            self.Number is not None or
            self.EffectiveDate is not None or
            self.ExpirationDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='LicenseOrPermitDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LicenseOrPermitDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LicenseOrPermitDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='LicenseOrPermitDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='LicenseOrPermitDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='LicenseOrPermitDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Number>%s</ns:Number>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Number), input_name='Number')), eol_))
        if self.EffectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EffectiveDate>%s</ns:EffectiveDate>%s' % (self.gds_format_date(self.EffectiveDate, input_name='EffectiveDate'), eol_))
        if self.ExpirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ExpirationDate>%s</ns:ExpirationDate>%s' % (self.gds_format_date(self.ExpirationDate, input_name='ExpirationDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Number':
            Number_ = child_.text
            Number_ = self.gds_validate_string(Number_, node, 'Number')
            self.Number = Number_
        elif nodeName_ == 'EffectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EffectiveDate = dval_
        elif nodeName_ == 'ExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ExpirationDate = dval_
# end class LicenseOrPermitDetail


class LinearMeasure(GeneratedsSuper):
    """Represents a one-dimensional measurement in small units (e.g.
    suitable for measuring a package or document), contrasted with
    Distance, which represents a large one-dimensional measurement
    (e.g. distance between cities)."""
    subclass = None
    superclass = None
    def __init__(self, Value=None, Units=None):
        self.original_tagname_ = None
        self.Value = Value
        self.Units = Units
        self.validate_LinearUnits(self.Units)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearMeasure.subclass:
            return LinearMeasure.subclass(*args_, **kwargs_)
        else:
            return LinearMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def validate_LinearUnits(self, value):
        # Validate type LinearUnits, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CM', 'IN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LinearUnits' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Value is not None or
            self.Units is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='LinearMeasure', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinearMeasure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearMeasure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='LinearMeasure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='LinearMeasure'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='LinearMeasure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_format_float(self.Value, input_name='Value'), eol_))
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Units>%s</ns:Units>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Units), input_name='Units')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
        elif nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
            # validate type LinearUnits
            self.validate_LinearUnits(self.Units)
# end class LinearMeasure


class Localization(GeneratedsSuper):
    """Identifies the representation of human-readable text."""
    subclass = None
    superclass = None
    def __init__(self, LanguageCode=None, LocaleCode=None):
        self.original_tagname_ = None
        self.LanguageCode = LanguageCode
        self.LocaleCode = LocaleCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Localization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Localization.subclass:
            return Localization.subclass(*args_, **kwargs_)
        else:
            return Localization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_LocaleCode(self): return self.LocaleCode
    def set_LocaleCode(self, LocaleCode): self.LocaleCode = LocaleCode
    def hasContent_(self):
        if (
            self.LanguageCode is not None or
            self.LocaleCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Localization', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Localization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Localization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Localization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Localization'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Localization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LanguageCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LanguageCode>%s</ns:LanguageCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LanguageCode), input_name='LanguageCode')), eol_))
        if self.LocaleCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LocaleCode>%s</ns:LocaleCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocaleCode), input_name='LocaleCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LanguageCode':
            LanguageCode_ = child_.text
            LanguageCode_ = self.gds_validate_string(LanguageCode_, node, 'LanguageCode')
            self.LanguageCode = LanguageCode_
        elif nodeName_ == 'LocaleCode':
            LocaleCode_ = child_.text
            LocaleCode_ = self.gds_validate_string(LocaleCode_, node, 'LocaleCode')
            self.LocaleCode = LocaleCode_
# end class Localization


class Measure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Quantity=None, Units=None):
        self.original_tagname_ = None
        self.Quantity = Quantity
        self.Units = Units
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Measure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Measure.subclass:
            return Measure.subclass(*args_, **kwargs_)
        else:
            return Measure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def hasContent_(self):
        if (
            self.Quantity is not None or
            self.Units is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Measure', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Measure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Measure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Measure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Measure'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Measure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Quantity>%s</ns:Quantity>%s' % (self.gds_format_float(self.Quantity, input_name='Quantity'), eol_))
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Units>%s</ns:Units>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Units), input_name='Units')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Quantity':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Quantity')
            self.Quantity = fval_
        elif nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
# end class Measure


class Money(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Currency=None, Amount=None):
        self.original_tagname_ = None
        self.Currency = Currency
        self.Amount = Amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Money)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Money.subclass:
            return Money.subclass(*args_, **kwargs_)
        else:
            return Money(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Currency(self): return self.Currency
    def set_Currency(self, Currency): self.Currency = Currency
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def hasContent_(self):
        if (
            self.Currency is not None or
            self.Amount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Money', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Money')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Money')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Money', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Money'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Money', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Currency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Currency>%s</ns:Currency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Currency), input_name='Currency')), eol_))
        if self.Amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Amount>%s</ns:Amount>%s' % (self.gds_format_float(self.Amount, input_name='Amount'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Currency':
            Currency_ = child_.text
            Currency_ = self.gds_validate_string(Currency_, node, 'Currency')
            self.Currency = Currency_
        elif nodeName_ == 'Amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Amount')
            self.Amount = fval_
# end class Money


class NaftaCertificateOfOriginDetail(GeneratedsSuper):
    """Data required to produce a Certificate of Origin document. Remaining
    content (business data) to be defined once requirements have
    been completed."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, BlanketPeriod=None, ImporterSpecification=None, SignatureContact=None, ProducerSpecification=None, Producers=None, CustomerImageUsages=None):
        self.original_tagname_ = None
        self.Format = Format
        self.BlanketPeriod = BlanketPeriod
        self.ImporterSpecification = ImporterSpecification
        self.validate_NaftaImporterSpecificationType(self.ImporterSpecification)
        self.SignatureContact = SignatureContact
        self.ProducerSpecification = ProducerSpecification
        self.validate_NaftaProducerSpecificationType(self.ProducerSpecification)
        if Producers is None:
            self.Producers = []
        else:
            self.Producers = Producers
        if CustomerImageUsages is None:
            self.CustomerImageUsages = []
        else:
            self.CustomerImageUsages = CustomerImageUsages
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NaftaCertificateOfOriginDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NaftaCertificateOfOriginDetail.subclass:
            return NaftaCertificateOfOriginDetail.subclass(*args_, **kwargs_)
        else:
            return NaftaCertificateOfOriginDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_BlanketPeriod(self): return self.BlanketPeriod
    def set_BlanketPeriod(self, BlanketPeriod): self.BlanketPeriod = BlanketPeriod
    def get_ImporterSpecification(self): return self.ImporterSpecification
    def set_ImporterSpecification(self, ImporterSpecification): self.ImporterSpecification = ImporterSpecification
    def get_SignatureContact(self): return self.SignatureContact
    def set_SignatureContact(self, SignatureContact): self.SignatureContact = SignatureContact
    def get_ProducerSpecification(self): return self.ProducerSpecification
    def set_ProducerSpecification(self, ProducerSpecification): self.ProducerSpecification = ProducerSpecification
    def get_Producers(self): return self.Producers
    def set_Producers(self, Producers): self.Producers = Producers
    def add_Producers(self, value): self.Producers.append(value)
    def insert_Producers_at(self, index, value): self.Producers.insert(index, value)
    def replace_Producers_at(self, index, value): self.Producers[index] = value
    def get_CustomerImageUsages(self): return self.CustomerImageUsages
    def set_CustomerImageUsages(self, CustomerImageUsages): self.CustomerImageUsages = CustomerImageUsages
    def add_CustomerImageUsages(self, value): self.CustomerImageUsages.append(value)
    def insert_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages.insert(index, value)
    def replace_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages[index] = value
    def validate_NaftaImporterSpecificationType(self, value):
        # Validate type NaftaImporterSpecificationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['IMPORTER_OF_RECORD', 'RECIPIENT', 'UNKNOWN', 'VARIOUS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NaftaImporterSpecificationType' % {"value" : value.encode("utf-8")} )
    def validate_NaftaProducerSpecificationType(self, value):
        # Validate type NaftaProducerSpecificationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AVAILABLE_UPON_REQUEST', 'MULTIPLE_SPECIFIED', 'SAME', 'SINGLE_SPECIFIED', 'UNKNOWN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NaftaProducerSpecificationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Format is not None or
            self.BlanketPeriod is not None or
            self.ImporterSpecification is not None or
            self.SignatureContact is not None or
            self.ProducerSpecification is not None or
            self.Producers or
            self.CustomerImageUsages
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='NaftaCertificateOfOriginDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NaftaCertificateOfOriginDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NaftaCertificateOfOriginDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='NaftaCertificateOfOriginDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='NaftaCertificateOfOriginDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='NaftaCertificateOfOriginDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            self.Format.export(outfile, level, namespace_, name_='Format', pretty_print=pretty_print)
        if self.BlanketPeriod is not None:
            self.BlanketPeriod.export(outfile, level, namespace_, name_='BlanketPeriod', pretty_print=pretty_print)
        if self.ImporterSpecification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ImporterSpecification>%s</ns:ImporterSpecification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ImporterSpecification), input_name='ImporterSpecification')), eol_))
        if self.SignatureContact is not None:
            self.SignatureContact.export(outfile, level, namespace_, name_='SignatureContact', pretty_print=pretty_print)
        if self.ProducerSpecification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ProducerSpecification>%s</ns:ProducerSpecification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProducerSpecification), input_name='ProducerSpecification')), eol_))
        for Producers_ in self.Producers:
            Producers_.export(outfile, level, namespace_, name_='Producers', pretty_print=pretty_print)
        for CustomerImageUsages_ in self.CustomerImageUsages:
            CustomerImageUsages_.export(outfile, level, namespace_, name_='CustomerImageUsages', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
        elif nodeName_ == 'BlanketPeriod':
            obj_ = DateRange.factory()
            obj_.build(child_)
            self.BlanketPeriod = obj_
            obj_.original_tagname_ = 'BlanketPeriod'
        elif nodeName_ == 'ImporterSpecification':
            ImporterSpecification_ = child_.text
            ImporterSpecification_ = self.gds_validate_string(ImporterSpecification_, node, 'ImporterSpecification')
            self.ImporterSpecification = ImporterSpecification_
            # validate type NaftaImporterSpecificationType
            self.validate_NaftaImporterSpecificationType(self.ImporterSpecification)
        elif nodeName_ == 'SignatureContact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.SignatureContact = obj_
            obj_.original_tagname_ = 'SignatureContact'
        elif nodeName_ == 'ProducerSpecification':
            ProducerSpecification_ = child_.text
            ProducerSpecification_ = self.gds_validate_string(ProducerSpecification_, node, 'ProducerSpecification')
            self.ProducerSpecification = ProducerSpecification_
            # validate type NaftaProducerSpecificationType
            self.validate_NaftaProducerSpecificationType(self.ProducerSpecification)
        elif nodeName_ == 'Producers':
            obj_ = NaftaProducer.factory()
            obj_.build(child_)
            self.Producers.append(obj_)
            obj_.original_tagname_ = 'Producers'
        elif nodeName_ == 'CustomerImageUsages':
            obj_ = CustomerImageUsage.factory()
            obj_.build(child_)
            self.CustomerImageUsages.append(obj_)
            obj_.original_tagname_ = 'CustomerImageUsages'
# end class NaftaCertificateOfOriginDetail


class NaftaCommodityDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PreferenceCriterion=None, ProducerDetermination=None, ProducerId=None, NetCostMethod=None, NetCostDateRange=None):
        self.original_tagname_ = None
        self.PreferenceCriterion = PreferenceCriterion
        self.validate_NaftaPreferenceCriterionCode(self.PreferenceCriterion)
        self.ProducerDetermination = ProducerDetermination
        self.validate_NaftaProducerDeterminationCode(self.ProducerDetermination)
        self.ProducerId = ProducerId
        self.NetCostMethod = NetCostMethod
        self.validate_NaftaNetCostMethodCode(self.NetCostMethod)
        self.NetCostDateRange = NetCostDateRange
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NaftaCommodityDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NaftaCommodityDetail.subclass:
            return NaftaCommodityDetail.subclass(*args_, **kwargs_)
        else:
            return NaftaCommodityDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PreferenceCriterion(self): return self.PreferenceCriterion
    def set_PreferenceCriterion(self, PreferenceCriterion): self.PreferenceCriterion = PreferenceCriterion
    def get_ProducerDetermination(self): return self.ProducerDetermination
    def set_ProducerDetermination(self, ProducerDetermination): self.ProducerDetermination = ProducerDetermination
    def get_ProducerId(self): return self.ProducerId
    def set_ProducerId(self, ProducerId): self.ProducerId = ProducerId
    def get_NetCostMethod(self): return self.NetCostMethod
    def set_NetCostMethod(self, NetCostMethod): self.NetCostMethod = NetCostMethod
    def get_NetCostDateRange(self): return self.NetCostDateRange
    def set_NetCostDateRange(self, NetCostDateRange): self.NetCostDateRange = NetCostDateRange
    def validate_NaftaPreferenceCriterionCode(self, value):
        # Validate type NaftaPreferenceCriterionCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'B', 'C', 'D', 'E', 'F']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NaftaPreferenceCriterionCode' % {"value" : value.encode("utf-8")} )
    def validate_NaftaProducerDeterminationCode(self, value):
        # Validate type NaftaProducerDeterminationCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NO_1', 'NO_2', 'NO_3', 'YES']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NaftaProducerDeterminationCode' % {"value" : value.encode("utf-8")} )
    def validate_NaftaNetCostMethodCode(self, value):
        # Validate type NaftaNetCostMethodCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NC', 'NO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NaftaNetCostMethodCode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PreferenceCriterion is not None or
            self.ProducerDetermination is not None or
            self.ProducerId is not None or
            self.NetCostMethod is not None or
            self.NetCostDateRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='NaftaCommodityDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NaftaCommodityDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NaftaCommodityDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='NaftaCommodityDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='NaftaCommodityDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='NaftaCommodityDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PreferenceCriterion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PreferenceCriterion>%s</ns:PreferenceCriterion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PreferenceCriterion), input_name='PreferenceCriterion')), eol_))
        if self.ProducerDetermination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ProducerDetermination>%s</ns:ProducerDetermination>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProducerDetermination), input_name='ProducerDetermination')), eol_))
        if self.ProducerId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ProducerId>%s</ns:ProducerId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProducerId), input_name='ProducerId')), eol_))
        if self.NetCostMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:NetCostMethod>%s</ns:NetCostMethod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NetCostMethod), input_name='NetCostMethod')), eol_))
        if self.NetCostDateRange is not None:
            self.NetCostDateRange.export(outfile, level, namespace_, name_='NetCostDateRange', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PreferenceCriterion':
            PreferenceCriterion_ = child_.text
            PreferenceCriterion_ = self.gds_validate_string(PreferenceCriterion_, node, 'PreferenceCriterion')
            self.PreferenceCriterion = PreferenceCriterion_
            # validate type NaftaPreferenceCriterionCode
            self.validate_NaftaPreferenceCriterionCode(self.PreferenceCriterion)
        elif nodeName_ == 'ProducerDetermination':
            ProducerDetermination_ = child_.text
            ProducerDetermination_ = self.gds_validate_string(ProducerDetermination_, node, 'ProducerDetermination')
            self.ProducerDetermination = ProducerDetermination_
            # validate type NaftaProducerDeterminationCode
            self.validate_NaftaProducerDeterminationCode(self.ProducerDetermination)
        elif nodeName_ == 'ProducerId':
            ProducerId_ = child_.text
            ProducerId_ = self.gds_validate_string(ProducerId_, node, 'ProducerId')
            self.ProducerId = ProducerId_
        elif nodeName_ == 'NetCostMethod':
            NetCostMethod_ = child_.text
            NetCostMethod_ = self.gds_validate_string(NetCostMethod_, node, 'NetCostMethod')
            self.NetCostMethod = NetCostMethod_
            # validate type NaftaNetCostMethodCode
            self.validate_NaftaNetCostMethodCode(self.NetCostMethod)
        elif nodeName_ == 'NetCostDateRange':
            obj_ = DateRange.factory()
            obj_.build(child_)
            self.NetCostDateRange = obj_
            obj_.original_tagname_ = 'NetCostDateRange'
# end class NaftaCommodityDetail


class NaftaLowValueStatementDetail(GeneratedsSuper):
    """Specifies the information necessary for printing the NAFTA Low Value
    statement on customs documentation."""
    subclass = None
    superclass = None
    def __init__(self, Role=None):
        self.original_tagname_ = None
        self.Role = Role
        self.validate_CustomsRoleType(self.Role)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NaftaLowValueStatementDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NaftaLowValueStatementDetail.subclass:
            return NaftaLowValueStatementDetail.subclass(*args_, **kwargs_)
        else:
            return NaftaLowValueStatementDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def validate_CustomsRoleType(self, value):
        # Validate type CustomsRoleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EXPORTER', 'IMPORTER', 'LEGAL_AGENT', 'PRODUCER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomsRoleType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Role is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='NaftaLowValueStatementDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NaftaLowValueStatementDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NaftaLowValueStatementDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='NaftaLowValueStatementDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='NaftaLowValueStatementDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='NaftaLowValueStatementDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Role is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Role>%s</ns:Role>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Role), input_name='Role')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Role':
            Role_ = child_.text
            Role_ = self.gds_validate_string(Role_, node, 'Role')
            self.Role = Role_
            # validate type CustomsRoleType
            self.validate_CustomsRoleType(self.Role)
# end class NaftaLowValueStatementDetail


class NaftaProducer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, Producer=None):
        self.original_tagname_ = None
        self.Id = Id
        self.Producer = Producer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NaftaProducer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NaftaProducer.subclass:
            return NaftaProducer.subclass(*args_, **kwargs_)
        else:
            return NaftaProducer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Producer(self): return self.Producer
    def set_Producer(self, Producer): self.Producer = Producer
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Producer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='NaftaProducer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NaftaProducer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NaftaProducer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='NaftaProducer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='NaftaProducer'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='NaftaProducer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Id>%s</ns:Id>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), eol_))
        if self.Producer is not None:
            self.Producer.export(outfile, level, namespace_, name_='Producer', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'Producer':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Producer = obj_
            obj_.original_tagname_ = 'Producer'
# end class NaftaProducer


class NetExplosiveDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Amount=None, Units=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_NetExplosiveClassificationType(self.Type)
        self.Amount = Amount
        self.Units = Units
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetExplosiveDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetExplosiveDetail.subclass:
            return NetExplosiveDetail.subclass(*args_, **kwargs_)
        else:
            return NetExplosiveDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def validate_NetExplosiveClassificationType(self, value):
        # Validate type NetExplosiveClassificationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NET_EXPLOSIVE_CONTENT', 'NET_EXPLOSIVE_MASS', 'NET_EXPLOSIVE_QUANTITY', 'NET_EXPLOSIVE_WEIGHT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NetExplosiveClassificationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Amount is not None or
            self.Units is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='NetExplosiveDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NetExplosiveDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetExplosiveDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='NetExplosiveDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='NetExplosiveDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='NetExplosiveDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Amount>%s</ns:Amount>%s' % (self.gds_format_float(self.Amount, input_name='Amount'), eol_))
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Units>%s</ns:Units>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Units), input_name='Units')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type NetExplosiveClassificationType
            self.validate_NetExplosiveClassificationType(self.Type)
        elif nodeName_ == 'Amount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Amount')
            self.Amount = fval_
        elif nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
# end class NetExplosiveDetail


class Notification(GeneratedsSuper):
    """The descriptive data regarding the result of the submitted
    transaction."""
    subclass = None
    superclass = None
    def __init__(self, Severity=None, Source=None, Code=None, Message=None, LocalizedMessage=None, MessageParameters=None):
        self.original_tagname_ = None
        self.Severity = Severity
        self.validate_NotificationSeverityType(self.Severity)
        self.Source = Source
        self.Code = Code
        self.Message = Message
        self.LocalizedMessage = LocalizedMessage
        if MessageParameters is None:
            self.MessageParameters = []
        else:
            self.MessageParameters = MessageParameters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Notification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Notification.subclass:
            return Notification.subclass(*args_, **kwargs_)
        else:
            return Notification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Severity(self): return self.Severity
    def set_Severity(self, Severity): self.Severity = Severity
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Message(self): return self.Message
    def set_Message(self, Message): self.Message = Message
    def get_LocalizedMessage(self): return self.LocalizedMessage
    def set_LocalizedMessage(self, LocalizedMessage): self.LocalizedMessage = LocalizedMessage
    def get_MessageParameters(self): return self.MessageParameters
    def set_MessageParameters(self, MessageParameters): self.MessageParameters = MessageParameters
    def add_MessageParameters(self, value): self.MessageParameters.append(value)
    def insert_MessageParameters_at(self, index, value): self.MessageParameters.insert(index, value)
    def replace_MessageParameters_at(self, index, value): self.MessageParameters[index] = value
    def validate_NotificationSeverityType(self, value):
        # Validate type NotificationSeverityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ERROR', 'FAILURE', 'NOTE', 'SUCCESS', 'WARNING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NotificationSeverityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Severity is not None or
            self.Source is not None or
            self.Code is not None or
            self.Message is not None or
            self.LocalizedMessage is not None or
            self.MessageParameters
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Notification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Notification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Notification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Notification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Notification'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Notification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Severity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Severity>%s</ns:Severity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Severity), input_name='Severity')), eol_))
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Source>%s</ns:Source>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Source), input_name='Source')), eol_))
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Code>%s</ns:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Message is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Message>%s</ns:Message>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Message), input_name='Message')), eol_))
        if self.LocalizedMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LocalizedMessage>%s</ns:LocalizedMessage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalizedMessage), input_name='LocalizedMessage')), eol_))
        for MessageParameters_ in self.MessageParameters:
            MessageParameters_.export(outfile, level, namespace_, name_='MessageParameters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Severity':
            Severity_ = child_.text
            Severity_ = self.gds_validate_string(Severity_, node, 'Severity')
            self.Severity = Severity_
            # validate type NotificationSeverityType
            self.validate_NotificationSeverityType(self.Severity)
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
        elif nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Message':
            Message_ = child_.text
            Message_ = self.gds_validate_string(Message_, node, 'Message')
            self.Message = Message_
        elif nodeName_ == 'LocalizedMessage':
            LocalizedMessage_ = child_.text
            LocalizedMessage_ = self.gds_validate_string(LocalizedMessage_, node, 'LocalizedMessage')
            self.LocalizedMessage = LocalizedMessage_
        elif nodeName_ == 'MessageParameters':
            obj_ = NotificationParameter.factory()
            obj_.build(child_)
            self.MessageParameters.append(obj_)
            obj_.original_tagname_ = 'MessageParameters'
# end class Notification


class NotificationDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NotificationType=None, EmailDetail=None, Localization=None):
        self.original_tagname_ = None
        self.NotificationType = NotificationType
        self.validate_NotificationType(self.NotificationType)
        self.EmailDetail = EmailDetail
        self.Localization = Localization
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotificationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotificationDetail.subclass:
            return NotificationDetail.subclass(*args_, **kwargs_)
        else:
            return NotificationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NotificationType(self): return self.NotificationType
    def set_NotificationType(self, NotificationType): self.NotificationType = NotificationType
    def get_EmailDetail(self): return self.EmailDetail
    def set_EmailDetail(self, EmailDetail): self.EmailDetail = EmailDetail
    def get_Localization(self): return self.Localization
    def set_Localization(self, Localization): self.Localization = Localization
    def validate_NotificationType(self, value):
        # Validate type NotificationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EMAIL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NotificationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NotificationType is not None or
            self.EmailDetail is not None or
            self.Localization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='NotificationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NotificationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='NotificationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='NotificationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='NotificationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NotificationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:NotificationType>%s</ns:NotificationType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NotificationType), input_name='NotificationType')), eol_))
        if self.EmailDetail is not None:
            self.EmailDetail.export(outfile, level, namespace_, name_='EmailDetail', pretty_print=pretty_print)
        if self.Localization is not None:
            self.Localization.export(outfile, level, namespace_, name_='Localization', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NotificationType':
            NotificationType_ = child_.text
            NotificationType_ = self.gds_validate_string(NotificationType_, node, 'NotificationType')
            self.NotificationType = NotificationType_
            # validate type NotificationType
            self.validate_NotificationType(self.NotificationType)
        elif nodeName_ == 'EmailDetail':
            obj_ = EMailDetail.factory()
            obj_.build(child_)
            self.EmailDetail = obj_
            obj_.original_tagname_ = 'EmailDetail'
        elif nodeName_ == 'Localization':
            obj_ = Localization.factory()
            obj_.build(child_)
            self.Localization = obj_
            obj_.original_tagname_ = 'Localization'
# end class NotificationDetail


class NotificationParameter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, Value=None):
        self.original_tagname_ = None
        self.Id = Id
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotificationParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotificationParameter.subclass:
            return NotificationParameter.subclass(*args_, **kwargs_)
        else:
            return NotificationParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='NotificationParameter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NotificationParameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='NotificationParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='NotificationParameter'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='NotificationParameter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Id>%s</ns:Id>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class NotificationParameter


class Op900Detail(GeneratedsSuper):
    """The instructions indicating how to print the OP-900 form for
    hazardous materials packages."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, Reference=None, CustomerImageUsages=None, SignatureName=None):
        self.original_tagname_ = None
        self.Format = Format
        self.Reference = Reference
        self.validate_CustomerReferenceType(self.Reference)
        if CustomerImageUsages is None:
            self.CustomerImageUsages = []
        else:
            self.CustomerImageUsages = CustomerImageUsages
        self.SignatureName = SignatureName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Op900Detail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Op900Detail.subclass:
            return Op900Detail.subclass(*args_, **kwargs_)
        else:
            return Op900Detail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def get_CustomerImageUsages(self): return self.CustomerImageUsages
    def set_CustomerImageUsages(self, CustomerImageUsages): self.CustomerImageUsages = CustomerImageUsages
    def add_CustomerImageUsages(self, value): self.CustomerImageUsages.append(value)
    def insert_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages.insert(index, value)
    def replace_CustomerImageUsages_at(self, index, value): self.CustomerImageUsages[index] = value
    def get_SignatureName(self): return self.SignatureName
    def set_SignatureName(self, SignatureName): self.SignatureName = SignatureName
    def validate_CustomerReferenceType(self, value):
        # Validate type CustomerReferenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUSTOMER_REFERENCE', 'DEPARTMENT_NUMBER', 'INTRACOUNTRY_REGULATORY_REFERENCE', 'INVOICE_NUMBER', 'P_O_NUMBER', 'RMA_ASSOCIATION', 'SHIPMENT_INTEGRITY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomerReferenceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Format is not None or
            self.Reference is not None or
            self.CustomerImageUsages or
            self.SignatureName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Op900Detail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Op900Detail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Op900Detail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Op900Detail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Op900Detail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Op900Detail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            self.Format.export(outfile, level, namespace_, name_='Format', pretty_print=pretty_print)
        if self.Reference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Reference>%s</ns:Reference>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Reference), input_name='Reference')), eol_))
        for CustomerImageUsages_ in self.CustomerImageUsages:
            CustomerImageUsages_.export(outfile, level, namespace_, name_='CustomerImageUsages', pretty_print=pretty_print)
        if self.SignatureName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SignatureName>%s</ns:SignatureName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SignatureName), input_name='SignatureName')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
        elif nodeName_ == 'Reference':
            Reference_ = child_.text
            Reference_ = self.gds_validate_string(Reference_, node, 'Reference')
            self.Reference = Reference_
            # validate type CustomerReferenceType
            self.validate_CustomerReferenceType(self.Reference)
        elif nodeName_ == 'CustomerImageUsages':
            obj_ = CustomerImageUsage.factory()
            obj_.build(child_)
            self.CustomerImageUsages.append(obj_)
            obj_.original_tagname_ = 'CustomerImageUsages'
        elif nodeName_ == 'SignatureName':
            SignatureName_ = child_.text
            SignatureName_ = self.gds_validate_string(SignatureName_, node, 'SignatureName')
            self.SignatureName = SignatureName_
# end class Op900Detail


class OperationalInstruction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Number=None, Content=None):
        self.original_tagname_ = None
        self.Number = Number
        self.Content = Content
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OperationalInstruction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OperationalInstruction.subclass:
            return OperationalInstruction.subclass(*args_, **kwargs_)
        else:
            return OperationalInstruction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def get_Content(self): return self.Content
    def set_Content(self, Content): self.Content = Content
    def hasContent_(self):
        if (
            self.Number is not None or
            self.Content is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='OperationalInstruction', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OperationalInstruction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationalInstruction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='OperationalInstruction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='OperationalInstruction'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='OperationalInstruction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Number>%s</ns:Number>%s' % (self.gds_format_integer(self.Number, input_name='Number'), eol_))
        if self.Content is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Content>%s</ns:Content>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Content), input_name='Content')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Number':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Number')
            self.Number = ival_
        elif nodeName_ == 'Content':
            Content_ = child_.text
            Content_ = self.gds_validate_string(Content_, node, 'Content')
            self.Content = Content_
# end class OperationalInstruction


class PackageBarcodes(GeneratedsSuper):
    """Each instance of this data type represents the set of barcodes (of
    all types) which are associated with a specific package."""
    subclass = None
    superclass = None
    def __init__(self, BinaryBarcodes=None, StringBarcodes=None):
        self.original_tagname_ = None
        if BinaryBarcodes is None:
            self.BinaryBarcodes = []
        else:
            self.BinaryBarcodes = BinaryBarcodes
        if StringBarcodes is None:
            self.StringBarcodes = []
        else:
            self.StringBarcodes = StringBarcodes
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageBarcodes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageBarcodes.subclass:
            return PackageBarcodes.subclass(*args_, **kwargs_)
        else:
            return PackageBarcodes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BinaryBarcodes(self): return self.BinaryBarcodes
    def set_BinaryBarcodes(self, BinaryBarcodes): self.BinaryBarcodes = BinaryBarcodes
    def add_BinaryBarcodes(self, value): self.BinaryBarcodes.append(value)
    def insert_BinaryBarcodes_at(self, index, value): self.BinaryBarcodes.insert(index, value)
    def replace_BinaryBarcodes_at(self, index, value): self.BinaryBarcodes[index] = value
    def get_StringBarcodes(self): return self.StringBarcodes
    def set_StringBarcodes(self, StringBarcodes): self.StringBarcodes = StringBarcodes
    def add_StringBarcodes(self, value): self.StringBarcodes.append(value)
    def insert_StringBarcodes_at(self, index, value): self.StringBarcodes.insert(index, value)
    def replace_StringBarcodes_at(self, index, value): self.StringBarcodes[index] = value
    def hasContent_(self):
        if (
            self.BinaryBarcodes or
            self.StringBarcodes
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PackageBarcodes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PackageBarcodes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageBarcodes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PackageBarcodes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PackageBarcodes'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PackageBarcodes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BinaryBarcodes_ in self.BinaryBarcodes:
            BinaryBarcodes_.export(outfile, level, namespace_, name_='BinaryBarcodes', pretty_print=pretty_print)
        for StringBarcodes_ in self.StringBarcodes:
            StringBarcodes_.export(outfile, level, namespace_, name_='StringBarcodes', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BinaryBarcodes':
            obj_ = BinaryBarcode.factory()
            obj_.build(child_)
            self.BinaryBarcodes.append(obj_)
            obj_.original_tagname_ = 'BinaryBarcodes'
        elif nodeName_ == 'StringBarcodes':
            obj_ = StringBarcode.factory()
            obj_.build(child_)
            self.StringBarcodes.append(obj_)
            obj_.original_tagname_ = 'StringBarcodes'
# end class PackageBarcodes


class PackageOperationalDetail(GeneratedsSuper):
    """Package-level data required for labeling and/or movement."""
    subclass = None
    superclass = None
    def __init__(self, AstraHandlingText=None, OperationalInstructions=None, Barcodes=None, GroundServiceCode=None):
        self.original_tagname_ = None
        self.AstraHandlingText = AstraHandlingText
        if OperationalInstructions is None:
            self.OperationalInstructions = []
        else:
            self.OperationalInstructions = OperationalInstructions
        self.Barcodes = Barcodes
        self.GroundServiceCode = GroundServiceCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageOperationalDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageOperationalDetail.subclass:
            return PackageOperationalDetail.subclass(*args_, **kwargs_)
        else:
            return PackageOperationalDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AstraHandlingText(self): return self.AstraHandlingText
    def set_AstraHandlingText(self, AstraHandlingText): self.AstraHandlingText = AstraHandlingText
    def get_OperationalInstructions(self): return self.OperationalInstructions
    def set_OperationalInstructions(self, OperationalInstructions): self.OperationalInstructions = OperationalInstructions
    def add_OperationalInstructions(self, value): self.OperationalInstructions.append(value)
    def insert_OperationalInstructions_at(self, index, value): self.OperationalInstructions.insert(index, value)
    def replace_OperationalInstructions_at(self, index, value): self.OperationalInstructions[index] = value
    def get_Barcodes(self): return self.Barcodes
    def set_Barcodes(self, Barcodes): self.Barcodes = Barcodes
    def get_GroundServiceCode(self): return self.GroundServiceCode
    def set_GroundServiceCode(self, GroundServiceCode): self.GroundServiceCode = GroundServiceCode
    def hasContent_(self):
        if (
            self.AstraHandlingText is not None or
            self.OperationalInstructions or
            self.Barcodes is not None or
            self.GroundServiceCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PackageOperationalDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PackageOperationalDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageOperationalDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PackageOperationalDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PackageOperationalDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PackageOperationalDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AstraHandlingText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AstraHandlingText>%s</ns:AstraHandlingText>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AstraHandlingText), input_name='AstraHandlingText')), eol_))
        for OperationalInstructions_ in self.OperationalInstructions:
            OperationalInstructions_.export(outfile, level, namespace_, name_='OperationalInstructions', pretty_print=pretty_print)
        if self.Barcodes is not None:
            self.Barcodes.export(outfile, level, namespace_, name_='Barcodes', pretty_print=pretty_print)
        if self.GroundServiceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:GroundServiceCode>%s</ns:GroundServiceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GroundServiceCode), input_name='GroundServiceCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AstraHandlingText':
            AstraHandlingText_ = child_.text
            AstraHandlingText_ = self.gds_validate_string(AstraHandlingText_, node, 'AstraHandlingText')
            self.AstraHandlingText = AstraHandlingText_
        elif nodeName_ == 'OperationalInstructions':
            obj_ = OperationalInstruction.factory()
            obj_.build(child_)
            self.OperationalInstructions.append(obj_)
            obj_.original_tagname_ = 'OperationalInstructions'
        elif nodeName_ == 'Barcodes':
            obj_ = PackageBarcodes.factory()
            obj_.build(child_)
            self.Barcodes = obj_
            obj_.original_tagname_ = 'Barcodes'
        elif nodeName_ == 'GroundServiceCode':
            GroundServiceCode_ = child_.text
            GroundServiceCode_ = self.gds_validate_string(GroundServiceCode_, node, 'GroundServiceCode')
            self.GroundServiceCode = GroundServiceCode_
# end class PackageOperationalDetail


class PackageRateDetail(GeneratedsSuper):
    """Data for a package's rates, as calculated per a specific rate type."""
    subclass = None
    superclass = None
    def __init__(self, RateType=None, RatedWeightMethod=None, MinimumChargeType=None, BillingWeight=None, DimWeight=None, OversizeWeight=None, BaseCharge=None, TotalFreightDiscounts=None, NetFreight=None, TotalSurcharges=None, NetFedExCharge=None, TotalTaxes=None, NetCharge=None, TotalRebates=None, FreightDiscounts=None, Rebates=None, Surcharges=None, Taxes=None, VariableHandlingCharges=None):
        self.original_tagname_ = None
        self.RateType = RateType
        self.validate_ReturnedRateType(self.RateType)
        self.RatedWeightMethod = RatedWeightMethod
        self.validate_RatedWeightMethod(self.RatedWeightMethod)
        self.MinimumChargeType = MinimumChargeType
        self.validate_MinimumChargeType(self.MinimumChargeType)
        self.BillingWeight = BillingWeight
        self.DimWeight = DimWeight
        self.OversizeWeight = OversizeWeight
        self.BaseCharge = BaseCharge
        self.TotalFreightDiscounts = TotalFreightDiscounts
        self.NetFreight = NetFreight
        self.TotalSurcharges = TotalSurcharges
        self.NetFedExCharge = NetFedExCharge
        self.TotalTaxes = TotalTaxes
        self.NetCharge = NetCharge
        self.TotalRebates = TotalRebates
        if FreightDiscounts is None:
            self.FreightDiscounts = []
        else:
            self.FreightDiscounts = FreightDiscounts
        if Rebates is None:
            self.Rebates = []
        else:
            self.Rebates = Rebates
        if Surcharges is None:
            self.Surcharges = []
        else:
            self.Surcharges = Surcharges
        if Taxes is None:
            self.Taxes = []
        else:
            self.Taxes = Taxes
        self.VariableHandlingCharges = VariableHandlingCharges
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageRateDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageRateDetail.subclass:
            return PackageRateDetail.subclass(*args_, **kwargs_)
        else:
            return PackageRateDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RateType(self): return self.RateType
    def set_RateType(self, RateType): self.RateType = RateType
    def get_RatedWeightMethod(self): return self.RatedWeightMethod
    def set_RatedWeightMethod(self, RatedWeightMethod): self.RatedWeightMethod = RatedWeightMethod
    def get_MinimumChargeType(self): return self.MinimumChargeType
    def set_MinimumChargeType(self, MinimumChargeType): self.MinimumChargeType = MinimumChargeType
    def get_BillingWeight(self): return self.BillingWeight
    def set_BillingWeight(self, BillingWeight): self.BillingWeight = BillingWeight
    def get_DimWeight(self): return self.DimWeight
    def set_DimWeight(self, DimWeight): self.DimWeight = DimWeight
    def get_OversizeWeight(self): return self.OversizeWeight
    def set_OversizeWeight(self, OversizeWeight): self.OversizeWeight = OversizeWeight
    def get_BaseCharge(self): return self.BaseCharge
    def set_BaseCharge(self, BaseCharge): self.BaseCharge = BaseCharge
    def get_TotalFreightDiscounts(self): return self.TotalFreightDiscounts
    def set_TotalFreightDiscounts(self, TotalFreightDiscounts): self.TotalFreightDiscounts = TotalFreightDiscounts
    def get_NetFreight(self): return self.NetFreight
    def set_NetFreight(self, NetFreight): self.NetFreight = NetFreight
    def get_TotalSurcharges(self): return self.TotalSurcharges
    def set_TotalSurcharges(self, TotalSurcharges): self.TotalSurcharges = TotalSurcharges
    def get_NetFedExCharge(self): return self.NetFedExCharge
    def set_NetFedExCharge(self, NetFedExCharge): self.NetFedExCharge = NetFedExCharge
    def get_TotalTaxes(self): return self.TotalTaxes
    def set_TotalTaxes(self, TotalTaxes): self.TotalTaxes = TotalTaxes
    def get_NetCharge(self): return self.NetCharge
    def set_NetCharge(self, NetCharge): self.NetCharge = NetCharge
    def get_TotalRebates(self): return self.TotalRebates
    def set_TotalRebates(self, TotalRebates): self.TotalRebates = TotalRebates
    def get_FreightDiscounts(self): return self.FreightDiscounts
    def set_FreightDiscounts(self, FreightDiscounts): self.FreightDiscounts = FreightDiscounts
    def add_FreightDiscounts(self, value): self.FreightDiscounts.append(value)
    def insert_FreightDiscounts_at(self, index, value): self.FreightDiscounts.insert(index, value)
    def replace_FreightDiscounts_at(self, index, value): self.FreightDiscounts[index] = value
    def get_Rebates(self): return self.Rebates
    def set_Rebates(self, Rebates): self.Rebates = Rebates
    def add_Rebates(self, value): self.Rebates.append(value)
    def insert_Rebates_at(self, index, value): self.Rebates.insert(index, value)
    def replace_Rebates_at(self, index, value): self.Rebates[index] = value
    def get_Surcharges(self): return self.Surcharges
    def set_Surcharges(self, Surcharges): self.Surcharges = Surcharges
    def add_Surcharges(self, value): self.Surcharges.append(value)
    def insert_Surcharges_at(self, index, value): self.Surcharges.insert(index, value)
    def replace_Surcharges_at(self, index, value): self.Surcharges[index] = value
    def get_Taxes(self): return self.Taxes
    def set_Taxes(self, Taxes): self.Taxes = Taxes
    def add_Taxes(self, value): self.Taxes.append(value)
    def insert_Taxes_at(self, index, value): self.Taxes.insert(index, value)
    def replace_Taxes_at(self, index, value): self.Taxes[index] = value
    def get_VariableHandlingCharges(self): return self.VariableHandlingCharges
    def set_VariableHandlingCharges(self, VariableHandlingCharges): self.VariableHandlingCharges = VariableHandlingCharges
    def validate_ReturnedRateType(self, value):
        # Validate type ReturnedRateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INCENTIVE', 'NEGOTIATED', 'PAYOR_ACCOUNT_PACKAGE', 'PAYOR_ACCOUNT_SHIPMENT', 'PAYOR_LIST_PACKAGE', 'PAYOR_LIST_SHIPMENT', 'PREFERRED_ACCOUNT_PACKAGE', 'PREFERRED_ACCOUNT_SHIPMENT', 'PREFERRED_LIST_PACKAGE', 'PREFERRED_LIST_SHIPMENT', 'PREFERRED_NEGOTIATED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReturnedRateType' % {"value" : value.encode("utf-8")} )
    def validate_RatedWeightMethod(self, value):
        # Validate type RatedWeightMethod, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACTUAL', 'AVERAGE_PACKAGE_WEIGHT_MINIMUM', 'BALLOON', 'DEFAULT_WEIGHT_APPLIED', 'DIM', 'FREIGHT_MINIMUM', 'MIXED', 'OVERSIZE', 'OVERSIZE_1', 'OVERSIZE_2', 'OVERSIZE_3', 'PACKAGING_MINIMUM', 'WEIGHT_BREAK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RatedWeightMethod' % {"value" : value.encode("utf-8")} )
    def validate_MinimumChargeType(self, value):
        # Validate type MinimumChargeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUSTOMER', 'CUSTOMER_FREIGHT_WEIGHT', 'EARNED_DISCOUNT', 'MIXED', 'RATE_SCALE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MinimumChargeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RateType is not None or
            self.RatedWeightMethod is not None or
            self.MinimumChargeType is not None or
            self.BillingWeight is not None or
            self.DimWeight is not None or
            self.OversizeWeight is not None or
            self.BaseCharge is not None or
            self.TotalFreightDiscounts is not None or
            self.NetFreight is not None or
            self.TotalSurcharges is not None or
            self.NetFedExCharge is not None or
            self.TotalTaxes is not None or
            self.NetCharge is not None or
            self.TotalRebates is not None or
            self.FreightDiscounts or
            self.Rebates or
            self.Surcharges or
            self.Taxes or
            self.VariableHandlingCharges is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PackageRateDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PackageRateDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageRateDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PackageRateDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PackageRateDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PackageRateDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RateType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateType>%s</ns:RateType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateType), input_name='RateType')), eol_))
        if self.RatedWeightMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RatedWeightMethod>%s</ns:RatedWeightMethod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RatedWeightMethod), input_name='RatedWeightMethod')), eol_))
        if self.MinimumChargeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:MinimumChargeType>%s</ns:MinimumChargeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MinimumChargeType), input_name='MinimumChargeType')), eol_))
        if self.BillingWeight is not None:
            self.BillingWeight.export(outfile, level, namespace_, name_='BillingWeight', pretty_print=pretty_print)
        if self.DimWeight is not None:
            self.DimWeight.export(outfile, level, namespace_, name_='DimWeight', pretty_print=pretty_print)
        if self.OversizeWeight is not None:
            self.OversizeWeight.export(outfile, level, namespace_, name_='OversizeWeight', pretty_print=pretty_print)
        if self.BaseCharge is not None:
            self.BaseCharge.export(outfile, level, namespace_, name_='BaseCharge', pretty_print=pretty_print)
        if self.TotalFreightDiscounts is not None:
            self.TotalFreightDiscounts.export(outfile, level, namespace_, name_='TotalFreightDiscounts', pretty_print=pretty_print)
        if self.NetFreight is not None:
            self.NetFreight.export(outfile, level, namespace_, name_='NetFreight', pretty_print=pretty_print)
        if self.TotalSurcharges is not None:
            self.TotalSurcharges.export(outfile, level, namespace_, name_='TotalSurcharges', pretty_print=pretty_print)
        if self.NetFedExCharge is not None:
            self.NetFedExCharge.export(outfile, level, namespace_, name_='NetFedExCharge', pretty_print=pretty_print)
        if self.TotalTaxes is not None:
            self.TotalTaxes.export(outfile, level, namespace_, name_='TotalTaxes', pretty_print=pretty_print)
        if self.NetCharge is not None:
            self.NetCharge.export(outfile, level, namespace_, name_='NetCharge', pretty_print=pretty_print)
        if self.TotalRebates is not None:
            self.TotalRebates.export(outfile, level, namespace_, name_='TotalRebates', pretty_print=pretty_print)
        for FreightDiscounts_ in self.FreightDiscounts:
            FreightDiscounts_.export(outfile, level, namespace_, name_='FreightDiscounts', pretty_print=pretty_print)
        for Rebates_ in self.Rebates:
            Rebates_.export(outfile, level, namespace_, name_='Rebates', pretty_print=pretty_print)
        for Surcharges_ in self.Surcharges:
            Surcharges_.export(outfile, level, namespace_, name_='Surcharges', pretty_print=pretty_print)
        for Taxes_ in self.Taxes:
            Taxes_.export(outfile, level, namespace_, name_='Taxes', pretty_print=pretty_print)
        if self.VariableHandlingCharges is not None:
            self.VariableHandlingCharges.export(outfile, level, namespace_, name_='VariableHandlingCharges', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RateType':
            RateType_ = child_.text
            RateType_ = self.gds_validate_string(RateType_, node, 'RateType')
            self.RateType = RateType_
            # validate type ReturnedRateType
            self.validate_ReturnedRateType(self.RateType)
        elif nodeName_ == 'RatedWeightMethod':
            RatedWeightMethod_ = child_.text
            RatedWeightMethod_ = self.gds_validate_string(RatedWeightMethod_, node, 'RatedWeightMethod')
            self.RatedWeightMethod = RatedWeightMethod_
            # validate type RatedWeightMethod
            self.validate_RatedWeightMethod(self.RatedWeightMethod)
        elif nodeName_ == 'MinimumChargeType':
            MinimumChargeType_ = child_.text
            MinimumChargeType_ = self.gds_validate_string(MinimumChargeType_, node, 'MinimumChargeType')
            self.MinimumChargeType = MinimumChargeType_
            # validate type MinimumChargeType
            self.validate_MinimumChargeType(self.MinimumChargeType)
        elif nodeName_ == 'BillingWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.BillingWeight = obj_
            obj_.original_tagname_ = 'BillingWeight'
        elif nodeName_ == 'DimWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.DimWeight = obj_
            obj_.original_tagname_ = 'DimWeight'
        elif nodeName_ == 'OversizeWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.OversizeWeight = obj_
            obj_.original_tagname_ = 'OversizeWeight'
        elif nodeName_ == 'BaseCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.BaseCharge = obj_
            obj_.original_tagname_ = 'BaseCharge'
        elif nodeName_ == 'TotalFreightDiscounts':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalFreightDiscounts = obj_
            obj_.original_tagname_ = 'TotalFreightDiscounts'
        elif nodeName_ == 'NetFreight':
            obj_ = Money.factory()
            obj_.build(child_)
            self.NetFreight = obj_
            obj_.original_tagname_ = 'NetFreight'
        elif nodeName_ == 'TotalSurcharges':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalSurcharges = obj_
            obj_.original_tagname_ = 'TotalSurcharges'
        elif nodeName_ == 'NetFedExCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.NetFedExCharge = obj_
            obj_.original_tagname_ = 'NetFedExCharge'
        elif nodeName_ == 'TotalTaxes':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalTaxes = obj_
            obj_.original_tagname_ = 'TotalTaxes'
        elif nodeName_ == 'NetCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.NetCharge = obj_
            obj_.original_tagname_ = 'NetCharge'
        elif nodeName_ == 'TotalRebates':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalRebates = obj_
            obj_.original_tagname_ = 'TotalRebates'
        elif nodeName_ == 'FreightDiscounts':
            obj_ = RateDiscount.factory()
            obj_.build(child_)
            self.FreightDiscounts.append(obj_)
            obj_.original_tagname_ = 'FreightDiscounts'
        elif nodeName_ == 'Rebates':
            obj_ = Rebate.factory()
            obj_.build(child_)
            self.Rebates.append(obj_)
            obj_.original_tagname_ = 'Rebates'
        elif nodeName_ == 'Surcharges':
            obj_ = Surcharge.factory()
            obj_.build(child_)
            self.Surcharges.append(obj_)
            obj_.original_tagname_ = 'Surcharges'
        elif nodeName_ == 'Taxes':
            obj_ = Tax.factory()
            obj_.build(child_)
            self.Taxes.append(obj_)
            obj_.original_tagname_ = 'Taxes'
        elif nodeName_ == 'VariableHandlingCharges':
            obj_ = VariableHandlingCharges.factory()
            obj_.build(child_)
            self.VariableHandlingCharges = obj_
            obj_.original_tagname_ = 'VariableHandlingCharges'
# end class PackageRateDetail


class PackageRating(GeneratedsSuper):
    """This class groups together for a single package all package-level
    rate data (across all rate types) as part of the response to a
    shipping request, which groups shipment-level data together and
    groups package-level data by package."""
    subclass = None
    superclass = None
    def __init__(self, ActualRateType=None, EffectiveNetDiscount=None, PackageRateDetails=None):
        self.original_tagname_ = None
        self.ActualRateType = ActualRateType
        self.validate_ReturnedRateType(self.ActualRateType)
        self.EffectiveNetDiscount = EffectiveNetDiscount
        if PackageRateDetails is None:
            self.PackageRateDetails = []
        else:
            self.PackageRateDetails = PackageRateDetails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageRating)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageRating.subclass:
            return PackageRating.subclass(*args_, **kwargs_)
        else:
            return PackageRating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActualRateType(self): return self.ActualRateType
    def set_ActualRateType(self, ActualRateType): self.ActualRateType = ActualRateType
    def get_EffectiveNetDiscount(self): return self.EffectiveNetDiscount
    def set_EffectiveNetDiscount(self, EffectiveNetDiscount): self.EffectiveNetDiscount = EffectiveNetDiscount
    def get_PackageRateDetails(self): return self.PackageRateDetails
    def set_PackageRateDetails(self, PackageRateDetails): self.PackageRateDetails = PackageRateDetails
    def add_PackageRateDetails(self, value): self.PackageRateDetails.append(value)
    def insert_PackageRateDetails_at(self, index, value): self.PackageRateDetails.insert(index, value)
    def replace_PackageRateDetails_at(self, index, value): self.PackageRateDetails[index] = value
    def validate_ReturnedRateType(self, value):
        # Validate type ReturnedRateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INCENTIVE', 'NEGOTIATED', 'PAYOR_ACCOUNT_PACKAGE', 'PAYOR_ACCOUNT_SHIPMENT', 'PAYOR_LIST_PACKAGE', 'PAYOR_LIST_SHIPMENT', 'PREFERRED_ACCOUNT_PACKAGE', 'PREFERRED_ACCOUNT_SHIPMENT', 'PREFERRED_LIST_PACKAGE', 'PREFERRED_LIST_SHIPMENT', 'PREFERRED_NEGOTIATED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReturnedRateType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ActualRateType is not None or
            self.EffectiveNetDiscount is not None or
            self.PackageRateDetails
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PackageRating', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PackageRating')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageRating')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PackageRating', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PackageRating'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PackageRating', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActualRateType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ActualRateType>%s</ns:ActualRateType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ActualRateType), input_name='ActualRateType')), eol_))
        if self.EffectiveNetDiscount is not None:
            self.EffectiveNetDiscount.export(outfile, level, namespace_, name_='EffectiveNetDiscount', pretty_print=pretty_print)
        for PackageRateDetails_ in self.PackageRateDetails:
            PackageRateDetails_.export(outfile, level, namespace_, name_='PackageRateDetails', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActualRateType':
            ActualRateType_ = child_.text
            ActualRateType_ = self.gds_validate_string(ActualRateType_, node, 'ActualRateType')
            self.ActualRateType = ActualRateType_
            # validate type ReturnedRateType
            self.validate_ReturnedRateType(self.ActualRateType)
        elif nodeName_ == 'EffectiveNetDiscount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.EffectiveNetDiscount = obj_
            obj_.original_tagname_ = 'EffectiveNetDiscount'
        elif nodeName_ == 'PackageRateDetails':
            obj_ = PackageRateDetail.factory()
            obj_.build(child_)
            self.PackageRateDetails.append(obj_)
            obj_.original_tagname_ = 'PackageRateDetails'
# end class PackageRating


class PackageSpecialServicesRequested(GeneratedsSuper):
    """These special services are available at the package level for some
    or all service types. If the shipper is requesting a special
    service which requires additional data, the package special
    service type must be present in the specialServiceTypes
    collection, and the supporting detail must be provided in the
    appropriate sub-object below."""
    subclass = None
    superclass = None
    def __init__(self, SpecialServiceTypes=None, CodDetail=None, DangerousGoodsDetail=None, BatteryDetails=None, DryIceWeight=None, SignatureOptionDetail=None, PriorityAlertDetail=None, AlcoholDetail=None):
        self.original_tagname_ = None
        if SpecialServiceTypes is None:
            self.SpecialServiceTypes = []
        else:
            self.SpecialServiceTypes = SpecialServiceTypes
        self.CodDetail = CodDetail
        self.DangerousGoodsDetail = DangerousGoodsDetail
        if BatteryDetails is None:
            self.BatteryDetails = []
        else:
            self.BatteryDetails = BatteryDetails
        self.DryIceWeight = DryIceWeight
        self.SignatureOptionDetail = SignatureOptionDetail
        self.PriorityAlertDetail = PriorityAlertDetail
        self.AlcoholDetail = AlcoholDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageSpecialServicesRequested)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageSpecialServicesRequested.subclass:
            return PackageSpecialServicesRequested.subclass(*args_, **kwargs_)
        else:
            return PackageSpecialServicesRequested(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialServiceTypes(self): return self.SpecialServiceTypes
    def set_SpecialServiceTypes(self, SpecialServiceTypes): self.SpecialServiceTypes = SpecialServiceTypes
    def add_SpecialServiceTypes(self, value): self.SpecialServiceTypes.append(value)
    def insert_SpecialServiceTypes_at(self, index, value): self.SpecialServiceTypes.insert(index, value)
    def replace_SpecialServiceTypes_at(self, index, value): self.SpecialServiceTypes[index] = value
    def get_CodDetail(self): return self.CodDetail
    def set_CodDetail(self, CodDetail): self.CodDetail = CodDetail
    def get_DangerousGoodsDetail(self): return self.DangerousGoodsDetail
    def set_DangerousGoodsDetail(self, DangerousGoodsDetail): self.DangerousGoodsDetail = DangerousGoodsDetail
    def get_BatteryDetails(self): return self.BatteryDetails
    def set_BatteryDetails(self, BatteryDetails): self.BatteryDetails = BatteryDetails
    def add_BatteryDetails(self, value): self.BatteryDetails.append(value)
    def insert_BatteryDetails_at(self, index, value): self.BatteryDetails.insert(index, value)
    def replace_BatteryDetails_at(self, index, value): self.BatteryDetails[index] = value
    def get_DryIceWeight(self): return self.DryIceWeight
    def set_DryIceWeight(self, DryIceWeight): self.DryIceWeight = DryIceWeight
    def get_SignatureOptionDetail(self): return self.SignatureOptionDetail
    def set_SignatureOptionDetail(self, SignatureOptionDetail): self.SignatureOptionDetail = SignatureOptionDetail
    def get_PriorityAlertDetail(self): return self.PriorityAlertDetail
    def set_PriorityAlertDetail(self, PriorityAlertDetail): self.PriorityAlertDetail = PriorityAlertDetail
    def get_AlcoholDetail(self): return self.AlcoholDetail
    def set_AlcoholDetail(self, AlcoholDetail): self.AlcoholDetail = AlcoholDetail
    def validate_PackageSpecialServiceType(self, value):
        # Validate type PackageSpecialServiceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ALCOHOL', 'APPOINTMENT_DELIVERY', 'BATTERY', 'COD', 'DANGEROUS_GOODS', 'DRY_ICE', 'NON_STANDARD_CONTAINER', 'PRIORITY_ALERT', 'SIGNATURE_OPTION']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PackageSpecialServiceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SpecialServiceTypes or
            self.CodDetail is not None or
            self.DangerousGoodsDetail is not None or
            self.BatteryDetails or
            self.DryIceWeight is not None or
            self.SignatureOptionDetail is not None or
            self.PriorityAlertDetail is not None or
            self.AlcoholDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PackageSpecialServicesRequested', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PackageSpecialServicesRequested')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageSpecialServicesRequested')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PackageSpecialServicesRequested', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PackageSpecialServicesRequested'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PackageSpecialServicesRequested', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SpecialServiceTypes_ in self.SpecialServiceTypes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SpecialServiceTypes>%s</ns:SpecialServiceTypes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(SpecialServiceTypes_), input_name='SpecialServiceTypes')), eol_))
        if self.CodDetail is not None:
            self.CodDetail.export(outfile, level, namespace_, name_='CodDetail', pretty_print=pretty_print)
        if self.DangerousGoodsDetail is not None:
            self.DangerousGoodsDetail.export(outfile, level, namespace_, name_='DangerousGoodsDetail', pretty_print=pretty_print)
        for BatteryDetails_ in self.BatteryDetails:
            BatteryDetails_.export(outfile, level, namespace_, name_='BatteryDetails', pretty_print=pretty_print)
        if self.DryIceWeight is not None:
            self.DryIceWeight.export(outfile, level, namespace_, name_='DryIceWeight', pretty_print=pretty_print)
        if self.SignatureOptionDetail is not None:
            self.SignatureOptionDetail.export(outfile, level, namespace_, name_='SignatureOptionDetail', pretty_print=pretty_print)
        if self.PriorityAlertDetail is not None:
            self.PriorityAlertDetail.export(outfile, level, namespace_, name_='PriorityAlertDetail', pretty_print=pretty_print)
        if self.AlcoholDetail is not None:
            self.AlcoholDetail.export(outfile, level, namespace_, name_='AlcoholDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialServiceTypes':
            SpecialServiceTypes_ = child_.text
            SpecialServiceTypes_ = self.gds_validate_string(SpecialServiceTypes_, node, 'SpecialServiceTypes')
            self.SpecialServiceTypes.append(SpecialServiceTypes_)
            # validate type PackageSpecialServiceType
            self.validate_PackageSpecialServiceType(self.SpecialServiceTypes[-1])
        elif nodeName_ == 'CodDetail':
            obj_ = CodDetail.factory()
            obj_.build(child_)
            self.CodDetail = obj_
            obj_.original_tagname_ = 'CodDetail'
        elif nodeName_ == 'DangerousGoodsDetail':
            obj_ = DangerousGoodsDetail.factory()
            obj_.build(child_)
            self.DangerousGoodsDetail = obj_
            obj_.original_tagname_ = 'DangerousGoodsDetail'
        elif nodeName_ == 'BatteryDetails':
            obj_ = BatteryClassificationDetail.factory()
            obj_.build(child_)
            self.BatteryDetails.append(obj_)
            obj_.original_tagname_ = 'BatteryDetails'
        elif nodeName_ == 'DryIceWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.DryIceWeight = obj_
            obj_.original_tagname_ = 'DryIceWeight'
        elif nodeName_ == 'SignatureOptionDetail':
            obj_ = SignatureOptionDetail.factory()
            obj_.build(child_)
            self.SignatureOptionDetail = obj_
            obj_.original_tagname_ = 'SignatureOptionDetail'
        elif nodeName_ == 'PriorityAlertDetail':
            obj_ = PriorityAlertDetail.factory()
            obj_.build(child_)
            self.PriorityAlertDetail = obj_
            obj_.original_tagname_ = 'PriorityAlertDetail'
        elif nodeName_ == 'AlcoholDetail':
            obj_ = AlcoholDetail.factory()
            obj_.build(child_)
            self.AlcoholDetail = obj_
            obj_.original_tagname_ = 'AlcoholDetail'
# end class PackageSpecialServicesRequested


class Party(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AccountNumber=None, Tins=None, Contact=None, Address=None):
        self.original_tagname_ = None
        self.AccountNumber = AccountNumber
        if Tins is None:
            self.Tins = []
        else:
            self.Tins = Tins
        self.Contact = Contact
        self.Address = Address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party.subclass:
            return Party.subclass(*args_, **kwargs_)
        else:
            return Party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccountNumber(self): return self.AccountNumber
    def set_AccountNumber(self, AccountNumber): self.AccountNumber = AccountNumber
    def get_Tins(self): return self.Tins
    def set_Tins(self, Tins): self.Tins = Tins
    def add_Tins(self, value): self.Tins.append(value)
    def insert_Tins_at(self, index, value): self.Tins.insert(index, value)
    def replace_Tins_at(self, index, value): self.Tins[index] = value
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def hasContent_(self):
        if (
            self.AccountNumber is not None or
            self.Tins or
            self.Contact is not None or
            self.Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Party', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Party')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Party', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Party'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Party', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AccountNumber>%s</ns:AccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AccountNumber), input_name='AccountNumber')), eol_))
        for Tins_ in self.Tins:
            Tins_.export(outfile, level, namespace_, name_='Tins', pretty_print=pretty_print)
        if self.Contact is not None:
            self.Contact.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccountNumber':
            AccountNumber_ = child_.text
            AccountNumber_ = self.gds_validate_string(AccountNumber_, node, 'AccountNumber')
            self.AccountNumber = AccountNumber_
        elif nodeName_ == 'Tins':
            obj_ = TaxpayerIdentification.factory()
            obj_.build(child_)
            self.Tins.append(obj_)
            obj_.original_tagname_ = 'Tins'
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.Contact = obj_
            obj_.original_tagname_ = 'Contact'
        elif nodeName_ == 'Address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
# end class Party


class Payment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PaymentType=None, Payor=None):
        self.original_tagname_ = None
        self.PaymentType = PaymentType
        self.validate_PaymentType(self.PaymentType)
        self.Payor = Payor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Payment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Payment.subclass:
            return Payment.subclass(*args_, **kwargs_)
        else:
            return Payment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PaymentType(self): return self.PaymentType
    def set_PaymentType(self, PaymentType): self.PaymentType = PaymentType
    def get_Payor(self): return self.Payor
    def set_Payor(self, Payor): self.Payor = Payor
    def validate_PaymentType(self, value):
        # Validate type PaymentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACCOUNT', 'COLLECT', 'RECIPIENT', 'SENDER', 'THIRD_PARTY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PaymentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PaymentType is not None or
            self.Payor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Payment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Payment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Payment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Payment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Payment'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Payment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PaymentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PaymentType>%s</ns:PaymentType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PaymentType), input_name='PaymentType')), eol_))
        if self.Payor is not None:
            self.Payor.export(outfile, level, namespace_, name_='Payor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PaymentType':
            PaymentType_ = child_.text
            PaymentType_ = self.gds_validate_string(PaymentType_, node, 'PaymentType')
            self.PaymentType = PaymentType_
            # validate type PaymentType
            self.validate_PaymentType(self.PaymentType)
        elif nodeName_ == 'Payor':
            obj_ = Payor.factory()
            obj_.build(child_)
            self.Payor = obj_
            obj_.original_tagname_ = 'Payor'
# end class Payment


class Payor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ResponsibleParty=None):
        self.original_tagname_ = None
        self.ResponsibleParty = ResponsibleParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Payor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Payor.subclass:
            return Payor.subclass(*args_, **kwargs_)
        else:
            return Payor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResponsibleParty(self): return self.ResponsibleParty
    def set_ResponsibleParty(self, ResponsibleParty): self.ResponsibleParty = ResponsibleParty
    def hasContent_(self):
        if (
            self.ResponsibleParty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Payor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Payor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Payor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Payor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Payor'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Payor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ResponsibleParty is not None:
            self.ResponsibleParty.export(outfile, level, namespace_, name_='ResponsibleParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResponsibleParty':
            obj_ = Party.factory()
            obj_.build(child_)
            self.ResponsibleParty = obj_
            obj_.original_tagname_ = 'ResponsibleParty'
# end class Payor


class PendingShipmentAccessDetail(GeneratedsSuper):
    """This information describes how and when a pending shipment may be
    accessed for completion."""
    subclass = None
    superclass = None
    def __init__(self, AccessorDetails=None):
        self.original_tagname_ = None
        if AccessorDetails is None:
            self.AccessorDetails = []
        else:
            self.AccessorDetails = AccessorDetails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PendingShipmentAccessDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PendingShipmentAccessDetail.subclass:
            return PendingShipmentAccessDetail.subclass(*args_, **kwargs_)
        else:
            return PendingShipmentAccessDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccessorDetails(self): return self.AccessorDetails
    def set_AccessorDetails(self, AccessorDetails): self.AccessorDetails = AccessorDetails
    def add_AccessorDetails(self, value): self.AccessorDetails.append(value)
    def insert_AccessorDetails_at(self, index, value): self.AccessorDetails.insert(index, value)
    def replace_AccessorDetails_at(self, index, value): self.AccessorDetails[index] = value
    def hasContent_(self):
        if (
            self.AccessorDetails
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PendingShipmentAccessDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PendingShipmentAccessDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PendingShipmentAccessDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PendingShipmentAccessDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PendingShipmentAccessDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PendingShipmentAccessDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AccessorDetails_ in self.AccessorDetails:
            AccessorDetails_.export(outfile, level, namespace_, name_='AccessorDetails', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccessorDetails':
            obj_ = PendingShipmentAccessorDetail.factory()
            obj_.build(child_)
            self.AccessorDetails.append(obj_)
            obj_.original_tagname_ = 'AccessorDetails'
# end class PendingShipmentAccessDetail


class PendingShipmentAccessorDetail(GeneratedsSuper):
    """Specifies the details to be used by the user of the pending shipment"""
    subclass = None
    superclass = None
    def __init__(self, Role=None, UserId=None, Password=None, EmailLabelUrl=None):
        self.original_tagname_ = None
        self.Role = Role
        self.validate_AccessorRoleType(self.Role)
        self.UserId = UserId
        self.Password = Password
        self.EmailLabelUrl = EmailLabelUrl
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PendingShipmentAccessorDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PendingShipmentAccessorDetail.subclass:
            return PendingShipmentAccessorDetail.subclass(*args_, **kwargs_)
        else:
            return PendingShipmentAccessorDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def get_UserId(self): return self.UserId
    def set_UserId(self, UserId): self.UserId = UserId
    def get_Password(self): return self.Password
    def set_Password(self, Password): self.Password = Password
    def get_EmailLabelUrl(self): return self.EmailLabelUrl
    def set_EmailLabelUrl(self, EmailLabelUrl): self.EmailLabelUrl = EmailLabelUrl
    def validate_AccessorRoleType(self, value):
        # Validate type AccessorRoleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SHIPMENT_COMPLETOR', 'SHIPMENT_INITIATOR']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AccessorRoleType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Role is not None or
            self.UserId is not None or
            self.Password is not None or
            self.EmailLabelUrl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PendingShipmentAccessorDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PendingShipmentAccessorDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PendingShipmentAccessorDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PendingShipmentAccessorDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PendingShipmentAccessorDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PendingShipmentAccessorDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Role is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Role>%s</ns:Role>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Role), input_name='Role')), eol_))
        if self.UserId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:UserId>%s</ns:UserId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UserId), input_name='UserId')), eol_))
        if self.Password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Password>%s</ns:Password>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Password), input_name='Password')), eol_))
        if self.EmailLabelUrl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EmailLabelUrl>%s</ns:EmailLabelUrl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EmailLabelUrl), input_name='EmailLabelUrl')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Role':
            Role_ = child_.text
            Role_ = self.gds_validate_string(Role_, node, 'Role')
            self.Role = Role_
            # validate type AccessorRoleType
            self.validate_AccessorRoleType(self.Role)
        elif nodeName_ == 'UserId':
            UserId_ = child_.text
            UserId_ = self.gds_validate_string(UserId_, node, 'UserId')
            self.UserId = UserId_
        elif nodeName_ == 'Password':
            Password_ = child_.text
            Password_ = self.gds_validate_string(Password_, node, 'Password')
            self.Password = Password_
        elif nodeName_ == 'EmailLabelUrl':
            EmailLabelUrl_ = child_.text
            EmailLabelUrl_ = self.gds_validate_string(EmailLabelUrl_, node, 'EmailLabelUrl')
            self.EmailLabelUrl = EmailLabelUrl_
# end class PendingShipmentAccessorDetail


class PendingShipmentDetail(GeneratedsSuper):
    """This information describes the kind of pending shipment being
    requested."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, ExpirationDate=None, EmailLabelDetail=None, ProcessingOptions=None, RecommendedDocumentSpecification=None, DocumentReferences=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_PendingShipmentType(self.Type)
        if isinstance(ExpirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ExpirationDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ExpirationDate
        self.ExpirationDate = initvalue_
        self.EmailLabelDetail = EmailLabelDetail
        self.ProcessingOptions = ProcessingOptions
        self.RecommendedDocumentSpecification = RecommendedDocumentSpecification
        if DocumentReferences is None:
            self.DocumentReferences = []
        else:
            self.DocumentReferences = DocumentReferences
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PendingShipmentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PendingShipmentDetail.subclass:
            return PendingShipmentDetail.subclass(*args_, **kwargs_)
        else:
            return PendingShipmentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ExpirationDate(self): return self.ExpirationDate
    def set_ExpirationDate(self, ExpirationDate): self.ExpirationDate = ExpirationDate
    def get_EmailLabelDetail(self): return self.EmailLabelDetail
    def set_EmailLabelDetail(self, EmailLabelDetail): self.EmailLabelDetail = EmailLabelDetail
    def get_ProcessingOptions(self): return self.ProcessingOptions
    def set_ProcessingOptions(self, ProcessingOptions): self.ProcessingOptions = ProcessingOptions
    def get_RecommendedDocumentSpecification(self): return self.RecommendedDocumentSpecification
    def set_RecommendedDocumentSpecification(self, RecommendedDocumentSpecification): self.RecommendedDocumentSpecification = RecommendedDocumentSpecification
    def get_DocumentReferences(self): return self.DocumentReferences
    def set_DocumentReferences(self, DocumentReferences): self.DocumentReferences = DocumentReferences
    def add_DocumentReferences(self, value): self.DocumentReferences.append(value)
    def insert_DocumentReferences_at(self, index, value): self.DocumentReferences.insert(index, value)
    def replace_DocumentReferences_at(self, index, value): self.DocumentReferences[index] = value
    def validate_PendingShipmentType(self, value):
        # Validate type PendingShipmentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EMAIL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PendingShipmentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.ExpirationDate is not None or
            self.EmailLabelDetail is not None or
            self.ProcessingOptions is not None or
            self.RecommendedDocumentSpecification is not None or
            self.DocumentReferences
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PendingShipmentDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PendingShipmentDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PendingShipmentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PendingShipmentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PendingShipmentDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PendingShipmentDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.ExpirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ExpirationDate>%s</ns:ExpirationDate>%s' % (self.gds_format_date(self.ExpirationDate, input_name='ExpirationDate'), eol_))
        if self.EmailLabelDetail is not None:
            self.EmailLabelDetail.export(outfile, level, namespace_, name_='EmailLabelDetail', pretty_print=pretty_print)
        if self.ProcessingOptions is not None:
            self.ProcessingOptions.export(outfile, level, namespace_, name_='ProcessingOptions', pretty_print=pretty_print)
        if self.RecommendedDocumentSpecification is not None:
            self.RecommendedDocumentSpecification.export(outfile, level, namespace_, name_='RecommendedDocumentSpecification', pretty_print=pretty_print)
        for DocumentReferences_ in self.DocumentReferences:
            DocumentReferences_.export(outfile, level, namespace_, name_='DocumentReferences', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type PendingShipmentType
            self.validate_PendingShipmentType(self.Type)
        elif nodeName_ == 'ExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ExpirationDate = dval_
        elif nodeName_ == 'EmailLabelDetail':
            obj_ = EMailLabelDetail.factory()
            obj_.build(child_)
            self.EmailLabelDetail = obj_
            obj_.original_tagname_ = 'EmailLabelDetail'
        elif nodeName_ == 'ProcessingOptions':
            obj_ = PendingShipmentProcessingOptionsRequested.factory()
            obj_.build(child_)
            self.ProcessingOptions = obj_
            obj_.original_tagname_ = 'ProcessingOptions'
        elif nodeName_ == 'RecommendedDocumentSpecification':
            obj_ = RecommendedDocumentSpecification.factory()
            obj_.build(child_)
            self.RecommendedDocumentSpecification = obj_
            obj_.original_tagname_ = 'RecommendedDocumentSpecification'
        elif nodeName_ == 'DocumentReferences':
            obj_ = UploadDocumentReferenceDetail.factory()
            obj_.build(child_)
            self.DocumentReferences.append(obj_)
            obj_.original_tagname_ = 'DocumentReferences'
# end class PendingShipmentDetail


class PendingShipmentProcessingOptionsRequested(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Options=None):
        self.original_tagname_ = None
        if Options is None:
            self.Options = []
        else:
            self.Options = Options
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PendingShipmentProcessingOptionsRequested)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PendingShipmentProcessingOptionsRequested.subclass:
            return PendingShipmentProcessingOptionsRequested.subclass(*args_, **kwargs_)
        else:
            return PendingShipmentProcessingOptionsRequested(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Options(self): return self.Options
    def set_Options(self, Options): self.Options = Options
    def add_Options(self, value): self.Options.append(value)
    def insert_Options_at(self, index, value): self.Options.insert(index, value)
    def replace_Options_at(self, index, value): self.Options[index] = value
    def validate_PendingShipmentProcessingOptionType(self, value):
        # Validate type PendingShipmentProcessingOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ALLOW_MODIFICATIONS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PendingShipmentProcessingOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Options
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PendingShipmentProcessingOptionsRequested', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PendingShipmentProcessingOptionsRequested')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PendingShipmentProcessingOptionsRequested')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PendingShipmentProcessingOptionsRequested', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PendingShipmentProcessingOptionsRequested'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PendingShipmentProcessingOptionsRequested', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Options_ in self.Options:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Options>%s</ns:Options>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Options_), input_name='Options')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Options':
            Options_ = child_.text
            Options_ = self.gds_validate_string(Options_, node, 'Options')
            self.Options.append(Options_)
            # validate type PendingShipmentProcessingOptionType
            self.validate_PendingShipmentProcessingOptionType(self.Options[-1])
# end class PendingShipmentProcessingOptionsRequested


class PickupDetail(GeneratedsSuper):
    """This class describes the pickup characteristics of a shipment (e.g.
    for use in a tag request)."""
    subclass = None
    superclass = None
    def __init__(self, ReadyDateTime=None, LatestPickupDateTime=None, CourierInstructions=None, RequestType=None, RequestSource=None):
        self.original_tagname_ = None
        if isinstance(ReadyDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ReadyDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ReadyDateTime
        self.ReadyDateTime = initvalue_
        if isinstance(LatestPickupDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(LatestPickupDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = LatestPickupDateTime
        self.LatestPickupDateTime = initvalue_
        self.CourierInstructions = CourierInstructions
        self.RequestType = RequestType
        self.validate_PickupRequestType(self.RequestType)
        self.RequestSource = RequestSource
        self.validate_PickupRequestSourceType(self.RequestSource)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupDetail.subclass:
            return PickupDetail.subclass(*args_, **kwargs_)
        else:
            return PickupDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReadyDateTime(self): return self.ReadyDateTime
    def set_ReadyDateTime(self, ReadyDateTime): self.ReadyDateTime = ReadyDateTime
    def get_LatestPickupDateTime(self): return self.LatestPickupDateTime
    def set_LatestPickupDateTime(self, LatestPickupDateTime): self.LatestPickupDateTime = LatestPickupDateTime
    def get_CourierInstructions(self): return self.CourierInstructions
    def set_CourierInstructions(self, CourierInstructions): self.CourierInstructions = CourierInstructions
    def get_RequestType(self): return self.RequestType
    def set_RequestType(self, RequestType): self.RequestType = RequestType
    def get_RequestSource(self): return self.RequestSource
    def set_RequestSource(self, RequestSource): self.RequestSource = RequestSource
    def validate_PickupRequestType(self, value):
        # Validate type PickupRequestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FUTURE_DAY', 'SAME_DAY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PickupRequestType' % {"value" : value.encode("utf-8")} )
    def validate_PickupRequestSourceType(self, value):
        # Validate type PickupRequestSourceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AUTOMATION', 'CUSTOMER_SERVICE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PickupRequestSourceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ReadyDateTime is not None or
            self.LatestPickupDateTime is not None or
            self.CourierInstructions is not None or
            self.RequestType is not None or
            self.RequestSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PickupDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PickupDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PickupDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PickupDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReadyDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ReadyDateTime>%s</ns:ReadyDateTime>%s' % (self.gds_format_datetime(self.ReadyDateTime, input_name='ReadyDateTime'), eol_))
        if self.LatestPickupDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LatestPickupDateTime>%s</ns:LatestPickupDateTime>%s' % (self.gds_format_datetime(self.LatestPickupDateTime, input_name='LatestPickupDateTime'), eol_))
        if self.CourierInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CourierInstructions>%s</ns:CourierInstructions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CourierInstructions), input_name='CourierInstructions')), eol_))
        if self.RequestType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RequestType>%s</ns:RequestType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RequestType), input_name='RequestType')), eol_))
        if self.RequestSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RequestSource>%s</ns:RequestSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RequestSource), input_name='RequestSource')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReadyDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ReadyDateTime = dval_
        elif nodeName_ == 'LatestPickupDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.LatestPickupDateTime = dval_
        elif nodeName_ == 'CourierInstructions':
            CourierInstructions_ = child_.text
            CourierInstructions_ = self.gds_validate_string(CourierInstructions_, node, 'CourierInstructions')
            self.CourierInstructions = CourierInstructions_
        elif nodeName_ == 'RequestType':
            RequestType_ = child_.text
            RequestType_ = self.gds_validate_string(RequestType_, node, 'RequestType')
            self.RequestType = RequestType_
            # validate type PickupRequestType
            self.validate_PickupRequestType(self.RequestType)
        elif nodeName_ == 'RequestSource':
            RequestSource_ = child_.text
            RequestSource_ = self.gds_validate_string(RequestSource_, node, 'RequestSource')
            self.RequestSource = RequestSource_
            # validate type PickupRequestSourceType
            self.validate_PickupRequestSourceType(self.RequestSource)
# end class PickupDetail


class PrintedReference(GeneratedsSuper):
    """Represents a reference identifier printed on Freight bills of lading"""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_PrintedReferenceType(self.Type)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrintedReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrintedReference.subclass:
            return PrintedReference.subclass(*args_, **kwargs_)
        else:
            return PrintedReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_PrintedReferenceType(self, value):
        # Validate type PrintedReferenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BILL_OF_LADING', 'CONSIGNEE_ID_NUMBER', 'SHIPPER_ID_NUMBER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PrintedReferenceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PrintedReference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrintedReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrintedReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PrintedReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PrintedReference'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PrintedReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type PrintedReferenceType
            self.validate_PrintedReferenceType(self.Type)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class PrintedReference


class PriorityAlertDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EnhancementTypes=None, Content=None):
        self.original_tagname_ = None
        if EnhancementTypes is None:
            self.EnhancementTypes = []
        else:
            self.EnhancementTypes = EnhancementTypes
        if Content is None:
            self.Content = []
        else:
            self.Content = Content
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PriorityAlertDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PriorityAlertDetail.subclass:
            return PriorityAlertDetail.subclass(*args_, **kwargs_)
        else:
            return PriorityAlertDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EnhancementTypes(self): return self.EnhancementTypes
    def set_EnhancementTypes(self, EnhancementTypes): self.EnhancementTypes = EnhancementTypes
    def add_EnhancementTypes(self, value): self.EnhancementTypes.append(value)
    def insert_EnhancementTypes_at(self, index, value): self.EnhancementTypes.insert(index, value)
    def replace_EnhancementTypes_at(self, index, value): self.EnhancementTypes[index] = value
    def get_Content(self): return self.Content
    def set_Content(self, Content): self.Content = Content
    def add_Content(self, value): self.Content.append(value)
    def insert_Content_at(self, index, value): self.Content.insert(index, value)
    def replace_Content_at(self, index, value): self.Content[index] = value
    def validate_PriorityAlertEnhancementType(self, value):
        # Validate type PriorityAlertEnhancementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PRIORITY_ALERT_PLUS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PriorityAlertEnhancementType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EnhancementTypes or
            self.Content
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='PriorityAlertDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PriorityAlertDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriorityAlertDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='PriorityAlertDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='PriorityAlertDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='PriorityAlertDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EnhancementTypes_ in self.EnhancementTypes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EnhancementTypes>%s</ns:EnhancementTypes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(EnhancementTypes_), input_name='EnhancementTypes')), eol_))
        for Content_ in self.Content:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Content>%s</ns:Content>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Content_), input_name='Content')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnhancementTypes':
            EnhancementTypes_ = child_.text
            EnhancementTypes_ = self.gds_validate_string(EnhancementTypes_, node, 'EnhancementTypes')
            self.EnhancementTypes.append(EnhancementTypes_)
            # validate type PriorityAlertEnhancementType
            self.validate_PriorityAlertEnhancementType(self.EnhancementTypes[-1])
        elif nodeName_ == 'Content':
            Content_ = child_.text
            Content_ = self.gds_validate_string(Content_, node, 'Content')
            self.Content.append(Content_)
# end class PriorityAlertDetail


class ProcessShipmentReply(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HighestSeverity=None, Notifications=None, TransactionDetail=None, Version=None, JobId=None, CompletedShipmentDetail=None, ErrorLabels=None):
        self.original_tagname_ = None
        self.HighestSeverity = HighestSeverity
        self.validate_NotificationSeverityType(self.HighestSeverity)
        if Notifications is None:
            self.Notifications = []
        else:
            self.Notifications = Notifications
        self.TransactionDetail = TransactionDetail
        self.Version = Version
        self.JobId = JobId
        self.CompletedShipmentDetail = CompletedShipmentDetail
        if ErrorLabels is None:
            self.ErrorLabels = []
        else:
            self.ErrorLabels = ErrorLabels
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessShipmentReply)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessShipmentReply.subclass:
            return ProcessShipmentReply.subclass(*args_, **kwargs_)
        else:
            return ProcessShipmentReply(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HighestSeverity(self): return self.HighestSeverity
    def set_HighestSeverity(self, HighestSeverity): self.HighestSeverity = HighestSeverity
    def get_Notifications(self): return self.Notifications
    def set_Notifications(self, Notifications): self.Notifications = Notifications
    def add_Notifications(self, value): self.Notifications.append(value)
    def insert_Notifications_at(self, index, value): self.Notifications.insert(index, value)
    def replace_Notifications_at(self, index, value): self.Notifications[index] = value
    def get_TransactionDetail(self): return self.TransactionDetail
    def set_TransactionDetail(self, TransactionDetail): self.TransactionDetail = TransactionDetail
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_JobId(self): return self.JobId
    def set_JobId(self, JobId): self.JobId = JobId
    def get_CompletedShipmentDetail(self): return self.CompletedShipmentDetail
    def set_CompletedShipmentDetail(self, CompletedShipmentDetail): self.CompletedShipmentDetail = CompletedShipmentDetail
    def get_ErrorLabels(self): return self.ErrorLabels
    def set_ErrorLabels(self, ErrorLabels): self.ErrorLabels = ErrorLabels
    def add_ErrorLabels(self, value): self.ErrorLabels.append(value)
    def insert_ErrorLabels_at(self, index, value): self.ErrorLabels.insert(index, value)
    def replace_ErrorLabels_at(self, index, value): self.ErrorLabels[index] = value
    def validate_NotificationSeverityType(self, value):
        # Validate type NotificationSeverityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ERROR', 'FAILURE', 'NOTE', 'SUCCESS', 'WARNING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NotificationSeverityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.HighestSeverity is not None or
            self.Notifications or
            self.TransactionDetail is not None or
            self.Version is not None or
            self.JobId is not None or
            self.CompletedShipmentDetail is not None or
            self.ErrorLabels
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ProcessShipmentReply', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcessShipmentReply')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessShipmentReply')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ProcessShipmentReply', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ProcessShipmentReply'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ProcessShipmentReply', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HighestSeverity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HighestSeverity>%s</ns:HighestSeverity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HighestSeverity), input_name='HighestSeverity')), eol_))
        for Notifications_ in self.Notifications:
            Notifications_.export(outfile, level, namespace_, name_='Notifications', pretty_print=pretty_print)
        if self.TransactionDetail is not None:
            self.TransactionDetail.export(outfile, level, namespace_, name_='TransactionDetail', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.JobId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:JobId>%s</ns:JobId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.JobId), input_name='JobId')), eol_))
        if self.CompletedShipmentDetail is not None:
            self.CompletedShipmentDetail.export(outfile, level, namespace_, name_='CompletedShipmentDetail', pretty_print=pretty_print)
        for ErrorLabels_ in self.ErrorLabels:
            ErrorLabels_.export(outfile, level, namespace_, name_='ErrorLabels', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HighestSeverity':
            HighestSeverity_ = child_.text
            HighestSeverity_ = self.gds_validate_string(HighestSeverity_, node, 'HighestSeverity')
            self.HighestSeverity = HighestSeverity_
            # validate type NotificationSeverityType
            self.validate_NotificationSeverityType(self.HighestSeverity)
        elif nodeName_ == 'Notifications':
            obj_ = Notification.factory()
            obj_.build(child_)
            self.Notifications.append(obj_)
            obj_.original_tagname_ = 'Notifications'
        elif nodeName_ == 'TransactionDetail':
            obj_ = TransactionDetail.factory()
            obj_.build(child_)
            self.TransactionDetail = obj_
            obj_.original_tagname_ = 'TransactionDetail'
        elif nodeName_ == 'Version':
            obj_ = VersionId.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'JobId':
            JobId_ = child_.text
            JobId_ = self.gds_validate_string(JobId_, node, 'JobId')
            self.JobId = JobId_
        elif nodeName_ == 'CompletedShipmentDetail':
            obj_ = CompletedShipmentDetail.factory()
            obj_.build(child_)
            self.CompletedShipmentDetail = obj_
            obj_.original_tagname_ = 'CompletedShipmentDetail'
        elif nodeName_ == 'ErrorLabels':
            obj_ = ShippingDocument.factory()
            obj_.build(child_)
            self.ErrorLabels.append(obj_)
            obj_.original_tagname_ = 'ErrorLabels'
# end class ProcessShipmentReply


class ProcessShipmentRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAuthenticationDetail=None, ClientDetail=None, TransactionDetail=None, Version=None, RequestedShipment=None):
        self.original_tagname_ = None
        self.WebAuthenticationDetail = WebAuthenticationDetail
        self.ClientDetail = ClientDetail
        self.TransactionDetail = TransactionDetail
        self.Version = Version
        self.RequestedShipment = RequestedShipment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessShipmentRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessShipmentRequest.subclass:
            return ProcessShipmentRequest.subclass(*args_, **kwargs_)
        else:
            return ProcessShipmentRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAuthenticationDetail(self): return self.WebAuthenticationDetail
    def set_WebAuthenticationDetail(self, WebAuthenticationDetail): self.WebAuthenticationDetail = WebAuthenticationDetail
    def get_ClientDetail(self): return self.ClientDetail
    def set_ClientDetail(self, ClientDetail): self.ClientDetail = ClientDetail
    def get_TransactionDetail(self): return self.TransactionDetail
    def set_TransactionDetail(self, TransactionDetail): self.TransactionDetail = TransactionDetail
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_RequestedShipment(self): return self.RequestedShipment
    def set_RequestedShipment(self, RequestedShipment): self.RequestedShipment = RequestedShipment
    def hasContent_(self):
        if (
            self.WebAuthenticationDetail is not None or
            self.ClientDetail is not None or
            self.TransactionDetail is not None or
            self.Version is not None or
            self.RequestedShipment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ProcessShipmentRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcessShipmentRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessShipmentRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ProcessShipmentRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ProcessShipmentRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ProcessShipmentRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WebAuthenticationDetail is not None:
            self.WebAuthenticationDetail.export(outfile, level, namespace_, name_='WebAuthenticationDetail', pretty_print=pretty_print)
        if self.ClientDetail is not None:
            self.ClientDetail.export(outfile, level, namespace_, name_='ClientDetail', pretty_print=pretty_print)
        if self.TransactionDetail is not None:
            self.TransactionDetail.export(outfile, level, namespace_, name_='TransactionDetail', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.RequestedShipment is not None:
            self.RequestedShipment.export(outfile, level, namespace_, name_='RequestedShipment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAuthenticationDetail':
            obj_ = WebAuthenticationDetail.factory()
            obj_.build(child_)
            self.WebAuthenticationDetail = obj_
            obj_.original_tagname_ = 'WebAuthenticationDetail'
        elif nodeName_ == 'ClientDetail':
            obj_ = ClientDetail.factory()
            obj_.build(child_)
            self.ClientDetail = obj_
            obj_.original_tagname_ = 'ClientDetail'
        elif nodeName_ == 'TransactionDetail':
            obj_ = TransactionDetail.factory()
            obj_.build(child_)
            self.TransactionDetail = obj_
            obj_.original_tagname_ = 'TransactionDetail'
        elif nodeName_ == 'Version':
            obj_ = VersionId.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'RequestedShipment':
            obj_ = RequestedShipment.factory()
            obj_.build(child_)
            self.RequestedShipment = obj_
            obj_.original_tagname_ = 'RequestedShipment'
# end class ProcessShipmentRequest


class ProcessTagReply(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HighestSeverity=None, Notifications=None, TransactionDetail=None, Version=None, CompletedShipmentDetail=None):
        self.original_tagname_ = None
        self.HighestSeverity = HighestSeverity
        self.validate_NotificationSeverityType(self.HighestSeverity)
        if Notifications is None:
            self.Notifications = []
        else:
            self.Notifications = Notifications
        self.TransactionDetail = TransactionDetail
        self.Version = Version
        self.CompletedShipmentDetail = CompletedShipmentDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessTagReply)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessTagReply.subclass:
            return ProcessTagReply.subclass(*args_, **kwargs_)
        else:
            return ProcessTagReply(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HighestSeverity(self): return self.HighestSeverity
    def set_HighestSeverity(self, HighestSeverity): self.HighestSeverity = HighestSeverity
    def get_Notifications(self): return self.Notifications
    def set_Notifications(self, Notifications): self.Notifications = Notifications
    def add_Notifications(self, value): self.Notifications.append(value)
    def insert_Notifications_at(self, index, value): self.Notifications.insert(index, value)
    def replace_Notifications_at(self, index, value): self.Notifications[index] = value
    def get_TransactionDetail(self): return self.TransactionDetail
    def set_TransactionDetail(self, TransactionDetail): self.TransactionDetail = TransactionDetail
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_CompletedShipmentDetail(self): return self.CompletedShipmentDetail
    def set_CompletedShipmentDetail(self, CompletedShipmentDetail): self.CompletedShipmentDetail = CompletedShipmentDetail
    def validate_NotificationSeverityType(self, value):
        # Validate type NotificationSeverityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ERROR', 'FAILURE', 'NOTE', 'SUCCESS', 'WARNING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NotificationSeverityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.HighestSeverity is not None or
            self.Notifications or
            self.TransactionDetail is not None or
            self.Version is not None or
            self.CompletedShipmentDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ProcessTagReply', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcessTagReply')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessTagReply')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ProcessTagReply', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ProcessTagReply'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ProcessTagReply', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HighestSeverity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HighestSeverity>%s</ns:HighestSeverity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HighestSeverity), input_name='HighestSeverity')), eol_))
        for Notifications_ in self.Notifications:
            Notifications_.export(outfile, level, namespace_, name_='Notifications', pretty_print=pretty_print)
        if self.TransactionDetail is not None:
            self.TransactionDetail.export(outfile, level, namespace_, name_='TransactionDetail', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.CompletedShipmentDetail is not None:
            self.CompletedShipmentDetail.export(outfile, level, namespace_, name_='CompletedShipmentDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HighestSeverity':
            HighestSeverity_ = child_.text
            HighestSeverity_ = self.gds_validate_string(HighestSeverity_, node, 'HighestSeverity')
            self.HighestSeverity = HighestSeverity_
            # validate type NotificationSeverityType
            self.validate_NotificationSeverityType(self.HighestSeverity)
        elif nodeName_ == 'Notifications':
            obj_ = Notification.factory()
            obj_.build(child_)
            self.Notifications.append(obj_)
            obj_.original_tagname_ = 'Notifications'
        elif nodeName_ == 'TransactionDetail':
            obj_ = TransactionDetail.factory()
            obj_.build(child_)
            self.TransactionDetail = obj_
            obj_.original_tagname_ = 'TransactionDetail'
        elif nodeName_ == 'Version':
            obj_ = VersionId.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'CompletedShipmentDetail':
            obj_ = CompletedShipmentDetail.factory()
            obj_.build(child_)
            self.CompletedShipmentDetail = obj_
            obj_.original_tagname_ = 'CompletedShipmentDetail'
# end class ProcessTagReply


class ProcessTagRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAuthenticationDetail=None, ClientDetail=None, TransactionDetail=None, Version=None, RequestedShipment=None):
        self.original_tagname_ = None
        self.WebAuthenticationDetail = WebAuthenticationDetail
        self.ClientDetail = ClientDetail
        self.TransactionDetail = TransactionDetail
        self.Version = Version
        self.RequestedShipment = RequestedShipment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessTagRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessTagRequest.subclass:
            return ProcessTagRequest.subclass(*args_, **kwargs_)
        else:
            return ProcessTagRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAuthenticationDetail(self): return self.WebAuthenticationDetail
    def set_WebAuthenticationDetail(self, WebAuthenticationDetail): self.WebAuthenticationDetail = WebAuthenticationDetail
    def get_ClientDetail(self): return self.ClientDetail
    def set_ClientDetail(self, ClientDetail): self.ClientDetail = ClientDetail
    def get_TransactionDetail(self): return self.TransactionDetail
    def set_TransactionDetail(self, TransactionDetail): self.TransactionDetail = TransactionDetail
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_RequestedShipment(self): return self.RequestedShipment
    def set_RequestedShipment(self, RequestedShipment): self.RequestedShipment = RequestedShipment
    def hasContent_(self):
        if (
            self.WebAuthenticationDetail is not None or
            self.ClientDetail is not None or
            self.TransactionDetail is not None or
            self.Version is not None or
            self.RequestedShipment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ProcessTagRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcessTagRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessTagRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ProcessTagRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ProcessTagRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ProcessTagRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WebAuthenticationDetail is not None:
            self.WebAuthenticationDetail.export(outfile, level, namespace_, name_='WebAuthenticationDetail', pretty_print=pretty_print)
        if self.ClientDetail is not None:
            self.ClientDetail.export(outfile, level, namespace_, name_='ClientDetail', pretty_print=pretty_print)
        if self.TransactionDetail is not None:
            self.TransactionDetail.export(outfile, level, namespace_, name_='TransactionDetail', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.RequestedShipment is not None:
            self.RequestedShipment.export(outfile, level, namespace_, name_='RequestedShipment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAuthenticationDetail':
            obj_ = WebAuthenticationDetail.factory()
            obj_.build(child_)
            self.WebAuthenticationDetail = obj_
            obj_.original_tagname_ = 'WebAuthenticationDetail'
        elif nodeName_ == 'ClientDetail':
            obj_ = ClientDetail.factory()
            obj_.build(child_)
            self.ClientDetail = obj_
            obj_.original_tagname_ = 'ClientDetail'
        elif nodeName_ == 'TransactionDetail':
            obj_ = TransactionDetail.factory()
            obj_.build(child_)
            self.TransactionDetail = obj_
            obj_.original_tagname_ = 'TransactionDetail'
        elif nodeName_ == 'Version':
            obj_ = VersionId.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'RequestedShipment':
            obj_ = RequestedShipment.factory()
            obj_.build(child_)
            self.RequestedShipment = obj_
            obj_.original_tagname_ = 'RequestedShipment'
# end class ProcessTagRequest


class RadioactivityDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TransportIndex=None, SurfaceReading=None, CriticalitySafetyIndex=None, Dimensions=None):
        self.original_tagname_ = None
        self.TransportIndex = TransportIndex
        self.SurfaceReading = SurfaceReading
        self.CriticalitySafetyIndex = CriticalitySafetyIndex
        self.Dimensions = Dimensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadioactivityDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadioactivityDetail.subclass:
            return RadioactivityDetail.subclass(*args_, **kwargs_)
        else:
            return RadioactivityDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TransportIndex(self): return self.TransportIndex
    def set_TransportIndex(self, TransportIndex): self.TransportIndex = TransportIndex
    def get_SurfaceReading(self): return self.SurfaceReading
    def set_SurfaceReading(self, SurfaceReading): self.SurfaceReading = SurfaceReading
    def get_CriticalitySafetyIndex(self): return self.CriticalitySafetyIndex
    def set_CriticalitySafetyIndex(self, CriticalitySafetyIndex): self.CriticalitySafetyIndex = CriticalitySafetyIndex
    def get_Dimensions(self): return self.Dimensions
    def set_Dimensions(self, Dimensions): self.Dimensions = Dimensions
    def hasContent_(self):
        if (
            self.TransportIndex is not None or
            self.SurfaceReading is not None or
            self.CriticalitySafetyIndex is not None or
            self.Dimensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='RadioactivityDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadioactivityDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadioactivityDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='RadioactivityDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='RadioactivityDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='RadioactivityDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TransportIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TransportIndex>%s</ns:TransportIndex>%s' % (self.gds_format_float(self.TransportIndex, input_name='TransportIndex'), eol_))
        if self.SurfaceReading is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SurfaceReading>%s</ns:SurfaceReading>%s' % (self.gds_format_float(self.SurfaceReading, input_name='SurfaceReading'), eol_))
        if self.CriticalitySafetyIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CriticalitySafetyIndex>%s</ns:CriticalitySafetyIndex>%s' % (self.gds_format_float(self.CriticalitySafetyIndex, input_name='CriticalitySafetyIndex'), eol_))
        if self.Dimensions is not None:
            self.Dimensions.export(outfile, level, namespace_, name_='Dimensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TransportIndex':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TransportIndex')
            self.TransportIndex = fval_
        elif nodeName_ == 'SurfaceReading':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SurfaceReading')
            self.SurfaceReading = fval_
        elif nodeName_ == 'CriticalitySafetyIndex':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CriticalitySafetyIndex')
            self.CriticalitySafetyIndex = fval_
        elif nodeName_ == 'Dimensions':
            obj_ = Dimensions.factory()
            obj_.build(child_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'Dimensions'
# end class RadioactivityDetail


class RadionuclideActivity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Value=None, UnitOfMeasure=None):
        self.original_tagname_ = None
        self.Value = Value
        self.UnitOfMeasure = UnitOfMeasure
        self.validate_RadioactivityUnitOfMeasure(self.UnitOfMeasure)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadionuclideActivity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadionuclideActivity.subclass:
            return RadionuclideActivity.subclass(*args_, **kwargs_)
        else:
            return RadionuclideActivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_UnitOfMeasure(self): return self.UnitOfMeasure
    def set_UnitOfMeasure(self, UnitOfMeasure): self.UnitOfMeasure = UnitOfMeasure
    def validate_RadioactivityUnitOfMeasure(self, value):
        # Validate type RadioactivityUnitOfMeasure, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BQ', 'GBQ', 'KBQ', 'MBQ', 'PBQ', 'TBQ']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RadioactivityUnitOfMeasure' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Value is not None or
            self.UnitOfMeasure is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='RadionuclideActivity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadionuclideActivity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadionuclideActivity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='RadionuclideActivity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='RadionuclideActivity'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='RadionuclideActivity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_format_float(self.Value, input_name='Value'), eol_))
        if self.UnitOfMeasure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:UnitOfMeasure>%s</ns:UnitOfMeasure>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UnitOfMeasure), input_name='UnitOfMeasure')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
        elif nodeName_ == 'UnitOfMeasure':
            UnitOfMeasure_ = child_.text
            UnitOfMeasure_ = self.gds_validate_string(UnitOfMeasure_, node, 'UnitOfMeasure')
            self.UnitOfMeasure = UnitOfMeasure_
            # validate type RadioactivityUnitOfMeasure
            self.validate_RadioactivityUnitOfMeasure(self.UnitOfMeasure)
# end class RadionuclideActivity


class RadionuclideDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Radionuclide=None, Activity=None, ExceptedPackagingIsReportableQuantity=None, PhysicalForm=None, ChemicalForm=None):
        self.original_tagname_ = None
        self.Radionuclide = Radionuclide
        self.Activity = Activity
        self.ExceptedPackagingIsReportableQuantity = ExceptedPackagingIsReportableQuantity
        self.PhysicalForm = PhysicalForm
        self.validate_PhysicalFormType(self.PhysicalForm)
        self.ChemicalForm = ChemicalForm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadionuclideDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadionuclideDetail.subclass:
            return RadionuclideDetail.subclass(*args_, **kwargs_)
        else:
            return RadionuclideDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Radionuclide(self): return self.Radionuclide
    def set_Radionuclide(self, Radionuclide): self.Radionuclide = Radionuclide
    def get_Activity(self): return self.Activity
    def set_Activity(self, Activity): self.Activity = Activity
    def get_ExceptedPackagingIsReportableQuantity(self): return self.ExceptedPackagingIsReportableQuantity
    def set_ExceptedPackagingIsReportableQuantity(self, ExceptedPackagingIsReportableQuantity): self.ExceptedPackagingIsReportableQuantity = ExceptedPackagingIsReportableQuantity
    def get_PhysicalForm(self): return self.PhysicalForm
    def set_PhysicalForm(self, PhysicalForm): self.PhysicalForm = PhysicalForm
    def get_ChemicalForm(self): return self.ChemicalForm
    def set_ChemicalForm(self, ChemicalForm): self.ChemicalForm = ChemicalForm
    def validate_PhysicalFormType(self, value):
        # Validate type PhysicalFormType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['GAS', 'LIQUID', 'SOLID', 'SPECIAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PhysicalFormType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Radionuclide is not None or
            self.Activity is not None or
            self.ExceptedPackagingIsReportableQuantity is not None or
            self.PhysicalForm is not None or
            self.ChemicalForm is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='RadionuclideDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadionuclideDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadionuclideDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='RadionuclideDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='RadionuclideDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='RadionuclideDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Radionuclide is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Radionuclide>%s</ns:Radionuclide>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Radionuclide), input_name='Radionuclide')), eol_))
        if self.Activity is not None:
            self.Activity.export(outfile, level, namespace_, name_='Activity', pretty_print=pretty_print)
        if self.ExceptedPackagingIsReportableQuantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ExceptedPackagingIsReportableQuantity>%s</ns:ExceptedPackagingIsReportableQuantity>%s' % (self.gds_format_boolean(self.ExceptedPackagingIsReportableQuantity, input_name='ExceptedPackagingIsReportableQuantity'), eol_))
        if self.PhysicalForm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PhysicalForm>%s</ns:PhysicalForm>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PhysicalForm), input_name='PhysicalForm')), eol_))
        if self.ChemicalForm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ChemicalForm>%s</ns:ChemicalForm>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChemicalForm), input_name='ChemicalForm')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Radionuclide':
            Radionuclide_ = child_.text
            Radionuclide_ = self.gds_validate_string(Radionuclide_, node, 'Radionuclide')
            self.Radionuclide = Radionuclide_
        elif nodeName_ == 'Activity':
            obj_ = RadionuclideActivity.factory()
            obj_.build(child_)
            self.Activity = obj_
            obj_.original_tagname_ = 'Activity'
        elif nodeName_ == 'ExceptedPackagingIsReportableQuantity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ExceptedPackagingIsReportableQuantity')
            self.ExceptedPackagingIsReportableQuantity = ival_
        elif nodeName_ == 'PhysicalForm':
            PhysicalForm_ = child_.text
            PhysicalForm_ = self.gds_validate_string(PhysicalForm_, node, 'PhysicalForm')
            self.PhysicalForm = PhysicalForm_
            # validate type PhysicalFormType
            self.validate_PhysicalFormType(self.PhysicalForm)
        elif nodeName_ == 'ChemicalForm':
            ChemicalForm_ = child_.text
            ChemicalForm_ = self.gds_validate_string(ChemicalForm_, node, 'ChemicalForm')
            self.ChemicalForm = ChemicalForm_
# end class RadionuclideDetail


class RateDiscount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RateDiscountType=None, Description=None, Amount=None, Percent=None):
        self.original_tagname_ = None
        self.RateDiscountType = RateDiscountType
        self.validate_RateDiscountType(self.RateDiscountType)
        self.Description = Description
        self.Amount = Amount
        self.Percent = Percent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateDiscount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateDiscount.subclass:
            return RateDiscount.subclass(*args_, **kwargs_)
        else:
            return RateDiscount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RateDiscountType(self): return self.RateDiscountType
    def set_RateDiscountType(self, RateDiscountType): self.RateDiscountType = RateDiscountType
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def get_Percent(self): return self.Percent
    def set_Percent(self, Percent): self.Percent = Percent
    def validate_RateDiscountType(self, value):
        # Validate type RateDiscountType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BONUS', 'COUPON', 'EARNED', 'INCENTIVE', 'OTHER', 'VOLUME']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateDiscountType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RateDiscountType is not None or
            self.Description is not None or
            self.Amount is not None or
            self.Percent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='RateDiscount', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RateDiscount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateDiscount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='RateDiscount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='RateDiscount'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='RateDiscount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RateDiscountType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateDiscountType>%s</ns:RateDiscountType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateDiscountType), input_name='RateDiscountType')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Amount is not None:
            self.Amount.export(outfile, level, namespace_, name_='Amount', pretty_print=pretty_print)
        if self.Percent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Percent>%s</ns:Percent>%s' % (self.gds_format_float(self.Percent, input_name='Percent'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RateDiscountType':
            RateDiscountType_ = child_.text
            RateDiscountType_ = self.gds_validate_string(RateDiscountType_, node, 'RateDiscountType')
            self.RateDiscountType = RateDiscountType_
            # validate type RateDiscountType
            self.validate_RateDiscountType(self.RateDiscountType)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Amount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.Amount = obj_
            obj_.original_tagname_ = 'Amount'
        elif nodeName_ == 'Percent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Percent')
            self.Percent = fval_
# end class RateDiscount


class Rebate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RebateType=None, Description=None, Amount=None, Percent=None):
        self.original_tagname_ = None
        self.RebateType = RebateType
        self.validate_RebateType(self.RebateType)
        self.Description = Description
        self.Amount = Amount
        self.Percent = Percent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rebate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rebate.subclass:
            return Rebate.subclass(*args_, **kwargs_)
        else:
            return Rebate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RebateType(self): return self.RebateType
    def set_RebateType(self, RebateType): self.RebateType = RebateType
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def get_Percent(self): return self.Percent
    def set_Percent(self, Percent): self.Percent = Percent
    def validate_RebateType(self, value):
        # Validate type RebateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BONUS', 'EARNED', 'OTHER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RebateType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RebateType is not None or
            self.Description is not None or
            self.Amount is not None or
            self.Percent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Rebate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Rebate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Rebate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Rebate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Rebate'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Rebate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RebateType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RebateType>%s</ns:RebateType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RebateType), input_name='RebateType')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Amount is not None:
            self.Amount.export(outfile, level, namespace_, name_='Amount', pretty_print=pretty_print)
        if self.Percent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Percent>%s</ns:Percent>%s' % (self.gds_format_float(self.Percent, input_name='Percent'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RebateType':
            RebateType_ = child_.text
            RebateType_ = self.gds_validate_string(RebateType_, node, 'RebateType')
            self.RebateType = RebateType_
            # validate type RebateType
            self.validate_RebateType(self.RebateType)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Amount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.Amount = obj_
            obj_.original_tagname_ = 'Amount'
        elif nodeName_ == 'Percent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Percent')
            self.Percent = fval_
# end class Rebate


class RecipientCustomsId(GeneratedsSuper):
    """Specifies how the recipient is identified for customs purposes; the
    requirements on this information vary with destination country."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_RecipientCustomsIdType(self.Type)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecipientCustomsId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecipientCustomsId.subclass:
            return RecipientCustomsId.subclass(*args_, **kwargs_)
        else:
            return RecipientCustomsId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_RecipientCustomsIdType(self, value):
        # Validate type RecipientCustomsIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COMPANY', 'INDIVIDUAL', 'PASSPORT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RecipientCustomsIdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='RecipientCustomsId', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RecipientCustomsId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecipientCustomsId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='RecipientCustomsId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='RecipientCustomsId'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='RecipientCustomsId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type RecipientCustomsIdType
            self.validate_RecipientCustomsIdType(self.Type)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class RecipientCustomsId


class RecommendedDocumentSpecification(GeneratedsSuper):
    """Specifies the details about documents that are recommended to be
    included with the shipment for ease of shipment processing and
    transportation."""
    subclass = None
    superclass = None
    def __init__(self, Types=None):
        self.original_tagname_ = None
        if Types is None:
            self.Types = []
        else:
            self.Types = Types
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RecommendedDocumentSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RecommendedDocumentSpecification.subclass:
            return RecommendedDocumentSpecification.subclass(*args_, **kwargs_)
        else:
            return RecommendedDocumentSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Types(self): return self.Types
    def set_Types(self, Types): self.Types = Types
    def add_Types(self, value): self.Types.append(value)
    def insert_Types_at(self, index, value): self.Types.insert(index, value)
    def replace_Types_at(self, index, value): self.Types[index] = value
    def validate_RecommendedDocumentType(self, value):
        # Validate type RecommendedDocumentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ANTIQUE_STATEMENT_EUROPEAN_UNION', 'ANTIQUE_STATEMENT_UNITED_STATES', 'ASSEMBLER_DECLARATION', 'BEARING_WORKSHEET', 'CERTIFICATE_OF_SHIPMENTS_TO_SYRIA', 'COMMERCIAL_INVOICE_FOR_THE_CARIBBEAN_COMMON_MARKET', 'CONIFEROUS_SOLID_WOOD_PACKAGING_MATERIAL_TO_THE_PEOPLES_REPUBLIC_OF_CHINA', 'DECLARATION_FOR_FREE_ENTRY_OF_RETURNED_AMERICAN_PRODUCTS', 'DECLARATION_OF_BIOLOGICAL_STANDARDS', 'DECLARATION_OF_IMPORTED_ELECTRONIC_PRODUCTS_SUBJECT_TO_RADIATION_CONTROL_STANDARD', 'ELECTRONIC_INTEGRATED_CIRCUIT_WORKSHEET', 'FILM_AND_VIDEO_CERTIFICATE', 'INTERIM_FOOTWEAR_INVOICE', 'NAFTA_CERTIFICATE_OF_ORIGIN_CANADA_ENGLISH', 'NAFTA_CERTIFICATE_OF_ORIGIN_CANADA_FRENCH', 'NAFTA_CERTIFICATE_OF_ORIGIN_SPANISH', 'NAFTA_CERTIFICATE_OF_ORIGIN_UNITED_STATES', 'PACKING_LIST', 'PRINTED_CIRCUIT_BOARD_WORKSHEET', 'REPAIRED_WATCH_BREAKOUT_WORKSHEET', 'STATEMENT_REGARDING_THE_IMPORT_OF_RADIO_FREQUENCY_DEVICES', 'TOXIC_SUBSTANCES_CONTROL_ACT', 'UNITED_STATES_CARIBBEAN_BASIN_TRADE_PARTNERSHIP_ACT_CERTIFICATE_OF_ORIGIN_NON_TEXTILES', 'UNITED_STATES_CARIBBEAN_BASIN_TRADE_PARTNERSHIP_ACT_CERTIFICATE_OF_ORIGIN_TEXTILES', 'UNITED_STATES_NEW_WATCH_WORKSHEET', 'UNITED_STATES_WATCH_REPAIR_DECLARATION']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RecommendedDocumentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Types
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='RecommendedDocumentSpecification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RecommendedDocumentSpecification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecommendedDocumentSpecification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='RecommendedDocumentSpecification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='RecommendedDocumentSpecification'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='RecommendedDocumentSpecification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Types_ in self.Types:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:domain>%s</ns:domain>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Types_), input_name='domain')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domain':
            Types_ = child_.text
            Types_ = self.gds_validate_string(Types_, node, 'domain')
            self.Types.append(Types_)
            # validate type RecommendedDocumentType
            self.validate_RecommendedDocumentType(self.Types[-1])
# end class RecommendedDocumentSpecification


class RegulatoryLabelContentDetail(GeneratedsSuper):
    """Specifies details needed to generate any label artifacts required
    due to regulatory requirements."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, GenerationOptions=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_RegulatoryLabelType(self.Type)
        if GenerationOptions is None:
            self.GenerationOptions = []
        else:
            self.GenerationOptions = GenerationOptions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulatoryLabelContentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulatoryLabelContentDetail.subclass:
            return RegulatoryLabelContentDetail.subclass(*args_, **kwargs_)
        else:
            return RegulatoryLabelContentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_GenerationOptions(self): return self.GenerationOptions
    def set_GenerationOptions(self, GenerationOptions): self.GenerationOptions = GenerationOptions
    def add_GenerationOptions(self, value): self.GenerationOptions.append(value)
    def insert_GenerationOptions_at(self, index, value): self.GenerationOptions.insert(index, value)
    def replace_GenerationOptions_at(self, index, value): self.GenerationOptions[index] = value
    def validate_RegulatoryLabelType(self, value):
        # Validate type RegulatoryLabelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ALCOHOL_SHIPMENT_LABEL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RegulatoryLabelType' % {"value" : value.encode("utf-8")} )
    def validate_CustomerSpecifiedLabelGenerationOptionType(self, value):
        # Validate type CustomerSpecifiedLabelGenerationOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CONTENT_ON_SHIPPING_LABEL_ONLY', 'CONTENT_ON_SHIPPING_LABEL_PREFERRED', 'CONTENT_ON_SUPPLEMENTAL_LABEL_ONLY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomerSpecifiedLabelGenerationOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.GenerationOptions
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='RegulatoryLabelContentDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegulatoryLabelContentDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegulatoryLabelContentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='RegulatoryLabelContentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='RegulatoryLabelContentDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='RegulatoryLabelContentDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        for GenerationOptions_ in self.GenerationOptions:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:GenerationOptions>%s</ns:GenerationOptions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(GenerationOptions_), input_name='GenerationOptions')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type RegulatoryLabelType
            self.validate_RegulatoryLabelType(self.Type)
        elif nodeName_ == 'GenerationOptions':
            GenerationOptions_ = child_.text
            GenerationOptions_ = self.gds_validate_string(GenerationOptions_, node, 'GenerationOptions')
            self.GenerationOptions.append(GenerationOptions_)
            # validate type CustomerSpecifiedLabelGenerationOptionType
            self.validate_CustomerSpecifiedLabelGenerationOptionType(self.GenerationOptions[-1])
# end class RegulatoryLabelContentDetail


class RequestedPackageLineItem(GeneratedsSuper):
    """This class rationalizes RequestedPackage and RequestedPackageSummary
    from previous interfaces."""
    subclass = None
    superclass = None
    def __init__(self, SequenceNumber=None, GroupNumber=None, GroupPackageCount=None, VariableHandlingChargeDetail=None, InsuredValue=None, Weight=None, Dimensions=None, PhysicalPackaging=None, ItemDescription=None, ItemDescriptionForClearance=None, CustomerReferences=None, SpecialServicesRequested=None, ContentRecords=None):
        self.original_tagname_ = None
        self.SequenceNumber = SequenceNumber
        self.GroupNumber = GroupNumber
        self.GroupPackageCount = GroupPackageCount
        self.VariableHandlingChargeDetail = VariableHandlingChargeDetail
        self.InsuredValue = InsuredValue
        self.Weight = Weight
        self.Dimensions = Dimensions
        self.PhysicalPackaging = PhysicalPackaging
        self.validate_PhysicalPackagingType(self.PhysicalPackaging)
        self.ItemDescription = ItemDescription
        self.ItemDescriptionForClearance = ItemDescriptionForClearance
        if CustomerReferences is None:
            self.CustomerReferences = []
        else:
            self.CustomerReferences = CustomerReferences
        self.SpecialServicesRequested = SpecialServicesRequested
        if ContentRecords is None:
            self.ContentRecords = []
        else:
            self.ContentRecords = ContentRecords
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestedPackageLineItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestedPackageLineItem.subclass:
            return RequestedPackageLineItem.subclass(*args_, **kwargs_)
        else:
            return RequestedPackageLineItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SequenceNumber(self): return self.SequenceNumber
    def set_SequenceNumber(self, SequenceNumber): self.SequenceNumber = SequenceNumber
    def get_GroupNumber(self): return self.GroupNumber
    def set_GroupNumber(self, GroupNumber): self.GroupNumber = GroupNumber
    def get_GroupPackageCount(self): return self.GroupPackageCount
    def set_GroupPackageCount(self, GroupPackageCount): self.GroupPackageCount = GroupPackageCount
    def get_VariableHandlingChargeDetail(self): return self.VariableHandlingChargeDetail
    def set_VariableHandlingChargeDetail(self, VariableHandlingChargeDetail): self.VariableHandlingChargeDetail = VariableHandlingChargeDetail
    def get_InsuredValue(self): return self.InsuredValue
    def set_InsuredValue(self, InsuredValue): self.InsuredValue = InsuredValue
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_Dimensions(self): return self.Dimensions
    def set_Dimensions(self, Dimensions): self.Dimensions = Dimensions
    def get_PhysicalPackaging(self): return self.PhysicalPackaging
    def set_PhysicalPackaging(self, PhysicalPackaging): self.PhysicalPackaging = PhysicalPackaging
    def get_ItemDescription(self): return self.ItemDescription
    def set_ItemDescription(self, ItemDescription): self.ItemDescription = ItemDescription
    def get_ItemDescriptionForClearance(self): return self.ItemDescriptionForClearance
    def set_ItemDescriptionForClearance(self, ItemDescriptionForClearance): self.ItemDescriptionForClearance = ItemDescriptionForClearance
    def get_CustomerReferences(self): return self.CustomerReferences
    def set_CustomerReferences(self, CustomerReferences): self.CustomerReferences = CustomerReferences
    def add_CustomerReferences(self, value): self.CustomerReferences.append(value)
    def insert_CustomerReferences_at(self, index, value): self.CustomerReferences.insert(index, value)
    def replace_CustomerReferences_at(self, index, value): self.CustomerReferences[index] = value
    def get_SpecialServicesRequested(self): return self.SpecialServicesRequested
    def set_SpecialServicesRequested(self, SpecialServicesRequested): self.SpecialServicesRequested = SpecialServicesRequested
    def get_ContentRecords(self): return self.ContentRecords
    def set_ContentRecords(self, ContentRecords): self.ContentRecords = ContentRecords
    def add_ContentRecords(self, value): self.ContentRecords.append(value)
    def insert_ContentRecords_at(self, index, value): self.ContentRecords.insert(index, value)
    def replace_ContentRecords_at(self, index, value): self.ContentRecords[index] = value
    def validate_PhysicalPackagingType(self, value):
        # Validate type PhysicalPackagingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BAG', 'BARREL', 'BASKET', 'BOX', 'BUCKET', 'BUNDLE', 'CARTON', 'CASE', 'CONTAINER', 'CRATE', 'CYLINDER', 'DRUM', 'ENVELOPE', 'HAMPER', 'OTHER', 'PAIL', 'PALLET', 'PIECE', 'REEL', 'ROLL', 'SKID', 'TANK', 'TUBE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PhysicalPackagingType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SequenceNumber is not None or
            self.GroupNumber is not None or
            self.GroupPackageCount is not None or
            self.VariableHandlingChargeDetail is not None or
            self.InsuredValue is not None or
            self.Weight is not None or
            self.Dimensions is not None or
            self.PhysicalPackaging is not None or
            self.ItemDescription is not None or
            self.ItemDescriptionForClearance is not None or
            self.CustomerReferences or
            self.SpecialServicesRequested is not None or
            self.ContentRecords
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='RequestedPackageLineItem', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestedPackageLineItem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestedPackageLineItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='RequestedPackageLineItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='RequestedPackageLineItem'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='RequestedPackageLineItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SequenceNumber>%s</ns:SequenceNumber>%s' % (self.gds_format_integer(self.SequenceNumber, input_name='SequenceNumber'), eol_))
        if self.GroupNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:GroupNumber>%s</ns:GroupNumber>%s' % (self.gds_format_integer(self.GroupNumber, input_name='GroupNumber'), eol_))
        if self.GroupPackageCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:GroupPackageCount>%s</ns:GroupPackageCount>%s' % (self.gds_format_integer(self.GroupPackageCount, input_name='GroupPackageCount'), eol_))
        if self.VariableHandlingChargeDetail is not None:
            self.VariableHandlingChargeDetail.export(outfile, level, namespace_, name_='VariableHandlingChargeDetail', pretty_print=pretty_print)
        if self.InsuredValue is not None:
            self.InsuredValue.export(outfile, level, namespace_, name_='InsuredValue', pretty_print=pretty_print)
        if self.Weight is not None:
            self.Weight.export(outfile, level, namespace_, name_='Weight', pretty_print=pretty_print)
        if self.Dimensions is not None:
            self.Dimensions.export(outfile, level, namespace_, name_='Dimensions', pretty_print=pretty_print)
        if self.PhysicalPackaging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PhysicalPackaging>%s</ns:PhysicalPackaging>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PhysicalPackaging), input_name='PhysicalPackaging')), eol_))
        if self.ItemDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ItemDescription>%s</ns:ItemDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ItemDescription), input_name='ItemDescription')), eol_))
        if self.ItemDescriptionForClearance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ItemDescriptionForClearance>%s</ns:ItemDescriptionForClearance>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ItemDescriptionForClearance), input_name='ItemDescriptionForClearance')), eol_))
        for CustomerReferences_ in self.CustomerReferences:
            CustomerReferences_.export(outfile, level, namespace_, name_='CustomerReferences', pretty_print=pretty_print)
        if self.SpecialServicesRequested is not None:
            self.SpecialServicesRequested.export(outfile, level, namespace_, name_='SpecialServicesRequested', pretty_print=pretty_print)
        for ContentRecords_ in self.ContentRecords:
            ContentRecords_.export(outfile, level, namespace_, name_='ContentRecords', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SequenceNumber')
            self.SequenceNumber = ival_
        elif nodeName_ == 'GroupNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'GroupNumber')
            self.GroupNumber = ival_
        elif nodeName_ == 'GroupPackageCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'GroupPackageCount')
            self.GroupPackageCount = ival_
        elif nodeName_ == 'VariableHandlingChargeDetail':
            obj_ = VariableHandlingChargeDetail.factory()
            obj_.build(child_)
            self.VariableHandlingChargeDetail = obj_
            obj_.original_tagname_ = 'VariableHandlingChargeDetail'
        elif nodeName_ == 'InsuredValue':
            obj_ = Money.factory()
            obj_.build(child_)
            self.InsuredValue = obj_
            obj_.original_tagname_ = 'InsuredValue'
        elif nodeName_ == 'Weight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.Weight = obj_
            obj_.original_tagname_ = 'Weight'
        elif nodeName_ == 'Dimensions':
            obj_ = Dimensions.factory()
            obj_.build(child_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'Dimensions'
        elif nodeName_ == 'PhysicalPackaging':
            PhysicalPackaging_ = child_.text
            PhysicalPackaging_ = self.gds_validate_string(PhysicalPackaging_, node, 'PhysicalPackaging')
            self.PhysicalPackaging = PhysicalPackaging_
            # validate type PhysicalPackagingType
            self.validate_PhysicalPackagingType(self.PhysicalPackaging)
        elif nodeName_ == 'ItemDescription':
            ItemDescription_ = child_.text
            ItemDescription_ = self.gds_validate_string(ItemDescription_, node, 'ItemDescription')
            self.ItemDescription = ItemDescription_
        elif nodeName_ == 'ItemDescriptionForClearance':
            ItemDescriptionForClearance_ = child_.text
            ItemDescriptionForClearance_ = self.gds_validate_string(ItemDescriptionForClearance_, node, 'ItemDescriptionForClearance')
            self.ItemDescriptionForClearance = ItemDescriptionForClearance_
        elif nodeName_ == 'CustomerReferences':
            obj_ = CustomerReference.factory()
            obj_.build(child_)
            self.CustomerReferences.append(obj_)
            obj_.original_tagname_ = 'CustomerReferences'
        elif nodeName_ == 'SpecialServicesRequested':
            obj_ = PackageSpecialServicesRequested.factory()
            obj_.build(child_)
            self.SpecialServicesRequested = obj_
            obj_.original_tagname_ = 'SpecialServicesRequested'
        elif nodeName_ == 'ContentRecords':
            obj_ = ContentRecord.factory()
            obj_.build(child_)
            self.ContentRecords.append(obj_)
            obj_.original_tagname_ = 'ContentRecords'
# end class RequestedPackageLineItem


class RequestedShipment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ShipTimestamp=None, DropoffType=None, ServiceType=None, PackagingType=None, ManifestDetail=None, TotalWeight=None, TotalInsuredValue=None, PreferredCurrency=None, ShipmentAuthorizationDetail=None, Shipper=None, Recipient=None, RecipientLocationNumber=None, Origin=None, SoldTo=None, ShippingChargesPayment=None, SpecialServicesRequested=None, ExpressFreightDetail=None, FreightShipmentDetail=None, DeliveryInstructions=None, VariableHandlingChargeDetail=None, CustomsClearanceDetail=None, PickupDetail=None, SmartPostDetail=None, BlockInsightVisibility=None, LabelSpecification=None, ShippingDocumentSpecification=None, RateRequestTypes=None, EdtRequestType=None, MasterTrackingId=None, PackageCount=None, ConfigurationData=None, RequestedPackageLineItems=None):
        self.original_tagname_ = None
        if isinstance(ShipTimestamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ShipTimestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ShipTimestamp
        self.ShipTimestamp = initvalue_
        self.DropoffType = DropoffType
        self.validate_DropoffType(self.DropoffType)
        self.ServiceType = ServiceType
        self.validate_ServiceType(self.ServiceType)
        self.PackagingType = PackagingType
        self.validate_PackagingType(self.PackagingType)
        self.ManifestDetail = ManifestDetail
        self.TotalWeight = TotalWeight
        self.TotalInsuredValue = TotalInsuredValue
        self.PreferredCurrency = PreferredCurrency
        self.ShipmentAuthorizationDetail = ShipmentAuthorizationDetail
        self.Shipper = Shipper
        self.Recipient = Recipient
        self.RecipientLocationNumber = RecipientLocationNumber
        self.Origin = Origin
        self.SoldTo = SoldTo
        self.ShippingChargesPayment = ShippingChargesPayment
        self.SpecialServicesRequested = SpecialServicesRequested
        self.ExpressFreightDetail = ExpressFreightDetail
        self.FreightShipmentDetail = FreightShipmentDetail
        self.DeliveryInstructions = DeliveryInstructions
        self.VariableHandlingChargeDetail = VariableHandlingChargeDetail
        self.CustomsClearanceDetail = CustomsClearanceDetail
        self.PickupDetail = PickupDetail
        self.SmartPostDetail = SmartPostDetail
        self.BlockInsightVisibility = BlockInsightVisibility
        self.LabelSpecification = LabelSpecification
        self.ShippingDocumentSpecification = ShippingDocumentSpecification
        if RateRequestTypes is None:
            self.RateRequestTypes = []
        else:
            self.RateRequestTypes = RateRequestTypes
        self.EdtRequestType = EdtRequestType
        self.validate_EdtRequestType(self.EdtRequestType)
        self.MasterTrackingId = MasterTrackingId
        self.PackageCount = PackageCount
        self.ConfigurationData = ConfigurationData
        if RequestedPackageLineItems is None:
            self.RequestedPackageLineItems = []
        else:
            self.RequestedPackageLineItems = RequestedPackageLineItems
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestedShipment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestedShipment.subclass:
            return RequestedShipment.subclass(*args_, **kwargs_)
        else:
            return RequestedShipment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShipTimestamp(self): return self.ShipTimestamp
    def set_ShipTimestamp(self, ShipTimestamp): self.ShipTimestamp = ShipTimestamp
    def get_DropoffType(self): return self.DropoffType
    def set_DropoffType(self, DropoffType): self.DropoffType = DropoffType
    def get_ServiceType(self): return self.ServiceType
    def set_ServiceType(self, ServiceType): self.ServiceType = ServiceType
    def get_PackagingType(self): return self.PackagingType
    def set_PackagingType(self, PackagingType): self.PackagingType = PackagingType
    def get_ManifestDetail(self): return self.ManifestDetail
    def set_ManifestDetail(self, ManifestDetail): self.ManifestDetail = ManifestDetail
    def get_TotalWeight(self): return self.TotalWeight
    def set_TotalWeight(self, TotalWeight): self.TotalWeight = TotalWeight
    def get_TotalInsuredValue(self): return self.TotalInsuredValue
    def set_TotalInsuredValue(self, TotalInsuredValue): self.TotalInsuredValue = TotalInsuredValue
    def get_PreferredCurrency(self): return self.PreferredCurrency
    def set_PreferredCurrency(self, PreferredCurrency): self.PreferredCurrency = PreferredCurrency
    def get_ShipmentAuthorizationDetail(self): return self.ShipmentAuthorizationDetail
    def set_ShipmentAuthorizationDetail(self, ShipmentAuthorizationDetail): self.ShipmentAuthorizationDetail = ShipmentAuthorizationDetail
    def get_Shipper(self): return self.Shipper
    def set_Shipper(self, Shipper): self.Shipper = Shipper
    def get_Recipient(self): return self.Recipient
    def set_Recipient(self, Recipient): self.Recipient = Recipient
    def get_RecipientLocationNumber(self): return self.RecipientLocationNumber
    def set_RecipientLocationNumber(self, RecipientLocationNumber): self.RecipientLocationNumber = RecipientLocationNumber
    def get_Origin(self): return self.Origin
    def set_Origin(self, Origin): self.Origin = Origin
    def get_SoldTo(self): return self.SoldTo
    def set_SoldTo(self, SoldTo): self.SoldTo = SoldTo
    def get_ShippingChargesPayment(self): return self.ShippingChargesPayment
    def set_ShippingChargesPayment(self, ShippingChargesPayment): self.ShippingChargesPayment = ShippingChargesPayment
    def get_SpecialServicesRequested(self): return self.SpecialServicesRequested
    def set_SpecialServicesRequested(self, SpecialServicesRequested): self.SpecialServicesRequested = SpecialServicesRequested
    def get_ExpressFreightDetail(self): return self.ExpressFreightDetail
    def set_ExpressFreightDetail(self, ExpressFreightDetail): self.ExpressFreightDetail = ExpressFreightDetail
    def get_FreightShipmentDetail(self): return self.FreightShipmentDetail
    def set_FreightShipmentDetail(self, FreightShipmentDetail): self.FreightShipmentDetail = FreightShipmentDetail
    def get_DeliveryInstructions(self): return self.DeliveryInstructions
    def set_DeliveryInstructions(self, DeliveryInstructions): self.DeliveryInstructions = DeliveryInstructions
    def get_VariableHandlingChargeDetail(self): return self.VariableHandlingChargeDetail
    def set_VariableHandlingChargeDetail(self, VariableHandlingChargeDetail): self.VariableHandlingChargeDetail = VariableHandlingChargeDetail
    def get_CustomsClearanceDetail(self): return self.CustomsClearanceDetail
    def set_CustomsClearanceDetail(self, CustomsClearanceDetail): self.CustomsClearanceDetail = CustomsClearanceDetail
    def get_PickupDetail(self): return self.PickupDetail
    def set_PickupDetail(self, PickupDetail): self.PickupDetail = PickupDetail
    def get_SmartPostDetail(self): return self.SmartPostDetail
    def set_SmartPostDetail(self, SmartPostDetail): self.SmartPostDetail = SmartPostDetail
    def get_BlockInsightVisibility(self): return self.BlockInsightVisibility
    def set_BlockInsightVisibility(self, BlockInsightVisibility): self.BlockInsightVisibility = BlockInsightVisibility
    def get_LabelSpecification(self): return self.LabelSpecification
    def set_LabelSpecification(self, LabelSpecification): self.LabelSpecification = LabelSpecification
    def get_ShippingDocumentSpecification(self): return self.ShippingDocumentSpecification
    def set_ShippingDocumentSpecification(self, ShippingDocumentSpecification): self.ShippingDocumentSpecification = ShippingDocumentSpecification
    def get_RateRequestTypes(self): return self.RateRequestTypes
    def set_RateRequestTypes(self, RateRequestTypes): self.RateRequestTypes = RateRequestTypes
    def add_RateRequestTypes(self, value): self.RateRequestTypes.append(value)
    def insert_RateRequestTypes_at(self, index, value): self.RateRequestTypes.insert(index, value)
    def replace_RateRequestTypes_at(self, index, value): self.RateRequestTypes[index] = value
    def get_EdtRequestType(self): return self.EdtRequestType
    def set_EdtRequestType(self, EdtRequestType): self.EdtRequestType = EdtRequestType
    def get_MasterTrackingId(self): return self.MasterTrackingId
    def set_MasterTrackingId(self, MasterTrackingId): self.MasterTrackingId = MasterTrackingId
    def get_PackageCount(self): return self.PackageCount
    def set_PackageCount(self, PackageCount): self.PackageCount = PackageCount
    def get_ConfigurationData(self): return self.ConfigurationData
    def set_ConfigurationData(self, ConfigurationData): self.ConfigurationData = ConfigurationData
    def get_RequestedPackageLineItems(self): return self.RequestedPackageLineItems
    def set_RequestedPackageLineItems(self, RequestedPackageLineItems): self.RequestedPackageLineItems = RequestedPackageLineItems
    def add_RequestedPackageLineItems(self, value): self.RequestedPackageLineItems.append(value)
    def insert_RequestedPackageLineItems_at(self, index, value): self.RequestedPackageLineItems.insert(index, value)
    def replace_RequestedPackageLineItems_at(self, index, value): self.RequestedPackageLineItems[index] = value
    def validate_DropoffType(self, value):
        # Validate type DropoffType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BUSINESS_SERVICE_CENTER', 'DROP_BOX', 'REGULAR_PICKUP', 'REQUEST_COURIER', 'STATION']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DropoffType' % {"value" : value.encode("utf-8")} )
    def validate_ServiceType(self, value):
        # Validate type ServiceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EUROPE_FIRST_INTERNATIONAL_PRIORITY', 'FEDEX_1_DAY_FREIGHT', 'FEDEX_2_DAY', 'FEDEX_2_DAY_AM', 'FEDEX_2_DAY_FREIGHT', 'FEDEX_3_DAY_FREIGHT', 'FEDEX_DISTANCE_DEFERRED', 'FEDEX_EXPRESS_SAVER', 'FEDEX_FIRST_FREIGHT', 'FEDEX_FREIGHT_ECONOMY', 'FEDEX_FREIGHT_PRIORITY', 'FEDEX_GROUND', 'FEDEX_NEXT_DAY_AFTERNOON', 'FEDEX_NEXT_DAY_EARLY_MORNING', 'FEDEX_NEXT_DAY_END_OF_DAY', 'FEDEX_NEXT_DAY_FREIGHT', 'FEDEX_NEXT_DAY_MID_MORNING', 'FIRST_OVERNIGHT', 'GROUND_HOME_DELIVERY', 'INTERNATIONAL_ECONOMY', 'INTERNATIONAL_ECONOMY_FREIGHT', 'INTERNATIONAL_FIRST', 'INTERNATIONAL_PRIORITY', 'INTERNATIONAL_PRIORITY_EXPRESS', 'INTERNATIONAL_PRIORITY_FREIGHT', 'PRIORITY_OVERNIGHT', 'SAME_DAY', 'SAME_DAY_CITY', 'SMART_POST', 'STANDARD_OVERNIGHT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ServiceType' % {"value" : value.encode("utf-8")} )
    def validate_PackagingType(self, value):
        # Validate type PackagingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEDEX_10KG_BOX', 'FEDEX_25KG_BOX', 'FEDEX_BOX', 'FEDEX_ENVELOPE', 'FEDEX_EXTRA_LARGE_BOX', 'FEDEX_LARGE_BOX', 'FEDEX_MEDIUM_BOX', 'FEDEX_PAK', 'FEDEX_SMALL_BOX', 'FEDEX_TUBE', 'YOUR_PACKAGING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PackagingType' % {"value" : value.encode("utf-8")} )
    def validate_RateRequestType(self, value):
        # Validate type RateRequestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['LIST', 'NONE', 'PREFERRED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateRequestType' % {"value" : value.encode("utf-8")} )
    def validate_EdtRequestType(self, value):
        # Validate type EdtRequestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ALL', 'NONE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EdtRequestType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ShipTimestamp is not None or
            self.DropoffType is not None or
            self.ServiceType is not None or
            self.PackagingType is not None or
            self.ManifestDetail is not None or
            self.TotalWeight is not None or
            self.TotalInsuredValue is not None or
            self.PreferredCurrency is not None or
            self.ShipmentAuthorizationDetail is not None or
            self.Shipper is not None or
            self.Recipient is not None or
            self.RecipientLocationNumber is not None or
            self.Origin is not None or
            self.SoldTo is not None or
            self.ShippingChargesPayment is not None or
            self.SpecialServicesRequested is not None or
            self.ExpressFreightDetail is not None or
            self.FreightShipmentDetail is not None or
            self.DeliveryInstructions is not None or
            self.VariableHandlingChargeDetail is not None or
            self.CustomsClearanceDetail is not None or
            self.PickupDetail is not None or
            self.SmartPostDetail is not None or
            self.BlockInsightVisibility is not None or
            self.LabelSpecification is not None or
            self.ShippingDocumentSpecification is not None or
            self.RateRequestTypes or
            self.EdtRequestType is not None or
            self.MasterTrackingId is not None or
            self.PackageCount is not None or
            self.ConfigurationData is not None or
            self.RequestedPackageLineItems
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='RequestedShipment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestedShipment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestedShipment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='RequestedShipment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='RequestedShipment'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='RequestedShipment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ShipTimestamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ShipTimestamp>%s</ns:ShipTimestamp>%s' % (self.gds_format_datetime(self.ShipTimestamp, input_name='ShipTimestamp'), eol_))
        if self.DropoffType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DropoffType>%s</ns:DropoffType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DropoffType), input_name='DropoffType')), eol_))
        if self.ServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ServiceType>%s</ns:ServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceType), input_name='ServiceType')), eol_))
        if self.PackagingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackagingType>%s</ns:PackagingType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackagingType), input_name='PackagingType')), eol_))
        if self.ManifestDetail is not None:
            self.ManifestDetail.export(outfile, level, namespace_, name_='ManifestDetail', pretty_print=pretty_print)
        if self.TotalWeight is not None:
            self.TotalWeight.export(outfile, level, namespace_, name_='TotalWeight', pretty_print=pretty_print)
        if self.TotalInsuredValue is not None:
            self.TotalInsuredValue.export(outfile, level, namespace_, name_='TotalInsuredValue', pretty_print=pretty_print)
        if self.PreferredCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PreferredCurrency>%s</ns:PreferredCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PreferredCurrency), input_name='PreferredCurrency')), eol_))
        if self.ShipmentAuthorizationDetail is not None:
            self.ShipmentAuthorizationDetail.export(outfile, level, namespace_, name_='ShipmentAuthorizationDetail', pretty_print=pretty_print)
        if self.Shipper is not None:
            self.Shipper.export(outfile, level, namespace_, name_='Shipper', pretty_print=pretty_print)
        if self.Recipient is not None:
            self.Recipient.export(outfile, level, namespace_, name_='Recipient', pretty_print=pretty_print)
        if self.RecipientLocationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RecipientLocationNumber>%s</ns:RecipientLocationNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RecipientLocationNumber), input_name='RecipientLocationNumber')), eol_))
        if self.Origin is not None:
            self.Origin.export(outfile, level, namespace_, name_='Origin', pretty_print=pretty_print)
        if self.SoldTo is not None:
            self.SoldTo.export(outfile, level, namespace_, name_='SoldTo', pretty_print=pretty_print)
        if self.ShippingChargesPayment is not None:
            self.ShippingChargesPayment.export(outfile, level, namespace_, name_='ShippingChargesPayment', pretty_print=pretty_print)
        if self.SpecialServicesRequested is not None:
            self.SpecialServicesRequested.export(outfile, level, namespace_, name_='SpecialServicesRequested', pretty_print=pretty_print)
        if self.ExpressFreightDetail is not None:
            self.ExpressFreightDetail.export(outfile, level, namespace_, name_='ExpressFreightDetail', pretty_print=pretty_print)
        if self.FreightShipmentDetail is not None:
            self.FreightShipmentDetail.export(outfile, level, namespace_, name_='FreightShipmentDetail', pretty_print=pretty_print)
        if self.DeliveryInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DeliveryInstructions>%s</ns:DeliveryInstructions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryInstructions), input_name='DeliveryInstructions')), eol_))
        if self.VariableHandlingChargeDetail is not None:
            self.VariableHandlingChargeDetail.export(outfile, level, namespace_, name_='VariableHandlingChargeDetail', pretty_print=pretty_print)
        if self.CustomsClearanceDetail is not None:
            self.CustomsClearanceDetail.export(outfile, level, namespace_, name_='CustomsClearanceDetail', pretty_print=pretty_print)
        if self.PickupDetail is not None:
            self.PickupDetail.export(outfile, level, namespace_, name_='PickupDetail', pretty_print=pretty_print)
        if self.SmartPostDetail is not None:
            self.SmartPostDetail.export(outfile, level, namespace_, name_='SmartPostDetail', pretty_print=pretty_print)
        if self.BlockInsightVisibility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:BlockInsightVisibility>%s</ns:BlockInsightVisibility>%s' % (self.gds_format_boolean(self.BlockInsightVisibility, input_name='BlockInsightVisibility'), eol_))
        if self.LabelSpecification is not None:
            self.LabelSpecification.export(outfile, level, namespace_, name_='LabelSpecification', pretty_print=pretty_print)
        if self.ShippingDocumentSpecification is not None:
            self.ShippingDocumentSpecification.export(outfile, level, namespace_, name_='ShippingDocumentSpecification', pretty_print=pretty_print)
        for RateRequestTypes_ in self.RateRequestTypes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateRequestTypes>%s</ns:RateRequestTypes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(RateRequestTypes_), input_name='RateRequestTypes')), eol_))
        if self.EdtRequestType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EdtRequestType>%s</ns:EdtRequestType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EdtRequestType), input_name='EdtRequestType')), eol_))
        if self.MasterTrackingId is not None:
            self.MasterTrackingId.export(outfile, level, namespace_, name_='MasterTrackingId', pretty_print=pretty_print)
        if self.PackageCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackageCount>%s</ns:PackageCount>%s' % (self.gds_format_integer(self.PackageCount, input_name='PackageCount'), eol_))
        if self.ConfigurationData is not None:
            self.ConfigurationData.export(outfile, level, namespace_, name_='ConfigurationData', pretty_print=pretty_print)
        for RequestedPackageLineItems_ in self.RequestedPackageLineItems:
            RequestedPackageLineItems_.export(outfile, level, namespace_, name_='RequestedPackageLineItems', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ShipTimestamp':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ShipTimestamp = dval_
        elif nodeName_ == 'DropoffType':
            DropoffType_ = child_.text
            DropoffType_ = self.gds_validate_string(DropoffType_, node, 'DropoffType')
            self.DropoffType = DropoffType_
            # validate type DropoffType
            self.validate_DropoffType(self.DropoffType)
        elif nodeName_ == 'ServiceType':
            ServiceType_ = child_.text
            ServiceType_ = self.gds_validate_string(ServiceType_, node, 'ServiceType')
            self.ServiceType = ServiceType_
            # validate type ServiceType
            self.validate_ServiceType(self.ServiceType)
        elif nodeName_ == 'PackagingType':
            PackagingType_ = child_.text
            PackagingType_ = self.gds_validate_string(PackagingType_, node, 'PackagingType')
            self.PackagingType = PackagingType_
            # validate type PackagingType
            self.validate_PackagingType(self.PackagingType)
        elif nodeName_ == 'ManifestDetail':
            obj_ = ShipmentManifestDetail.factory()
            obj_.build(child_)
            self.ManifestDetail = obj_
            obj_.original_tagname_ = 'ManifestDetail'
        elif nodeName_ == 'TotalWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.TotalWeight = obj_
            obj_.original_tagname_ = 'TotalWeight'
        elif nodeName_ == 'TotalInsuredValue':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalInsuredValue = obj_
            obj_.original_tagname_ = 'TotalInsuredValue'
        elif nodeName_ == 'PreferredCurrency':
            PreferredCurrency_ = child_.text
            PreferredCurrency_ = self.gds_validate_string(PreferredCurrency_, node, 'PreferredCurrency')
            self.PreferredCurrency = PreferredCurrency_
        elif nodeName_ == 'ShipmentAuthorizationDetail':
            obj_ = ShipmentAuthorizationDetail.factory()
            obj_.build(child_)
            self.ShipmentAuthorizationDetail = obj_
            obj_.original_tagname_ = 'ShipmentAuthorizationDetail'
        elif nodeName_ == 'Shipper':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Shipper = obj_
            obj_.original_tagname_ = 'Shipper'
        elif nodeName_ == 'Recipient':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Recipient = obj_
            obj_.original_tagname_ = 'Recipient'
        elif nodeName_ == 'RecipientLocationNumber':
            RecipientLocationNumber_ = child_.text
            RecipientLocationNumber_ = self.gds_validate_string(RecipientLocationNumber_, node, 'RecipientLocationNumber')
            self.RecipientLocationNumber = RecipientLocationNumber_
        elif nodeName_ == 'Origin':
            obj_ = ContactAndAddress.factory()
            obj_.build(child_)
            self.Origin = obj_
            obj_.original_tagname_ = 'Origin'
        elif nodeName_ == 'SoldTo':
            obj_ = Party.factory()
            obj_.build(child_)
            self.SoldTo = obj_
            obj_.original_tagname_ = 'SoldTo'
        elif nodeName_ == 'ShippingChargesPayment':
            obj_ = Payment.factory()
            obj_.build(child_)
            self.ShippingChargesPayment = obj_
            obj_.original_tagname_ = 'ShippingChargesPayment'
        elif nodeName_ == 'SpecialServicesRequested':
            obj_ = ShipmentSpecialServicesRequested.factory()
            obj_.build(child_)
            self.SpecialServicesRequested = obj_
            obj_.original_tagname_ = 'SpecialServicesRequested'
        elif nodeName_ == 'ExpressFreightDetail':
            obj_ = ExpressFreightDetail.factory()
            obj_.build(child_)
            self.ExpressFreightDetail = obj_
            obj_.original_tagname_ = 'ExpressFreightDetail'
        elif nodeName_ == 'FreightShipmentDetail':
            obj_ = FreightShipmentDetail.factory()
            obj_.build(child_)
            self.FreightShipmentDetail = obj_
            obj_.original_tagname_ = 'FreightShipmentDetail'
        elif nodeName_ == 'DeliveryInstructions':
            DeliveryInstructions_ = child_.text
            DeliveryInstructions_ = self.gds_validate_string(DeliveryInstructions_, node, 'DeliveryInstructions')
            self.DeliveryInstructions = DeliveryInstructions_
        elif nodeName_ == 'VariableHandlingChargeDetail':
            obj_ = VariableHandlingChargeDetail.factory()
            obj_.build(child_)
            self.VariableHandlingChargeDetail = obj_
            obj_.original_tagname_ = 'VariableHandlingChargeDetail'
        elif nodeName_ == 'CustomsClearanceDetail':
            obj_ = CustomsClearanceDetail.factory()
            obj_.build(child_)
            self.CustomsClearanceDetail = obj_
            obj_.original_tagname_ = 'CustomsClearanceDetail'
        elif nodeName_ == 'PickupDetail':
            obj_ = PickupDetail.factory()
            obj_.build(child_)
            self.PickupDetail = obj_
            obj_.original_tagname_ = 'PickupDetail'
        elif nodeName_ == 'SmartPostDetail':
            obj_ = SmartPostShipmentDetail.factory()
            obj_.build(child_)
            self.SmartPostDetail = obj_
            obj_.original_tagname_ = 'SmartPostDetail'
        elif nodeName_ == 'BlockInsightVisibility':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BlockInsightVisibility')
            self.BlockInsightVisibility = ival_
        elif nodeName_ == 'LabelSpecification':
            obj_ = LabelSpecification.factory()
            obj_.build(child_)
            self.LabelSpecification = obj_
            obj_.original_tagname_ = 'LabelSpecification'
        elif nodeName_ == 'ShippingDocumentSpecification':
            obj_ = ShippingDocumentSpecification.factory()
            obj_.build(child_)
            self.ShippingDocumentSpecification = obj_
            obj_.original_tagname_ = 'ShippingDocumentSpecification'
        elif nodeName_ == 'RateRequestTypes':
            RateRequestTypes_ = child_.text
            RateRequestTypes_ = self.gds_validate_string(RateRequestTypes_, node, 'RateRequestTypes')
            self.RateRequestTypes.append(RateRequestTypes_)
            # validate type RateRequestType
            self.validate_RateRequestType(self.RateRequestTypes[-1])
        elif nodeName_ == 'EdtRequestType':
            EdtRequestType_ = child_.text
            EdtRequestType_ = self.gds_validate_string(EdtRequestType_, node, 'EdtRequestType')
            self.EdtRequestType = EdtRequestType_
            # validate type EdtRequestType
            self.validate_EdtRequestType(self.EdtRequestType)
        elif nodeName_ == 'MasterTrackingId':
            obj_ = TrackingId.factory()
            obj_.build(child_)
            self.MasterTrackingId = obj_
            obj_.original_tagname_ = 'MasterTrackingId'
        elif nodeName_ == 'PackageCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'PackageCount')
            self.PackageCount = ival_
        elif nodeName_ == 'ConfigurationData':
            obj_ = ShipmentConfigurationData.factory()
            obj_.build(child_)
            self.ConfigurationData = obj_
            obj_.original_tagname_ = 'ConfigurationData'
        elif nodeName_ == 'RequestedPackageLineItems':
            obj_ = RequestedPackageLineItem.factory()
            obj_.build(child_)
            self.RequestedPackageLineItems.append(obj_)
            obj_.original_tagname_ = 'RequestedPackageLineItems'
# end class RequestedShipment


class ReturnAssociationDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TrackingNumber=None, ShipDate=None):
        self.original_tagname_ = None
        self.TrackingNumber = TrackingNumber
        if isinstance(ShipDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ShipDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ShipDate
        self.ShipDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReturnAssociationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReturnAssociationDetail.subclass:
            return ReturnAssociationDetail.subclass(*args_, **kwargs_)
        else:
            return ReturnAssociationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrackingNumber(self): return self.TrackingNumber
    def set_TrackingNumber(self, TrackingNumber): self.TrackingNumber = TrackingNumber
    def get_ShipDate(self): return self.ShipDate
    def set_ShipDate(self, ShipDate): self.ShipDate = ShipDate
    def hasContent_(self):
        if (
            self.TrackingNumber is not None or
            self.ShipDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ReturnAssociationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReturnAssociationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnAssociationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ReturnAssociationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ReturnAssociationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ReturnAssociationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrackingNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TrackingNumber>%s</ns:TrackingNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TrackingNumber), input_name='TrackingNumber')), eol_))
        if self.ShipDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ShipDate>%s</ns:ShipDate>%s' % (self.gds_format_date(self.ShipDate, input_name='ShipDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrackingNumber':
            TrackingNumber_ = child_.text
            TrackingNumber_ = self.gds_validate_string(TrackingNumber_, node, 'TrackingNumber')
            self.TrackingNumber = TrackingNumber_
        elif nodeName_ == 'ShipDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ShipDate = dval_
# end class ReturnAssociationDetail


class ReturnEMailDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MerchantPhoneNumber=None, AllowedSpecialServices=None):
        self.original_tagname_ = None
        self.MerchantPhoneNumber = MerchantPhoneNumber
        if AllowedSpecialServices is None:
            self.AllowedSpecialServices = []
        else:
            self.AllowedSpecialServices = AllowedSpecialServices
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReturnEMailDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReturnEMailDetail.subclass:
            return ReturnEMailDetail.subclass(*args_, **kwargs_)
        else:
            return ReturnEMailDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MerchantPhoneNumber(self): return self.MerchantPhoneNumber
    def set_MerchantPhoneNumber(self, MerchantPhoneNumber): self.MerchantPhoneNumber = MerchantPhoneNumber
    def get_AllowedSpecialServices(self): return self.AllowedSpecialServices
    def set_AllowedSpecialServices(self, AllowedSpecialServices): self.AllowedSpecialServices = AllowedSpecialServices
    def add_AllowedSpecialServices(self, value): self.AllowedSpecialServices.append(value)
    def insert_AllowedSpecialServices_at(self, index, value): self.AllowedSpecialServices.insert(index, value)
    def replace_AllowedSpecialServices_at(self, index, value): self.AllowedSpecialServices[index] = value
    def validate_ReturnEMailAllowedSpecialServiceType(self, value):
        # Validate type ReturnEMailAllowedSpecialServiceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SATURDAY_DELIVERY', 'SATURDAY_PICKUP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReturnEMailAllowedSpecialServiceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MerchantPhoneNumber is not None or
            self.AllowedSpecialServices
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ReturnEMailDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReturnEMailDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnEMailDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ReturnEMailDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ReturnEMailDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ReturnEMailDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MerchantPhoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:MerchantPhoneNumber>%s</ns:MerchantPhoneNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MerchantPhoneNumber), input_name='MerchantPhoneNumber')), eol_))
        for AllowedSpecialServices_ in self.AllowedSpecialServices:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AllowedSpecialServices>%s</ns:AllowedSpecialServices>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AllowedSpecialServices_), input_name='AllowedSpecialServices')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MerchantPhoneNumber':
            MerchantPhoneNumber_ = child_.text
            MerchantPhoneNumber_ = self.gds_validate_string(MerchantPhoneNumber_, node, 'MerchantPhoneNumber')
            self.MerchantPhoneNumber = MerchantPhoneNumber_
        elif nodeName_ == 'AllowedSpecialServices':
            AllowedSpecialServices_ = child_.text
            AllowedSpecialServices_ = self.gds_validate_string(AllowedSpecialServices_, node, 'AllowedSpecialServices')
            self.AllowedSpecialServices.append(AllowedSpecialServices_)
            # validate type ReturnEMailAllowedSpecialServiceType
            self.validate_ReturnEMailAllowedSpecialServiceType(self.AllowedSpecialServices[-1])
# end class ReturnEMailDetail


class ReturnInstructionsDetail(GeneratedsSuper):
    """The instructions indicating how to print the return instructions(
    e.g. image type) Specifies characteristics of a shipping
    document to be produced."""
    subclass = None
    superclass = None
    def __init__(self, Format=None, CustomText=None):
        self.original_tagname_ = None
        self.Format = Format
        self.CustomText = CustomText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReturnInstructionsDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReturnInstructionsDetail.subclass:
            return ReturnInstructionsDetail.subclass(*args_, **kwargs_)
        else:
            return ReturnInstructionsDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def get_CustomText(self): return self.CustomText
    def set_CustomText(self, CustomText): self.CustomText = CustomText
    def hasContent_(self):
        if (
            self.Format is not None or
            self.CustomText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ReturnInstructionsDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReturnInstructionsDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnInstructionsDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ReturnInstructionsDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ReturnInstructionsDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ReturnInstructionsDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Format is not None:
            self.Format.export(outfile, level, namespace_, name_='Format', pretty_print=pretty_print)
        if self.CustomText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomText>%s</ns:CustomText>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomText), input_name='CustomText')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Format':
            obj_ = ShippingDocumentFormat.factory()
            obj_.build(child_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
        elif nodeName_ == 'CustomText':
            CustomText_ = child_.text
            CustomText_ = self.gds_validate_string(CustomText_, node, 'CustomText')
            self.CustomText = CustomText_
# end class ReturnInstructionsDetail


class ReturnShipmentDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReturnType=None, Rma=None, ReturnEMailDetail=None, ReturnAssociation=None):
        self.original_tagname_ = None
        self.ReturnType = ReturnType
        self.validate_ReturnType(self.ReturnType)
        self.Rma = Rma
        self.ReturnEMailDetail = ReturnEMailDetail
        self.ReturnAssociation = ReturnAssociation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReturnShipmentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReturnShipmentDetail.subclass:
            return ReturnShipmentDetail.subclass(*args_, **kwargs_)
        else:
            return ReturnShipmentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReturnType(self): return self.ReturnType
    def set_ReturnType(self, ReturnType): self.ReturnType = ReturnType
    def get_Rma(self): return self.Rma
    def set_Rma(self, Rma): self.Rma = Rma
    def get_ReturnEMailDetail(self): return self.ReturnEMailDetail
    def set_ReturnEMailDetail(self, ReturnEMailDetail): self.ReturnEMailDetail = ReturnEMailDetail
    def get_ReturnAssociation(self): return self.ReturnAssociation
    def set_ReturnAssociation(self, ReturnAssociation): self.ReturnAssociation = ReturnAssociation
    def validate_ReturnType(self, value):
        # Validate type ReturnType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEDEX_TAG', 'PENDING', 'PRINT_RETURN_LABEL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReturnType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ReturnType is not None or
            self.Rma is not None or
            self.ReturnEMailDetail is not None or
            self.ReturnAssociation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ReturnShipmentDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReturnShipmentDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReturnShipmentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ReturnShipmentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ReturnShipmentDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ReturnShipmentDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReturnType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ReturnType>%s</ns:ReturnType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReturnType), input_name='ReturnType')), eol_))
        if self.Rma is not None:
            self.Rma.export(outfile, level, namespace_, name_='Rma', pretty_print=pretty_print)
        if self.ReturnEMailDetail is not None:
            self.ReturnEMailDetail.export(outfile, level, namespace_, name_='ReturnEMailDetail', pretty_print=pretty_print)
        if self.ReturnAssociation is not None:
            self.ReturnAssociation.export(outfile, level, namespace_, name_='ReturnAssociation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReturnType':
            ReturnType_ = child_.text
            ReturnType_ = self.gds_validate_string(ReturnType_, node, 'ReturnType')
            self.ReturnType = ReturnType_
            # validate type ReturnType
            self.validate_ReturnType(self.ReturnType)
        elif nodeName_ == 'Rma':
            obj_ = Rma.factory()
            obj_.build(child_)
            self.Rma = obj_
            obj_.original_tagname_ = 'Rma'
        elif nodeName_ == 'ReturnEMailDetail':
            obj_ = ReturnEMailDetail.factory()
            obj_.build(child_)
            self.ReturnEMailDetail = obj_
            obj_.original_tagname_ = 'ReturnEMailDetail'
        elif nodeName_ == 'ReturnAssociation':
            obj_ = ReturnAssociationDetail.factory()
            obj_.build(child_)
            self.ReturnAssociation = obj_
            obj_.original_tagname_ = 'ReturnAssociation'
# end class ReturnShipmentDetail


class Rma(GeneratedsSuper):
    """June 2011 ITG 121203 IR-RMA number has been removed from this
    structure and added as a new customer reference type. The
    structure remains because of the reason field below."""
    subclass = None
    superclass = None
    def __init__(self, Reason=None):
        self.original_tagname_ = None
        self.Reason = Reason
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rma)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rma.subclass:
            return Rma.subclass(*args_, **kwargs_)
        else:
            return Rma(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reason(self): return self.Reason
    def set_Reason(self, Reason): self.Reason = Reason
    def hasContent_(self):
        if (
            self.Reason is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Rma', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Rma')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Rma')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Rma', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Rma'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Rma', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Reason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Reason>%s</ns:Reason>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Reason), input_name='Reason')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reason':
            Reason_ = child_.text
            Reason_ = self.gds_validate_string(Reason_, node, 'Reason')
            self.Reason = Reason_
# end class Rma


class ShipmentAuthorizationDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AccountNumber=None):
        self.original_tagname_ = None
        self.AccountNumber = AccountNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentAuthorizationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentAuthorizationDetail.subclass:
            return ShipmentAuthorizationDetail.subclass(*args_, **kwargs_)
        else:
            return ShipmentAuthorizationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccountNumber(self): return self.AccountNumber
    def set_AccountNumber(self, AccountNumber): self.AccountNumber = AccountNumber
    def hasContent_(self):
        if (
            self.AccountNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentAuthorizationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentAuthorizationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentAuthorizationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentAuthorizationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentAuthorizationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentAuthorizationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AccountNumber>%s</ns:AccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AccountNumber), input_name='AccountNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccountNumber':
            AccountNumber_ = child_.text
            AccountNumber_ = self.gds_validate_string(AccountNumber_, node, 'AccountNumber')
            self.AccountNumber = AccountNumber_
# end class ShipmentAuthorizationDetail


class ShipmentConfigurationData(GeneratedsSuper):
    """Specifies data structures that may be re-used multiple times with s
    single shipment."""
    subclass = None
    superclass = None
    def __init__(self, DangerousGoodsPackageConfigurations=None):
        self.original_tagname_ = None
        if DangerousGoodsPackageConfigurations is None:
            self.DangerousGoodsPackageConfigurations = []
        else:
            self.DangerousGoodsPackageConfigurations = DangerousGoodsPackageConfigurations
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentConfigurationData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentConfigurationData.subclass:
            return ShipmentConfigurationData.subclass(*args_, **kwargs_)
        else:
            return ShipmentConfigurationData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DangerousGoodsPackageConfigurations(self): return self.DangerousGoodsPackageConfigurations
    def set_DangerousGoodsPackageConfigurations(self, DangerousGoodsPackageConfigurations): self.DangerousGoodsPackageConfigurations = DangerousGoodsPackageConfigurations
    def add_DangerousGoodsPackageConfigurations(self, value): self.DangerousGoodsPackageConfigurations.append(value)
    def insert_DangerousGoodsPackageConfigurations_at(self, index, value): self.DangerousGoodsPackageConfigurations.insert(index, value)
    def replace_DangerousGoodsPackageConfigurations_at(self, index, value): self.DangerousGoodsPackageConfigurations[index] = value
    def hasContent_(self):
        if (
            self.DangerousGoodsPackageConfigurations
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentConfigurationData', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentConfigurationData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentConfigurationData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentConfigurationData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentConfigurationData'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentConfigurationData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DangerousGoodsPackageConfigurations_ in self.DangerousGoodsPackageConfigurations:
            DangerousGoodsPackageConfigurations_.export(outfile, level, namespace_, name_='DangerousGoodsPackageConfigurations', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DangerousGoodsPackageConfigurations':
            obj_ = DangerousGoodsDetail.factory()
            obj_.build(child_)
            self.DangerousGoodsPackageConfigurations.append(obj_)
            obj_.original_tagname_ = 'DangerousGoodsPackageConfigurations'
# end class ShipmentConfigurationData


class ShipmentDryIceDetail(GeneratedsSuper):
    """Shipment-level totals of dry ice data across all packages."""
    subclass = None
    superclass = None
    def __init__(self, PackageCount=None, TotalWeight=None, ProcessingOptions=None):
        self.original_tagname_ = None
        self.PackageCount = PackageCount
        self.TotalWeight = TotalWeight
        self.ProcessingOptions = ProcessingOptions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentDryIceDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentDryIceDetail.subclass:
            return ShipmentDryIceDetail.subclass(*args_, **kwargs_)
        else:
            return ShipmentDryIceDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PackageCount(self): return self.PackageCount
    def set_PackageCount(self, PackageCount): self.PackageCount = PackageCount
    def get_TotalWeight(self): return self.TotalWeight
    def set_TotalWeight(self, TotalWeight): self.TotalWeight = TotalWeight
    def get_ProcessingOptions(self): return self.ProcessingOptions
    def set_ProcessingOptions(self, ProcessingOptions): self.ProcessingOptions = ProcessingOptions
    def hasContent_(self):
        if (
            self.PackageCount is not None or
            self.TotalWeight is not None or
            self.ProcessingOptions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentDryIceDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentDryIceDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentDryIceDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentDryIceDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentDryIceDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentDryIceDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PackageCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackageCount>%s</ns:PackageCount>%s' % (self.gds_format_integer(self.PackageCount, input_name='PackageCount'), eol_))
        if self.TotalWeight is not None:
            self.TotalWeight.export(outfile, level, namespace_, name_='TotalWeight', pretty_print=pretty_print)
        if self.ProcessingOptions is not None:
            self.ProcessingOptions.export(outfile, level, namespace_, name_='ProcessingOptions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PackageCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'PackageCount')
            self.PackageCount = ival_
        elif nodeName_ == 'TotalWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.TotalWeight = obj_
            obj_.original_tagname_ = 'TotalWeight'
        elif nodeName_ == 'ProcessingOptions':
            obj_ = ShipmentDryIceProcessingOptionsRequested.factory()
            obj_.build(child_)
            self.ProcessingOptions = obj_
            obj_.original_tagname_ = 'ProcessingOptions'
# end class ShipmentDryIceDetail


class ShipmentDryIceProcessingOptionsRequested(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Options=None):
        self.original_tagname_ = None
        if Options is None:
            self.Options = []
        else:
            self.Options = Options
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentDryIceProcessingOptionsRequested)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentDryIceProcessingOptionsRequested.subclass:
            return ShipmentDryIceProcessingOptionsRequested.subclass(*args_, **kwargs_)
        else:
            return ShipmentDryIceProcessingOptionsRequested(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Options(self): return self.Options
    def set_Options(self, Options): self.Options = Options
    def add_Options(self, value): self.Options.append(value)
    def insert_Options_at(self, index, value): self.Options.insert(index, value)
    def replace_Options_at(self, index, value): self.Options[index] = value
    def validate_ShipmentDryIceProcessingOptionType(self, value):
        # Validate type ShipmentDryIceProcessingOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SHIPMENT_LEVEL_DRY_ICE_ONLY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShipmentDryIceProcessingOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Options
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentDryIceProcessingOptionsRequested', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentDryIceProcessingOptionsRequested')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentDryIceProcessingOptionsRequested')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentDryIceProcessingOptionsRequested', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentDryIceProcessingOptionsRequested'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentDryIceProcessingOptionsRequested', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Options_ in self.Options:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Options>%s</ns:Options>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Options_), input_name='Options')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Options':
            Options_ = child_.text
            Options_ = self.gds_validate_string(Options_, node, 'Options')
            self.Options.append(Options_)
            # validate type ShipmentDryIceProcessingOptionType
            self.validate_ShipmentDryIceProcessingOptionType(self.Options[-1])
# end class ShipmentDryIceProcessingOptionsRequested


class ShipmentEventNotificationDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AggregationType=None, PersonalMessage=None, EventNotifications=None):
        self.original_tagname_ = None
        self.AggregationType = AggregationType
        self.validate_ShipmentNotificationAggregationType(self.AggregationType)
        self.PersonalMessage = PersonalMessage
        if EventNotifications is None:
            self.EventNotifications = []
        else:
            self.EventNotifications = EventNotifications
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentEventNotificationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentEventNotificationDetail.subclass:
            return ShipmentEventNotificationDetail.subclass(*args_, **kwargs_)
        else:
            return ShipmentEventNotificationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AggregationType(self): return self.AggregationType
    def set_AggregationType(self, AggregationType): self.AggregationType = AggregationType
    def get_PersonalMessage(self): return self.PersonalMessage
    def set_PersonalMessage(self, PersonalMessage): self.PersonalMessage = PersonalMessage
    def get_EventNotifications(self): return self.EventNotifications
    def set_EventNotifications(self, EventNotifications): self.EventNotifications = EventNotifications
    def add_EventNotifications(self, value): self.EventNotifications.append(value)
    def insert_EventNotifications_at(self, index, value): self.EventNotifications.insert(index, value)
    def replace_EventNotifications_at(self, index, value): self.EventNotifications[index] = value
    def validate_ShipmentNotificationAggregationType(self, value):
        # Validate type ShipmentNotificationAggregationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PER_PACKAGE', 'PER_SHIPMENT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShipmentNotificationAggregationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AggregationType is not None or
            self.PersonalMessage is not None or
            self.EventNotifications
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentEventNotificationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentEventNotificationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentEventNotificationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentEventNotificationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentEventNotificationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentEventNotificationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AggregationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AggregationType>%s</ns:AggregationType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AggregationType), input_name='AggregationType')), eol_))
        if self.PersonalMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PersonalMessage>%s</ns:PersonalMessage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PersonalMessage), input_name='PersonalMessage')), eol_))
        for EventNotifications_ in self.EventNotifications:
            EventNotifications_.export(outfile, level, namespace_, name_='EventNotifications', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AggregationType':
            AggregationType_ = child_.text
            AggregationType_ = self.gds_validate_string(AggregationType_, node, 'AggregationType')
            self.AggregationType = AggregationType_
            # validate type ShipmentNotificationAggregationType
            self.validate_ShipmentNotificationAggregationType(self.AggregationType)
        elif nodeName_ == 'PersonalMessage':
            PersonalMessage_ = child_.text
            PersonalMessage_ = self.gds_validate_string(PersonalMessage_, node, 'PersonalMessage')
            self.PersonalMessage = PersonalMessage_
        elif nodeName_ == 'EventNotifications':
            obj_ = ShipmentEventNotificationSpecification.factory()
            obj_.build(child_)
            self.EventNotifications.append(obj_)
            obj_.original_tagname_ = 'EventNotifications'
# end class ShipmentEventNotificationDetail


class ShipmentEventNotificationSpecification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Role=None, Events=None, NotificationDetail=None, FormatSpecification=None):
        self.original_tagname_ = None
        self.Role = Role
        self.validate_ShipmentNotificationRoleType(self.Role)
        if Events is None:
            self.Events = []
        else:
            self.Events = Events
        self.NotificationDetail = NotificationDetail
        self.FormatSpecification = FormatSpecification
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentEventNotificationSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentEventNotificationSpecification.subclass:
            return ShipmentEventNotificationSpecification.subclass(*args_, **kwargs_)
        else:
            return ShipmentEventNotificationSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def get_Events(self): return self.Events
    def set_Events(self, Events): self.Events = Events
    def add_Events(self, value): self.Events.append(value)
    def insert_Events_at(self, index, value): self.Events.insert(index, value)
    def replace_Events_at(self, index, value): self.Events[index] = value
    def get_NotificationDetail(self): return self.NotificationDetail
    def set_NotificationDetail(self, NotificationDetail): self.NotificationDetail = NotificationDetail
    def get_FormatSpecification(self): return self.FormatSpecification
    def set_FormatSpecification(self, FormatSpecification): self.FormatSpecification = FormatSpecification
    def validate_ShipmentNotificationRoleType(self, value):
        # Validate type ShipmentNotificationRoleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BROKER', 'OTHER', 'RECIPIENT', 'SHIPPER', 'THIRD_PARTY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShipmentNotificationRoleType' % {"value" : value.encode("utf-8")} )
    def validate_NotificationEventType(self, value):
        # Validate type NotificationEventType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ON_DELIVERY', 'ON_ESTIMATED_DELIVERY', 'ON_EXCEPTION', 'ON_SHIPMENT', 'ON_TENDER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NotificationEventType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Role is not None or
            self.Events or
            self.NotificationDetail is not None or
            self.FormatSpecification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentEventNotificationSpecification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentEventNotificationSpecification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentEventNotificationSpecification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentEventNotificationSpecification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentEventNotificationSpecification'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentEventNotificationSpecification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Role is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Role>%s</ns:Role>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Role), input_name='Role')), eol_))
        for Events_ in self.Events:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Events>%s</ns:Events>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Events_), input_name='Events')), eol_))
        if self.NotificationDetail is not None:
            self.NotificationDetail.export(outfile, level, namespace_, name_='NotificationDetail', pretty_print=pretty_print)
        if self.FormatSpecification is not None:
            self.FormatSpecification.export(outfile, level, namespace_, name_='FormatSpecification', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Role':
            Role_ = child_.text
            Role_ = self.gds_validate_string(Role_, node, 'Role')
            self.Role = Role_
            # validate type ShipmentNotificationRoleType
            self.validate_ShipmentNotificationRoleType(self.Role)
        elif nodeName_ == 'Events':
            Events_ = child_.text
            Events_ = self.gds_validate_string(Events_, node, 'Events')
            self.Events.append(Events_)
            # validate type NotificationEventType
            self.validate_NotificationEventType(self.Events[-1])
        elif nodeName_ == 'NotificationDetail':
            obj_ = NotificationDetail.factory()
            obj_.build(child_)
            self.NotificationDetail = obj_
            obj_.original_tagname_ = 'NotificationDetail'
        elif nodeName_ == 'FormatSpecification':
            obj_ = ShipmentNotificationFormatSpecification.factory()
            obj_.build(child_)
            self.FormatSpecification = obj_
            obj_.original_tagname_ = 'FormatSpecification'
# end class ShipmentEventNotificationSpecification


class ShipmentLegRateDetail(GeneratedsSuper):
    """Data for a single leg of a shipment's total/summary rates, as
    calculated per a specific rate type."""
    subclass = None
    superclass = None
    def __init__(self, LegDescription=None, LegOrigin=None, LegOriginLocationId=None, LegDestination=None, LegDestinationLocationId=None, RateType=None, RateScale=None, RateZone=None, PricingCode=None, RatedWeightMethod=None, MinimumChargeType=None, CurrencyExchangeRate=None, SpecialRatingApplied=None, DimDivisor=None, DimDivisorType=None, FuelSurchargePercent=None, TotalBillingWeight=None, TotalDimWeight=None, TotalBaseCharge=None, TotalFreightDiscounts=None, TotalNetFreight=None, TotalSurcharges=None, TotalNetFedExCharge=None, TotalTaxes=None, TotalNetCharge=None, TotalRebates=None, TotalDutiesAndTaxes=None, TotalNetChargeWithDutiesAndTaxes=None, FreightRateDetail=None, FreightDiscounts=None, Rebates=None, Surcharges=None, Taxes=None, DutiesAndTaxes=None, VariableHandlingCharges=None, TotalVariableHandlingCharges=None):
        self.original_tagname_ = None
        self.LegDescription = LegDescription
        self.LegOrigin = LegOrigin
        self.LegOriginLocationId = LegOriginLocationId
        self.LegDestination = LegDestination
        self.LegDestinationLocationId = LegDestinationLocationId
        self.RateType = RateType
        self.validate_ReturnedRateType(self.RateType)
        self.RateScale = RateScale
        self.RateZone = RateZone
        self.PricingCode = PricingCode
        self.validate_PricingCodeType(self.PricingCode)
        self.RatedWeightMethod = RatedWeightMethod
        self.validate_RatedWeightMethod(self.RatedWeightMethod)
        self.MinimumChargeType = MinimumChargeType
        self.validate_MinimumChargeType(self.MinimumChargeType)
        self.CurrencyExchangeRate = CurrencyExchangeRate
        if SpecialRatingApplied is None:
            self.SpecialRatingApplied = []
        else:
            self.SpecialRatingApplied = SpecialRatingApplied
        self.DimDivisor = DimDivisor
        self.DimDivisorType = DimDivisorType
        self.validate_RateDimensionalDivisorType(self.DimDivisorType)
        self.FuelSurchargePercent = FuelSurchargePercent
        self.TotalBillingWeight = TotalBillingWeight
        self.TotalDimWeight = TotalDimWeight
        self.TotalBaseCharge = TotalBaseCharge
        self.TotalFreightDiscounts = TotalFreightDiscounts
        self.TotalNetFreight = TotalNetFreight
        self.TotalSurcharges = TotalSurcharges
        self.TotalNetFedExCharge = TotalNetFedExCharge
        self.TotalTaxes = TotalTaxes
        self.TotalNetCharge = TotalNetCharge
        self.TotalRebates = TotalRebates
        self.TotalDutiesAndTaxes = TotalDutiesAndTaxes
        self.TotalNetChargeWithDutiesAndTaxes = TotalNetChargeWithDutiesAndTaxes
        self.FreightRateDetail = FreightRateDetail
        if FreightDiscounts is None:
            self.FreightDiscounts = []
        else:
            self.FreightDiscounts = FreightDiscounts
        if Rebates is None:
            self.Rebates = []
        else:
            self.Rebates = Rebates
        if Surcharges is None:
            self.Surcharges = []
        else:
            self.Surcharges = Surcharges
        if Taxes is None:
            self.Taxes = []
        else:
            self.Taxes = Taxes
        if DutiesAndTaxes is None:
            self.DutiesAndTaxes = []
        else:
            self.DutiesAndTaxes = DutiesAndTaxes
        self.VariableHandlingCharges = VariableHandlingCharges
        self.TotalVariableHandlingCharges = TotalVariableHandlingCharges
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentLegRateDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentLegRateDetail.subclass:
            return ShipmentLegRateDetail.subclass(*args_, **kwargs_)
        else:
            return ShipmentLegRateDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LegDescription(self): return self.LegDescription
    def set_LegDescription(self, LegDescription): self.LegDescription = LegDescription
    def get_LegOrigin(self): return self.LegOrigin
    def set_LegOrigin(self, LegOrigin): self.LegOrigin = LegOrigin
    def get_LegOriginLocationId(self): return self.LegOriginLocationId
    def set_LegOriginLocationId(self, LegOriginLocationId): self.LegOriginLocationId = LegOriginLocationId
    def get_LegDestination(self): return self.LegDestination
    def set_LegDestination(self, LegDestination): self.LegDestination = LegDestination
    def get_LegDestinationLocationId(self): return self.LegDestinationLocationId
    def set_LegDestinationLocationId(self, LegDestinationLocationId): self.LegDestinationLocationId = LegDestinationLocationId
    def get_RateType(self): return self.RateType
    def set_RateType(self, RateType): self.RateType = RateType
    def get_RateScale(self): return self.RateScale
    def set_RateScale(self, RateScale): self.RateScale = RateScale
    def get_RateZone(self): return self.RateZone
    def set_RateZone(self, RateZone): self.RateZone = RateZone
    def get_PricingCode(self): return self.PricingCode
    def set_PricingCode(self, PricingCode): self.PricingCode = PricingCode
    def get_RatedWeightMethod(self): return self.RatedWeightMethod
    def set_RatedWeightMethod(self, RatedWeightMethod): self.RatedWeightMethod = RatedWeightMethod
    def get_MinimumChargeType(self): return self.MinimumChargeType
    def set_MinimumChargeType(self, MinimumChargeType): self.MinimumChargeType = MinimumChargeType
    def get_CurrencyExchangeRate(self): return self.CurrencyExchangeRate
    def set_CurrencyExchangeRate(self, CurrencyExchangeRate): self.CurrencyExchangeRate = CurrencyExchangeRate
    def get_SpecialRatingApplied(self): return self.SpecialRatingApplied
    def set_SpecialRatingApplied(self, SpecialRatingApplied): self.SpecialRatingApplied = SpecialRatingApplied
    def add_SpecialRatingApplied(self, value): self.SpecialRatingApplied.append(value)
    def insert_SpecialRatingApplied_at(self, index, value): self.SpecialRatingApplied.insert(index, value)
    def replace_SpecialRatingApplied_at(self, index, value): self.SpecialRatingApplied[index] = value
    def get_DimDivisor(self): return self.DimDivisor
    def set_DimDivisor(self, DimDivisor): self.DimDivisor = DimDivisor
    def get_DimDivisorType(self): return self.DimDivisorType
    def set_DimDivisorType(self, DimDivisorType): self.DimDivisorType = DimDivisorType
    def get_FuelSurchargePercent(self): return self.FuelSurchargePercent
    def set_FuelSurchargePercent(self, FuelSurchargePercent): self.FuelSurchargePercent = FuelSurchargePercent
    def get_TotalBillingWeight(self): return self.TotalBillingWeight
    def set_TotalBillingWeight(self, TotalBillingWeight): self.TotalBillingWeight = TotalBillingWeight
    def get_TotalDimWeight(self): return self.TotalDimWeight
    def set_TotalDimWeight(self, TotalDimWeight): self.TotalDimWeight = TotalDimWeight
    def get_TotalBaseCharge(self): return self.TotalBaseCharge
    def set_TotalBaseCharge(self, TotalBaseCharge): self.TotalBaseCharge = TotalBaseCharge
    def get_TotalFreightDiscounts(self): return self.TotalFreightDiscounts
    def set_TotalFreightDiscounts(self, TotalFreightDiscounts): self.TotalFreightDiscounts = TotalFreightDiscounts
    def get_TotalNetFreight(self): return self.TotalNetFreight
    def set_TotalNetFreight(self, TotalNetFreight): self.TotalNetFreight = TotalNetFreight
    def get_TotalSurcharges(self): return self.TotalSurcharges
    def set_TotalSurcharges(self, TotalSurcharges): self.TotalSurcharges = TotalSurcharges
    def get_TotalNetFedExCharge(self): return self.TotalNetFedExCharge
    def set_TotalNetFedExCharge(self, TotalNetFedExCharge): self.TotalNetFedExCharge = TotalNetFedExCharge
    def get_TotalTaxes(self): return self.TotalTaxes
    def set_TotalTaxes(self, TotalTaxes): self.TotalTaxes = TotalTaxes
    def get_TotalNetCharge(self): return self.TotalNetCharge
    def set_TotalNetCharge(self, TotalNetCharge): self.TotalNetCharge = TotalNetCharge
    def get_TotalRebates(self): return self.TotalRebates
    def set_TotalRebates(self, TotalRebates): self.TotalRebates = TotalRebates
    def get_TotalDutiesAndTaxes(self): return self.TotalDutiesAndTaxes
    def set_TotalDutiesAndTaxes(self, TotalDutiesAndTaxes): self.TotalDutiesAndTaxes = TotalDutiesAndTaxes
    def get_TotalNetChargeWithDutiesAndTaxes(self): return self.TotalNetChargeWithDutiesAndTaxes
    def set_TotalNetChargeWithDutiesAndTaxes(self, TotalNetChargeWithDutiesAndTaxes): self.TotalNetChargeWithDutiesAndTaxes = TotalNetChargeWithDutiesAndTaxes
    def get_FreightRateDetail(self): return self.FreightRateDetail
    def set_FreightRateDetail(self, FreightRateDetail): self.FreightRateDetail = FreightRateDetail
    def get_FreightDiscounts(self): return self.FreightDiscounts
    def set_FreightDiscounts(self, FreightDiscounts): self.FreightDiscounts = FreightDiscounts
    def add_FreightDiscounts(self, value): self.FreightDiscounts.append(value)
    def insert_FreightDiscounts_at(self, index, value): self.FreightDiscounts.insert(index, value)
    def replace_FreightDiscounts_at(self, index, value): self.FreightDiscounts[index] = value
    def get_Rebates(self): return self.Rebates
    def set_Rebates(self, Rebates): self.Rebates = Rebates
    def add_Rebates(self, value): self.Rebates.append(value)
    def insert_Rebates_at(self, index, value): self.Rebates.insert(index, value)
    def replace_Rebates_at(self, index, value): self.Rebates[index] = value
    def get_Surcharges(self): return self.Surcharges
    def set_Surcharges(self, Surcharges): self.Surcharges = Surcharges
    def add_Surcharges(self, value): self.Surcharges.append(value)
    def insert_Surcharges_at(self, index, value): self.Surcharges.insert(index, value)
    def replace_Surcharges_at(self, index, value): self.Surcharges[index] = value
    def get_Taxes(self): return self.Taxes
    def set_Taxes(self, Taxes): self.Taxes = Taxes
    def add_Taxes(self, value): self.Taxes.append(value)
    def insert_Taxes_at(self, index, value): self.Taxes.insert(index, value)
    def replace_Taxes_at(self, index, value): self.Taxes[index] = value
    def get_DutiesAndTaxes(self): return self.DutiesAndTaxes
    def set_DutiesAndTaxes(self, DutiesAndTaxes): self.DutiesAndTaxes = DutiesAndTaxes
    def add_DutiesAndTaxes(self, value): self.DutiesAndTaxes.append(value)
    def insert_DutiesAndTaxes_at(self, index, value): self.DutiesAndTaxes.insert(index, value)
    def replace_DutiesAndTaxes_at(self, index, value): self.DutiesAndTaxes[index] = value
    def get_VariableHandlingCharges(self): return self.VariableHandlingCharges
    def set_VariableHandlingCharges(self, VariableHandlingCharges): self.VariableHandlingCharges = VariableHandlingCharges
    def get_TotalVariableHandlingCharges(self): return self.TotalVariableHandlingCharges
    def set_TotalVariableHandlingCharges(self, TotalVariableHandlingCharges): self.TotalVariableHandlingCharges = TotalVariableHandlingCharges
    def validate_ReturnedRateType(self, value):
        # Validate type ReturnedRateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INCENTIVE', 'NEGOTIATED', 'PAYOR_ACCOUNT_PACKAGE', 'PAYOR_ACCOUNT_SHIPMENT', 'PAYOR_LIST_PACKAGE', 'PAYOR_LIST_SHIPMENT', 'PREFERRED_ACCOUNT_PACKAGE', 'PREFERRED_ACCOUNT_SHIPMENT', 'PREFERRED_LIST_PACKAGE', 'PREFERRED_LIST_SHIPMENT', 'PREFERRED_NEGOTIATED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReturnedRateType' % {"value" : value.encode("utf-8")} )
    def validate_PricingCodeType(self, value):
        # Validate type PricingCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACTUAL', 'ALTERNATE', 'BASE', 'HUNDREDWEIGHT', 'HUNDREDWEIGHT_ALTERNATE', 'INTERNATIONAL_DISTRIBUTION', 'INTERNATIONAL_ECONOMY_SERVICE', 'LTL_FREIGHT', 'PACKAGE', 'SHIPMENT', 'SHIPMENT_FIVE_POUND_OPTIONAL', 'SHIPMENT_OPTIONAL', 'SPECIAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PricingCodeType' % {"value" : value.encode("utf-8")} )
    def validate_RatedWeightMethod(self, value):
        # Validate type RatedWeightMethod, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACTUAL', 'AVERAGE_PACKAGE_WEIGHT_MINIMUM', 'BALLOON', 'DEFAULT_WEIGHT_APPLIED', 'DIM', 'FREIGHT_MINIMUM', 'MIXED', 'OVERSIZE', 'OVERSIZE_1', 'OVERSIZE_2', 'OVERSIZE_3', 'PACKAGING_MINIMUM', 'WEIGHT_BREAK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RatedWeightMethod' % {"value" : value.encode("utf-8")} )
    def validate_MinimumChargeType(self, value):
        # Validate type MinimumChargeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUSTOMER', 'CUSTOMER_FREIGHT_WEIGHT', 'EARNED_DISCOUNT', 'MIXED', 'RATE_SCALE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MinimumChargeType' % {"value" : value.encode("utf-8")} )
    def validate_SpecialRatingAppliedType(self, value):
        # Validate type SpecialRatingAppliedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEDEX_ONE_RATE', 'FIXED_FUEL_SURCHARGE', 'IMPORT_PRICING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SpecialRatingAppliedType' % {"value" : value.encode("utf-8")} )
    def validate_RateDimensionalDivisorType(self, value):
        # Validate type RateDimensionalDivisorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COUNTRY', 'CUSTOMER', 'OTHER', 'PRODUCT', 'WAIVED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateDimensionalDivisorType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LegDescription is not None or
            self.LegOrigin is not None or
            self.LegOriginLocationId is not None or
            self.LegDestination is not None or
            self.LegDestinationLocationId is not None or
            self.RateType is not None or
            self.RateScale is not None or
            self.RateZone is not None or
            self.PricingCode is not None or
            self.RatedWeightMethod is not None or
            self.MinimumChargeType is not None or
            self.CurrencyExchangeRate is not None or
            self.SpecialRatingApplied or
            self.DimDivisor is not None or
            self.DimDivisorType is not None or
            self.FuelSurchargePercent is not None or
            self.TotalBillingWeight is not None or
            self.TotalDimWeight is not None or
            self.TotalBaseCharge is not None or
            self.TotalFreightDiscounts is not None or
            self.TotalNetFreight is not None or
            self.TotalSurcharges is not None or
            self.TotalNetFedExCharge is not None or
            self.TotalTaxes is not None or
            self.TotalNetCharge is not None or
            self.TotalRebates is not None or
            self.TotalDutiesAndTaxes is not None or
            self.TotalNetChargeWithDutiesAndTaxes is not None or
            self.FreightRateDetail is not None or
            self.FreightDiscounts or
            self.Rebates or
            self.Surcharges or
            self.Taxes or
            self.DutiesAndTaxes or
            self.VariableHandlingCharges is not None or
            self.TotalVariableHandlingCharges is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentLegRateDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentLegRateDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentLegRateDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentLegRateDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentLegRateDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentLegRateDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LegDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LegDescription>%s</ns:LegDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LegDescription), input_name='LegDescription')), eol_))
        if self.LegOrigin is not None:
            self.LegOrigin.export(outfile, level, namespace_, name_='LegOrigin', pretty_print=pretty_print)
        if self.LegOriginLocationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LegOriginLocationId>%s</ns:LegOriginLocationId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LegOriginLocationId), input_name='LegOriginLocationId')), eol_))
        if self.LegDestination is not None:
            self.LegDestination.export(outfile, level, namespace_, name_='LegDestination', pretty_print=pretty_print)
        if self.LegDestinationLocationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LegDestinationLocationId>%s</ns:LegDestinationLocationId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LegDestinationLocationId), input_name='LegDestinationLocationId')), eol_))
        if self.RateType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateType>%s</ns:RateType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateType), input_name='RateType')), eol_))
        if self.RateScale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateScale>%s</ns:RateScale>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateScale), input_name='RateScale')), eol_))
        if self.RateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateZone>%s</ns:RateZone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateZone), input_name='RateZone')), eol_))
        if self.PricingCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PricingCode>%s</ns:PricingCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PricingCode), input_name='PricingCode')), eol_))
        if self.RatedWeightMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RatedWeightMethod>%s</ns:RatedWeightMethod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RatedWeightMethod), input_name='RatedWeightMethod')), eol_))
        if self.MinimumChargeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:MinimumChargeType>%s</ns:MinimumChargeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MinimumChargeType), input_name='MinimumChargeType')), eol_))
        if self.CurrencyExchangeRate is not None:
            self.CurrencyExchangeRate.export(outfile, level, namespace_, name_='CurrencyExchangeRate', pretty_print=pretty_print)
        for SpecialRatingApplied_ in self.SpecialRatingApplied:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SpecialRatingApplied>%s</ns:SpecialRatingApplied>%s' % (self.gds_encode(self.gds_format_string(quote_xml(SpecialRatingApplied_), input_name='SpecialRatingApplied')), eol_))
        if self.DimDivisor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DimDivisor>%s</ns:DimDivisor>%s' % (self.gds_format_integer(self.DimDivisor, input_name='DimDivisor'), eol_))
        if self.DimDivisorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DimDivisorType>%s</ns:DimDivisorType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DimDivisorType), input_name='DimDivisorType')), eol_))
        if self.FuelSurchargePercent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FuelSurchargePercent>%s</ns:FuelSurchargePercent>%s' % (self.gds_format_float(self.FuelSurchargePercent, input_name='FuelSurchargePercent'), eol_))
        if self.TotalBillingWeight is not None:
            self.TotalBillingWeight.export(outfile, level, namespace_, name_='TotalBillingWeight', pretty_print=pretty_print)
        if self.TotalDimWeight is not None:
            self.TotalDimWeight.export(outfile, level, namespace_, name_='TotalDimWeight', pretty_print=pretty_print)
        if self.TotalBaseCharge is not None:
            self.TotalBaseCharge.export(outfile, level, namespace_, name_='TotalBaseCharge', pretty_print=pretty_print)
        if self.TotalFreightDiscounts is not None:
            self.TotalFreightDiscounts.export(outfile, level, namespace_, name_='TotalFreightDiscounts', pretty_print=pretty_print)
        if self.TotalNetFreight is not None:
            self.TotalNetFreight.export(outfile, level, namespace_, name_='TotalNetFreight', pretty_print=pretty_print)
        if self.TotalSurcharges is not None:
            self.TotalSurcharges.export(outfile, level, namespace_, name_='TotalSurcharges', pretty_print=pretty_print)
        if self.TotalNetFedExCharge is not None:
            self.TotalNetFedExCharge.export(outfile, level, namespace_, name_='TotalNetFedExCharge', pretty_print=pretty_print)
        if self.TotalTaxes is not None:
            self.TotalTaxes.export(outfile, level, namespace_, name_='TotalTaxes', pretty_print=pretty_print)
        if self.TotalNetCharge is not None:
            self.TotalNetCharge.export(outfile, level, namespace_, name_='TotalNetCharge', pretty_print=pretty_print)
        if self.TotalRebates is not None:
            self.TotalRebates.export(outfile, level, namespace_, name_='TotalRebates', pretty_print=pretty_print)
        if self.TotalDutiesAndTaxes is not None:
            self.TotalDutiesAndTaxes.export(outfile, level, namespace_, name_='TotalDutiesAndTaxes', pretty_print=pretty_print)
        if self.TotalNetChargeWithDutiesAndTaxes is not None:
            self.TotalNetChargeWithDutiesAndTaxes.export(outfile, level, namespace_, name_='TotalNetChargeWithDutiesAndTaxes', pretty_print=pretty_print)
        if self.FreightRateDetail is not None:
            self.FreightRateDetail.export(outfile, level, namespace_, name_='FreightRateDetail', pretty_print=pretty_print)
        for FreightDiscounts_ in self.FreightDiscounts:
            FreightDiscounts_.export(outfile, level, namespace_, name_='FreightDiscounts', pretty_print=pretty_print)
        for Rebates_ in self.Rebates:
            Rebates_.export(outfile, level, namespace_, name_='Rebates', pretty_print=pretty_print)
        for Surcharges_ in self.Surcharges:
            Surcharges_.export(outfile, level, namespace_, name_='Surcharges', pretty_print=pretty_print)
        for Taxes_ in self.Taxes:
            Taxes_.export(outfile, level, namespace_, name_='Taxes', pretty_print=pretty_print)
        for DutiesAndTaxes_ in self.DutiesAndTaxes:
            DutiesAndTaxes_.export(outfile, level, namespace_, name_='DutiesAndTaxes', pretty_print=pretty_print)
        if self.VariableHandlingCharges is not None:
            self.VariableHandlingCharges.export(outfile, level, namespace_, name_='VariableHandlingCharges', pretty_print=pretty_print)
        if self.TotalVariableHandlingCharges is not None:
            self.TotalVariableHandlingCharges.export(outfile, level, namespace_, name_='TotalVariableHandlingCharges', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LegDescription':
            LegDescription_ = child_.text
            LegDescription_ = self.gds_validate_string(LegDescription_, node, 'LegDescription')
            self.LegDescription = LegDescription_
        elif nodeName_ == 'LegOrigin':
            obj_ = Address.factory()
            obj_.build(child_)
            self.LegOrigin = obj_
            obj_.original_tagname_ = 'LegOrigin'
        elif nodeName_ == 'LegOriginLocationId':
            LegOriginLocationId_ = child_.text
            LegOriginLocationId_ = self.gds_validate_string(LegOriginLocationId_, node, 'LegOriginLocationId')
            self.LegOriginLocationId = LegOriginLocationId_
        elif nodeName_ == 'LegDestination':
            obj_ = Address.factory()
            obj_.build(child_)
            self.LegDestination = obj_
            obj_.original_tagname_ = 'LegDestination'
        elif nodeName_ == 'LegDestinationLocationId':
            LegDestinationLocationId_ = child_.text
            LegDestinationLocationId_ = self.gds_validate_string(LegDestinationLocationId_, node, 'LegDestinationLocationId')
            self.LegDestinationLocationId = LegDestinationLocationId_
        elif nodeName_ == 'RateType':
            RateType_ = child_.text
            RateType_ = self.gds_validate_string(RateType_, node, 'RateType')
            self.RateType = RateType_
            # validate type ReturnedRateType
            self.validate_ReturnedRateType(self.RateType)
        elif nodeName_ == 'RateScale':
            RateScale_ = child_.text
            RateScale_ = self.gds_validate_string(RateScale_, node, 'RateScale')
            self.RateScale = RateScale_
        elif nodeName_ == 'RateZone':
            RateZone_ = child_.text
            RateZone_ = self.gds_validate_string(RateZone_, node, 'RateZone')
            self.RateZone = RateZone_
        elif nodeName_ == 'PricingCode':
            PricingCode_ = child_.text
            PricingCode_ = self.gds_validate_string(PricingCode_, node, 'PricingCode')
            self.PricingCode = PricingCode_
            # validate type PricingCodeType
            self.validate_PricingCodeType(self.PricingCode)
        elif nodeName_ == 'RatedWeightMethod':
            RatedWeightMethod_ = child_.text
            RatedWeightMethod_ = self.gds_validate_string(RatedWeightMethod_, node, 'RatedWeightMethod')
            self.RatedWeightMethod = RatedWeightMethod_
            # validate type RatedWeightMethod
            self.validate_RatedWeightMethod(self.RatedWeightMethod)
        elif nodeName_ == 'MinimumChargeType':
            MinimumChargeType_ = child_.text
            MinimumChargeType_ = self.gds_validate_string(MinimumChargeType_, node, 'MinimumChargeType')
            self.MinimumChargeType = MinimumChargeType_
            # validate type MinimumChargeType
            self.validate_MinimumChargeType(self.MinimumChargeType)
        elif nodeName_ == 'CurrencyExchangeRate':
            obj_ = CurrencyExchangeRate.factory()
            obj_.build(child_)
            self.CurrencyExchangeRate = obj_
            obj_.original_tagname_ = 'CurrencyExchangeRate'
        elif nodeName_ == 'SpecialRatingApplied':
            SpecialRatingApplied_ = child_.text
            SpecialRatingApplied_ = self.gds_validate_string(SpecialRatingApplied_, node, 'SpecialRatingApplied')
            self.SpecialRatingApplied.append(SpecialRatingApplied_)
            # validate type SpecialRatingAppliedType
            self.validate_SpecialRatingAppliedType(self.SpecialRatingApplied[-1])
        elif nodeName_ == 'DimDivisor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'DimDivisor')
            self.DimDivisor = ival_
        elif nodeName_ == 'DimDivisorType':
            DimDivisorType_ = child_.text
            DimDivisorType_ = self.gds_validate_string(DimDivisorType_, node, 'DimDivisorType')
            self.DimDivisorType = DimDivisorType_
            # validate type RateDimensionalDivisorType
            self.validate_RateDimensionalDivisorType(self.DimDivisorType)
        elif nodeName_ == 'FuelSurchargePercent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'FuelSurchargePercent')
            self.FuelSurchargePercent = fval_
        elif nodeName_ == 'TotalBillingWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.TotalBillingWeight = obj_
            obj_.original_tagname_ = 'TotalBillingWeight'
        elif nodeName_ == 'TotalDimWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.TotalDimWeight = obj_
            obj_.original_tagname_ = 'TotalDimWeight'
        elif nodeName_ == 'TotalBaseCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalBaseCharge = obj_
            obj_.original_tagname_ = 'TotalBaseCharge'
        elif nodeName_ == 'TotalFreightDiscounts':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalFreightDiscounts = obj_
            obj_.original_tagname_ = 'TotalFreightDiscounts'
        elif nodeName_ == 'TotalNetFreight':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalNetFreight = obj_
            obj_.original_tagname_ = 'TotalNetFreight'
        elif nodeName_ == 'TotalSurcharges':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalSurcharges = obj_
            obj_.original_tagname_ = 'TotalSurcharges'
        elif nodeName_ == 'TotalNetFedExCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalNetFedExCharge = obj_
            obj_.original_tagname_ = 'TotalNetFedExCharge'
        elif nodeName_ == 'TotalTaxes':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalTaxes = obj_
            obj_.original_tagname_ = 'TotalTaxes'
        elif nodeName_ == 'TotalNetCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalNetCharge = obj_
            obj_.original_tagname_ = 'TotalNetCharge'
        elif nodeName_ == 'TotalRebates':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalRebates = obj_
            obj_.original_tagname_ = 'TotalRebates'
        elif nodeName_ == 'TotalDutiesAndTaxes':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalDutiesAndTaxes = obj_
            obj_.original_tagname_ = 'TotalDutiesAndTaxes'
        elif nodeName_ == 'TotalNetChargeWithDutiesAndTaxes':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalNetChargeWithDutiesAndTaxes = obj_
            obj_.original_tagname_ = 'TotalNetChargeWithDutiesAndTaxes'
        elif nodeName_ == 'FreightRateDetail':
            obj_ = FreightRateDetail.factory()
            obj_.build(child_)
            self.FreightRateDetail = obj_
            obj_.original_tagname_ = 'FreightRateDetail'
        elif nodeName_ == 'FreightDiscounts':
            obj_ = RateDiscount.factory()
            obj_.build(child_)
            self.FreightDiscounts.append(obj_)
            obj_.original_tagname_ = 'FreightDiscounts'
        elif nodeName_ == 'Rebates':
            obj_ = Rebate.factory()
            obj_.build(child_)
            self.Rebates.append(obj_)
            obj_.original_tagname_ = 'Rebates'
        elif nodeName_ == 'Surcharges':
            obj_ = Surcharge.factory()
            obj_.build(child_)
            self.Surcharges.append(obj_)
            obj_.original_tagname_ = 'Surcharges'
        elif nodeName_ == 'Taxes':
            obj_ = Tax.factory()
            obj_.build(child_)
            self.Taxes.append(obj_)
            obj_.original_tagname_ = 'Taxes'
        elif nodeName_ == 'DutiesAndTaxes':
            obj_ = EdtCommodityTax.factory()
            obj_.build(child_)
            self.DutiesAndTaxes.append(obj_)
            obj_.original_tagname_ = 'DutiesAndTaxes'
        elif nodeName_ == 'VariableHandlingCharges':
            obj_ = VariableHandlingCharges.factory()
            obj_.build(child_)
            self.VariableHandlingCharges = obj_
            obj_.original_tagname_ = 'VariableHandlingCharges'
        elif nodeName_ == 'TotalVariableHandlingCharges':
            obj_ = VariableHandlingCharges.factory()
            obj_.build(child_)
            self.TotalVariableHandlingCharges = obj_
            obj_.original_tagname_ = 'TotalVariableHandlingCharges'
# end class ShipmentLegRateDetail


class ShipmentManifestDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ManifestReferenceType=None):
        self.original_tagname_ = None
        self.ManifestReferenceType = ManifestReferenceType
        self.validate_CustomerReferenceType(self.ManifestReferenceType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentManifestDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentManifestDetail.subclass:
            return ShipmentManifestDetail.subclass(*args_, **kwargs_)
        else:
            return ShipmentManifestDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ManifestReferenceType(self): return self.ManifestReferenceType
    def set_ManifestReferenceType(self, ManifestReferenceType): self.ManifestReferenceType = ManifestReferenceType
    def validate_CustomerReferenceType(self, value):
        # Validate type CustomerReferenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUSTOMER_REFERENCE', 'DEPARTMENT_NUMBER', 'INTRACOUNTRY_REGULATORY_REFERENCE', 'INVOICE_NUMBER', 'P_O_NUMBER', 'RMA_ASSOCIATION', 'SHIPMENT_INTEGRITY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CustomerReferenceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ManifestReferenceType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentManifestDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentManifestDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentManifestDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentManifestDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentManifestDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentManifestDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ManifestReferenceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ManifestReferenceType>%s</ns:ManifestReferenceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ManifestReferenceType), input_name='ManifestReferenceType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ManifestReferenceType':
            ManifestReferenceType_ = child_.text
            ManifestReferenceType_ = self.gds_validate_string(ManifestReferenceType_, node, 'ManifestReferenceType')
            self.ManifestReferenceType = ManifestReferenceType_
            # validate type CustomerReferenceType
            self.validate_CustomerReferenceType(self.ManifestReferenceType)
# end class ShipmentManifestDetail


class ShipmentNotificationFormatSpecification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_NotificationFormatType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentNotificationFormatSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentNotificationFormatSpecification.subclass:
            return ShipmentNotificationFormatSpecification.subclass(*args_, **kwargs_)
        else:
            return ShipmentNotificationFormatSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_NotificationFormatType(self, value):
        # Validate type NotificationFormatType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['HTML', 'TEXT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NotificationFormatType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentNotificationFormatSpecification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentNotificationFormatSpecification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentNotificationFormatSpecification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentNotificationFormatSpecification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentNotificationFormatSpecification'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentNotificationFormatSpecification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type NotificationFormatType
            self.validate_NotificationFormatType(self.Type)
# end class ShipmentNotificationFormatSpecification


class ShipmentOperationalDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UrsaPrefixCode=None, UrsaSuffixCode=None, OriginLocationId=None, OriginLocationNumber=None, OriginServiceArea=None, DestinationLocationId=None, DestinationLocationNumber=None, DestinationServiceArea=None, DestinationLocationStateOrProvinceCode=None, DeliveryDate=None, DeliveryDay=None, PublishedDeliveryTime=None, CommitDate=None, CommitDay=None, TransitTime=None, MaximumTransitTime=None, CustomTransitTime=None, IneligibleForMoneyBackGuarantee=None, DeliveryEligibilities=None, AstraPlannedServiceLevel=None, AstraDescription=None, PostalCode=None, StateOrProvinceCode=None, CountryCode=None, AirportId=None, ServiceCode=None, PackagingCode=None, Scac=None):
        self.original_tagname_ = None
        self.UrsaPrefixCode = UrsaPrefixCode
        self.UrsaSuffixCode = UrsaSuffixCode
        self.OriginLocationId = OriginLocationId
        self.OriginLocationNumber = OriginLocationNumber
        self.OriginServiceArea = OriginServiceArea
        self.DestinationLocationId = DestinationLocationId
        self.DestinationLocationNumber = DestinationLocationNumber
        self.DestinationServiceArea = DestinationServiceArea
        self.DestinationLocationStateOrProvinceCode = DestinationLocationStateOrProvinceCode
        if isinstance(DeliveryDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DeliveryDate, '%Y-%m-%d').date()
        else:
            initvalue_ = DeliveryDate
        self.DeliveryDate = initvalue_
        self.DeliveryDay = DeliveryDay
        self.validate_DayOfWeekType(self.DeliveryDay)
        if isinstance(PublishedDeliveryTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PublishedDeliveryTime, '%H:%M:%S').time()
        else:
            initvalue_ = PublishedDeliveryTime
        self.PublishedDeliveryTime = initvalue_
        if isinstance(CommitDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(CommitDate, '%Y-%m-%d').date()
        else:
            initvalue_ = CommitDate
        self.CommitDate = initvalue_
        self.CommitDay = CommitDay
        self.validate_DayOfWeekType(self.CommitDay)
        self.TransitTime = TransitTime
        self.validate_TransitTimeType(self.TransitTime)
        self.MaximumTransitTime = MaximumTransitTime
        self.validate_TransitTimeType(self.MaximumTransitTime)
        self.CustomTransitTime = CustomTransitTime
        self.validate_TransitTimeType(self.CustomTransitTime)
        self.IneligibleForMoneyBackGuarantee = IneligibleForMoneyBackGuarantee
        if DeliveryEligibilities is None:
            self.DeliveryEligibilities = []
        else:
            self.DeliveryEligibilities = DeliveryEligibilities
        self.AstraPlannedServiceLevel = AstraPlannedServiceLevel
        self.AstraDescription = AstraDescription
        self.PostalCode = PostalCode
        self.StateOrProvinceCode = StateOrProvinceCode
        self.CountryCode = CountryCode
        self.AirportId = AirportId
        self.ServiceCode = ServiceCode
        self.PackagingCode = PackagingCode
        self.Scac = Scac
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentOperationalDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentOperationalDetail.subclass:
            return ShipmentOperationalDetail.subclass(*args_, **kwargs_)
        else:
            return ShipmentOperationalDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UrsaPrefixCode(self): return self.UrsaPrefixCode
    def set_UrsaPrefixCode(self, UrsaPrefixCode): self.UrsaPrefixCode = UrsaPrefixCode
    def get_UrsaSuffixCode(self): return self.UrsaSuffixCode
    def set_UrsaSuffixCode(self, UrsaSuffixCode): self.UrsaSuffixCode = UrsaSuffixCode
    def get_OriginLocationId(self): return self.OriginLocationId
    def set_OriginLocationId(self, OriginLocationId): self.OriginLocationId = OriginLocationId
    def get_OriginLocationNumber(self): return self.OriginLocationNumber
    def set_OriginLocationNumber(self, OriginLocationNumber): self.OriginLocationNumber = OriginLocationNumber
    def get_OriginServiceArea(self): return self.OriginServiceArea
    def set_OriginServiceArea(self, OriginServiceArea): self.OriginServiceArea = OriginServiceArea
    def get_DestinationLocationId(self): return self.DestinationLocationId
    def set_DestinationLocationId(self, DestinationLocationId): self.DestinationLocationId = DestinationLocationId
    def get_DestinationLocationNumber(self): return self.DestinationLocationNumber
    def set_DestinationLocationNumber(self, DestinationLocationNumber): self.DestinationLocationNumber = DestinationLocationNumber
    def get_DestinationServiceArea(self): return self.DestinationServiceArea
    def set_DestinationServiceArea(self, DestinationServiceArea): self.DestinationServiceArea = DestinationServiceArea
    def get_DestinationLocationStateOrProvinceCode(self): return self.DestinationLocationStateOrProvinceCode
    def set_DestinationLocationStateOrProvinceCode(self, DestinationLocationStateOrProvinceCode): self.DestinationLocationStateOrProvinceCode = DestinationLocationStateOrProvinceCode
    def get_DeliveryDate(self): return self.DeliveryDate
    def set_DeliveryDate(self, DeliveryDate): self.DeliveryDate = DeliveryDate
    def get_DeliveryDay(self): return self.DeliveryDay
    def set_DeliveryDay(self, DeliveryDay): self.DeliveryDay = DeliveryDay
    def get_PublishedDeliveryTime(self): return self.PublishedDeliveryTime
    def set_PublishedDeliveryTime(self, PublishedDeliveryTime): self.PublishedDeliveryTime = PublishedDeliveryTime
    def get_CommitDate(self): return self.CommitDate
    def set_CommitDate(self, CommitDate): self.CommitDate = CommitDate
    def get_CommitDay(self): return self.CommitDay
    def set_CommitDay(self, CommitDay): self.CommitDay = CommitDay
    def get_TransitTime(self): return self.TransitTime
    def set_TransitTime(self, TransitTime): self.TransitTime = TransitTime
    def get_MaximumTransitTime(self): return self.MaximumTransitTime
    def set_MaximumTransitTime(self, MaximumTransitTime): self.MaximumTransitTime = MaximumTransitTime
    def get_CustomTransitTime(self): return self.CustomTransitTime
    def set_CustomTransitTime(self, CustomTransitTime): self.CustomTransitTime = CustomTransitTime
    def get_IneligibleForMoneyBackGuarantee(self): return self.IneligibleForMoneyBackGuarantee
    def set_IneligibleForMoneyBackGuarantee(self, IneligibleForMoneyBackGuarantee): self.IneligibleForMoneyBackGuarantee = IneligibleForMoneyBackGuarantee
    def get_DeliveryEligibilities(self): return self.DeliveryEligibilities
    def set_DeliveryEligibilities(self, DeliveryEligibilities): self.DeliveryEligibilities = DeliveryEligibilities
    def add_DeliveryEligibilities(self, value): self.DeliveryEligibilities.append(value)
    def insert_DeliveryEligibilities_at(self, index, value): self.DeliveryEligibilities.insert(index, value)
    def replace_DeliveryEligibilities_at(self, index, value): self.DeliveryEligibilities[index] = value
    def get_AstraPlannedServiceLevel(self): return self.AstraPlannedServiceLevel
    def set_AstraPlannedServiceLevel(self, AstraPlannedServiceLevel): self.AstraPlannedServiceLevel = AstraPlannedServiceLevel
    def get_AstraDescription(self): return self.AstraDescription
    def set_AstraDescription(self, AstraDescription): self.AstraDescription = AstraDescription
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_StateOrProvinceCode(self): return self.StateOrProvinceCode
    def set_StateOrProvinceCode(self, StateOrProvinceCode): self.StateOrProvinceCode = StateOrProvinceCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_AirportId(self): return self.AirportId
    def set_AirportId(self, AirportId): self.AirportId = AirportId
    def get_ServiceCode(self): return self.ServiceCode
    def set_ServiceCode(self, ServiceCode): self.ServiceCode = ServiceCode
    def get_PackagingCode(self): return self.PackagingCode
    def set_PackagingCode(self, PackagingCode): self.PackagingCode = PackagingCode
    def get_Scac(self): return self.Scac
    def set_Scac(self, Scac): self.Scac = Scac
    def validate_DayOfWeekType(self, value):
        # Validate type DayOfWeekType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FRI', 'MON', 'SAT', 'SUN', 'THU', 'TUE', 'WED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DayOfWeekType' % {"value" : value.encode("utf-8")} )
    def validate_TransitTimeType(self, value):
        # Validate type TransitTimeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EIGHTEEN_DAYS', 'EIGHT_DAYS', 'ELEVEN_DAYS', 'FIFTEEN_DAYS', 'FIVE_DAYS', 'FOURTEEN_DAYS', 'FOUR_DAYS', 'NINETEEN_DAYS', 'NINE_DAYS', 'ONE_DAY', 'SEVENTEEN_DAYS', 'SEVEN_DAYS', 'SIXTEEN_DAYS', 'SIX_DAYS', 'TEN_DAYS', 'THIRTEEN_DAYS', 'THREE_DAYS', 'TWELVE_DAYS', 'TWENTY_DAYS', 'TWO_DAYS', 'UNKNOWN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TransitTimeType' % {"value" : value.encode("utf-8")} )
    def validate_GroundDeliveryEligibilityType(self, value):
        # Validate type GroundDeliveryEligibilityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ALTERNATE_DAY_SERVICE', 'CARTAGE_AGENT_DELIVERY', 'SATURDAY_DELIVERY', 'USPS_DELIVERY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on GroundDeliveryEligibilityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.UrsaPrefixCode is not None or
            self.UrsaSuffixCode is not None or
            self.OriginLocationId is not None or
            self.OriginLocationNumber is not None or
            self.OriginServiceArea is not None or
            self.DestinationLocationId is not None or
            self.DestinationLocationNumber is not None or
            self.DestinationServiceArea is not None or
            self.DestinationLocationStateOrProvinceCode is not None or
            self.DeliveryDate is not None or
            self.DeliveryDay is not None or
            self.PublishedDeliveryTime is not None or
            self.CommitDate is not None or
            self.CommitDay is not None or
            self.TransitTime is not None or
            self.MaximumTransitTime is not None or
            self.CustomTransitTime is not None or
            self.IneligibleForMoneyBackGuarantee is not None or
            self.DeliveryEligibilities or
            self.AstraPlannedServiceLevel is not None or
            self.AstraDescription is not None or
            self.PostalCode is not None or
            self.StateOrProvinceCode is not None or
            self.CountryCode is not None or
            self.AirportId is not None or
            self.ServiceCode is not None or
            self.PackagingCode is not None or
            self.Scac is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentOperationalDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentOperationalDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentOperationalDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentOperationalDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentOperationalDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentOperationalDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UrsaPrefixCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:UrsaPrefixCode>%s</ns:UrsaPrefixCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UrsaPrefixCode), input_name='UrsaPrefixCode')), eol_))
        if self.UrsaSuffixCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:UrsaSuffixCode>%s</ns:UrsaSuffixCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UrsaSuffixCode), input_name='UrsaSuffixCode')), eol_))
        if self.OriginLocationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:OriginLocationId>%s</ns:OriginLocationId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginLocationId), input_name='OriginLocationId')), eol_))
        if self.OriginLocationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:OriginLocationNumber>%s</ns:OriginLocationNumber>%s' % (self.gds_format_integer(self.OriginLocationNumber, input_name='OriginLocationNumber'), eol_))
        if self.OriginServiceArea is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:OriginServiceArea>%s</ns:OriginServiceArea>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginServiceArea), input_name='OriginServiceArea')), eol_))
        if self.DestinationLocationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DestinationLocationId>%s</ns:DestinationLocationId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationLocationId), input_name='DestinationLocationId')), eol_))
        if self.DestinationLocationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DestinationLocationNumber>%s</ns:DestinationLocationNumber>%s' % (self.gds_format_integer(self.DestinationLocationNumber, input_name='DestinationLocationNumber'), eol_))
        if self.DestinationServiceArea is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DestinationServiceArea>%s</ns:DestinationServiceArea>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationServiceArea), input_name='DestinationServiceArea')), eol_))
        if self.DestinationLocationStateOrProvinceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DestinationLocationStateOrProvinceCode>%s</ns:DestinationLocationStateOrProvinceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationLocationStateOrProvinceCode), input_name='DestinationLocationStateOrProvinceCode')), eol_))
        if self.DeliveryDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DeliveryDate>%s</ns:DeliveryDate>%s' % (self.gds_format_date(self.DeliveryDate, input_name='DeliveryDate'), eol_))
        if self.DeliveryDay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DeliveryDay>%s</ns:DeliveryDay>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryDay), input_name='DeliveryDay')), eol_))
        if self.PublishedDeliveryTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PublishedDeliveryTime>%s</ns:PublishedDeliveryTime>%s' % (self.gds_format_time(self.PublishedDeliveryTime, input_name='PublishedDeliveryTime'), eol_))
        if self.CommitDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CommitDate>%s</ns:CommitDate>%s' % (self.gds_format_date(self.CommitDate, input_name='CommitDate'), eol_))
        if self.CommitDay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CommitDay>%s</ns:CommitDay>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CommitDay), input_name='CommitDay')), eol_))
        if self.TransitTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TransitTime>%s</ns:TransitTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransitTime), input_name='TransitTime')), eol_))
        if self.MaximumTransitTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:MaximumTransitTime>%s</ns:MaximumTransitTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MaximumTransitTime), input_name='MaximumTransitTime')), eol_))
        if self.CustomTransitTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomTransitTime>%s</ns:CustomTransitTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomTransitTime), input_name='CustomTransitTime')), eol_))
        if self.IneligibleForMoneyBackGuarantee is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:IneligibleForMoneyBackGuarantee>%s</ns:IneligibleForMoneyBackGuarantee>%s' % (self.gds_format_boolean(self.IneligibleForMoneyBackGuarantee, input_name='IneligibleForMoneyBackGuarantee'), eol_))
        for DeliveryEligibilities_ in self.DeliveryEligibilities:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DeliveryEligibilities>%s</ns:DeliveryEligibilities>%s' % (self.gds_encode(self.gds_format_string(quote_xml(DeliveryEligibilities_), input_name='DeliveryEligibilities')), eol_))
        if self.AstraPlannedServiceLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AstraPlannedServiceLevel>%s</ns:AstraPlannedServiceLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AstraPlannedServiceLevel), input_name='AstraPlannedServiceLevel')), eol_))
        if self.AstraDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AstraDescription>%s</ns:AstraDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AstraDescription), input_name='AstraDescription')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PostalCode>%s</ns:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.StateOrProvinceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:StateOrProvinceCode>%s</ns:StateOrProvinceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateOrProvinceCode), input_name='StateOrProvinceCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CountryCode>%s</ns:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.AirportId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AirportId>%s</ns:AirportId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AirportId), input_name='AirportId')), eol_))
        if self.ServiceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ServiceCode>%s</ns:ServiceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceCode), input_name='ServiceCode')), eol_))
        if self.PackagingCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackagingCode>%s</ns:PackagingCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackagingCode), input_name='PackagingCode')), eol_))
        if self.Scac is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Scac>%s</ns:Scac>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Scac), input_name='Scac')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UrsaPrefixCode':
            UrsaPrefixCode_ = child_.text
            UrsaPrefixCode_ = self.gds_validate_string(UrsaPrefixCode_, node, 'UrsaPrefixCode')
            self.UrsaPrefixCode = UrsaPrefixCode_
        elif nodeName_ == 'UrsaSuffixCode':
            UrsaSuffixCode_ = child_.text
            UrsaSuffixCode_ = self.gds_validate_string(UrsaSuffixCode_, node, 'UrsaSuffixCode')
            self.UrsaSuffixCode = UrsaSuffixCode_
        elif nodeName_ == 'OriginLocationId':
            OriginLocationId_ = child_.text
            OriginLocationId_ = self.gds_validate_string(OriginLocationId_, node, 'OriginLocationId')
            self.OriginLocationId = OriginLocationId_
        elif nodeName_ == 'OriginLocationNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OriginLocationNumber')
            self.OriginLocationNumber = ival_
        elif nodeName_ == 'OriginServiceArea':
            OriginServiceArea_ = child_.text
            OriginServiceArea_ = self.gds_validate_string(OriginServiceArea_, node, 'OriginServiceArea')
            self.OriginServiceArea = OriginServiceArea_
        elif nodeName_ == 'DestinationLocationId':
            DestinationLocationId_ = child_.text
            DestinationLocationId_ = self.gds_validate_string(DestinationLocationId_, node, 'DestinationLocationId')
            self.DestinationLocationId = DestinationLocationId_
        elif nodeName_ == 'DestinationLocationNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DestinationLocationNumber')
            self.DestinationLocationNumber = ival_
        elif nodeName_ == 'DestinationServiceArea':
            DestinationServiceArea_ = child_.text
            DestinationServiceArea_ = self.gds_validate_string(DestinationServiceArea_, node, 'DestinationServiceArea')
            self.DestinationServiceArea = DestinationServiceArea_
        elif nodeName_ == 'DestinationLocationStateOrProvinceCode':
            DestinationLocationStateOrProvinceCode_ = child_.text
            DestinationLocationStateOrProvinceCode_ = self.gds_validate_string(DestinationLocationStateOrProvinceCode_, node, 'DestinationLocationStateOrProvinceCode')
            self.DestinationLocationStateOrProvinceCode = DestinationLocationStateOrProvinceCode_
        elif nodeName_ == 'DeliveryDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DeliveryDate = dval_
        elif nodeName_ == 'DeliveryDay':
            DeliveryDay_ = child_.text
            DeliveryDay_ = self.gds_validate_string(DeliveryDay_, node, 'DeliveryDay')
            self.DeliveryDay = DeliveryDay_
            # validate type DayOfWeekType
            self.validate_DayOfWeekType(self.DeliveryDay)
        elif nodeName_ == 'PublishedDeliveryTime':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.PublishedDeliveryTime = dval_
        elif nodeName_ == 'CommitDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.CommitDate = dval_
        elif nodeName_ == 'CommitDay':
            CommitDay_ = child_.text
            CommitDay_ = self.gds_validate_string(CommitDay_, node, 'CommitDay')
            self.CommitDay = CommitDay_
            # validate type DayOfWeekType
            self.validate_DayOfWeekType(self.CommitDay)
        elif nodeName_ == 'TransitTime':
            TransitTime_ = child_.text
            TransitTime_ = self.gds_validate_string(TransitTime_, node, 'TransitTime')
            self.TransitTime = TransitTime_
            # validate type TransitTimeType
            self.validate_TransitTimeType(self.TransitTime)
        elif nodeName_ == 'MaximumTransitTime':
            MaximumTransitTime_ = child_.text
            MaximumTransitTime_ = self.gds_validate_string(MaximumTransitTime_, node, 'MaximumTransitTime')
            self.MaximumTransitTime = MaximumTransitTime_
            # validate type TransitTimeType
            self.validate_TransitTimeType(self.MaximumTransitTime)
        elif nodeName_ == 'CustomTransitTime':
            CustomTransitTime_ = child_.text
            CustomTransitTime_ = self.gds_validate_string(CustomTransitTime_, node, 'CustomTransitTime')
            self.CustomTransitTime = CustomTransitTime_
            # validate type TransitTimeType
            self.validate_TransitTimeType(self.CustomTransitTime)
        elif nodeName_ == 'IneligibleForMoneyBackGuarantee':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IneligibleForMoneyBackGuarantee')
            self.IneligibleForMoneyBackGuarantee = ival_
        elif nodeName_ == 'DeliveryEligibilities':
            DeliveryEligibilities_ = child_.text
            DeliveryEligibilities_ = self.gds_validate_string(DeliveryEligibilities_, node, 'DeliveryEligibilities')
            self.DeliveryEligibilities.append(DeliveryEligibilities_)
            # validate type GroundDeliveryEligibilityType
            self.validate_GroundDeliveryEligibilityType(self.DeliveryEligibilities[-1])
        elif nodeName_ == 'AstraPlannedServiceLevel':
            AstraPlannedServiceLevel_ = child_.text
            AstraPlannedServiceLevel_ = self.gds_validate_string(AstraPlannedServiceLevel_, node, 'AstraPlannedServiceLevel')
            self.AstraPlannedServiceLevel = AstraPlannedServiceLevel_
        elif nodeName_ == 'AstraDescription':
            AstraDescription_ = child_.text
            AstraDescription_ = self.gds_validate_string(AstraDescription_, node, 'AstraDescription')
            self.AstraDescription = AstraDescription_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'StateOrProvinceCode':
            StateOrProvinceCode_ = child_.text
            StateOrProvinceCode_ = self.gds_validate_string(StateOrProvinceCode_, node, 'StateOrProvinceCode')
            self.StateOrProvinceCode = StateOrProvinceCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
        elif nodeName_ == 'AirportId':
            AirportId_ = child_.text
            AirportId_ = self.gds_validate_string(AirportId_, node, 'AirportId')
            self.AirportId = AirportId_
        elif nodeName_ == 'ServiceCode':
            ServiceCode_ = child_.text
            ServiceCode_ = self.gds_validate_string(ServiceCode_, node, 'ServiceCode')
            self.ServiceCode = ServiceCode_
        elif nodeName_ == 'PackagingCode':
            PackagingCode_ = child_.text
            PackagingCode_ = self.gds_validate_string(PackagingCode_, node, 'PackagingCode')
            self.PackagingCode = PackagingCode_
        elif nodeName_ == 'Scac':
            Scac_ = child_.text
            Scac_ = self.gds_validate_string(Scac_, node, 'Scac')
            self.Scac = Scac_
# end class ShipmentOperationalDetail


class ShipmentRateDetail(GeneratedsSuper):
    """Data for a shipment's total/summary rates, as calculated per a
    specific rate type. The "total..." fields may differ from the
    sum of corresponding package data for Multiweight or Express
    MPS."""
    subclass = None
    superclass = None
    def __init__(self, RateType=None, RateScale=None, RateZone=None, PricingCode=None, RatedWeightMethod=None, MinimumChargeType=None, CurrencyExchangeRate=None, SpecialRatingApplied=None, DimDivisor=None, DimDivisorType=None, FuelSurchargePercent=None, TotalBillingWeight=None, TotalDimWeight=None, TotalBaseCharge=None, TotalFreightDiscounts=None, TotalNetFreight=None, TotalSurcharges=None, TotalNetFedExCharge=None, TotalTaxes=None, TotalNetCharge=None, TotalRebates=None, TotalDutiesAndTaxes=None, TotalAncillaryFeesAndTaxes=None, TotalDutiesTaxesAndFees=None, TotalNetChargeWithDutiesAndTaxes=None, ShipmentLegRateDetails=None, FreightRateDetail=None, FreightDiscounts=None, Rebates=None, Surcharges=None, Taxes=None, DutiesAndTaxes=None, AncillaryFeesAndTaxes=None, VariableHandlingCharges=None, TotalVariableHandlingCharges=None):
        self.original_tagname_ = None
        self.RateType = RateType
        self.validate_ReturnedRateType(self.RateType)
        self.RateScale = RateScale
        self.RateZone = RateZone
        self.PricingCode = PricingCode
        self.validate_PricingCodeType(self.PricingCode)
        self.RatedWeightMethod = RatedWeightMethod
        self.validate_RatedWeightMethod(self.RatedWeightMethod)
        self.MinimumChargeType = MinimumChargeType
        self.validate_MinimumChargeType(self.MinimumChargeType)
        self.CurrencyExchangeRate = CurrencyExchangeRate
        if SpecialRatingApplied is None:
            self.SpecialRatingApplied = []
        else:
            self.SpecialRatingApplied = SpecialRatingApplied
        self.DimDivisor = DimDivisor
        self.DimDivisorType = DimDivisorType
        self.validate_RateDimensionalDivisorType(self.DimDivisorType)
        self.FuelSurchargePercent = FuelSurchargePercent
        self.TotalBillingWeight = TotalBillingWeight
        self.TotalDimWeight = TotalDimWeight
        self.TotalBaseCharge = TotalBaseCharge
        self.TotalFreightDiscounts = TotalFreightDiscounts
        self.TotalNetFreight = TotalNetFreight
        self.TotalSurcharges = TotalSurcharges
        self.TotalNetFedExCharge = TotalNetFedExCharge
        self.TotalTaxes = TotalTaxes
        self.TotalNetCharge = TotalNetCharge
        self.TotalRebates = TotalRebates
        self.TotalDutiesAndTaxes = TotalDutiesAndTaxes
        self.TotalAncillaryFeesAndTaxes = TotalAncillaryFeesAndTaxes
        self.TotalDutiesTaxesAndFees = TotalDutiesTaxesAndFees
        self.TotalNetChargeWithDutiesAndTaxes = TotalNetChargeWithDutiesAndTaxes
        if ShipmentLegRateDetails is None:
            self.ShipmentLegRateDetails = []
        else:
            self.ShipmentLegRateDetails = ShipmentLegRateDetails
        self.FreightRateDetail = FreightRateDetail
        if FreightDiscounts is None:
            self.FreightDiscounts = []
        else:
            self.FreightDiscounts = FreightDiscounts
        if Rebates is None:
            self.Rebates = []
        else:
            self.Rebates = Rebates
        if Surcharges is None:
            self.Surcharges = []
        else:
            self.Surcharges = Surcharges
        if Taxes is None:
            self.Taxes = []
        else:
            self.Taxes = Taxes
        if DutiesAndTaxes is None:
            self.DutiesAndTaxes = []
        else:
            self.DutiesAndTaxes = DutiesAndTaxes
        if AncillaryFeesAndTaxes is None:
            self.AncillaryFeesAndTaxes = []
        else:
            self.AncillaryFeesAndTaxes = AncillaryFeesAndTaxes
        self.VariableHandlingCharges = VariableHandlingCharges
        self.TotalVariableHandlingCharges = TotalVariableHandlingCharges
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentRateDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentRateDetail.subclass:
            return ShipmentRateDetail.subclass(*args_, **kwargs_)
        else:
            return ShipmentRateDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RateType(self): return self.RateType
    def set_RateType(self, RateType): self.RateType = RateType
    def get_RateScale(self): return self.RateScale
    def set_RateScale(self, RateScale): self.RateScale = RateScale
    def get_RateZone(self): return self.RateZone
    def set_RateZone(self, RateZone): self.RateZone = RateZone
    def get_PricingCode(self): return self.PricingCode
    def set_PricingCode(self, PricingCode): self.PricingCode = PricingCode
    def get_RatedWeightMethod(self): return self.RatedWeightMethod
    def set_RatedWeightMethod(self, RatedWeightMethod): self.RatedWeightMethod = RatedWeightMethod
    def get_MinimumChargeType(self): return self.MinimumChargeType
    def set_MinimumChargeType(self, MinimumChargeType): self.MinimumChargeType = MinimumChargeType
    def get_CurrencyExchangeRate(self): return self.CurrencyExchangeRate
    def set_CurrencyExchangeRate(self, CurrencyExchangeRate): self.CurrencyExchangeRate = CurrencyExchangeRate
    def get_SpecialRatingApplied(self): return self.SpecialRatingApplied
    def set_SpecialRatingApplied(self, SpecialRatingApplied): self.SpecialRatingApplied = SpecialRatingApplied
    def add_SpecialRatingApplied(self, value): self.SpecialRatingApplied.append(value)
    def insert_SpecialRatingApplied_at(self, index, value): self.SpecialRatingApplied.insert(index, value)
    def replace_SpecialRatingApplied_at(self, index, value): self.SpecialRatingApplied[index] = value
    def get_DimDivisor(self): return self.DimDivisor
    def set_DimDivisor(self, DimDivisor): self.DimDivisor = DimDivisor
    def get_DimDivisorType(self): return self.DimDivisorType
    def set_DimDivisorType(self, DimDivisorType): self.DimDivisorType = DimDivisorType
    def get_FuelSurchargePercent(self): return self.FuelSurchargePercent
    def set_FuelSurchargePercent(self, FuelSurchargePercent): self.FuelSurchargePercent = FuelSurchargePercent
    def get_TotalBillingWeight(self): return self.TotalBillingWeight
    def set_TotalBillingWeight(self, TotalBillingWeight): self.TotalBillingWeight = TotalBillingWeight
    def get_TotalDimWeight(self): return self.TotalDimWeight
    def set_TotalDimWeight(self, TotalDimWeight): self.TotalDimWeight = TotalDimWeight
    def get_TotalBaseCharge(self): return self.TotalBaseCharge
    def set_TotalBaseCharge(self, TotalBaseCharge): self.TotalBaseCharge = TotalBaseCharge
    def get_TotalFreightDiscounts(self): return self.TotalFreightDiscounts
    def set_TotalFreightDiscounts(self, TotalFreightDiscounts): self.TotalFreightDiscounts = TotalFreightDiscounts
    def get_TotalNetFreight(self): return self.TotalNetFreight
    def set_TotalNetFreight(self, TotalNetFreight): self.TotalNetFreight = TotalNetFreight
    def get_TotalSurcharges(self): return self.TotalSurcharges
    def set_TotalSurcharges(self, TotalSurcharges): self.TotalSurcharges = TotalSurcharges
    def get_TotalNetFedExCharge(self): return self.TotalNetFedExCharge
    def set_TotalNetFedExCharge(self, TotalNetFedExCharge): self.TotalNetFedExCharge = TotalNetFedExCharge
    def get_TotalTaxes(self): return self.TotalTaxes
    def set_TotalTaxes(self, TotalTaxes): self.TotalTaxes = TotalTaxes
    def get_TotalNetCharge(self): return self.TotalNetCharge
    def set_TotalNetCharge(self, TotalNetCharge): self.TotalNetCharge = TotalNetCharge
    def get_TotalRebates(self): return self.TotalRebates
    def set_TotalRebates(self, TotalRebates): self.TotalRebates = TotalRebates
    def get_TotalDutiesAndTaxes(self): return self.TotalDutiesAndTaxes
    def set_TotalDutiesAndTaxes(self, TotalDutiesAndTaxes): self.TotalDutiesAndTaxes = TotalDutiesAndTaxes
    def get_TotalAncillaryFeesAndTaxes(self): return self.TotalAncillaryFeesAndTaxes
    def set_TotalAncillaryFeesAndTaxes(self, TotalAncillaryFeesAndTaxes): self.TotalAncillaryFeesAndTaxes = TotalAncillaryFeesAndTaxes
    def get_TotalDutiesTaxesAndFees(self): return self.TotalDutiesTaxesAndFees
    def set_TotalDutiesTaxesAndFees(self, TotalDutiesTaxesAndFees): self.TotalDutiesTaxesAndFees = TotalDutiesTaxesAndFees
    def get_TotalNetChargeWithDutiesAndTaxes(self): return self.TotalNetChargeWithDutiesAndTaxes
    def set_TotalNetChargeWithDutiesAndTaxes(self, TotalNetChargeWithDutiesAndTaxes): self.TotalNetChargeWithDutiesAndTaxes = TotalNetChargeWithDutiesAndTaxes
    def get_ShipmentLegRateDetails(self): return self.ShipmentLegRateDetails
    def set_ShipmentLegRateDetails(self, ShipmentLegRateDetails): self.ShipmentLegRateDetails = ShipmentLegRateDetails
    def add_ShipmentLegRateDetails(self, value): self.ShipmentLegRateDetails.append(value)
    def insert_ShipmentLegRateDetails_at(self, index, value): self.ShipmentLegRateDetails.insert(index, value)
    def replace_ShipmentLegRateDetails_at(self, index, value): self.ShipmentLegRateDetails[index] = value
    def get_FreightRateDetail(self): return self.FreightRateDetail
    def set_FreightRateDetail(self, FreightRateDetail): self.FreightRateDetail = FreightRateDetail
    def get_FreightDiscounts(self): return self.FreightDiscounts
    def set_FreightDiscounts(self, FreightDiscounts): self.FreightDiscounts = FreightDiscounts
    def add_FreightDiscounts(self, value): self.FreightDiscounts.append(value)
    def insert_FreightDiscounts_at(self, index, value): self.FreightDiscounts.insert(index, value)
    def replace_FreightDiscounts_at(self, index, value): self.FreightDiscounts[index] = value
    def get_Rebates(self): return self.Rebates
    def set_Rebates(self, Rebates): self.Rebates = Rebates
    def add_Rebates(self, value): self.Rebates.append(value)
    def insert_Rebates_at(self, index, value): self.Rebates.insert(index, value)
    def replace_Rebates_at(self, index, value): self.Rebates[index] = value
    def get_Surcharges(self): return self.Surcharges
    def set_Surcharges(self, Surcharges): self.Surcharges = Surcharges
    def add_Surcharges(self, value): self.Surcharges.append(value)
    def insert_Surcharges_at(self, index, value): self.Surcharges.insert(index, value)
    def replace_Surcharges_at(self, index, value): self.Surcharges[index] = value
    def get_Taxes(self): return self.Taxes
    def set_Taxes(self, Taxes): self.Taxes = Taxes
    def add_Taxes(self, value): self.Taxes.append(value)
    def insert_Taxes_at(self, index, value): self.Taxes.insert(index, value)
    def replace_Taxes_at(self, index, value): self.Taxes[index] = value
    def get_DutiesAndTaxes(self): return self.DutiesAndTaxes
    def set_DutiesAndTaxes(self, DutiesAndTaxes): self.DutiesAndTaxes = DutiesAndTaxes
    def add_DutiesAndTaxes(self, value): self.DutiesAndTaxes.append(value)
    def insert_DutiesAndTaxes_at(self, index, value): self.DutiesAndTaxes.insert(index, value)
    def replace_DutiesAndTaxes_at(self, index, value): self.DutiesAndTaxes[index] = value
    def get_AncillaryFeesAndTaxes(self): return self.AncillaryFeesAndTaxes
    def set_AncillaryFeesAndTaxes(self, AncillaryFeesAndTaxes): self.AncillaryFeesAndTaxes = AncillaryFeesAndTaxes
    def add_AncillaryFeesAndTaxes(self, value): self.AncillaryFeesAndTaxes.append(value)
    def insert_AncillaryFeesAndTaxes_at(self, index, value): self.AncillaryFeesAndTaxes.insert(index, value)
    def replace_AncillaryFeesAndTaxes_at(self, index, value): self.AncillaryFeesAndTaxes[index] = value
    def get_VariableHandlingCharges(self): return self.VariableHandlingCharges
    def set_VariableHandlingCharges(self, VariableHandlingCharges): self.VariableHandlingCharges = VariableHandlingCharges
    def get_TotalVariableHandlingCharges(self): return self.TotalVariableHandlingCharges
    def set_TotalVariableHandlingCharges(self, TotalVariableHandlingCharges): self.TotalVariableHandlingCharges = TotalVariableHandlingCharges
    def validate_ReturnedRateType(self, value):
        # Validate type ReturnedRateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INCENTIVE', 'NEGOTIATED', 'PAYOR_ACCOUNT_PACKAGE', 'PAYOR_ACCOUNT_SHIPMENT', 'PAYOR_LIST_PACKAGE', 'PAYOR_LIST_SHIPMENT', 'PREFERRED_ACCOUNT_PACKAGE', 'PREFERRED_ACCOUNT_SHIPMENT', 'PREFERRED_LIST_PACKAGE', 'PREFERRED_LIST_SHIPMENT', 'PREFERRED_NEGOTIATED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReturnedRateType' % {"value" : value.encode("utf-8")} )
    def validate_PricingCodeType(self, value):
        # Validate type PricingCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACTUAL', 'ALTERNATE', 'BASE', 'HUNDREDWEIGHT', 'HUNDREDWEIGHT_ALTERNATE', 'INTERNATIONAL_DISTRIBUTION', 'INTERNATIONAL_ECONOMY_SERVICE', 'LTL_FREIGHT', 'PACKAGE', 'SHIPMENT', 'SHIPMENT_FIVE_POUND_OPTIONAL', 'SHIPMENT_OPTIONAL', 'SPECIAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PricingCodeType' % {"value" : value.encode("utf-8")} )
    def validate_RatedWeightMethod(self, value):
        # Validate type RatedWeightMethod, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACTUAL', 'AVERAGE_PACKAGE_WEIGHT_MINIMUM', 'BALLOON', 'DEFAULT_WEIGHT_APPLIED', 'DIM', 'FREIGHT_MINIMUM', 'MIXED', 'OVERSIZE', 'OVERSIZE_1', 'OVERSIZE_2', 'OVERSIZE_3', 'PACKAGING_MINIMUM', 'WEIGHT_BREAK']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RatedWeightMethod' % {"value" : value.encode("utf-8")} )
    def validate_MinimumChargeType(self, value):
        # Validate type MinimumChargeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUSTOMER', 'CUSTOMER_FREIGHT_WEIGHT', 'EARNED_DISCOUNT', 'MIXED', 'RATE_SCALE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MinimumChargeType' % {"value" : value.encode("utf-8")} )
    def validate_SpecialRatingAppliedType(self, value):
        # Validate type SpecialRatingAppliedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEDEX_ONE_RATE', 'FIXED_FUEL_SURCHARGE', 'IMPORT_PRICING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SpecialRatingAppliedType' % {"value" : value.encode("utf-8")} )
    def validate_RateDimensionalDivisorType(self, value):
        # Validate type RateDimensionalDivisorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['COUNTRY', 'CUSTOMER', 'OTHER', 'PRODUCT', 'WAIVED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateDimensionalDivisorType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RateType is not None or
            self.RateScale is not None or
            self.RateZone is not None or
            self.PricingCode is not None or
            self.RatedWeightMethod is not None or
            self.MinimumChargeType is not None or
            self.CurrencyExchangeRate is not None or
            self.SpecialRatingApplied or
            self.DimDivisor is not None or
            self.DimDivisorType is not None or
            self.FuelSurchargePercent is not None or
            self.TotalBillingWeight is not None or
            self.TotalDimWeight is not None or
            self.TotalBaseCharge is not None or
            self.TotalFreightDiscounts is not None or
            self.TotalNetFreight is not None or
            self.TotalSurcharges is not None or
            self.TotalNetFedExCharge is not None or
            self.TotalTaxes is not None or
            self.TotalNetCharge is not None or
            self.TotalRebates is not None or
            self.TotalDutiesAndTaxes is not None or
            self.TotalAncillaryFeesAndTaxes is not None or
            self.TotalDutiesTaxesAndFees is not None or
            self.TotalNetChargeWithDutiesAndTaxes is not None or
            self.ShipmentLegRateDetails or
            self.FreightRateDetail is not None or
            self.FreightDiscounts or
            self.Rebates or
            self.Surcharges or
            self.Taxes or
            self.DutiesAndTaxes or
            self.AncillaryFeesAndTaxes or
            self.VariableHandlingCharges is not None or
            self.TotalVariableHandlingCharges is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentRateDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentRateDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentRateDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentRateDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentRateDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentRateDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RateType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateType>%s</ns:RateType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateType), input_name='RateType')), eol_))
        if self.RateScale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateScale>%s</ns:RateScale>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateScale), input_name='RateScale')), eol_))
        if self.RateZone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateZone>%s</ns:RateZone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateZone), input_name='RateZone')), eol_))
        if self.PricingCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PricingCode>%s</ns:PricingCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PricingCode), input_name='PricingCode')), eol_))
        if self.RatedWeightMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RatedWeightMethod>%s</ns:RatedWeightMethod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RatedWeightMethod), input_name='RatedWeightMethod')), eol_))
        if self.MinimumChargeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:MinimumChargeType>%s</ns:MinimumChargeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MinimumChargeType), input_name='MinimumChargeType')), eol_))
        if self.CurrencyExchangeRate is not None:
            self.CurrencyExchangeRate.export(outfile, level, namespace_, name_='CurrencyExchangeRate', pretty_print=pretty_print)
        for SpecialRatingApplied_ in self.SpecialRatingApplied:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SpecialRatingApplied>%s</ns:SpecialRatingApplied>%s' % (self.gds_encode(self.gds_format_string(quote_xml(SpecialRatingApplied_), input_name='SpecialRatingApplied')), eol_))
        if self.DimDivisor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DimDivisor>%s</ns:DimDivisor>%s' % (self.gds_format_integer(self.DimDivisor, input_name='DimDivisor'), eol_))
        if self.DimDivisorType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DimDivisorType>%s</ns:DimDivisorType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DimDivisorType), input_name='DimDivisorType')), eol_))
        if self.FuelSurchargePercent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FuelSurchargePercent>%s</ns:FuelSurchargePercent>%s' % (self.gds_format_float(self.FuelSurchargePercent, input_name='FuelSurchargePercent'), eol_))
        if self.TotalBillingWeight is not None:
            self.TotalBillingWeight.export(outfile, level, namespace_, name_='TotalBillingWeight', pretty_print=pretty_print)
        if self.TotalDimWeight is not None:
            self.TotalDimWeight.export(outfile, level, namespace_, name_='TotalDimWeight', pretty_print=pretty_print)
        if self.TotalBaseCharge is not None:
            self.TotalBaseCharge.export(outfile, level, namespace_, name_='TotalBaseCharge', pretty_print=pretty_print)
        if self.TotalFreightDiscounts is not None:
            self.TotalFreightDiscounts.export(outfile, level, namespace_, name_='TotalFreightDiscounts', pretty_print=pretty_print)
        if self.TotalNetFreight is not None:
            self.TotalNetFreight.export(outfile, level, namespace_, name_='TotalNetFreight', pretty_print=pretty_print)
        if self.TotalSurcharges is not None:
            self.TotalSurcharges.export(outfile, level, namespace_, name_='TotalSurcharges', pretty_print=pretty_print)
        if self.TotalNetFedExCharge is not None:
            self.TotalNetFedExCharge.export(outfile, level, namespace_, name_='TotalNetFedExCharge', pretty_print=pretty_print)
        if self.TotalTaxes is not None:
            self.TotalTaxes.export(outfile, level, namespace_, name_='TotalTaxes', pretty_print=pretty_print)
        if self.TotalNetCharge is not None:
            self.TotalNetCharge.export(outfile, level, namespace_, name_='TotalNetCharge', pretty_print=pretty_print)
        if self.TotalRebates is not None:
            self.TotalRebates.export(outfile, level, namespace_, name_='TotalRebates', pretty_print=pretty_print)
        if self.TotalDutiesAndTaxes is not None:
            self.TotalDutiesAndTaxes.export(outfile, level, namespace_, name_='TotalDutiesAndTaxes', pretty_print=pretty_print)
        if self.TotalAncillaryFeesAndTaxes is not None:
            self.TotalAncillaryFeesAndTaxes.export(outfile, level, namespace_, name_='TotalAncillaryFeesAndTaxes', pretty_print=pretty_print)
        if self.TotalDutiesTaxesAndFees is not None:
            self.TotalDutiesTaxesAndFees.export(outfile, level, namespace_, name_='TotalDutiesTaxesAndFees', pretty_print=pretty_print)
        if self.TotalNetChargeWithDutiesAndTaxes is not None:
            self.TotalNetChargeWithDutiesAndTaxes.export(outfile, level, namespace_, name_='TotalNetChargeWithDutiesAndTaxes', pretty_print=pretty_print)
        for ShipmentLegRateDetails_ in self.ShipmentLegRateDetails:
            ShipmentLegRateDetails_.export(outfile, level, namespace_, name_='ShipmentLegRateDetails', pretty_print=pretty_print)
        if self.FreightRateDetail is not None:
            self.FreightRateDetail.export(outfile, level, namespace_, name_='FreightRateDetail', pretty_print=pretty_print)
        for FreightDiscounts_ in self.FreightDiscounts:
            FreightDiscounts_.export(outfile, level, namespace_, name_='FreightDiscounts', pretty_print=pretty_print)
        for Rebates_ in self.Rebates:
            Rebates_.export(outfile, level, namespace_, name_='Rebates', pretty_print=pretty_print)
        for Surcharges_ in self.Surcharges:
            Surcharges_.export(outfile, level, namespace_, name_='Surcharges', pretty_print=pretty_print)
        for Taxes_ in self.Taxes:
            Taxes_.export(outfile, level, namespace_, name_='Taxes', pretty_print=pretty_print)
        for DutiesAndTaxes_ in self.DutiesAndTaxes:
            DutiesAndTaxes_.export(outfile, level, namespace_, name_='DutiesAndTaxes', pretty_print=pretty_print)
        for AncillaryFeesAndTaxes_ in self.AncillaryFeesAndTaxes:
            AncillaryFeesAndTaxes_.export(outfile, level, namespace_, name_='AncillaryFeesAndTaxes', pretty_print=pretty_print)
        if self.VariableHandlingCharges is not None:
            self.VariableHandlingCharges.export(outfile, level, namespace_, name_='VariableHandlingCharges', pretty_print=pretty_print)
        if self.TotalVariableHandlingCharges is not None:
            self.TotalVariableHandlingCharges.export(outfile, level, namespace_, name_='TotalVariableHandlingCharges', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RateType':
            RateType_ = child_.text
            RateType_ = self.gds_validate_string(RateType_, node, 'RateType')
            self.RateType = RateType_
            # validate type ReturnedRateType
            self.validate_ReturnedRateType(self.RateType)
        elif nodeName_ == 'RateScale':
            RateScale_ = child_.text
            RateScale_ = self.gds_validate_string(RateScale_, node, 'RateScale')
            self.RateScale = RateScale_
        elif nodeName_ == 'RateZone':
            RateZone_ = child_.text
            RateZone_ = self.gds_validate_string(RateZone_, node, 'RateZone')
            self.RateZone = RateZone_
        elif nodeName_ == 'PricingCode':
            PricingCode_ = child_.text
            PricingCode_ = self.gds_validate_string(PricingCode_, node, 'PricingCode')
            self.PricingCode = PricingCode_
            # validate type PricingCodeType
            self.validate_PricingCodeType(self.PricingCode)
        elif nodeName_ == 'RatedWeightMethod':
            RatedWeightMethod_ = child_.text
            RatedWeightMethod_ = self.gds_validate_string(RatedWeightMethod_, node, 'RatedWeightMethod')
            self.RatedWeightMethod = RatedWeightMethod_
            # validate type RatedWeightMethod
            self.validate_RatedWeightMethod(self.RatedWeightMethod)
        elif nodeName_ == 'MinimumChargeType':
            MinimumChargeType_ = child_.text
            MinimumChargeType_ = self.gds_validate_string(MinimumChargeType_, node, 'MinimumChargeType')
            self.MinimumChargeType = MinimumChargeType_
            # validate type MinimumChargeType
            self.validate_MinimumChargeType(self.MinimumChargeType)
        elif nodeName_ == 'CurrencyExchangeRate':
            obj_ = CurrencyExchangeRate.factory()
            obj_.build(child_)
            self.CurrencyExchangeRate = obj_
            obj_.original_tagname_ = 'CurrencyExchangeRate'
        elif nodeName_ == 'SpecialRatingApplied':
            SpecialRatingApplied_ = child_.text
            SpecialRatingApplied_ = self.gds_validate_string(SpecialRatingApplied_, node, 'SpecialRatingApplied')
            self.SpecialRatingApplied.append(SpecialRatingApplied_)
            # validate type SpecialRatingAppliedType
            self.validate_SpecialRatingAppliedType(self.SpecialRatingApplied[-1])
        elif nodeName_ == 'DimDivisor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'DimDivisor')
            self.DimDivisor = ival_
        elif nodeName_ == 'DimDivisorType':
            DimDivisorType_ = child_.text
            DimDivisorType_ = self.gds_validate_string(DimDivisorType_, node, 'DimDivisorType')
            self.DimDivisorType = DimDivisorType_
            # validate type RateDimensionalDivisorType
            self.validate_RateDimensionalDivisorType(self.DimDivisorType)
        elif nodeName_ == 'FuelSurchargePercent':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'FuelSurchargePercent')
            self.FuelSurchargePercent = fval_
        elif nodeName_ == 'TotalBillingWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.TotalBillingWeight = obj_
            obj_.original_tagname_ = 'TotalBillingWeight'
        elif nodeName_ == 'TotalDimWeight':
            obj_ = Weight.factory()
            obj_.build(child_)
            self.TotalDimWeight = obj_
            obj_.original_tagname_ = 'TotalDimWeight'
        elif nodeName_ == 'TotalBaseCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalBaseCharge = obj_
            obj_.original_tagname_ = 'TotalBaseCharge'
        elif nodeName_ == 'TotalFreightDiscounts':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalFreightDiscounts = obj_
            obj_.original_tagname_ = 'TotalFreightDiscounts'
        elif nodeName_ == 'TotalNetFreight':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalNetFreight = obj_
            obj_.original_tagname_ = 'TotalNetFreight'
        elif nodeName_ == 'TotalSurcharges':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalSurcharges = obj_
            obj_.original_tagname_ = 'TotalSurcharges'
        elif nodeName_ == 'TotalNetFedExCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalNetFedExCharge = obj_
            obj_.original_tagname_ = 'TotalNetFedExCharge'
        elif nodeName_ == 'TotalTaxes':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalTaxes = obj_
            obj_.original_tagname_ = 'TotalTaxes'
        elif nodeName_ == 'TotalNetCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalNetCharge = obj_
            obj_.original_tagname_ = 'TotalNetCharge'
        elif nodeName_ == 'TotalRebates':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalRebates = obj_
            obj_.original_tagname_ = 'TotalRebates'
        elif nodeName_ == 'TotalDutiesAndTaxes':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalDutiesAndTaxes = obj_
            obj_.original_tagname_ = 'TotalDutiesAndTaxes'
        elif nodeName_ == 'TotalAncillaryFeesAndTaxes':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalAncillaryFeesAndTaxes = obj_
            obj_.original_tagname_ = 'TotalAncillaryFeesAndTaxes'
        elif nodeName_ == 'TotalDutiesTaxesAndFees':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalDutiesTaxesAndFees = obj_
            obj_.original_tagname_ = 'TotalDutiesTaxesAndFees'
        elif nodeName_ == 'TotalNetChargeWithDutiesAndTaxes':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalNetChargeWithDutiesAndTaxes = obj_
            obj_.original_tagname_ = 'TotalNetChargeWithDutiesAndTaxes'
        elif nodeName_ == 'ShipmentLegRateDetails':
            obj_ = ShipmentLegRateDetail.factory()
            obj_.build(child_)
            self.ShipmentLegRateDetails.append(obj_)
            obj_.original_tagname_ = 'ShipmentLegRateDetails'
        elif nodeName_ == 'FreightRateDetail':
            obj_ = FreightRateDetail.factory()
            obj_.build(child_)
            self.FreightRateDetail = obj_
            obj_.original_tagname_ = 'FreightRateDetail'
        elif nodeName_ == 'FreightDiscounts':
            obj_ = RateDiscount.factory()
            obj_.build(child_)
            self.FreightDiscounts.append(obj_)
            obj_.original_tagname_ = 'FreightDiscounts'
        elif nodeName_ == 'Rebates':
            obj_ = Rebate.factory()
            obj_.build(child_)
            self.Rebates.append(obj_)
            obj_.original_tagname_ = 'Rebates'
        elif nodeName_ == 'Surcharges':
            obj_ = Surcharge.factory()
            obj_.build(child_)
            self.Surcharges.append(obj_)
            obj_.original_tagname_ = 'Surcharges'
        elif nodeName_ == 'Taxes':
            obj_ = Tax.factory()
            obj_.build(child_)
            self.Taxes.append(obj_)
            obj_.original_tagname_ = 'Taxes'
        elif nodeName_ == 'DutiesAndTaxes':
            obj_ = EdtCommodityTax.factory()
            obj_.build(child_)
            self.DutiesAndTaxes.append(obj_)
            obj_.original_tagname_ = 'DutiesAndTaxes'
        elif nodeName_ == 'AncillaryFeesAndTaxes':
            obj_ = AncillaryFeeAndTax.factory()
            obj_.build(child_)
            self.AncillaryFeesAndTaxes.append(obj_)
            obj_.original_tagname_ = 'AncillaryFeesAndTaxes'
        elif nodeName_ == 'VariableHandlingCharges':
            obj_ = VariableHandlingCharges.factory()
            obj_.build(child_)
            self.VariableHandlingCharges = obj_
            obj_.original_tagname_ = 'VariableHandlingCharges'
        elif nodeName_ == 'TotalVariableHandlingCharges':
            obj_ = VariableHandlingCharges.factory()
            obj_.build(child_)
            self.TotalVariableHandlingCharges = obj_
            obj_.original_tagname_ = 'TotalVariableHandlingCharges'
# end class ShipmentRateDetail


class ShipmentRating(GeneratedsSuper):
    """This class groups together all shipment-level rate data (across all
    rate types) as part of the response to a shipping request, which
    groups shipment-level data together and groups package-level
    data by package."""
    subclass = None
    superclass = None
    def __init__(self, ActualRateType=None, EffectiveNetDiscount=None, ShipmentRateDetails=None):
        self.original_tagname_ = None
        self.ActualRateType = ActualRateType
        self.validate_ReturnedRateType(self.ActualRateType)
        self.EffectiveNetDiscount = EffectiveNetDiscount
        if ShipmentRateDetails is None:
            self.ShipmentRateDetails = []
        else:
            self.ShipmentRateDetails = ShipmentRateDetails
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentRating)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentRating.subclass:
            return ShipmentRating.subclass(*args_, **kwargs_)
        else:
            return ShipmentRating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActualRateType(self): return self.ActualRateType
    def set_ActualRateType(self, ActualRateType): self.ActualRateType = ActualRateType
    def get_EffectiveNetDiscount(self): return self.EffectiveNetDiscount
    def set_EffectiveNetDiscount(self, EffectiveNetDiscount): self.EffectiveNetDiscount = EffectiveNetDiscount
    def get_ShipmentRateDetails(self): return self.ShipmentRateDetails
    def set_ShipmentRateDetails(self, ShipmentRateDetails): self.ShipmentRateDetails = ShipmentRateDetails
    def add_ShipmentRateDetails(self, value): self.ShipmentRateDetails.append(value)
    def insert_ShipmentRateDetails_at(self, index, value): self.ShipmentRateDetails.insert(index, value)
    def replace_ShipmentRateDetails_at(self, index, value): self.ShipmentRateDetails[index] = value
    def validate_ReturnedRateType(self, value):
        # Validate type ReturnedRateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INCENTIVE', 'NEGOTIATED', 'PAYOR_ACCOUNT_PACKAGE', 'PAYOR_ACCOUNT_SHIPMENT', 'PAYOR_LIST_PACKAGE', 'PAYOR_LIST_SHIPMENT', 'PREFERRED_ACCOUNT_PACKAGE', 'PREFERRED_ACCOUNT_SHIPMENT', 'PREFERRED_LIST_PACKAGE', 'PREFERRED_LIST_SHIPMENT', 'PREFERRED_NEGOTIATED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReturnedRateType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ActualRateType is not None or
            self.EffectiveNetDiscount is not None or
            self.ShipmentRateDetails
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentRating', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentRating')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentRating')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentRating', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentRating'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentRating', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActualRateType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ActualRateType>%s</ns:ActualRateType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ActualRateType), input_name='ActualRateType')), eol_))
        if self.EffectiveNetDiscount is not None:
            self.EffectiveNetDiscount.export(outfile, level, namespace_, name_='EffectiveNetDiscount', pretty_print=pretty_print)
        for ShipmentRateDetails_ in self.ShipmentRateDetails:
            ShipmentRateDetails_.export(outfile, level, namespace_, name_='ShipmentRateDetails', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActualRateType':
            ActualRateType_ = child_.text
            ActualRateType_ = self.gds_validate_string(ActualRateType_, node, 'ActualRateType')
            self.ActualRateType = ActualRateType_
            # validate type ReturnedRateType
            self.validate_ReturnedRateType(self.ActualRateType)
        elif nodeName_ == 'EffectiveNetDiscount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.EffectiveNetDiscount = obj_
            obj_.original_tagname_ = 'EffectiveNetDiscount'
        elif nodeName_ == 'ShipmentRateDetails':
            obj_ = ShipmentRateDetail.factory()
            obj_.build(child_)
            self.ShipmentRateDetails.append(obj_)
            obj_.original_tagname_ = 'ShipmentRateDetails'
# end class ShipmentRating


class ShipmentReply(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HighestSeverity=None, Notifications=None, TransactionDetail=None, Version=None):
        self.original_tagname_ = None
        self.HighestSeverity = HighestSeverity
        self.validate_NotificationSeverityType(self.HighestSeverity)
        if Notifications is None:
            self.Notifications = []
        else:
            self.Notifications = Notifications
        self.TransactionDetail = TransactionDetail
        self.Version = Version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentReply)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentReply.subclass:
            return ShipmentReply.subclass(*args_, **kwargs_)
        else:
            return ShipmentReply(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HighestSeverity(self): return self.HighestSeverity
    def set_HighestSeverity(self, HighestSeverity): self.HighestSeverity = HighestSeverity
    def get_Notifications(self): return self.Notifications
    def set_Notifications(self, Notifications): self.Notifications = Notifications
    def add_Notifications(self, value): self.Notifications.append(value)
    def insert_Notifications_at(self, index, value): self.Notifications.insert(index, value)
    def replace_Notifications_at(self, index, value): self.Notifications[index] = value
    def get_TransactionDetail(self): return self.TransactionDetail
    def set_TransactionDetail(self, TransactionDetail): self.TransactionDetail = TransactionDetail
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_NotificationSeverityType(self, value):
        # Validate type NotificationSeverityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ERROR', 'FAILURE', 'NOTE', 'SUCCESS', 'WARNING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NotificationSeverityType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.HighestSeverity is not None or
            self.Notifications or
            self.TransactionDetail is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentReply', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentReply')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentReply')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentReply', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentReply'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentReply', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HighestSeverity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HighestSeverity>%s</ns:HighestSeverity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HighestSeverity), input_name='HighestSeverity')), eol_))
        for Notifications_ in self.Notifications:
            Notifications_.export(outfile, level, namespace_, name_='Notifications', pretty_print=pretty_print)
        if self.TransactionDetail is not None:
            self.TransactionDetail.export(outfile, level, namespace_, name_='TransactionDetail', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HighestSeverity':
            HighestSeverity_ = child_.text
            HighestSeverity_ = self.gds_validate_string(HighestSeverity_, node, 'HighestSeverity')
            self.HighestSeverity = HighestSeverity_
            # validate type NotificationSeverityType
            self.validate_NotificationSeverityType(self.HighestSeverity)
        elif nodeName_ == 'Notifications':
            obj_ = Notification.factory()
            obj_.build(child_)
            self.Notifications.append(obj_)
            obj_.original_tagname_ = 'Notifications'
        elif nodeName_ == 'TransactionDetail':
            obj_ = TransactionDetail.factory()
            obj_.build(child_)
            self.TransactionDetail = obj_
            obj_.original_tagname_ = 'TransactionDetail'
        elif nodeName_ == 'Version':
            obj_ = VersionId.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
# end class ShipmentReply


class ShipmentSpecialServicesRequested(GeneratedsSuper):
    """These special services are available at the shipment level for some
    or all service types. If the shipper is requesting a special
    service which requires additional data (such as the COD amount),
    the shipment special service type must be present in the
    specialServiceTypes collection, and the supporting detail must
    be provided in the appropriate sub-object below."""
    subclass = None
    superclass = None
    def __init__(self, SpecialServiceTypes=None, CodDetail=None, DeliveryOnInvoiceAcceptanceDetail=None, HoldAtLocationDetail=None, EventNotificationDetail=None, ReturnShipmentDetail=None, PendingShipmentDetail=None, InternationalControlledExportDetail=None, InternationalTrafficInArmsRegulationsDetail=None, ShipmentDryIceDetail=None, HomeDeliveryPremiumDetail=None, FreightGuaranteeDetail=None, EtdDetail=None, CustomDeliveryWindowDetail=None):
        self.original_tagname_ = None
        if SpecialServiceTypes is None:
            self.SpecialServiceTypes = []
        else:
            self.SpecialServiceTypes = SpecialServiceTypes
        self.CodDetail = CodDetail
        self.DeliveryOnInvoiceAcceptanceDetail = DeliveryOnInvoiceAcceptanceDetail
        self.HoldAtLocationDetail = HoldAtLocationDetail
        self.EventNotificationDetail = EventNotificationDetail
        self.ReturnShipmentDetail = ReturnShipmentDetail
        self.PendingShipmentDetail = PendingShipmentDetail
        self.InternationalControlledExportDetail = InternationalControlledExportDetail
        self.InternationalTrafficInArmsRegulationsDetail = InternationalTrafficInArmsRegulationsDetail
        self.ShipmentDryIceDetail = ShipmentDryIceDetail
        self.HomeDeliveryPremiumDetail = HomeDeliveryPremiumDetail
        self.FreightGuaranteeDetail = FreightGuaranteeDetail
        self.EtdDetail = EtdDetail
        self.CustomDeliveryWindowDetail = CustomDeliveryWindowDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentSpecialServicesRequested)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentSpecialServicesRequested.subclass:
            return ShipmentSpecialServicesRequested.subclass(*args_, **kwargs_)
        else:
            return ShipmentSpecialServicesRequested(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialServiceTypes(self): return self.SpecialServiceTypes
    def set_SpecialServiceTypes(self, SpecialServiceTypes): self.SpecialServiceTypes = SpecialServiceTypes
    def add_SpecialServiceTypes(self, value): self.SpecialServiceTypes.append(value)
    def insert_SpecialServiceTypes_at(self, index, value): self.SpecialServiceTypes.insert(index, value)
    def replace_SpecialServiceTypes_at(self, index, value): self.SpecialServiceTypes[index] = value
    def get_CodDetail(self): return self.CodDetail
    def set_CodDetail(self, CodDetail): self.CodDetail = CodDetail
    def get_DeliveryOnInvoiceAcceptanceDetail(self): return self.DeliveryOnInvoiceAcceptanceDetail
    def set_DeliveryOnInvoiceAcceptanceDetail(self, DeliveryOnInvoiceAcceptanceDetail): self.DeliveryOnInvoiceAcceptanceDetail = DeliveryOnInvoiceAcceptanceDetail
    def get_HoldAtLocationDetail(self): return self.HoldAtLocationDetail
    def set_HoldAtLocationDetail(self, HoldAtLocationDetail): self.HoldAtLocationDetail = HoldAtLocationDetail
    def get_EventNotificationDetail(self): return self.EventNotificationDetail
    def set_EventNotificationDetail(self, EventNotificationDetail): self.EventNotificationDetail = EventNotificationDetail
    def get_ReturnShipmentDetail(self): return self.ReturnShipmentDetail
    def set_ReturnShipmentDetail(self, ReturnShipmentDetail): self.ReturnShipmentDetail = ReturnShipmentDetail
    def get_PendingShipmentDetail(self): return self.PendingShipmentDetail
    def set_PendingShipmentDetail(self, PendingShipmentDetail): self.PendingShipmentDetail = PendingShipmentDetail
    def get_InternationalControlledExportDetail(self): return self.InternationalControlledExportDetail
    def set_InternationalControlledExportDetail(self, InternationalControlledExportDetail): self.InternationalControlledExportDetail = InternationalControlledExportDetail
    def get_InternationalTrafficInArmsRegulationsDetail(self): return self.InternationalTrafficInArmsRegulationsDetail
    def set_InternationalTrafficInArmsRegulationsDetail(self, InternationalTrafficInArmsRegulationsDetail): self.InternationalTrafficInArmsRegulationsDetail = InternationalTrafficInArmsRegulationsDetail
    def get_ShipmentDryIceDetail(self): return self.ShipmentDryIceDetail
    def set_ShipmentDryIceDetail(self, ShipmentDryIceDetail): self.ShipmentDryIceDetail = ShipmentDryIceDetail
    def get_HomeDeliveryPremiumDetail(self): return self.HomeDeliveryPremiumDetail
    def set_HomeDeliveryPremiumDetail(self, HomeDeliveryPremiumDetail): self.HomeDeliveryPremiumDetail = HomeDeliveryPremiumDetail
    def get_FreightGuaranteeDetail(self): return self.FreightGuaranteeDetail
    def set_FreightGuaranteeDetail(self, FreightGuaranteeDetail): self.FreightGuaranteeDetail = FreightGuaranteeDetail
    def get_EtdDetail(self): return self.EtdDetail
    def set_EtdDetail(self, EtdDetail): self.EtdDetail = EtdDetail
    def get_CustomDeliveryWindowDetail(self): return self.CustomDeliveryWindowDetail
    def set_CustomDeliveryWindowDetail(self, CustomDeliveryWindowDetail): self.CustomDeliveryWindowDetail = CustomDeliveryWindowDetail
    def validate_ShipmentSpecialServiceType(self, value):
        # Validate type ShipmentSpecialServiceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BROKER_SELECT_OPTION', 'CALL_BEFORE_DELIVERY', 'COD', 'CUSTOM_DELIVERY_WINDOW', 'CUT_FLOWERS', 'DANGEROUS_GOODS', 'DELIVERY_ON_INVOICE_ACCEPTANCE', 'DO_NOT_BREAK_DOWN_PALLETS', 'DO_NOT_STACK_PALLETS', 'DRY_ICE', 'EAST_COAST_SPECIAL', 'ELECTRONIC_TRADE_DOCUMENTS', 'EVENT_NOTIFICATION', 'EXCLUDE_FROM_CONSOLIDATION', 'EXTREME_LENGTH', 'FEDEX_ONE_RATE', 'FOOD', 'FREIGHT_GUARANTEE', 'FREIGHT_TO_COLLECT', 'FUTURE_DAY_SHIPMENT', 'HOLD_AT_LOCATION', 'HOME_DELIVERY_PREMIUM', 'INSIDE_DELIVERY', 'INSIDE_PICKUP', 'INTERNATIONAL_CONTROLLED_EXPORT_SERVICE', 'INTERNATIONAL_TRAFFIC_IN_ARMS_REGULATIONS', 'LIFTGATE_DELIVERY', 'LIFTGATE_PICKUP', 'LIMITED_ACCESS_DELIVERY', 'LIMITED_ACCESS_PICKUP', 'PENDING_SHIPMENT', 'PHARMACY_DELIVERY', 'POISON', 'PROTECTION_FROM_FREEZING', 'RETURNS_CLEARANCE', 'RETURN_SHIPMENT', 'SATURDAY_DELIVERY', 'SATURDAY_PICKUP', 'THIRD_PARTY_CONSIGNEE', 'TOP_LOAD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShipmentSpecialServiceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SpecialServiceTypes or
            self.CodDetail is not None or
            self.DeliveryOnInvoiceAcceptanceDetail is not None or
            self.HoldAtLocationDetail is not None or
            self.EventNotificationDetail is not None or
            self.ReturnShipmentDetail is not None or
            self.PendingShipmentDetail is not None or
            self.InternationalControlledExportDetail is not None or
            self.InternationalTrafficInArmsRegulationsDetail is not None or
            self.ShipmentDryIceDetail is not None or
            self.HomeDeliveryPremiumDetail is not None or
            self.FreightGuaranteeDetail is not None or
            self.EtdDetail is not None or
            self.CustomDeliveryWindowDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShipmentSpecialServicesRequested', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentSpecialServicesRequested')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentSpecialServicesRequested')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShipmentSpecialServicesRequested', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShipmentSpecialServicesRequested'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShipmentSpecialServicesRequested', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SpecialServiceTypes_ in self.SpecialServiceTypes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SpecialServiceTypes>%s</ns:SpecialServiceTypes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(SpecialServiceTypes_), input_name='SpecialServiceTypes')), eol_))
        if self.CodDetail is not None:
            self.CodDetail.export(outfile, level, namespace_, name_='CodDetail', pretty_print=pretty_print)
        if self.DeliveryOnInvoiceAcceptanceDetail is not None:
            self.DeliveryOnInvoiceAcceptanceDetail.export(outfile, level, namespace_, name_='DeliveryOnInvoiceAcceptanceDetail', pretty_print=pretty_print)
        if self.HoldAtLocationDetail is not None:
            self.HoldAtLocationDetail.export(outfile, level, namespace_, name_='HoldAtLocationDetail', pretty_print=pretty_print)
        if self.EventNotificationDetail is not None:
            self.EventNotificationDetail.export(outfile, level, namespace_, name_='EventNotificationDetail', pretty_print=pretty_print)
        if self.ReturnShipmentDetail is not None:
            self.ReturnShipmentDetail.export(outfile, level, namespace_, name_='ReturnShipmentDetail', pretty_print=pretty_print)
        if self.PendingShipmentDetail is not None:
            self.PendingShipmentDetail.export(outfile, level, namespace_, name_='PendingShipmentDetail', pretty_print=pretty_print)
        if self.InternationalControlledExportDetail is not None:
            self.InternationalControlledExportDetail.export(outfile, level, namespace_, name_='InternationalControlledExportDetail', pretty_print=pretty_print)
        if self.InternationalTrafficInArmsRegulationsDetail is not None:
            self.InternationalTrafficInArmsRegulationsDetail.export(outfile, level, namespace_, name_='InternationalTrafficInArmsRegulationsDetail', pretty_print=pretty_print)
        if self.ShipmentDryIceDetail is not None:
            self.ShipmentDryIceDetail.export(outfile, level, namespace_, name_='ShipmentDryIceDetail', pretty_print=pretty_print)
        if self.HomeDeliveryPremiumDetail is not None:
            self.HomeDeliveryPremiumDetail.export(outfile, level, namespace_, name_='HomeDeliveryPremiumDetail', pretty_print=pretty_print)
        if self.FreightGuaranteeDetail is not None:
            self.FreightGuaranteeDetail.export(outfile, level, namespace_, name_='FreightGuaranteeDetail', pretty_print=pretty_print)
        if self.EtdDetail is not None:
            self.EtdDetail.export(outfile, level, namespace_, name_='EtdDetail', pretty_print=pretty_print)
        if self.CustomDeliveryWindowDetail is not None:
            self.CustomDeliveryWindowDetail.export(outfile, level, namespace_, name_='CustomDeliveryWindowDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialServiceTypes':
            SpecialServiceTypes_ = child_.text
            SpecialServiceTypes_ = self.gds_validate_string(SpecialServiceTypes_, node, 'SpecialServiceTypes')
            self.SpecialServiceTypes.append(SpecialServiceTypes_)
            # validate type ShipmentSpecialServiceType
            self.validate_ShipmentSpecialServiceType(self.SpecialServiceTypes[-1])
        elif nodeName_ == 'CodDetail':
            obj_ = CodDetail.factory()
            obj_.build(child_)
            self.CodDetail = obj_
            obj_.original_tagname_ = 'CodDetail'
        elif nodeName_ == 'DeliveryOnInvoiceAcceptanceDetail':
            obj_ = DeliveryOnInvoiceAcceptanceDetail.factory()
            obj_.build(child_)
            self.DeliveryOnInvoiceAcceptanceDetail = obj_
            obj_.original_tagname_ = 'DeliveryOnInvoiceAcceptanceDetail'
        elif nodeName_ == 'HoldAtLocationDetail':
            obj_ = HoldAtLocationDetail.factory()
            obj_.build(child_)
            self.HoldAtLocationDetail = obj_
            obj_.original_tagname_ = 'HoldAtLocationDetail'
        elif nodeName_ == 'EventNotificationDetail':
            obj_ = ShipmentEventNotificationDetail.factory()
            obj_.build(child_)
            self.EventNotificationDetail = obj_
            obj_.original_tagname_ = 'EventNotificationDetail'
        elif nodeName_ == 'ReturnShipmentDetail':
            obj_ = ReturnShipmentDetail.factory()
            obj_.build(child_)
            self.ReturnShipmentDetail = obj_
            obj_.original_tagname_ = 'ReturnShipmentDetail'
        elif nodeName_ == 'PendingShipmentDetail':
            obj_ = PendingShipmentDetail.factory()
            obj_.build(child_)
            self.PendingShipmentDetail = obj_
            obj_.original_tagname_ = 'PendingShipmentDetail'
        elif nodeName_ == 'InternationalControlledExportDetail':
            obj_ = InternationalControlledExportDetail.factory()
            obj_.build(child_)
            self.InternationalControlledExportDetail = obj_
            obj_.original_tagname_ = 'InternationalControlledExportDetail'
        elif nodeName_ == 'InternationalTrafficInArmsRegulationsDetail':
            obj_ = InternationalTrafficInArmsRegulationsDetail.factory()
            obj_.build(child_)
            self.InternationalTrafficInArmsRegulationsDetail = obj_
            obj_.original_tagname_ = 'InternationalTrafficInArmsRegulationsDetail'
        elif nodeName_ == 'ShipmentDryIceDetail':
            obj_ = ShipmentDryIceDetail.factory()
            obj_.build(child_)
            self.ShipmentDryIceDetail = obj_
            obj_.original_tagname_ = 'ShipmentDryIceDetail'
        elif nodeName_ == 'HomeDeliveryPremiumDetail':
            obj_ = HomeDeliveryPremiumDetail.factory()
            obj_.build(child_)
            self.HomeDeliveryPremiumDetail = obj_
            obj_.original_tagname_ = 'HomeDeliveryPremiumDetail'
        elif nodeName_ == 'FreightGuaranteeDetail':
            obj_ = FreightGuaranteeDetail.factory()
            obj_.build(child_)
            self.FreightGuaranteeDetail = obj_
            obj_.original_tagname_ = 'FreightGuaranteeDetail'
        elif nodeName_ == 'EtdDetail':
            obj_ = EtdDetail.factory()
            obj_.build(child_)
            self.EtdDetail = obj_
            obj_.original_tagname_ = 'EtdDetail'
        elif nodeName_ == 'CustomDeliveryWindowDetail':
            obj_ = CustomDeliveryWindowDetail.factory()
            obj_.build(child_)
            self.CustomDeliveryWindowDetail = obj_
            obj_.original_tagname_ = 'CustomDeliveryWindowDetail'
# end class ShipmentSpecialServicesRequested


class ShippingDocument(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Localizations=None, Grouping=None, ShippingDocumentDisposition=None, AccessReference=None, ImageType=None, Resolution=None, CopiesToPrint=None, Parts=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_ReturnedShippingDocumentType(self.Type)
        if Localizations is None:
            self.Localizations = []
        else:
            self.Localizations = Localizations
        self.Grouping = Grouping
        self.validate_ShippingDocumentGroupingType(self.Grouping)
        self.ShippingDocumentDisposition = ShippingDocumentDisposition
        self.validate_ShippingDocumentDispositionType(self.ShippingDocumentDisposition)
        self.AccessReference = AccessReference
        self.ImageType = ImageType
        self.validate_ShippingDocumentImageType(self.ImageType)
        self.Resolution = Resolution
        self.CopiesToPrint = CopiesToPrint
        if Parts is None:
            self.Parts = []
        else:
            self.Parts = Parts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDocument.subclass:
            return ShippingDocument.subclass(*args_, **kwargs_)
        else:
            return ShippingDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Localizations(self): return self.Localizations
    def set_Localizations(self, Localizations): self.Localizations = Localizations
    def add_Localizations(self, value): self.Localizations.append(value)
    def insert_Localizations_at(self, index, value): self.Localizations.insert(index, value)
    def replace_Localizations_at(self, index, value): self.Localizations[index] = value
    def get_Grouping(self): return self.Grouping
    def set_Grouping(self, Grouping): self.Grouping = Grouping
    def get_ShippingDocumentDisposition(self): return self.ShippingDocumentDisposition
    def set_ShippingDocumentDisposition(self, ShippingDocumentDisposition): self.ShippingDocumentDisposition = ShippingDocumentDisposition
    def get_AccessReference(self): return self.AccessReference
    def set_AccessReference(self, AccessReference): self.AccessReference = AccessReference
    def get_ImageType(self): return self.ImageType
    def set_ImageType(self, ImageType): self.ImageType = ImageType
    def get_Resolution(self): return self.Resolution
    def set_Resolution(self, Resolution): self.Resolution = Resolution
    def get_CopiesToPrint(self): return self.CopiesToPrint
    def set_CopiesToPrint(self, CopiesToPrint): self.CopiesToPrint = CopiesToPrint
    def get_Parts(self): return self.Parts
    def set_Parts(self, Parts): self.Parts = Parts
    def add_Parts(self, value): self.Parts.append(value)
    def insert_Parts_at(self, index, value): self.Parts.insert(index, value)
    def replace_Parts_at(self, index, value): self.Parts[index] = value
    def validate_ReturnedShippingDocumentType(self, value):
        # Validate type ReturnedShippingDocumentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AUXILIARY_LABEL', 'CERTIFICATE_OF_ORIGIN', 'COD_AND_DELIVERY_ON_INVOICE_ACCEPTANCE_RETURN_2_D_BARCODE', 'COD_AND_DELIVERY_ON_INVOICE_ACCEPTANCE_RETURN_LABEL', 'COD_RETURN_2_D_BARCODE', 'COD_RETURN_LABEL', 'COMMERCIAL_INVOICE', 'CUSTOM_PACKAGE_DOCUMENT', 'CUSTOM_SHIPMENT_DOCUMENT', 'DANGEROUS_GOODS_SHIPPERS_DECLARATION', 'DELIVERY_ON_INVOICE_ACCEPTANCE_RETURN_2_D_BARCODE', 'DELIVERY_ON_INVOICE_ACCEPTANCE_RETURN_LABEL', 'ETD_LABEL', 'EXPORT_DECLARATION', 'FREIGHT_ADDRESS_LABEL', 'GENERAL_AGENCY_AGREEMENT', 'GROUND_BARCODE', 'NAFTA_CERTIFICATE_OF_ORIGIN', 'OP_900', 'OUTBOUND_2_D_BARCODE', 'OUTBOUND_LABEL', 'PRO_FORMA_INVOICE', 'RECIPIENT_ADDRESS_BARCODE', 'RECIPIENT_POSTAL_BARCODE', 'RETURN_INSTRUCTIONS', 'TERMS_AND_CONDITIONS', 'USPS_BARCODE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReturnedShippingDocumentType' % {"value" : value.encode("utf-8")} )
    def validate_ShippingDocumentGroupingType(self, value):
        # Validate type ShippingDocumentGroupingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CONSOLIDATED_BY_DOCUMENT_TYPE', 'INDIVIDUAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentGroupingType' % {"value" : value.encode("utf-8")} )
    def validate_ShippingDocumentDispositionType(self, value):
        # Validate type ShippingDocumentDispositionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEFERRED_STORED', 'EMAILED', 'QUEUED', 'RETURNED', 'STORED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentDispositionType' % {"value" : value.encode("utf-8")} )
    def validate_ShippingDocumentImageType(self, value):
        # Validate type ShippingDocumentImageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DOC', 'EPL2', 'PDF', 'PNG', 'RTF', 'TEXT', 'ZPLII']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentImageType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Localizations or
            self.Grouping is not None or
            self.ShippingDocumentDisposition is not None or
            self.AccessReference is not None or
            self.ImageType is not None or
            self.Resolution is not None or
            self.CopiesToPrint is not None or
            self.Parts
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShippingDocument', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShippingDocument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShippingDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShippingDocument'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShippingDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        for Localizations_ in self.Localizations:
            Localizations_.export(outfile, level, namespace_, name_='Localizations', pretty_print=pretty_print)
        if self.Grouping is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Grouping>%s</ns:Grouping>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Grouping), input_name='Grouping')), eol_))
        if self.ShippingDocumentDisposition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ShippingDocumentDisposition>%s</ns:ShippingDocumentDisposition>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShippingDocumentDisposition), input_name='ShippingDocumentDisposition')), eol_))
        if self.AccessReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AccessReference>%s</ns:AccessReference>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AccessReference), input_name='AccessReference')), eol_))
        if self.ImageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ImageType>%s</ns:ImageType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ImageType), input_name='ImageType')), eol_))
        if self.Resolution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Resolution>%s</ns:Resolution>%s' % (self.gds_format_integer(self.Resolution, input_name='Resolution'), eol_))
        if self.CopiesToPrint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CopiesToPrint>%s</ns:CopiesToPrint>%s' % (self.gds_format_integer(self.CopiesToPrint, input_name='CopiesToPrint'), eol_))
        for Parts_ in self.Parts:
            Parts_.export(outfile, level, namespace_, name_='Parts', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type ReturnedShippingDocumentType
            self.validate_ReturnedShippingDocumentType(self.Type)
        elif nodeName_ == 'Localizations':
            obj_ = Localization.factory()
            obj_.build(child_)
            self.Localizations.append(obj_)
            obj_.original_tagname_ = 'Localizations'
        elif nodeName_ == 'Grouping':
            Grouping_ = child_.text
            Grouping_ = self.gds_validate_string(Grouping_, node, 'Grouping')
            self.Grouping = Grouping_
            # validate type ShippingDocumentGroupingType
            self.validate_ShippingDocumentGroupingType(self.Grouping)
        elif nodeName_ == 'ShippingDocumentDisposition':
            ShippingDocumentDisposition_ = child_.text
            ShippingDocumentDisposition_ = self.gds_validate_string(ShippingDocumentDisposition_, node, 'ShippingDocumentDisposition')
            self.ShippingDocumentDisposition = ShippingDocumentDisposition_
            # validate type ShippingDocumentDispositionType
            self.validate_ShippingDocumentDispositionType(self.ShippingDocumentDisposition)
        elif nodeName_ == 'AccessReference':
            AccessReference_ = child_.text
            AccessReference_ = self.gds_validate_string(AccessReference_, node, 'AccessReference')
            self.AccessReference = AccessReference_
        elif nodeName_ == 'ImageType':
            ImageType_ = child_.text
            ImageType_ = self.gds_validate_string(ImageType_, node, 'ImageType')
            self.ImageType = ImageType_
            # validate type ShippingDocumentImageType
            self.validate_ShippingDocumentImageType(self.ImageType)
        elif nodeName_ == 'Resolution':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Resolution')
            self.Resolution = ival_
        elif nodeName_ == 'CopiesToPrint':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'CopiesToPrint')
            self.CopiesToPrint = ival_
        elif nodeName_ == 'Parts':
            obj_ = ShippingDocumentPart.factory()
            obj_.build(child_)
            self.Parts.append(obj_)
            obj_.original_tagname_ = 'Parts'
# end class ShippingDocument


class ShippingDocumentDispositionDetail(GeneratedsSuper):
    """Each occurrence of this class specifies a particular way in which a
    kind of shipping document is to be produced and provided."""
    subclass = None
    superclass = None
    def __init__(self, DispositionType=None, Grouping=None, StorageDetail=None, EMailDetail=None, PrintDetail=None):
        self.original_tagname_ = None
        self.DispositionType = DispositionType
        self.validate_ShippingDocumentDispositionType(self.DispositionType)
        self.Grouping = Grouping
        self.validate_ShippingDocumentGroupingType(self.Grouping)
        self.StorageDetail = StorageDetail
        self.EMailDetail = EMailDetail
        self.PrintDetail = PrintDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDocumentDispositionDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDocumentDispositionDetail.subclass:
            return ShippingDocumentDispositionDetail.subclass(*args_, **kwargs_)
        else:
            return ShippingDocumentDispositionDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DispositionType(self): return self.DispositionType
    def set_DispositionType(self, DispositionType): self.DispositionType = DispositionType
    def get_Grouping(self): return self.Grouping
    def set_Grouping(self, Grouping): self.Grouping = Grouping
    def get_StorageDetail(self): return self.StorageDetail
    def set_StorageDetail(self, StorageDetail): self.StorageDetail = StorageDetail
    def get_EMailDetail(self): return self.EMailDetail
    def set_EMailDetail(self, EMailDetail): self.EMailDetail = EMailDetail
    def get_PrintDetail(self): return self.PrintDetail
    def set_PrintDetail(self, PrintDetail): self.PrintDetail = PrintDetail
    def validate_ShippingDocumentDispositionType(self, value):
        # Validate type ShippingDocumentDispositionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEFERRED_STORED', 'EMAILED', 'QUEUED', 'RETURNED', 'STORED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentDispositionType' % {"value" : value.encode("utf-8")} )
    def validate_ShippingDocumentGroupingType(self, value):
        # Validate type ShippingDocumentGroupingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CONSOLIDATED_BY_DOCUMENT_TYPE', 'INDIVIDUAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentGroupingType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DispositionType is not None or
            self.Grouping is not None or
            self.StorageDetail is not None or
            self.EMailDetail is not None or
            self.PrintDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShippingDocumentDispositionDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDocumentDispositionDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShippingDocumentDispositionDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShippingDocumentDispositionDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShippingDocumentDispositionDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShippingDocumentDispositionDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DispositionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DispositionType>%s</ns:DispositionType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DispositionType), input_name='DispositionType')), eol_))
        if self.Grouping is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Grouping>%s</ns:Grouping>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Grouping), input_name='Grouping')), eol_))
        if self.StorageDetail is not None:
            self.StorageDetail.export(outfile, level, namespace_, name_='StorageDetail', pretty_print=pretty_print)
        if self.EMailDetail is not None:
            self.EMailDetail.export(outfile, level, namespace_, name_='EMailDetail', pretty_print=pretty_print)
        if self.PrintDetail is not None:
            self.PrintDetail.export(outfile, level, namespace_, name_='PrintDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DispositionType':
            DispositionType_ = child_.text
            DispositionType_ = self.gds_validate_string(DispositionType_, node, 'DispositionType')
            self.DispositionType = DispositionType_
            # validate type ShippingDocumentDispositionType
            self.validate_ShippingDocumentDispositionType(self.DispositionType)
        elif nodeName_ == 'Grouping':
            Grouping_ = child_.text
            Grouping_ = self.gds_validate_string(Grouping_, node, 'Grouping')
            self.Grouping = Grouping_
            # validate type ShippingDocumentGroupingType
            self.validate_ShippingDocumentGroupingType(self.Grouping)
        elif nodeName_ == 'StorageDetail':
            obj_ = ShippingDocumentStorageDetail.factory()
            obj_.build(child_)
            self.StorageDetail = obj_
            obj_.original_tagname_ = 'StorageDetail'
        elif nodeName_ == 'EMailDetail':
            obj_ = ShippingDocumentEMailDetail.factory()
            obj_.build(child_)
            self.EMailDetail = obj_
            obj_.original_tagname_ = 'EMailDetail'
        elif nodeName_ == 'PrintDetail':
            obj_ = ShippingDocumentPrintDetail.factory()
            obj_.build(child_)
            self.PrintDetail = obj_
            obj_.original_tagname_ = 'PrintDetail'
# end class ShippingDocumentDispositionDetail


class ShippingDocumentEMailDetail(GeneratedsSuper):
    """Specifies how to e-mail shipping documents."""
    subclass = None
    superclass = None
    def __init__(self, EMailRecipients=None, Grouping=None, Localization=None):
        self.original_tagname_ = None
        if EMailRecipients is None:
            self.EMailRecipients = []
        else:
            self.EMailRecipients = EMailRecipients
        self.Grouping = Grouping
        self.validate_ShippingDocumentEMailGroupingType(self.Grouping)
        self.Localization = Localization
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDocumentEMailDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDocumentEMailDetail.subclass:
            return ShippingDocumentEMailDetail.subclass(*args_, **kwargs_)
        else:
            return ShippingDocumentEMailDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EMailRecipients(self): return self.EMailRecipients
    def set_EMailRecipients(self, EMailRecipients): self.EMailRecipients = EMailRecipients
    def add_EMailRecipients(self, value): self.EMailRecipients.append(value)
    def insert_EMailRecipients_at(self, index, value): self.EMailRecipients.insert(index, value)
    def replace_EMailRecipients_at(self, index, value): self.EMailRecipients[index] = value
    def get_Grouping(self): return self.Grouping
    def set_Grouping(self, Grouping): self.Grouping = Grouping
    def get_Localization(self): return self.Localization
    def set_Localization(self, Localization): self.Localization = Localization
    def validate_ShippingDocumentEMailGroupingType(self, value):
        # Validate type ShippingDocumentEMailGroupingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BY_RECIPIENT', 'NONE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentEMailGroupingType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EMailRecipients or
            self.Grouping is not None or
            self.Localization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShippingDocumentEMailDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDocumentEMailDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShippingDocumentEMailDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShippingDocumentEMailDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShippingDocumentEMailDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShippingDocumentEMailDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EMailRecipients_ in self.EMailRecipients:
            EMailRecipients_.export(outfile, level, namespace_, name_='EMailRecipients', pretty_print=pretty_print)
        if self.Grouping is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Grouping>%s</ns:Grouping>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Grouping), input_name='Grouping')), eol_))
        if self.Localization is not None:
            self.Localization.export(outfile, level, namespace_, name_='Localization', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EMailRecipients':
            obj_ = ShippingDocumentEMailRecipient.factory()
            obj_.build(child_)
            self.EMailRecipients.append(obj_)
            obj_.original_tagname_ = 'EMailRecipients'
        elif nodeName_ == 'Grouping':
            Grouping_ = child_.text
            Grouping_ = self.gds_validate_string(Grouping_, node, 'Grouping')
            self.Grouping = Grouping_
            # validate type ShippingDocumentEMailGroupingType
            self.validate_ShippingDocumentEMailGroupingType(self.Grouping)
        elif nodeName_ == 'Localization':
            obj_ = Localization.factory()
            obj_.build(child_)
            self.Localization = obj_
            obj_.original_tagname_ = 'Localization'
# end class ShippingDocumentEMailDetail


class ShippingDocumentEMailRecipient(GeneratedsSuper):
    """Specifies an individual recipient of e-mailed shipping document(s)."""
    subclass = None
    superclass = None
    def __init__(self, RecipientType=None, Address=None):
        self.original_tagname_ = None
        self.RecipientType = RecipientType
        self.validate_EMailNotificationRecipientType(self.RecipientType)
        self.Address = Address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDocumentEMailRecipient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDocumentEMailRecipient.subclass:
            return ShippingDocumentEMailRecipient.subclass(*args_, **kwargs_)
        else:
            return ShippingDocumentEMailRecipient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RecipientType(self): return self.RecipientType
    def set_RecipientType(self, RecipientType): self.RecipientType = RecipientType
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def validate_EMailNotificationRecipientType(self, value):
        # Validate type EMailNotificationRecipientType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BROKER', 'OTHER', 'RECIPIENT', 'SHIPPER', 'THIRD_PARTY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EMailNotificationRecipientType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.RecipientType is not None or
            self.Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShippingDocumentEMailRecipient', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDocumentEMailRecipient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShippingDocumentEMailRecipient')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShippingDocumentEMailRecipient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShippingDocumentEMailRecipient'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShippingDocumentEMailRecipient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RecipientType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RecipientType>%s</ns:RecipientType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RecipientType), input_name='RecipientType')), eol_))
        if self.Address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Address>%s</ns:Address>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Address), input_name='Address')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RecipientType':
            RecipientType_ = child_.text
            RecipientType_ = self.gds_validate_string(RecipientType_, node, 'RecipientType')
            self.RecipientType = RecipientType_
            # validate type EMailNotificationRecipientType
            self.validate_EMailNotificationRecipientType(self.RecipientType)
        elif nodeName_ == 'Address':
            Address_ = child_.text
            Address_ = self.gds_validate_string(Address_, node, 'Address')
            self.Address = Address_
# end class ShippingDocumentEMailRecipient


class ShippingDocumentFormat(GeneratedsSuper):
    """Specifies characteristics of a shipping document to be produced."""
    subclass = None
    superclass = None
    def __init__(self, Dispositions=None, TopOfPageOffset=None, ImageType=None, StockType=None, ProvideInstructions=None, OptionsRequested=None, Localization=None, CustomDocumentIdentifier=None):
        self.original_tagname_ = None
        if Dispositions is None:
            self.Dispositions = []
        else:
            self.Dispositions = Dispositions
        self.TopOfPageOffset = TopOfPageOffset
        self.ImageType = ImageType
        self.validate_ShippingDocumentImageType(self.ImageType)
        self.StockType = StockType
        self.validate_ShippingDocumentStockType(self.StockType)
        self.ProvideInstructions = ProvideInstructions
        self.OptionsRequested = OptionsRequested
        self.Localization = Localization
        self.CustomDocumentIdentifier = CustomDocumentIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDocumentFormat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDocumentFormat.subclass:
            return ShippingDocumentFormat.subclass(*args_, **kwargs_)
        else:
            return ShippingDocumentFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dispositions(self): return self.Dispositions
    def set_Dispositions(self, Dispositions): self.Dispositions = Dispositions
    def add_Dispositions(self, value): self.Dispositions.append(value)
    def insert_Dispositions_at(self, index, value): self.Dispositions.insert(index, value)
    def replace_Dispositions_at(self, index, value): self.Dispositions[index] = value
    def get_TopOfPageOffset(self): return self.TopOfPageOffset
    def set_TopOfPageOffset(self, TopOfPageOffset): self.TopOfPageOffset = TopOfPageOffset
    def get_ImageType(self): return self.ImageType
    def set_ImageType(self, ImageType): self.ImageType = ImageType
    def get_StockType(self): return self.StockType
    def set_StockType(self, StockType): self.StockType = StockType
    def get_ProvideInstructions(self): return self.ProvideInstructions
    def set_ProvideInstructions(self, ProvideInstructions): self.ProvideInstructions = ProvideInstructions
    def get_OptionsRequested(self): return self.OptionsRequested
    def set_OptionsRequested(self, OptionsRequested): self.OptionsRequested = OptionsRequested
    def get_Localization(self): return self.Localization
    def set_Localization(self, Localization): self.Localization = Localization
    def get_CustomDocumentIdentifier(self): return self.CustomDocumentIdentifier
    def set_CustomDocumentIdentifier(self, CustomDocumentIdentifier): self.CustomDocumentIdentifier = CustomDocumentIdentifier
    def validate_ShippingDocumentImageType(self, value):
        # Validate type ShippingDocumentImageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DOC', 'EPL2', 'PDF', 'PNG', 'RTF', 'TEXT', 'ZPLII']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentImageType' % {"value" : value.encode("utf-8")} )
    def validate_ShippingDocumentStockType(self, value):
        # Validate type ShippingDocumentStockType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['OP_900_LG_B', 'OP_900_LL_B', 'OP_950', 'PAPER_4X6', 'PAPER_4_PER_PAGE_PORTRAIT', 'PAPER_LETTER', 'STOCK_4X6', 'STOCK_4X6.75_LEADING_DOC_TAB', 'STOCK_4X6.75_TRAILING_DOC_TAB', 'STOCK_4X8', 'STOCK_4X9_LEADING_DOC_TAB', 'STOCK_4X9_TRAILING_DOC_TAB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentStockType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Dispositions or
            self.TopOfPageOffset is not None or
            self.ImageType is not None or
            self.StockType is not None or
            self.ProvideInstructions is not None or
            self.OptionsRequested is not None or
            self.Localization is not None or
            self.CustomDocumentIdentifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShippingDocumentFormat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDocumentFormat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShippingDocumentFormat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShippingDocumentFormat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShippingDocumentFormat'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShippingDocumentFormat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Dispositions_ in self.Dispositions:
            Dispositions_.export(outfile, level, namespace_, name_='Dispositions', pretty_print=pretty_print)
        if self.TopOfPageOffset is not None:
            self.TopOfPageOffset.export(outfile, level, namespace_, name_='TopOfPageOffset', pretty_print=pretty_print)
        if self.ImageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ImageType>%s</ns:ImageType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ImageType), input_name='ImageType')), eol_))
        if self.StockType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:StockType>%s</ns:StockType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StockType), input_name='StockType')), eol_))
        if self.ProvideInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ProvideInstructions>%s</ns:ProvideInstructions>%s' % (self.gds_format_boolean(self.ProvideInstructions, input_name='ProvideInstructions'), eol_))
        if self.OptionsRequested is not None:
            self.OptionsRequested.export(outfile, level, namespace_, name_='OptionsRequested', pretty_print=pretty_print)
        if self.Localization is not None:
            self.Localization.export(outfile, level, namespace_, name_='Localization', pretty_print=pretty_print)
        if self.CustomDocumentIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomDocumentIdentifier>%s</ns:CustomDocumentIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomDocumentIdentifier), input_name='CustomDocumentIdentifier')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dispositions':
            obj_ = ShippingDocumentDispositionDetail.factory()
            obj_.build(child_)
            self.Dispositions.append(obj_)
            obj_.original_tagname_ = 'Dispositions'
        elif nodeName_ == 'TopOfPageOffset':
            obj_ = LinearMeasure.factory()
            obj_.build(child_)
            self.TopOfPageOffset = obj_
            obj_.original_tagname_ = 'TopOfPageOffset'
        elif nodeName_ == 'ImageType':
            ImageType_ = child_.text
            ImageType_ = self.gds_validate_string(ImageType_, node, 'ImageType')
            self.ImageType = ImageType_
            # validate type ShippingDocumentImageType
            self.validate_ShippingDocumentImageType(self.ImageType)
        elif nodeName_ == 'StockType':
            StockType_ = child_.text
            StockType_ = self.gds_validate_string(StockType_, node, 'StockType')
            self.StockType = StockType_
            # validate type ShippingDocumentStockType
            self.validate_ShippingDocumentStockType(self.StockType)
        elif nodeName_ == 'ProvideInstructions':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ProvideInstructions')
            self.ProvideInstructions = ival_
        elif nodeName_ == 'OptionsRequested':
            obj_ = DocumentFormatOptionsRequested.factory()
            obj_.build(child_)
            self.OptionsRequested = obj_
            obj_.original_tagname_ = 'OptionsRequested'
        elif nodeName_ == 'Localization':
            obj_ = Localization.factory()
            obj_.build(child_)
            self.Localization = obj_
            obj_.original_tagname_ = 'Localization'
        elif nodeName_ == 'CustomDocumentIdentifier':
            CustomDocumentIdentifier_ = child_.text
            CustomDocumentIdentifier_ = self.gds_validate_string(CustomDocumentIdentifier_, node, 'CustomDocumentIdentifier')
            self.CustomDocumentIdentifier = CustomDocumentIdentifier_
# end class ShippingDocumentFormat


class ShippingDocumentPart(GeneratedsSuper):
    """A single part of a shipping document, such as one page of a
    multiple-page document whose format requires a separate image
    per page."""
    subclass = None
    superclass = None
    def __init__(self, DocumentPartSequenceNumber=None, Image=None):
        self.original_tagname_ = None
        self.DocumentPartSequenceNumber = DocumentPartSequenceNumber
        self.Image = Image
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDocumentPart)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDocumentPart.subclass:
            return ShippingDocumentPart.subclass(*args_, **kwargs_)
        else:
            return ShippingDocumentPart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentPartSequenceNumber(self): return self.DocumentPartSequenceNumber
    def set_DocumentPartSequenceNumber(self, DocumentPartSequenceNumber): self.DocumentPartSequenceNumber = DocumentPartSequenceNumber
    def get_Image(self): return self.Image
    def set_Image(self, Image): self.Image = Image
    def hasContent_(self):
        if (
            self.DocumentPartSequenceNumber is not None or
            self.Image is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShippingDocumentPart', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDocumentPart')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShippingDocumentPart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShippingDocumentPart', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShippingDocumentPart'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShippingDocumentPart', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocumentPartSequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DocumentPartSequenceNumber>%s</ns:DocumentPartSequenceNumber>%s' % (self.gds_format_integer(self.DocumentPartSequenceNumber, input_name='DocumentPartSequenceNumber'), eol_))
        if self.Image is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Image>%s</ns:Image>%s' % (self.gds_format_base64(self.Image, input_name='Image'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocumentPartSequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'DocumentPartSequenceNumber')
            self.DocumentPartSequenceNumber = ival_
        elif nodeName_ == 'Image':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Image')
            else:
                bval_ = None
            self.Image = bval_
# end class ShippingDocumentPart


class ShippingDocumentPrintDetail(GeneratedsSuper):
    """Specifies printing options for a shipping document."""
    subclass = None
    superclass = None
    def __init__(self, PrinterId=None):
        self.original_tagname_ = None
        self.PrinterId = PrinterId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDocumentPrintDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDocumentPrintDetail.subclass:
            return ShippingDocumentPrintDetail.subclass(*args_, **kwargs_)
        else:
            return ShippingDocumentPrintDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PrinterId(self): return self.PrinterId
    def set_PrinterId(self, PrinterId): self.PrinterId = PrinterId
    def hasContent_(self):
        if (
            self.PrinterId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShippingDocumentPrintDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDocumentPrintDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShippingDocumentPrintDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShippingDocumentPrintDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShippingDocumentPrintDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShippingDocumentPrintDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PrinterId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PrinterId>%s</ns:PrinterId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PrinterId), input_name='PrinterId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PrinterId':
            PrinterId_ = child_.text
            PrinterId_ = self.gds_validate_string(PrinterId_, node, 'PrinterId')
            self.PrinterId = PrinterId_
# end class ShippingDocumentPrintDetail


class ShippingDocumentSpecification(GeneratedsSuper):
    """Contains all data required for additional (non-label) shipping
    documents to be produced in conjunction with a specific
    shipment."""
    subclass = None
    superclass = None
    def __init__(self, ShippingDocumentTypes=None, CertificateOfOrigin=None, CommercialInvoiceDetail=None, CustomPackageDocumentDetail=None, CustomShipmentDocumentDetail=None, ExportDeclarationDetail=None, GeneralAgencyAgreementDetail=None, NaftaCertificateOfOriginDetail=None, Op900Detail=None, DangerousGoodsShippersDeclarationDetail=None, FreightAddressLabelDetail=None, ReturnInstructionsDetail=None):
        self.original_tagname_ = None
        if ShippingDocumentTypes is None:
            self.ShippingDocumentTypes = []
        else:
            self.ShippingDocumentTypes = ShippingDocumentTypes
        self.CertificateOfOrigin = CertificateOfOrigin
        self.CommercialInvoiceDetail = CommercialInvoiceDetail
        if CustomPackageDocumentDetail is None:
            self.CustomPackageDocumentDetail = []
        else:
            self.CustomPackageDocumentDetail = CustomPackageDocumentDetail
        if CustomShipmentDocumentDetail is None:
            self.CustomShipmentDocumentDetail = []
        else:
            self.CustomShipmentDocumentDetail = CustomShipmentDocumentDetail
        self.ExportDeclarationDetail = ExportDeclarationDetail
        self.GeneralAgencyAgreementDetail = GeneralAgencyAgreementDetail
        self.NaftaCertificateOfOriginDetail = NaftaCertificateOfOriginDetail
        self.Op900Detail = Op900Detail
        self.DangerousGoodsShippersDeclarationDetail = DangerousGoodsShippersDeclarationDetail
        self.FreightAddressLabelDetail = FreightAddressLabelDetail
        self.ReturnInstructionsDetail = ReturnInstructionsDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDocumentSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDocumentSpecification.subclass:
            return ShippingDocumentSpecification.subclass(*args_, **kwargs_)
        else:
            return ShippingDocumentSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShippingDocumentTypes(self): return self.ShippingDocumentTypes
    def set_ShippingDocumentTypes(self, ShippingDocumentTypes): self.ShippingDocumentTypes = ShippingDocumentTypes
    def add_ShippingDocumentTypes(self, value): self.ShippingDocumentTypes.append(value)
    def insert_ShippingDocumentTypes_at(self, index, value): self.ShippingDocumentTypes.insert(index, value)
    def replace_ShippingDocumentTypes_at(self, index, value): self.ShippingDocumentTypes[index] = value
    def get_CertificateOfOrigin(self): return self.CertificateOfOrigin
    def set_CertificateOfOrigin(self, CertificateOfOrigin): self.CertificateOfOrigin = CertificateOfOrigin
    def get_CommercialInvoiceDetail(self): return self.CommercialInvoiceDetail
    def set_CommercialInvoiceDetail(self, CommercialInvoiceDetail): self.CommercialInvoiceDetail = CommercialInvoiceDetail
    def get_CustomPackageDocumentDetail(self): return self.CustomPackageDocumentDetail
    def set_CustomPackageDocumentDetail(self, CustomPackageDocumentDetail): self.CustomPackageDocumentDetail = CustomPackageDocumentDetail
    def add_CustomPackageDocumentDetail(self, value): self.CustomPackageDocumentDetail.append(value)
    def insert_CustomPackageDocumentDetail_at(self, index, value): self.CustomPackageDocumentDetail.insert(index, value)
    def replace_CustomPackageDocumentDetail_at(self, index, value): self.CustomPackageDocumentDetail[index] = value
    def get_CustomShipmentDocumentDetail(self): return self.CustomShipmentDocumentDetail
    def set_CustomShipmentDocumentDetail(self, CustomShipmentDocumentDetail): self.CustomShipmentDocumentDetail = CustomShipmentDocumentDetail
    def add_CustomShipmentDocumentDetail(self, value): self.CustomShipmentDocumentDetail.append(value)
    def insert_CustomShipmentDocumentDetail_at(self, index, value): self.CustomShipmentDocumentDetail.insert(index, value)
    def replace_CustomShipmentDocumentDetail_at(self, index, value): self.CustomShipmentDocumentDetail[index] = value
    def get_ExportDeclarationDetail(self): return self.ExportDeclarationDetail
    def set_ExportDeclarationDetail(self, ExportDeclarationDetail): self.ExportDeclarationDetail = ExportDeclarationDetail
    def get_GeneralAgencyAgreementDetail(self): return self.GeneralAgencyAgreementDetail
    def set_GeneralAgencyAgreementDetail(self, GeneralAgencyAgreementDetail): self.GeneralAgencyAgreementDetail = GeneralAgencyAgreementDetail
    def get_NaftaCertificateOfOriginDetail(self): return self.NaftaCertificateOfOriginDetail
    def set_NaftaCertificateOfOriginDetail(self, NaftaCertificateOfOriginDetail): self.NaftaCertificateOfOriginDetail = NaftaCertificateOfOriginDetail
    def get_Op900Detail(self): return self.Op900Detail
    def set_Op900Detail(self, Op900Detail): self.Op900Detail = Op900Detail
    def get_DangerousGoodsShippersDeclarationDetail(self): return self.DangerousGoodsShippersDeclarationDetail
    def set_DangerousGoodsShippersDeclarationDetail(self, DangerousGoodsShippersDeclarationDetail): self.DangerousGoodsShippersDeclarationDetail = DangerousGoodsShippersDeclarationDetail
    def get_FreightAddressLabelDetail(self): return self.FreightAddressLabelDetail
    def set_FreightAddressLabelDetail(self, FreightAddressLabelDetail): self.FreightAddressLabelDetail = FreightAddressLabelDetail
    def get_ReturnInstructionsDetail(self): return self.ReturnInstructionsDetail
    def set_ReturnInstructionsDetail(self, ReturnInstructionsDetail): self.ReturnInstructionsDetail = ReturnInstructionsDetail
    def validate_RequestedShippingDocumentType(self, value):
        # Validate type RequestedShippingDocumentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CERTIFICATE_OF_ORIGIN', 'COMMERCIAL_INVOICE', 'CUSTOMER_SPECIFIED_LABELS', 'CUSTOM_PACKAGE_DOCUMENT', 'CUSTOM_SHIPMENT_DOCUMENT', 'DANGEROUS_GOODS_SHIPPERS_DECLARATION', 'EXPORT_DECLARATION', 'FREIGHT_ADDRESS_LABEL', 'GENERAL_AGENCY_AGREEMENT', 'LABEL', 'NAFTA_CERTIFICATE_OF_ORIGIN', 'OP_900', 'PRO_FORMA_INVOICE', 'RETURN_INSTRUCTIONS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestedShippingDocumentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ShippingDocumentTypes or
            self.CertificateOfOrigin is not None or
            self.CommercialInvoiceDetail is not None or
            self.CustomPackageDocumentDetail or
            self.CustomShipmentDocumentDetail or
            self.ExportDeclarationDetail is not None or
            self.GeneralAgencyAgreementDetail is not None or
            self.NaftaCertificateOfOriginDetail is not None or
            self.Op900Detail is not None or
            self.DangerousGoodsShippersDeclarationDetail is not None or
            self.FreightAddressLabelDetail is not None or
            self.ReturnInstructionsDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShippingDocumentSpecification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDocumentSpecification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShippingDocumentSpecification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShippingDocumentSpecification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShippingDocumentSpecification'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShippingDocumentSpecification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ShippingDocumentTypes_ in self.ShippingDocumentTypes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ShippingDocumentTypes>%s</ns:ShippingDocumentTypes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(ShippingDocumentTypes_), input_name='ShippingDocumentTypes')), eol_))
        if self.CertificateOfOrigin is not None:
            self.CertificateOfOrigin.export(outfile, level, namespace_, name_='CertificateOfOrigin', pretty_print=pretty_print)
        if self.CommercialInvoiceDetail is not None:
            self.CommercialInvoiceDetail.export(outfile, level, namespace_, name_='CommercialInvoiceDetail', pretty_print=pretty_print)
        for CustomPackageDocumentDetail_ in self.CustomPackageDocumentDetail:
            CustomPackageDocumentDetail_.export(outfile, level, namespace_, name_='CustomPackageDocumentDetail', pretty_print=pretty_print)
        for CustomShipmentDocumentDetail_ in self.CustomShipmentDocumentDetail:
            CustomShipmentDocumentDetail_.export(outfile, level, namespace_, name_='CustomShipmentDocumentDetail', pretty_print=pretty_print)
        if self.ExportDeclarationDetail is not None:
            self.ExportDeclarationDetail.export(outfile, level, namespace_, name_='ExportDeclarationDetail', pretty_print=pretty_print)
        if self.GeneralAgencyAgreementDetail is not None:
            self.GeneralAgencyAgreementDetail.export(outfile, level, namespace_, name_='GeneralAgencyAgreementDetail', pretty_print=pretty_print)
        if self.NaftaCertificateOfOriginDetail is not None:
            self.NaftaCertificateOfOriginDetail.export(outfile, level, namespace_, name_='NaftaCertificateOfOriginDetail', pretty_print=pretty_print)
        if self.Op900Detail is not None:
            self.Op900Detail.export(outfile, level, namespace_, name_='Op900Detail', pretty_print=pretty_print)
        if self.DangerousGoodsShippersDeclarationDetail is not None:
            self.DangerousGoodsShippersDeclarationDetail.export(outfile, level, namespace_, name_='DangerousGoodsShippersDeclarationDetail', pretty_print=pretty_print)
        if self.FreightAddressLabelDetail is not None:
            self.FreightAddressLabelDetail.export(outfile, level, namespace_, name_='FreightAddressLabelDetail', pretty_print=pretty_print)
        if self.ReturnInstructionsDetail is not None:
            self.ReturnInstructionsDetail.export(outfile, level, namespace_, name_='ReturnInstructionsDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ShippingDocumentTypes':
            ShippingDocumentTypes_ = child_.text
            ShippingDocumentTypes_ = self.gds_validate_string(ShippingDocumentTypes_, node, 'ShippingDocumentTypes')
            self.ShippingDocumentTypes.append(ShippingDocumentTypes_)
            # validate type RequestedShippingDocumentType
            self.validate_RequestedShippingDocumentType(self.ShippingDocumentTypes[-1])
        elif nodeName_ == 'CertificateOfOrigin':
            obj_ = CertificateOfOriginDetail.factory()
            obj_.build(child_)
            self.CertificateOfOrigin = obj_
            obj_.original_tagname_ = 'CertificateOfOrigin'
        elif nodeName_ == 'CommercialInvoiceDetail':
            obj_ = CommercialInvoiceDetail.factory()
            obj_.build(child_)
            self.CommercialInvoiceDetail = obj_
            obj_.original_tagname_ = 'CommercialInvoiceDetail'
        elif nodeName_ == 'CustomPackageDocumentDetail':
            obj_ = CustomDocumentDetail.factory()
            obj_.build(child_)
            self.CustomPackageDocumentDetail.append(obj_)
            obj_.original_tagname_ = 'CustomPackageDocumentDetail'
        elif nodeName_ == 'CustomShipmentDocumentDetail':
            obj_ = CustomDocumentDetail.factory()
            obj_.build(child_)
            self.CustomShipmentDocumentDetail.append(obj_)
            obj_.original_tagname_ = 'CustomShipmentDocumentDetail'
        elif nodeName_ == 'ExportDeclarationDetail':
            obj_ = ExportDeclarationDetail.factory()
            obj_.build(child_)
            self.ExportDeclarationDetail = obj_
            obj_.original_tagname_ = 'ExportDeclarationDetail'
        elif nodeName_ == 'GeneralAgencyAgreementDetail':
            obj_ = GeneralAgencyAgreementDetail.factory()
            obj_.build(child_)
            self.GeneralAgencyAgreementDetail = obj_
            obj_.original_tagname_ = 'GeneralAgencyAgreementDetail'
        elif nodeName_ == 'NaftaCertificateOfOriginDetail':
            obj_ = NaftaCertificateOfOriginDetail.factory()
            obj_.build(child_)
            self.NaftaCertificateOfOriginDetail = obj_
            obj_.original_tagname_ = 'NaftaCertificateOfOriginDetail'
        elif nodeName_ == 'Op900Detail':
            obj_ = Op900Detail.factory()
            obj_.build(child_)
            self.Op900Detail = obj_
            obj_.original_tagname_ = 'Op900Detail'
        elif nodeName_ == 'DangerousGoodsShippersDeclarationDetail':
            obj_ = DangerousGoodsShippersDeclarationDetail.factory()
            obj_.build(child_)
            self.DangerousGoodsShippersDeclarationDetail = obj_
            obj_.original_tagname_ = 'DangerousGoodsShippersDeclarationDetail'
        elif nodeName_ == 'FreightAddressLabelDetail':
            obj_ = FreightAddressLabelDetail.factory()
            obj_.build(child_)
            self.FreightAddressLabelDetail = obj_
            obj_.original_tagname_ = 'FreightAddressLabelDetail'
        elif nodeName_ == 'ReturnInstructionsDetail':
            obj_ = ReturnInstructionsDetail.factory()
            obj_.build(child_)
            self.ReturnInstructionsDetail = obj_
            obj_.original_tagname_ = 'ReturnInstructionsDetail'
# end class ShippingDocumentSpecification


class ShippingDocumentStorageDetail(GeneratedsSuper):
    """Specifies how to store shipping documents."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, FilePath=None, FileNaming=None, FileSuffix=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_ShippingDocumentStorageDetailType(self.Type)
        self.FilePath = FilePath
        self.FileNaming = FileNaming
        self.validate_ShippingDocumentNamingType(self.FileNaming)
        self.FileSuffix = FileSuffix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShippingDocumentStorageDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShippingDocumentStorageDetail.subclass:
            return ShippingDocumentStorageDetail.subclass(*args_, **kwargs_)
        else:
            return ShippingDocumentStorageDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_FilePath(self): return self.FilePath
    def set_FilePath(self, FilePath): self.FilePath = FilePath
    def get_FileNaming(self): return self.FileNaming
    def set_FileNaming(self, FileNaming): self.FileNaming = FileNaming
    def get_FileSuffix(self): return self.FileSuffix
    def set_FileSuffix(self, FileSuffix): self.FileSuffix = FileSuffix
    def validate_ShippingDocumentStorageDetailType(self, value):
        # Validate type ShippingDocumentStorageDetailType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ASYNC_SERVICE', 'LOCAL_FILE_SYSTEM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentStorageDetailType' % {"value" : value.encode("utf-8")} )
    def validate_ShippingDocumentNamingType(self, value):
        # Validate type ShippingDocumentNamingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FAST', 'LEGACY_FXRS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShippingDocumentNamingType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.FilePath is not None or
            self.FileNaming is not None or
            self.FileSuffix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ShippingDocumentStorageDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShippingDocumentStorageDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShippingDocumentStorageDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ShippingDocumentStorageDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ShippingDocumentStorageDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ShippingDocumentStorageDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.FilePath is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FilePath>%s</ns:FilePath>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FilePath), input_name='FilePath')), eol_))
        if self.FileNaming is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FileNaming>%s</ns:FileNaming>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FileNaming), input_name='FileNaming')), eol_))
        if self.FileSuffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FileSuffix>%s</ns:FileSuffix>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FileSuffix), input_name='FileSuffix')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type ShippingDocumentStorageDetailType
            self.validate_ShippingDocumentStorageDetailType(self.Type)
        elif nodeName_ == 'FilePath':
            FilePath_ = child_.text
            FilePath_ = self.gds_validate_string(FilePath_, node, 'FilePath')
            self.FilePath = FilePath_
        elif nodeName_ == 'FileNaming':
            FileNaming_ = child_.text
            FileNaming_ = self.gds_validate_string(FileNaming_, node, 'FileNaming')
            self.FileNaming = FileNaming_
            # validate type ShippingDocumentNamingType
            self.validate_ShippingDocumentNamingType(self.FileNaming)
        elif nodeName_ == 'FileSuffix':
            FileSuffix_ = child_.text
            FileSuffix_ = self.gds_validate_string(FileSuffix_, node, 'FileSuffix')
            self.FileSuffix = FileSuffix_
# end class ShippingDocumentStorageDetail


class SignatureOptionDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OptionType=None, SignatureReleaseNumber=None):
        self.original_tagname_ = None
        self.OptionType = OptionType
        self.validate_SignatureOptionType(self.OptionType)
        self.SignatureReleaseNumber = SignatureReleaseNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureOptionDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureOptionDetail.subclass:
            return SignatureOptionDetail.subclass(*args_, **kwargs_)
        else:
            return SignatureOptionDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptionType(self): return self.OptionType
    def set_OptionType(self, OptionType): self.OptionType = OptionType
    def get_SignatureReleaseNumber(self): return self.SignatureReleaseNumber
    def set_SignatureReleaseNumber(self, SignatureReleaseNumber): self.SignatureReleaseNumber = SignatureReleaseNumber
    def validate_SignatureOptionType(self, value):
        # Validate type SignatureOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADULT', 'DIRECT', 'INDIRECT', 'NO_SIGNATURE_REQUIRED', 'SERVICE_DEFAULT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SignatureOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OptionType is not None or
            self.SignatureReleaseNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='SignatureOptionDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureOptionDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureOptionDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='SignatureOptionDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='SignatureOptionDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='SignatureOptionDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OptionType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:OptionType>%s</ns:OptionType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OptionType), input_name='OptionType')), eol_))
        if self.SignatureReleaseNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SignatureReleaseNumber>%s</ns:SignatureReleaseNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SignatureReleaseNumber), input_name='SignatureReleaseNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptionType':
            OptionType_ = child_.text
            OptionType_ = self.gds_validate_string(OptionType_, node, 'OptionType')
            self.OptionType = OptionType_
            # validate type SignatureOptionType
            self.validate_SignatureOptionType(self.OptionType)
        elif nodeName_ == 'SignatureReleaseNumber':
            SignatureReleaseNumber_ = child_.text
            SignatureReleaseNumber_ = self.gds_validate_string(SignatureReleaseNumber_, node, 'SignatureReleaseNumber')
            self.SignatureReleaseNumber = SignatureReleaseNumber_
# end class SignatureOptionDetail


class SmartPostShipmentDetail(GeneratedsSuper):
    """Data required for shipments handled under the SMART_POST and
    GROUND_SMART_POST service types."""
    subclass = None
    superclass = None
    def __init__(self, ProcessingOptionsRequested=None, Indicia=None, AncillaryEndorsement=None, HubId=None, CustomerManifestId=None):
        self.original_tagname_ = None
        self.ProcessingOptionsRequested = ProcessingOptionsRequested
        self.Indicia = Indicia
        self.validate_SmartPostIndiciaType(self.Indicia)
        self.AncillaryEndorsement = AncillaryEndorsement
        self.validate_SmartPostAncillaryEndorsementType(self.AncillaryEndorsement)
        self.HubId = HubId
        self.CustomerManifestId = CustomerManifestId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SmartPostShipmentDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SmartPostShipmentDetail.subclass:
            return SmartPostShipmentDetail.subclass(*args_, **kwargs_)
        else:
            return SmartPostShipmentDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProcessingOptionsRequested(self): return self.ProcessingOptionsRequested
    def set_ProcessingOptionsRequested(self, ProcessingOptionsRequested): self.ProcessingOptionsRequested = ProcessingOptionsRequested
    def get_Indicia(self): return self.Indicia
    def set_Indicia(self, Indicia): self.Indicia = Indicia
    def get_AncillaryEndorsement(self): return self.AncillaryEndorsement
    def set_AncillaryEndorsement(self, AncillaryEndorsement): self.AncillaryEndorsement = AncillaryEndorsement
    def get_HubId(self): return self.HubId
    def set_HubId(self, HubId): self.HubId = HubId
    def get_CustomerManifestId(self): return self.CustomerManifestId
    def set_CustomerManifestId(self, CustomerManifestId): self.CustomerManifestId = CustomerManifestId
    def validate_SmartPostIndiciaType(self, value):
        # Validate type SmartPostIndiciaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MEDIA_MAIL', 'PARCEL_RETURN', 'PARCEL_SELECT', 'PRESORTED_BOUND_PRINTED_MATTER', 'PRESORTED_STANDARD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SmartPostIndiciaType' % {"value" : value.encode("utf-8")} )
    def validate_SmartPostAncillaryEndorsementType(self, value):
        # Validate type SmartPostAncillaryEndorsementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADDRESS_CORRECTION', 'CARRIER_LEAVE_IF_NO_RESPONSE', 'CHANGE_SERVICE', 'FORWARDING_SERVICE', 'RETURN_SERVICE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SmartPostAncillaryEndorsementType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ProcessingOptionsRequested is not None or
            self.Indicia is not None or
            self.AncillaryEndorsement is not None or
            self.HubId is not None or
            self.CustomerManifestId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='SmartPostShipmentDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SmartPostShipmentDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SmartPostShipmentDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='SmartPostShipmentDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='SmartPostShipmentDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='SmartPostShipmentDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProcessingOptionsRequested is not None:
            self.ProcessingOptionsRequested.export(outfile, level, namespace_, name_='ProcessingOptionsRequested', pretty_print=pretty_print)
        if self.Indicia is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Indicia>%s</ns:Indicia>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Indicia), input_name='Indicia')), eol_))
        if self.AncillaryEndorsement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:AncillaryEndorsement>%s</ns:AncillaryEndorsement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AncillaryEndorsement), input_name='AncillaryEndorsement')), eol_))
        if self.HubId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HubId>%s</ns:HubId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HubId), input_name='HubId')), eol_))
        if self.CustomerManifestId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomerManifestId>%s</ns:CustomerManifestId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerManifestId), input_name='CustomerManifestId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProcessingOptionsRequested':
            obj_ = SmartPostShipmentProcessingOptionsRequested.factory()
            obj_.build(child_)
            self.ProcessingOptionsRequested = obj_
            obj_.original_tagname_ = 'ProcessingOptionsRequested'
        elif nodeName_ == 'Indicia':
            Indicia_ = child_.text
            Indicia_ = self.gds_validate_string(Indicia_, node, 'Indicia')
            self.Indicia = Indicia_
            # validate type SmartPostIndiciaType
            self.validate_SmartPostIndiciaType(self.Indicia)
        elif nodeName_ == 'AncillaryEndorsement':
            AncillaryEndorsement_ = child_.text
            AncillaryEndorsement_ = self.gds_validate_string(AncillaryEndorsement_, node, 'AncillaryEndorsement')
            self.AncillaryEndorsement = AncillaryEndorsement_
            # validate type SmartPostAncillaryEndorsementType
            self.validate_SmartPostAncillaryEndorsementType(self.AncillaryEndorsement)
        elif nodeName_ == 'HubId':
            HubId_ = child_.text
            HubId_ = self.gds_validate_string(HubId_, node, 'HubId')
            self.HubId = HubId_
        elif nodeName_ == 'CustomerManifestId':
            CustomerManifestId_ = child_.text
            CustomerManifestId_ = self.gds_validate_string(CustomerManifestId_, node, 'CustomerManifestId')
            self.CustomerManifestId = CustomerManifestId_
# end class SmartPostShipmentDetail


class SmartPostShipmentProcessingOptionsRequested(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Options=None):
        self.original_tagname_ = None
        if Options is None:
            self.Options = []
        else:
            self.Options = Options
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SmartPostShipmentProcessingOptionsRequested)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SmartPostShipmentProcessingOptionsRequested.subclass:
            return SmartPostShipmentProcessingOptionsRequested.subclass(*args_, **kwargs_)
        else:
            return SmartPostShipmentProcessingOptionsRequested(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Options(self): return self.Options
    def set_Options(self, Options): self.Options = Options
    def add_Options(self, value): self.Options.append(value)
    def insert_Options_at(self, index, value): self.Options.insert(index, value)
    def replace_Options_at(self, index, value): self.Options[index] = value
    def validate_SmartPostShipmentProcessingOptionType(self, value):
        # Validate type SmartPostShipmentProcessingOptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['GROUND_TRACKING_NUMBER_REQUESTED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SmartPostShipmentProcessingOptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Options
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='SmartPostShipmentProcessingOptionsRequested', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SmartPostShipmentProcessingOptionsRequested')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SmartPostShipmentProcessingOptionsRequested')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='SmartPostShipmentProcessingOptionsRequested', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='SmartPostShipmentProcessingOptionsRequested'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='SmartPostShipmentProcessingOptionsRequested', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Options_ in self.Options:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Options>%s</ns:Options>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Options_), input_name='Options')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Options':
            Options_ = child_.text
            Options_ = self.gds_validate_string(Options_, node, 'Options')
            self.Options.append(Options_)
            # validate type SmartPostShipmentProcessingOptionType
            self.validate_SmartPostShipmentProcessingOptionType(self.Options[-1])
# end class SmartPostShipmentProcessingOptionsRequested


class StringBarcode(GeneratedsSuper):
    """Each instance of this data type represents a barcode whose content
    must be represented as ASCII text (i.e. not binary data)."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_StringBarcodeType(self.Type)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringBarcode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringBarcode.subclass:
            return StringBarcode.subclass(*args_, **kwargs_)
        else:
            return StringBarcode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_StringBarcodeType(self, value):
        # Validate type StringBarcodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ADDRESS', 'ASTRA', 'FEDEX_1D', 'GROUND', 'POSTAL', 'USPS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on StringBarcodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='StringBarcode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringBarcode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringBarcode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='StringBarcode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='StringBarcode'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='StringBarcode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Type>%s</ns:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type StringBarcodeType
            self.validate_StringBarcodeType(self.Type)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class StringBarcode


class Surcharge(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SurchargeType=None, Level=None, Description=None, Amount=None):
        self.original_tagname_ = None
        self.SurchargeType = SurchargeType
        self.validate_SurchargeType(self.SurchargeType)
        self.Level = Level
        self.validate_SurchargeLevelType(self.Level)
        self.Description = Description
        self.Amount = Amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Surcharge)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Surcharge.subclass:
            return Surcharge.subclass(*args_, **kwargs_)
        else:
            return Surcharge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SurchargeType(self): return self.SurchargeType
    def set_SurchargeType(self, SurchargeType): self.SurchargeType = SurchargeType
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def validate_SurchargeType(self, value):
        # Validate type SurchargeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACCOUNT_NUMBER_PROCESSING_FEE', 'ADDITIONAL_HANDLING', 'ADDRESS_CORRECTION', 'ANCILLARY_FEE', 'APPOINTMENT_DELIVERY', 'BROKER_SELECT_OPTION', 'CANADIAN_DESTINATION', 'CLEARANCE_ENTRY_FEE', 'COD', 'CUT_FLOWERS', 'DANGEROUS_GOODS', 'DELIVERY_AREA', 'DELIVERY_CONFIRMATION', 'DELIVERY_ON_INVOICE_ACCEPTANCE', 'DOCUMENTATION_FEE', 'DRY_ICE', 'EMAIL_LABEL', 'EUROPE_FIRST', 'EXCESS_VALUE', 'EXHIBITION', 'EXPORT', 'EXTRA_SURFACE_HANDLING_CHARGE', 'EXTREME_LENGTH', 'FEDEX_INTRACOUNTRY_FEES', 'FEDEX_TAG', 'FICE', 'FLATBED', 'FREIGHT_GUARANTEE', 'FREIGHT_ON_VALUE', 'FREIGHT_TO_COLLECT', 'FUEL', 'HOLD_AT_LOCATION', 'HOME_DELIVERY_APPOINTMENT', 'HOME_DELIVERY_DATE_CERTAIN', 'HOME_DELIVERY_EVENING', 'INSIDE_DELIVERY', 'INSIDE_PICKUP', 'INSURED_VALUE', 'INTERHAWAII', 'LIFTGATE_DELIVERY', 'LIFTGATE_PICKUP', 'LIMITED_ACCESS_DELIVERY', 'LIMITED_ACCESS_PICKUP', 'METRO_DELIVERY', 'METRO_PICKUP', 'NON_MACHINABLE', 'OFFSHORE', 'ON_CALL_PICKUP', 'ON_DEMAND_CARE', 'OTHER', 'OUT_OF_DELIVERY_AREA', 'OUT_OF_PICKUP_AREA', 'OVERSIZE', 'OVER_DIMENSION', 'PIECE_COUNT_VERIFICATION', 'PRE_DELIVERY_NOTIFICATION', 'PRIORITY_ALERT', 'PROTECTION_FROM_FREEZING', 'REGIONAL_MALL_DELIVERY', 'REGIONAL_MALL_PICKUP', 'REROUTE', 'RESCHEDULE', 'RESIDENTIAL_DELIVERY', 'RESIDENTIAL_PICKUP', 'RETURN_LABEL', 'SATURDAY_DELIVERY', 'SATURDAY_PICKUP', 'SIGNATURE_OPTION', 'TARP', 'THIRD_PARTY_CONSIGNEE', 'TRANSMART_SERVICE_FEE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SurchargeType' % {"value" : value.encode("utf-8")} )
    def validate_SurchargeLevelType(self, value):
        # Validate type SurchargeLevelType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PACKAGE', 'SHIPMENT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SurchargeLevelType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SurchargeType is not None or
            self.Level is not None or
            self.Description is not None or
            self.Amount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Surcharge', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Surcharge')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Surcharge')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Surcharge', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Surcharge'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Surcharge', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SurchargeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SurchargeType>%s</ns:SurchargeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SurchargeType), input_name='SurchargeType')), eol_))
        if self.Level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Level>%s</ns:Level>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Level), input_name='Level')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Amount is not None:
            self.Amount.export(outfile, level, namespace_, name_='Amount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SurchargeType':
            SurchargeType_ = child_.text
            SurchargeType_ = self.gds_validate_string(SurchargeType_, node, 'SurchargeType')
            self.SurchargeType = SurchargeType_
            # validate type SurchargeType
            self.validate_SurchargeType(self.SurchargeType)
        elif nodeName_ == 'Level':
            Level_ = child_.text
            Level_ = self.gds_validate_string(Level_, node, 'Level')
            self.Level = Level_
            # validate type SurchargeLevelType
            self.validate_SurchargeLevelType(self.Level)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Amount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.Amount = obj_
            obj_.original_tagname_ = 'Amount'
# end class Surcharge


class Tax(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxType=None, Description=None, Amount=None):
        self.original_tagname_ = None
        self.TaxType = TaxType
        self.validate_TaxType(self.TaxType)
        self.Description = Description
        self.Amount = Amount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Tax)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Tax.subclass:
            return Tax.subclass(*args_, **kwargs_)
        else:
            return Tax(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxType(self): return self.TaxType
    def set_TaxType(self, TaxType): self.TaxType = TaxType
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def validate_TaxType(self, value):
        # Validate type TaxType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EXPORT', 'GST', 'HST', 'INTRACOUNTRY', 'OTHER', 'PST', 'VAT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TaxType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TaxType is not None or
            self.Description is not None or
            self.Amount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Tax', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Tax')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Tax')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Tax', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Tax'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Tax', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TaxType>%s</ns:TaxType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxType), input_name='TaxType')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Amount is not None:
            self.Amount.export(outfile, level, namespace_, name_='Amount', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxType':
            TaxType_ = child_.text
            TaxType_ = self.gds_validate_string(TaxType_, node, 'TaxType')
            self.TaxType = TaxType_
            # validate type TaxType
            self.validate_TaxType(self.TaxType)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Amount':
            obj_ = Money.factory()
            obj_.build(child_)
            self.Amount = obj_
            obj_.original_tagname_ = 'Amount'
# end class Tax


class TaxpayerIdentification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TinType=None, Number=None, Usage=None, EffectiveDate=None, ExpirationDate=None):
        self.original_tagname_ = None
        self.TinType = TinType
        self.validate_TinType(self.TinType)
        self.Number = Number
        self.Usage = Usage
        if isinstance(EffectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EffectiveDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EffectiveDate
        self.EffectiveDate = initvalue_
        if isinstance(ExpirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ExpirationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ExpirationDate
        self.ExpirationDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxpayerIdentification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxpayerIdentification.subclass:
            return TaxpayerIdentification.subclass(*args_, **kwargs_)
        else:
            return TaxpayerIdentification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TinType(self): return self.TinType
    def set_TinType(self, TinType): self.TinType = TinType
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def get_EffectiveDate(self): return self.EffectiveDate
    def set_EffectiveDate(self, EffectiveDate): self.EffectiveDate = EffectiveDate
    def get_ExpirationDate(self): return self.ExpirationDate
    def set_ExpirationDate(self, ExpirationDate): self.ExpirationDate = ExpirationDate
    def validate_TinType(self, value):
        # Validate type TinType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BUSINESS_NATIONAL', 'BUSINESS_STATE', 'BUSINESS_UNION', 'PERSONAL_NATIONAL', 'PERSONAL_STATE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TinType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TinType is not None or
            self.Number is not None or
            self.Usage is not None or
            self.EffectiveDate is not None or
            self.ExpirationDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='TaxpayerIdentification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxpayerIdentification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxpayerIdentification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='TaxpayerIdentification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='TaxpayerIdentification'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='TaxpayerIdentification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TinType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TinType>%s</ns:TinType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TinType), input_name='TinType')), eol_))
        if self.Number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Number>%s</ns:Number>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Number), input_name='Number')), eol_))
        if self.Usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Usage>%s</ns:Usage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Usage), input_name='Usage')), eol_))
        if self.EffectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:EffectiveDate>%s</ns:EffectiveDate>%s' % (self.gds_format_datetime(self.EffectiveDate, input_name='EffectiveDate'), eol_))
        if self.ExpirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ExpirationDate>%s</ns:ExpirationDate>%s' % (self.gds_format_datetime(self.ExpirationDate, input_name='ExpirationDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TinType':
            TinType_ = child_.text
            TinType_ = self.gds_validate_string(TinType_, node, 'TinType')
            self.TinType = TinType_
            # validate type TinType
            self.validate_TinType(self.TinType)
        elif nodeName_ == 'Number':
            Number_ = child_.text
            Number_ = self.gds_validate_string(Number_, node, 'Number')
            self.Number = Number_
        elif nodeName_ == 'Usage':
            Usage_ = child_.text
            Usage_ = self.gds_validate_string(Usage_, node, 'Usage')
            self.Usage = Usage_
        elif nodeName_ == 'EffectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.EffectiveDate = dval_
        elif nodeName_ == 'ExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ExpirationDate = dval_
# end class TaxpayerIdentification


class TrackingId(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TrackingIdType=None, FormId=None, UspsApplicationId=None, TrackingNumber=None):
        self.original_tagname_ = None
        self.TrackingIdType = TrackingIdType
        self.validate_TrackingIdType(self.TrackingIdType)
        self.FormId = FormId
        self.UspsApplicationId = UspsApplicationId
        self.TrackingNumber = TrackingNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrackingId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrackingId.subclass:
            return TrackingId.subclass(*args_, **kwargs_)
        else:
            return TrackingId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrackingIdType(self): return self.TrackingIdType
    def set_TrackingIdType(self, TrackingIdType): self.TrackingIdType = TrackingIdType
    def get_FormId(self): return self.FormId
    def set_FormId(self, FormId): self.FormId = FormId
    def get_UspsApplicationId(self): return self.UspsApplicationId
    def set_UspsApplicationId(self, UspsApplicationId): self.UspsApplicationId = UspsApplicationId
    def get_TrackingNumber(self): return self.TrackingNumber
    def set_TrackingNumber(self, TrackingNumber): self.TrackingNumber = TrackingNumber
    def validate_TrackingIdType(self, value):
        # Validate type TrackingIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EXPRESS', 'FEDEX', 'FREIGHT', 'GROUND', 'USPS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TrackingIdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TrackingIdType is not None or
            self.FormId is not None or
            self.UspsApplicationId is not None or
            self.TrackingNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='TrackingId', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrackingId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrackingId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='TrackingId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='TrackingId'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='TrackingId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrackingIdType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TrackingIdType>%s</ns:TrackingIdType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TrackingIdType), input_name='TrackingIdType')), eol_))
        if self.FormId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:FormId>%s</ns:FormId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FormId), input_name='FormId')), eol_))
        if self.UspsApplicationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:UspsApplicationId>%s</ns:UspsApplicationId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UspsApplicationId), input_name='UspsApplicationId')), eol_))
        if self.TrackingNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TrackingNumber>%s</ns:TrackingNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TrackingNumber), input_name='TrackingNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrackingIdType':
            TrackingIdType_ = child_.text
            TrackingIdType_ = self.gds_validate_string(TrackingIdType_, node, 'TrackingIdType')
            self.TrackingIdType = TrackingIdType_
            # validate type TrackingIdType
            self.validate_TrackingIdType(self.TrackingIdType)
        elif nodeName_ == 'FormId':
            FormId_ = child_.text
            FormId_ = self.gds_validate_string(FormId_, node, 'FormId')
            self.FormId = FormId_
        elif nodeName_ == 'UspsApplicationId':
            UspsApplicationId_ = child_.text
            UspsApplicationId_ = self.gds_validate_string(UspsApplicationId_, node, 'UspsApplicationId')
            self.UspsApplicationId = UspsApplicationId_
        elif nodeName_ == 'TrackingNumber':
            TrackingNumber_ = child_.text
            TrackingNumber_ = self.gds_validate_string(TrackingNumber_, node, 'TrackingNumber')
            self.TrackingNumber = TrackingNumber_
# end class TrackingId


class TransactionDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomerTransactionId=None, Localization=None):
        self.original_tagname_ = None
        self.CustomerTransactionId = CustomerTransactionId
        self.Localization = Localization
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransactionDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransactionDetail.subclass:
            return TransactionDetail.subclass(*args_, **kwargs_)
        else:
            return TransactionDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerTransactionId(self): return self.CustomerTransactionId
    def set_CustomerTransactionId(self, CustomerTransactionId): self.CustomerTransactionId = CustomerTransactionId
    def get_Localization(self): return self.Localization
    def set_Localization(self, Localization): self.Localization = Localization
    def hasContent_(self):
        if (
            self.CustomerTransactionId is not None or
            self.Localization is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='TransactionDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransactionDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransactionDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='TransactionDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='TransactionDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='TransactionDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerTransactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomerTransactionId>%s</ns:CustomerTransactionId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerTransactionId), input_name='CustomerTransactionId')), eol_))
        if self.Localization is not None:
            self.Localization.export(outfile, level, namespace_, name_='Localization', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerTransactionId':
            CustomerTransactionId_ = child_.text
            CustomerTransactionId_ = self.gds_validate_string(CustomerTransactionId_, node, 'CustomerTransactionId')
            self.CustomerTransactionId = CustomerTransactionId_
        elif nodeName_ == 'Localization':
            obj_ = Localization.factory()
            obj_.build(child_)
            self.Localization = obj_
            obj_.original_tagname_ = 'Localization'
# end class TransactionDetail


class UploadDocumentReferenceDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LineNumber=None, CustomerReference=None, Description=None, DocumentProducer=None, DocumentType=None, DocumentId=None, DocumentIdProducer=None):
        self.original_tagname_ = None
        self.LineNumber = LineNumber
        self.CustomerReference = CustomerReference
        self.Description = Description
        self.DocumentProducer = DocumentProducer
        self.validate_UploadDocumentProducerType(self.DocumentProducer)
        self.DocumentType = DocumentType
        self.validate_UploadDocumentType(self.DocumentType)
        self.DocumentId = DocumentId
        self.DocumentIdProducer = DocumentIdProducer
        self.validate_UploadDocumentIdProducer(self.DocumentIdProducer)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UploadDocumentReferenceDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UploadDocumentReferenceDetail.subclass:
            return UploadDocumentReferenceDetail.subclass(*args_, **kwargs_)
        else:
            return UploadDocumentReferenceDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LineNumber(self): return self.LineNumber
    def set_LineNumber(self, LineNumber): self.LineNumber = LineNumber
    def get_CustomerReference(self): return self.CustomerReference
    def set_CustomerReference(self, CustomerReference): self.CustomerReference = CustomerReference
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_DocumentProducer(self): return self.DocumentProducer
    def set_DocumentProducer(self, DocumentProducer): self.DocumentProducer = DocumentProducer
    def get_DocumentType(self): return self.DocumentType
    def set_DocumentType(self, DocumentType): self.DocumentType = DocumentType
    def get_DocumentId(self): return self.DocumentId
    def set_DocumentId(self, DocumentId): self.DocumentId = DocumentId
    def get_DocumentIdProducer(self): return self.DocumentIdProducer
    def set_DocumentIdProducer(self, DocumentIdProducer): self.DocumentIdProducer = DocumentIdProducer
    def validate_UploadDocumentProducerType(self, value):
        # Validate type UploadDocumentProducerType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUSTOMER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on UploadDocumentProducerType' % {"value" : value.encode("utf-8")} )
    def validate_UploadDocumentType(self, value):
        # Validate type UploadDocumentType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CERTIFICATE_OF_ORIGIN', 'COMMERCIAL_INVOICE', 'ETD_LABEL', 'NAFTA_CERTIFICATE_OF_ORIGIN', 'NET_RATE_SHEET', 'OTHER', 'PRO_FORMA_INVOICE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on UploadDocumentType' % {"value" : value.encode("utf-8")} )
    def validate_UploadDocumentIdProducer(self, value):
        # Validate type UploadDocumentIdProducer, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUSTOMER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on UploadDocumentIdProducer' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LineNumber is not None or
            self.CustomerReference is not None or
            self.Description is not None or
            self.DocumentProducer is not None or
            self.DocumentType is not None or
            self.DocumentId is not None or
            self.DocumentIdProducer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='UploadDocumentReferenceDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UploadDocumentReferenceDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UploadDocumentReferenceDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='UploadDocumentReferenceDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='UploadDocumentReferenceDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='UploadDocumentReferenceDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LineNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LineNumber>%s</ns:LineNumber>%s' % (self.gds_format_integer(self.LineNumber, input_name='LineNumber'), eol_))
        if self.CustomerReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:CustomerReference>%s</ns:CustomerReference>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerReference), input_name='CustomerReference')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Description>%s</ns:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.DocumentProducer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DocumentProducer>%s</ns:DocumentProducer>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocumentProducer), input_name='DocumentProducer')), eol_))
        if self.DocumentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DocumentType>%s</ns:DocumentType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocumentType), input_name='DocumentType')), eol_))
        if self.DocumentId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DocumentId>%s</ns:DocumentId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocumentId), input_name='DocumentId')), eol_))
        if self.DocumentIdProducer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:DocumentIdProducer>%s</ns:DocumentIdProducer>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocumentIdProducer), input_name='DocumentIdProducer')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LineNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'LineNumber')
            self.LineNumber = ival_
        elif nodeName_ == 'CustomerReference':
            CustomerReference_ = child_.text
            CustomerReference_ = self.gds_validate_string(CustomerReference_, node, 'CustomerReference')
            self.CustomerReference = CustomerReference_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'DocumentProducer':
            DocumentProducer_ = child_.text
            DocumentProducer_ = self.gds_validate_string(DocumentProducer_, node, 'DocumentProducer')
            self.DocumentProducer = DocumentProducer_
            # validate type UploadDocumentProducerType
            self.validate_UploadDocumentProducerType(self.DocumentProducer)
        elif nodeName_ == 'DocumentType':
            DocumentType_ = child_.text
            DocumentType_ = self.gds_validate_string(DocumentType_, node, 'DocumentType')
            self.DocumentType = DocumentType_
            # validate type UploadDocumentType
            self.validate_UploadDocumentType(self.DocumentType)
        elif nodeName_ == 'DocumentId':
            DocumentId_ = child_.text
            DocumentId_ = self.gds_validate_string(DocumentId_, node, 'DocumentId')
            self.DocumentId = DocumentId_
        elif nodeName_ == 'DocumentIdProducer':
            DocumentIdProducer_ = child_.text
            DocumentIdProducer_ = self.gds_validate_string(DocumentIdProducer_, node, 'DocumentIdProducer')
            self.DocumentIdProducer = DocumentIdProducer_
            # validate type UploadDocumentIdProducer
            self.validate_UploadDocumentIdProducer(self.DocumentIdProducer)
# end class UploadDocumentReferenceDetail


class ValidateShipmentRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAuthenticationDetail=None, ClientDetail=None, TransactionDetail=None, Version=None, RequestedShipment=None):
        self.original_tagname_ = None
        self.WebAuthenticationDetail = WebAuthenticationDetail
        self.ClientDetail = ClientDetail
        self.TransactionDetail = TransactionDetail
        self.Version = Version
        self.RequestedShipment = RequestedShipment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidateShipmentRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidateShipmentRequest.subclass:
            return ValidateShipmentRequest.subclass(*args_, **kwargs_)
        else:
            return ValidateShipmentRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAuthenticationDetail(self): return self.WebAuthenticationDetail
    def set_WebAuthenticationDetail(self, WebAuthenticationDetail): self.WebAuthenticationDetail = WebAuthenticationDetail
    def get_ClientDetail(self): return self.ClientDetail
    def set_ClientDetail(self, ClientDetail): self.ClientDetail = ClientDetail
    def get_TransactionDetail(self): return self.TransactionDetail
    def set_TransactionDetail(self, TransactionDetail): self.TransactionDetail = TransactionDetail
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_RequestedShipment(self): return self.RequestedShipment
    def set_RequestedShipment(self, RequestedShipment): self.RequestedShipment = RequestedShipment
    def hasContent_(self):
        if (
            self.WebAuthenticationDetail is not None or
            self.ClientDetail is not None or
            self.TransactionDetail is not None or
            self.Version is not None or
            self.RequestedShipment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ValidateShipmentRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidateShipmentRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValidateShipmentRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ValidateShipmentRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ValidateShipmentRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ValidateShipmentRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WebAuthenticationDetail is not None:
            self.WebAuthenticationDetail.export(outfile, level, namespace_, name_='WebAuthenticationDetail', pretty_print=pretty_print)
        if self.ClientDetail is not None:
            self.ClientDetail.export(outfile, level, namespace_, name_='ClientDetail', pretty_print=pretty_print)
        if self.TransactionDetail is not None:
            self.TransactionDetail.export(outfile, level, namespace_, name_='TransactionDetail', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.RequestedShipment is not None:
            self.RequestedShipment.export(outfile, level, namespace_, name_='RequestedShipment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAuthenticationDetail':
            obj_ = WebAuthenticationDetail.factory()
            obj_.build(child_)
            self.WebAuthenticationDetail = obj_
            obj_.original_tagname_ = 'WebAuthenticationDetail'
        elif nodeName_ == 'ClientDetail':
            obj_ = ClientDetail.factory()
            obj_.build(child_)
            self.ClientDetail = obj_
            obj_.original_tagname_ = 'ClientDetail'
        elif nodeName_ == 'TransactionDetail':
            obj_ = TransactionDetail.factory()
            obj_.build(child_)
            self.TransactionDetail = obj_
            obj_.original_tagname_ = 'TransactionDetail'
        elif nodeName_ == 'Version':
            obj_ = VersionId.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'RequestedShipment':
            obj_ = RequestedShipment.factory()
            obj_.build(child_)
            self.RequestedShipment = obj_
            obj_.original_tagname_ = 'RequestedShipment'
# end class ValidateShipmentRequest


class ValidatedHazardousCommodityContent(GeneratedsSuper):
    """Documents the kind and quantity of an individual hazardous commodity
    in a package."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Quantity=None, MassPoints=None, Options=None, NetExplosiveDetail=None):
        self.original_tagname_ = None
        self.Description = Description
        self.Quantity = Quantity
        self.MassPoints = MassPoints
        self.Options = Options
        self.NetExplosiveDetail = NetExplosiveDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidatedHazardousCommodityContent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidatedHazardousCommodityContent.subclass:
            return ValidatedHazardousCommodityContent.subclass(*args_, **kwargs_)
        else:
            return ValidatedHazardousCommodityContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def get_MassPoints(self): return self.MassPoints
    def set_MassPoints(self, MassPoints): self.MassPoints = MassPoints
    def get_Options(self): return self.Options
    def set_Options(self, Options): self.Options = Options
    def get_NetExplosiveDetail(self): return self.NetExplosiveDetail
    def set_NetExplosiveDetail(self, NetExplosiveDetail): self.NetExplosiveDetail = NetExplosiveDetail
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Quantity is not None or
            self.MassPoints is not None or
            self.Options is not None or
            self.NetExplosiveDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ValidatedHazardousCommodityContent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidatedHazardousCommodityContent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValidatedHazardousCommodityContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ValidatedHazardousCommodityContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ValidatedHazardousCommodityContent'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ValidatedHazardousCommodityContent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Quantity is not None:
            self.Quantity.export(outfile, level, namespace_, name_='Quantity', pretty_print=pretty_print)
        if self.MassPoints is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:MassPoints>%s</ns:MassPoints>%s' % (self.gds_format_float(self.MassPoints, input_name='MassPoints'), eol_))
        if self.Options is not None:
            self.Options.export(outfile, level, namespace_, name_='Options', pretty_print=pretty_print)
        if self.NetExplosiveDetail is not None:
            self.NetExplosiveDetail.export(outfile, level, namespace_, name_='NetExplosiveDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = ValidatedHazardousCommodityDescription.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Quantity':
            obj_ = HazardousCommodityQuantityDetail.factory()
            obj_.build(child_)
            self.Quantity = obj_
            obj_.original_tagname_ = 'Quantity'
        elif nodeName_ == 'MassPoints':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MassPoints')
            self.MassPoints = fval_
        elif nodeName_ == 'Options':
            obj_ = HazardousCommodityOptionDetail.factory()
            obj_.build(child_)
            self.Options = obj_
            obj_.original_tagname_ = 'Options'
        elif nodeName_ == 'NetExplosiveDetail':
            obj_ = NetExplosiveDetail.factory()
            obj_.build(child_)
            self.NetExplosiveDetail = obj_
            obj_.original_tagname_ = 'NetExplosiveDetail'
# end class ValidatedHazardousCommodityContent


class ValidatedHazardousCommodityDescription(GeneratedsSuper):
    """Identifies and describes an individual hazardous commodity. For
    201001 load, this is based on data from the FedEx Ground
    Hazardous Materials Shipping Guide."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, SequenceNumber=None, PackingGroup=None, PackingInstructions=None, ProperShippingName=None, ProperShippingNameAndDescription=None, TechnicalName=None, HazardClass=None, SubsidiaryClasses=None, Symbols=None, TunnelRestrictionCode=None, SpecialProvisions=None, Attributes=None, Authorization=None, LabelText=None):
        self.original_tagname_ = None
        self.Id = Id
        self.SequenceNumber = SequenceNumber
        self.PackingGroup = PackingGroup
        self.validate_HazardousCommodityPackingGroupType(self.PackingGroup)
        self.PackingInstructions = PackingInstructions
        self.ProperShippingName = ProperShippingName
        self.ProperShippingNameAndDescription = ProperShippingNameAndDescription
        self.TechnicalName = TechnicalName
        self.HazardClass = HazardClass
        if SubsidiaryClasses is None:
            self.SubsidiaryClasses = []
        else:
            self.SubsidiaryClasses = SubsidiaryClasses
        self.Symbols = Symbols
        self.TunnelRestrictionCode = TunnelRestrictionCode
        self.SpecialProvisions = SpecialProvisions
        if Attributes is None:
            self.Attributes = []
        else:
            self.Attributes = Attributes
        self.Authorization = Authorization
        self.LabelText = LabelText
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidatedHazardousCommodityDescription)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidatedHazardousCommodityDescription.subclass:
            return ValidatedHazardousCommodityDescription.subclass(*args_, **kwargs_)
        else:
            return ValidatedHazardousCommodityDescription(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_SequenceNumber(self): return self.SequenceNumber
    def set_SequenceNumber(self, SequenceNumber): self.SequenceNumber = SequenceNumber
    def get_PackingGroup(self): return self.PackingGroup
    def set_PackingGroup(self, PackingGroup): self.PackingGroup = PackingGroup
    def get_PackingInstructions(self): return self.PackingInstructions
    def set_PackingInstructions(self, PackingInstructions): self.PackingInstructions = PackingInstructions
    def get_ProperShippingName(self): return self.ProperShippingName
    def set_ProperShippingName(self, ProperShippingName): self.ProperShippingName = ProperShippingName
    def get_ProperShippingNameAndDescription(self): return self.ProperShippingNameAndDescription
    def set_ProperShippingNameAndDescription(self, ProperShippingNameAndDescription): self.ProperShippingNameAndDescription = ProperShippingNameAndDescription
    def get_TechnicalName(self): return self.TechnicalName
    def set_TechnicalName(self, TechnicalName): self.TechnicalName = TechnicalName
    def get_HazardClass(self): return self.HazardClass
    def set_HazardClass(self, HazardClass): self.HazardClass = HazardClass
    def get_SubsidiaryClasses(self): return self.SubsidiaryClasses
    def set_SubsidiaryClasses(self, SubsidiaryClasses): self.SubsidiaryClasses = SubsidiaryClasses
    def add_SubsidiaryClasses(self, value): self.SubsidiaryClasses.append(value)
    def insert_SubsidiaryClasses_at(self, index, value): self.SubsidiaryClasses.insert(index, value)
    def replace_SubsidiaryClasses_at(self, index, value): self.SubsidiaryClasses[index] = value
    def get_Symbols(self): return self.Symbols
    def set_Symbols(self, Symbols): self.Symbols = Symbols
    def get_TunnelRestrictionCode(self): return self.TunnelRestrictionCode
    def set_TunnelRestrictionCode(self, TunnelRestrictionCode): self.TunnelRestrictionCode = TunnelRestrictionCode
    def get_SpecialProvisions(self): return self.SpecialProvisions
    def set_SpecialProvisions(self, SpecialProvisions): self.SpecialProvisions = SpecialProvisions
    def get_Attributes(self): return self.Attributes
    def set_Attributes(self, Attributes): self.Attributes = Attributes
    def add_Attributes(self, value): self.Attributes.append(value)
    def insert_Attributes_at(self, index, value): self.Attributes.insert(index, value)
    def replace_Attributes_at(self, index, value): self.Attributes[index] = value
    def get_Authorization(self): return self.Authorization
    def set_Authorization(self, Authorization): self.Authorization = Authorization
    def get_LabelText(self): return self.LabelText
    def set_LabelText(self, LabelText): self.LabelText = LabelText
    def validate_HazardousCommodityPackingGroupType(self, value):
        # Validate type HazardousCommodityPackingGroupType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEFAULT', 'I', 'II', 'III']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityPackingGroupType' % {"value" : value.encode("utf-8")} )
    def validate_HazardousCommodityAttributeType(self, value):
        # Validate type HazardousCommodityAttributeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NOT_SUBJECT_TO_REGULATIONS', 'PLACARDED_VEHICLE_REQUIRED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HazardousCommodityAttributeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Id is not None or
            self.SequenceNumber is not None or
            self.PackingGroup is not None or
            self.PackingInstructions is not None or
            self.ProperShippingName is not None or
            self.ProperShippingNameAndDescription is not None or
            self.TechnicalName is not None or
            self.HazardClass is not None or
            self.SubsidiaryClasses or
            self.Symbols is not None or
            self.TunnelRestrictionCode is not None or
            self.SpecialProvisions is not None or
            self.Attributes or
            self.Authorization is not None or
            self.LabelText is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ValidatedHazardousCommodityDescription', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidatedHazardousCommodityDescription')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValidatedHazardousCommodityDescription')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ValidatedHazardousCommodityDescription', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ValidatedHazardousCommodityDescription'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ValidatedHazardousCommodityDescription', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Id>%s</ns:Id>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Id), input_name='Id')), eol_))
        if self.SequenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SequenceNumber>%s</ns:SequenceNumber>%s' % (self.gds_format_integer(self.SequenceNumber, input_name='SequenceNumber'), eol_))
        if self.PackingGroup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackingGroup>%s</ns:PackingGroup>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackingGroup), input_name='PackingGroup')), eol_))
        if self.PackingInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PackingInstructions>%s</ns:PackingInstructions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackingInstructions), input_name='PackingInstructions')), eol_))
        if self.ProperShippingName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ProperShippingName>%s</ns:ProperShippingName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProperShippingName), input_name='ProperShippingName')), eol_))
        if self.ProperShippingNameAndDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ProperShippingNameAndDescription>%s</ns:ProperShippingNameAndDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProperShippingNameAndDescription), input_name='ProperShippingNameAndDescription')), eol_))
        if self.TechnicalName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TechnicalName>%s</ns:TechnicalName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TechnicalName), input_name='TechnicalName')), eol_))
        if self.HazardClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:HazardClass>%s</ns:HazardClass>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HazardClass), input_name='HazardClass')), eol_))
        for SubsidiaryClasses_ in self.SubsidiaryClasses:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SubsidiaryClasses>%s</ns:SubsidiaryClasses>%s' % (self.gds_encode(self.gds_format_string(quote_xml(SubsidiaryClasses_), input_name='SubsidiaryClasses')), eol_))
        if self.Symbols is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Symbols>%s</ns:Symbols>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Symbols), input_name='Symbols')), eol_))
        if self.TunnelRestrictionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:TunnelRestrictionCode>%s</ns:TunnelRestrictionCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TunnelRestrictionCode), input_name='TunnelRestrictionCode')), eol_))
        if self.SpecialProvisions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:SpecialProvisions>%s</ns:SpecialProvisions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialProvisions), input_name='SpecialProvisions')), eol_))
        for Attributes_ in self.Attributes:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Attributes>%s</ns:Attributes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Attributes_), input_name='Attributes')), eol_))
        if self.Authorization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Authorization>%s</ns:Authorization>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Authorization), input_name='Authorization')), eol_))
        if self.LabelText is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:LabelText>%s</ns:LabelText>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelText), input_name='LabelText')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'SequenceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SequenceNumber')
            self.SequenceNumber = ival_
        elif nodeName_ == 'PackingGroup':
            PackingGroup_ = child_.text
            PackingGroup_ = self.gds_validate_string(PackingGroup_, node, 'PackingGroup')
            self.PackingGroup = PackingGroup_
            # validate type HazardousCommodityPackingGroupType
            self.validate_HazardousCommodityPackingGroupType(self.PackingGroup)
        elif nodeName_ == 'PackingInstructions':
            PackingInstructions_ = child_.text
            PackingInstructions_ = self.gds_validate_string(PackingInstructions_, node, 'PackingInstructions')
            self.PackingInstructions = PackingInstructions_
        elif nodeName_ == 'ProperShippingName':
            ProperShippingName_ = child_.text
            ProperShippingName_ = self.gds_validate_string(ProperShippingName_, node, 'ProperShippingName')
            self.ProperShippingName = ProperShippingName_
        elif nodeName_ == 'ProperShippingNameAndDescription':
            ProperShippingNameAndDescription_ = child_.text
            ProperShippingNameAndDescription_ = self.gds_validate_string(ProperShippingNameAndDescription_, node, 'ProperShippingNameAndDescription')
            self.ProperShippingNameAndDescription = ProperShippingNameAndDescription_
        elif nodeName_ == 'TechnicalName':
            TechnicalName_ = child_.text
            TechnicalName_ = self.gds_validate_string(TechnicalName_, node, 'TechnicalName')
            self.TechnicalName = TechnicalName_
        elif nodeName_ == 'HazardClass':
            HazardClass_ = child_.text
            HazardClass_ = self.gds_validate_string(HazardClass_, node, 'HazardClass')
            self.HazardClass = HazardClass_
        elif nodeName_ == 'SubsidiaryClasses':
            SubsidiaryClasses_ = child_.text
            SubsidiaryClasses_ = self.gds_validate_string(SubsidiaryClasses_, node, 'SubsidiaryClasses')
            self.SubsidiaryClasses.append(SubsidiaryClasses_)
        elif nodeName_ == 'Symbols':
            Symbols_ = child_.text
            Symbols_ = self.gds_validate_string(Symbols_, node, 'Symbols')
            self.Symbols = Symbols_
        elif nodeName_ == 'TunnelRestrictionCode':
            TunnelRestrictionCode_ = child_.text
            TunnelRestrictionCode_ = self.gds_validate_string(TunnelRestrictionCode_, node, 'TunnelRestrictionCode')
            self.TunnelRestrictionCode = TunnelRestrictionCode_
        elif nodeName_ == 'SpecialProvisions':
            SpecialProvisions_ = child_.text
            SpecialProvisions_ = self.gds_validate_string(SpecialProvisions_, node, 'SpecialProvisions')
            self.SpecialProvisions = SpecialProvisions_
        elif nodeName_ == 'Attributes':
            Attributes_ = child_.text
            Attributes_ = self.gds_validate_string(Attributes_, node, 'Attributes')
            self.Attributes.append(Attributes_)
            # validate type HazardousCommodityAttributeType
            self.validate_HazardousCommodityAttributeType(self.Attributes[-1])
        elif nodeName_ == 'Authorization':
            Authorization_ = child_.text
            Authorization_ = self.gds_validate_string(Authorization_, node, 'Authorization')
            self.Authorization = Authorization_
        elif nodeName_ == 'LabelText':
            LabelText_ = child_.text
            LabelText_ = self.gds_validate_string(LabelText_, node, 'LabelText')
            self.LabelText = LabelText_
# end class ValidatedHazardousCommodityDescription


class ValidatedHazardousContainer(GeneratedsSuper):
    """Specifies the concept of a container used to package dangerous goods
    commodities."""
    subclass = None
    superclass = None
    def __init__(self, QValue=None, HazardousCommodities=None):
        self.original_tagname_ = None
        self.QValue = QValue
        if HazardousCommodities is None:
            self.HazardousCommodities = []
        else:
            self.HazardousCommodities = HazardousCommodities
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidatedHazardousContainer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidatedHazardousContainer.subclass:
            return ValidatedHazardousContainer.subclass(*args_, **kwargs_)
        else:
            return ValidatedHazardousContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QValue(self): return self.QValue
    def set_QValue(self, QValue): self.QValue = QValue
    def get_HazardousCommodities(self): return self.HazardousCommodities
    def set_HazardousCommodities(self, HazardousCommodities): self.HazardousCommodities = HazardousCommodities
    def add_HazardousCommodities(self, value): self.HazardousCommodities.append(value)
    def insert_HazardousCommodities_at(self, index, value): self.HazardousCommodities.insert(index, value)
    def replace_HazardousCommodities_at(self, index, value): self.HazardousCommodities[index] = value
    def hasContent_(self):
        if (
            self.QValue is not None or
            self.HazardousCommodities
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='ValidatedHazardousContainer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidatedHazardousContainer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValidatedHazardousContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='ValidatedHazardousContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='ValidatedHazardousContainer'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='ValidatedHazardousContainer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.QValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:QValue>%s</ns:QValue>%s' % (self.gds_format_float(self.QValue, input_name='QValue'), eol_))
        for HazardousCommodities_ in self.HazardousCommodities:
            HazardousCommodities_.export(outfile, level, namespace_, name_='HazardousCommodities', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QValue')
            self.QValue = fval_
        elif nodeName_ == 'HazardousCommodities':
            obj_ = ValidatedHazardousCommodityContent.factory()
            obj_.build(child_)
            self.HazardousCommodities.append(obj_)
            obj_.original_tagname_ = 'HazardousCommodities'
# end class ValidatedHazardousContainer


class VariableHandlingChargeDetail(GeneratedsSuper):
    """This definition of variable handling charge detail is intended for
    use in Jan 2011 corp load."""
    subclass = None
    superclass = None
    def __init__(self, FixedValue=None, PercentValue=None, RateElementBasis=None, RateTypeBasis=None):
        self.original_tagname_ = None
        self.FixedValue = FixedValue
        self.PercentValue = PercentValue
        self.RateElementBasis = RateElementBasis
        self.validate_RateElementBasisType(self.RateElementBasis)
        self.RateTypeBasis = RateTypeBasis
        self.validate_RateTypeBasisType(self.RateTypeBasis)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableHandlingChargeDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableHandlingChargeDetail.subclass:
            return VariableHandlingChargeDetail.subclass(*args_, **kwargs_)
        else:
            return VariableHandlingChargeDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FixedValue(self): return self.FixedValue
    def set_FixedValue(self, FixedValue): self.FixedValue = FixedValue
    def get_PercentValue(self): return self.PercentValue
    def set_PercentValue(self, PercentValue): self.PercentValue = PercentValue
    def get_RateElementBasis(self): return self.RateElementBasis
    def set_RateElementBasis(self, RateElementBasis): self.RateElementBasis = RateElementBasis
    def get_RateTypeBasis(self): return self.RateTypeBasis
    def set_RateTypeBasis(self, RateTypeBasis): self.RateTypeBasis = RateTypeBasis
    def validate_RateElementBasisType(self, value):
        # Validate type RateElementBasisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BASE_CHARGE', 'NET_CHARGE', 'NET_CHARGE_EXCLUDING_TAXES', 'NET_FREIGHT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateElementBasisType' % {"value" : value.encode("utf-8")} )
    def validate_RateTypeBasisType(self, value):
        # Validate type RateTypeBasisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ACCOUNT', 'LIST']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RateTypeBasisType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FixedValue is not None or
            self.PercentValue is not None or
            self.RateElementBasis is not None or
            self.RateTypeBasis is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='VariableHandlingChargeDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableHandlingChargeDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableHandlingChargeDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='VariableHandlingChargeDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='VariableHandlingChargeDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='VariableHandlingChargeDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FixedValue is not None:
            self.FixedValue.export(outfile, level, namespace_, name_='FixedValue', pretty_print=pretty_print)
        if self.PercentValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:PercentValue>%s</ns:PercentValue>%s' % (self.gds_format_float(self.PercentValue, input_name='PercentValue'), eol_))
        if self.RateElementBasis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateElementBasis>%s</ns:RateElementBasis>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateElementBasis), input_name='RateElementBasis')), eol_))
        if self.RateTypeBasis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:RateTypeBasis>%s</ns:RateTypeBasis>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateTypeBasis), input_name='RateTypeBasis')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FixedValue':
            obj_ = Money.factory()
            obj_.build(child_)
            self.FixedValue = obj_
            obj_.original_tagname_ = 'FixedValue'
        elif nodeName_ == 'PercentValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PercentValue')
            self.PercentValue = fval_
        elif nodeName_ == 'RateElementBasis':
            RateElementBasis_ = child_.text
            RateElementBasis_ = self.gds_validate_string(RateElementBasis_, node, 'RateElementBasis')
            self.RateElementBasis = RateElementBasis_
            # validate type RateElementBasisType
            self.validate_RateElementBasisType(self.RateElementBasis)
        elif nodeName_ == 'RateTypeBasis':
            RateTypeBasis_ = child_.text
            RateTypeBasis_ = self.gds_validate_string(RateTypeBasis_, node, 'RateTypeBasis')
            self.RateTypeBasis = RateTypeBasis_
            # validate type RateTypeBasisType
            self.validate_RateTypeBasisType(self.RateTypeBasis)
# end class VariableHandlingChargeDetail


class VariableHandlingCharges(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VariableHandlingCharge=None, FixedVariableHandlingCharge=None, PercentVariableHandlingCharge=None, TotalCustomerCharge=None):
        self.original_tagname_ = None
        self.VariableHandlingCharge = VariableHandlingCharge
        self.FixedVariableHandlingCharge = FixedVariableHandlingCharge
        self.PercentVariableHandlingCharge = PercentVariableHandlingCharge
        self.TotalCustomerCharge = TotalCustomerCharge
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VariableHandlingCharges)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VariableHandlingCharges.subclass:
            return VariableHandlingCharges.subclass(*args_, **kwargs_)
        else:
            return VariableHandlingCharges(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VariableHandlingCharge(self): return self.VariableHandlingCharge
    def set_VariableHandlingCharge(self, VariableHandlingCharge): self.VariableHandlingCharge = VariableHandlingCharge
    def get_FixedVariableHandlingCharge(self): return self.FixedVariableHandlingCharge
    def set_FixedVariableHandlingCharge(self, FixedVariableHandlingCharge): self.FixedVariableHandlingCharge = FixedVariableHandlingCharge
    def get_PercentVariableHandlingCharge(self): return self.PercentVariableHandlingCharge
    def set_PercentVariableHandlingCharge(self, PercentVariableHandlingCharge): self.PercentVariableHandlingCharge = PercentVariableHandlingCharge
    def get_TotalCustomerCharge(self): return self.TotalCustomerCharge
    def set_TotalCustomerCharge(self, TotalCustomerCharge): self.TotalCustomerCharge = TotalCustomerCharge
    def hasContent_(self):
        if (
            self.VariableHandlingCharge is not None or
            self.FixedVariableHandlingCharge is not None or
            self.PercentVariableHandlingCharge is not None or
            self.TotalCustomerCharge is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='VariableHandlingCharges', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VariableHandlingCharges')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableHandlingCharges')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='VariableHandlingCharges', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='VariableHandlingCharges'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='VariableHandlingCharges', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VariableHandlingCharge is not None:
            self.VariableHandlingCharge.export(outfile, level, namespace_, name_='VariableHandlingCharge', pretty_print=pretty_print)
        if self.FixedVariableHandlingCharge is not None:
            self.FixedVariableHandlingCharge.export(outfile, level, namespace_, name_='FixedVariableHandlingCharge', pretty_print=pretty_print)
        if self.PercentVariableHandlingCharge is not None:
            self.PercentVariableHandlingCharge.export(outfile, level, namespace_, name_='PercentVariableHandlingCharge', pretty_print=pretty_print)
        if self.TotalCustomerCharge is not None:
            self.TotalCustomerCharge.export(outfile, level, namespace_, name_='TotalCustomerCharge', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VariableHandlingCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.VariableHandlingCharge = obj_
            obj_.original_tagname_ = 'VariableHandlingCharge'
        elif nodeName_ == 'FixedVariableHandlingCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.FixedVariableHandlingCharge = obj_
            obj_.original_tagname_ = 'FixedVariableHandlingCharge'
        elif nodeName_ == 'PercentVariableHandlingCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.PercentVariableHandlingCharge = obj_
            obj_.original_tagname_ = 'PercentVariableHandlingCharge'
        elif nodeName_ == 'TotalCustomerCharge':
            obj_ = Money.factory()
            obj_.build(child_)
            self.TotalCustomerCharge = obj_
            obj_.original_tagname_ = 'TotalCustomerCharge'
# end class VariableHandlingCharges


class Volume(GeneratedsSuper):
    """Three-dimensional volume/cubic measurement."""
    subclass = None
    superclass = None
    def __init__(self, Units=None, Value=None):
        self.original_tagname_ = None
        self.Units = Units
        self.validate_VolumeUnits(self.Units)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Volume)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Volume.subclass:
            return Volume.subclass(*args_, **kwargs_)
        else:
            return Volume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_VolumeUnits(self, value):
        # Validate type VolumeUnits, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['CUBIC_FT', 'CUBIC_M']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VolumeUnits' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Units is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Volume', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Volume')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Volume')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Volume', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Volume'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Volume', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Units>%s</ns:Units>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Units), input_name='Units')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_format_float(self.Value, input_name='Value'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
            # validate type VolumeUnits
            self.validate_VolumeUnits(self.Units)
        elif nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
# end class Volume


class Weight(GeneratedsSuper):
    """The descriptive data for the heaviness of an object."""
    subclass = None
    superclass = None
    def __init__(self, Units=None, Value=None):
        self.original_tagname_ = None
        self.Units = Units
        self.validate_WeightUnits(self.Units)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Weight)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Weight.subclass:
            return Weight.subclass(*args_, **kwargs_)
        else:
            return Weight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_WeightUnits(self, value):
        # Validate type WeightUnits, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['KG', 'LB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeightUnits' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Units is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='Weight', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Weight')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Weight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='Weight', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='Weight'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='Weight', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Units>%s</ns:Units>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Units), input_name='Units')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Value>%s</ns:Value>%s' % (self.gds_format_float(self.Value, input_name='Value'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
            # validate type WeightUnits
            self.validate_WeightUnits(self.Units)
        elif nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
# end class Weight


class WebAuthenticationDetail(GeneratedsSuper):
    """Used in authentication of the sender's identity."""
    subclass = None
    superclass = None
    def __init__(self, ParentCredential=None, UserCredential=None):
        self.original_tagname_ = None
        self.ParentCredential = ParentCredential
        self.UserCredential = UserCredential
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAuthenticationDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAuthenticationDetail.subclass:
            return WebAuthenticationDetail.subclass(*args_, **kwargs_)
        else:
            return WebAuthenticationDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParentCredential(self): return self.ParentCredential
    def set_ParentCredential(self, ParentCredential): self.ParentCredential = ParentCredential
    def get_UserCredential(self): return self.UserCredential
    def set_UserCredential(self, UserCredential): self.UserCredential = UserCredential
    def hasContent_(self):
        if (
            self.ParentCredential is not None or
            self.UserCredential is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='WebAuthenticationDetail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAuthenticationDetail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WebAuthenticationDetail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='WebAuthenticationDetail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='WebAuthenticationDetail'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='WebAuthenticationDetail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParentCredential is not None:
            self.ParentCredential.export(outfile, level, namespace_, name_='ParentCredential', pretty_print=pretty_print)
        if self.UserCredential is not None:
            self.UserCredential.export(outfile, level, namespace_, name_='UserCredential', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ParentCredential':
            obj_ = WebAuthenticationCredential.factory()
            obj_.build(child_)
            self.ParentCredential = obj_
            obj_.original_tagname_ = 'ParentCredential'
        elif nodeName_ == 'UserCredential':
            obj_ = WebAuthenticationCredential.factory()
            obj_.build(child_)
            self.UserCredential = obj_
            obj_.original_tagname_ = 'UserCredential'
# end class WebAuthenticationDetail


class WebAuthenticationCredential(GeneratedsSuper):
    """Two part authentication string used for the sender's identity"""
    subclass = None
    superclass = None
    def __init__(self, Key=None, Password=None):
        self.original_tagname_ = None
        self.Key = Key
        self.Password = Password
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAuthenticationCredential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAuthenticationCredential.subclass:
            return WebAuthenticationCredential.subclass(*args_, **kwargs_)
        else:
            return WebAuthenticationCredential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_Password(self): return self.Password
    def set_Password(self, Password): self.Password = Password
    def hasContent_(self):
        if (
            self.Key is not None or
            self.Password is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='WebAuthenticationCredential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAuthenticationCredential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WebAuthenticationCredential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='WebAuthenticationCredential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='WebAuthenticationCredential'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='WebAuthenticationCredential', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Key>%s</ns:Key>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Key), input_name='Key')), eol_))
        if self.Password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Password>%s</ns:Password>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Password), input_name='Password')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Key':
            Key_ = child_.text
            Key_ = self.gds_validate_string(Key_, node, 'Key')
            self.Key = Key_
        elif nodeName_ == 'Password':
            Password_ = child_.text
            Password_ = self.gds_validate_string(Password_, node, 'Password')
            self.Password = Password_
# end class WebAuthenticationCredential


class VersionId(GeneratedsSuper):
    """Identifies the version/level of a service operation expected by a
    caller (in each request) and performed by the callee (in each
    reply)."""
    subclass = None
    superclass = None
    def __init__(self, ServiceId=None, Major=None, Intermediate=None, Minor=None):
        self.original_tagname_ = None
        self.ServiceId = ServiceId
        self.Major = Major
        self.Intermediate = Intermediate
        self.Minor = Minor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VersionId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VersionId.subclass:
            return VersionId.subclass(*args_, **kwargs_)
        else:
            return VersionId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceId(self): return self.ServiceId
    def set_ServiceId(self, ServiceId): self.ServiceId = ServiceId
    def get_Major(self): return self.Major
    def set_Major(self, Major): self.Major = Major
    def get_Intermediate(self): return self.Intermediate
    def set_Intermediate(self, Intermediate): self.Intermediate = Intermediate
    def get_Minor(self): return self.Minor
    def set_Minor(self, Minor): self.Minor = Minor
    def hasContent_(self):
        if (
            self.ServiceId is not None or
            self.Major is not None or
            self.Intermediate is not None or
            self.Minor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ns:', name_='VersionId', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VersionId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VersionId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ns:', name_='VersionId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ns:', name_='VersionId'):
        pass
    def exportChildren(self, outfile, level, namespace_='ns:', name_='VersionId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:ServiceId>%s</ns:ServiceId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceId), input_name='ServiceId')), eol_))
        if self.Major is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Major>%s</ns:Major>%s' % (self.gds_format_integer(self.Major, input_name='Major'), eol_))
        if self.Intermediate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Intermediate>%s</ns:Intermediate>%s' % (self.gds_format_integer(self.Intermediate, input_name='Intermediate'), eol_))
        if self.Minor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ns:Minor>%s</ns:Minor>%s' % (self.gds_format_integer(self.Minor, input_name='Minor'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceId':
            ServiceId_ = child_.text
            ServiceId_ = self.gds_validate_string(ServiceId_, node, 'ServiceId')
            self.ServiceId = ServiceId_
        elif nodeName_ == 'Major':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Major')
            self.Major = ival_
        elif nodeName_ == 'Intermediate':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Intermediate')
            self.Intermediate = ival_
        elif nodeName_ == 'Minor':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Minor')
            self.Minor = ival_
# end class VersionId


GDSClassesMapping = {
    'DeleteShipmentRequest': DeleteShipmentRequest,
    'DeleteTagRequest': DeleteTagRequest,
    'ProcessShipmentReply': ProcessShipmentReply,
    'ProcessShipmentRequest': ProcessShipmentRequest,
    'ProcessTagReply': ProcessTagReply,
    'ProcessTagRequest': ProcessTagRequest,
    'ShipmentReply': ShipmentReply,
    'ValidateShipmentRequest': ValidateShipmentRequest,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeleteShipmentRequest'
        rootClass = DeleteShipmentRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ns="http://fedex.com/ws/ship/v21"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeleteShipmentRequest'
        rootClass = DeleteShipmentRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeleteShipmentRequest'
        rootClass = DeleteShipmentRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ns="http://fedex.com/ws/ship/v21"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeleteShipmentRequest'
        rootClass = DeleteShipmentRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ship_service_v21 import *\n\n')
        sys.stdout.write('import ship_service_v21 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AdditionalLabelsDetail",
    "Address",
    "AdrLicenseDetail",
    "AlcoholDetail",
    "AncillaryFeeAndTax",
    "AssociatedShipmentDetail",
    "BatteryClassificationDetail",
    "BinaryBarcode",
    "BrokerDetail",
    "CertificateOfOriginDetail",
    "ClientDetail",
    "CodAddTransportationChargesDetail",
    "CodDetail",
    "CodReturnPackageDetail",
    "CommercialInvoice",
    "CommercialInvoiceDetail",
    "Commodity",
    "CompletedCodDetail",
    "CompletedEtdDetail",
    "CompletedHazardousPackageDetail",
    "CompletedHazardousShipmentDetail",
    "CompletedHazardousSummaryDetail",
    "CompletedHoldAtLocationDetail",
    "CompletedPackageDetail",
    "CompletedShipmentDetail",
    "CompletedSmartPostDetail",
    "CompletedTagDetail",
    "ConfigurableLabelReferenceEntry",
    "Contact",
    "ContactAndAddress",
    "ContentRecord",
    "CurrencyExchangeRate",
    "CustomDeliveryWindowDetail",
    "CustomDocumentDetail",
    "CustomLabelBarcodeEntry",
    "CustomLabelBoxEntry",
    "CustomLabelDetail",
    "CustomLabelGraphicEntry",
    "CustomLabelPosition",
    "CustomLabelTextBoxEntry",
    "CustomLabelTextEntry",
    "CustomerImageUsage",
    "CustomerReference",
    "CustomerSpecifiedLabelDetail",
    "CustomsClearanceDetail",
    "CustomsDeclarationStatementDetail",
    "CustomsOptionDetail",
    "DangerousGoodsContainer",
    "DangerousGoodsDetail",
    "DangerousGoodsShippersDeclarationDetail",
    "DangerousGoodsSignatory",
    "DateRange",
    "DeleteShipmentRequest",
    "DeleteTagRequest",
    "DeliveryOnInvoiceAcceptanceDetail",
    "DestinationControlDetail",
    "Dimensions",
    "DocTabContent",
    "DocTabContentBarcoded",
    "DocTabContentZone001",
    "DocTabZoneSpecification",
    "DocumentFormatOptionsRequested",
    "DocumentGenerationDetail",
    "DocumentRequirementsDetail",
    "EMailDetail",
    "EMailLabelDetail",
    "EMailRecipient",
    "EdtCommodityTax",
    "EdtExciseCondition",
    "EdtTaxDetail",
    "EmailOptionsRequested",
    "EtdDetail",
    "ExportDeclarationDetail",
    "ExportDetail",
    "ExpressFreightDetail",
    "FreightAddressLabelDetail",
    "FreightBaseCharge",
    "FreightGuaranteeDetail",
    "FreightRateDetail",
    "FreightRateNotation",
    "FreightShipmentDetail",
    "FreightShipmentLineItem",
    "FreightSpecialServicePayment",
    "GeneralAgencyAgreementDetail",
    "HazardousCommodityContent",
    "HazardousCommodityDescription",
    "HazardousCommodityInnerReceptacleDetail",
    "HazardousCommodityOptionDetail",
    "HazardousCommodityPackagingDetail",
    "HazardousCommodityPackingDetail",
    "HazardousCommodityQuantityDetail",
    "HoldAtLocationDetail",
    "HomeDeliveryPremiumDetail",
    "InternationalControlledExportDetail",
    "InternationalTrafficInArmsRegulationsDetail",
    "LabelSpecification",
    "LiabilityCoverageDetail",
    "LicenseOrPermitDetail",
    "LinearMeasure",
    "Localization",
    "Measure",
    "Money",
    "NaftaCertificateOfOriginDetail",
    "NaftaCommodityDetail",
    "NaftaLowValueStatementDetail",
    "NaftaProducer",
    "NetExplosiveDetail",
    "Notification",
    "NotificationDetail",
    "NotificationParameter",
    "Op900Detail",
    "OperationalInstruction",
    "PackageBarcodes",
    "PackageOperationalDetail",
    "PackageRateDetail",
    "PackageRating",
    "PackageSpecialServicesRequested",
    "Party",
    "Payment",
    "Payor",
    "PendingShipmentAccessDetail",
    "PendingShipmentAccessorDetail",
    "PendingShipmentDetail",
    "PendingShipmentProcessingOptionsRequested",
    "PickupDetail",
    "PrintedReference",
    "PriorityAlertDetail",
    "ProcessShipmentReply",
    "ProcessShipmentRequest",
    "ProcessTagReply",
    "ProcessTagRequest",
    "RadioactivityDetail",
    "RadionuclideActivity",
    "RadionuclideDetail",
    "RateDiscount",
    "Rebate",
    "RecipientCustomsId",
    "RecommendedDocumentSpecification",
    "RegulatoryLabelContentDetail",
    "RequestedPackageLineItem",
    "RequestedShipment",
    "ReturnAssociationDetail",
    "ReturnEMailDetail",
    "ReturnInstructionsDetail",
    "ReturnShipmentDetail",
    "Rma",
    "ShipmentAuthorizationDetail",
    "ShipmentConfigurationData",
    "ShipmentDryIceDetail",
    "ShipmentDryIceProcessingOptionsRequested",
    "ShipmentEventNotificationDetail",
    "ShipmentEventNotificationSpecification",
    "ShipmentLegRateDetail",
    "ShipmentManifestDetail",
    "ShipmentNotificationFormatSpecification",
    "ShipmentOperationalDetail",
    "ShipmentRateDetail",
    "ShipmentRating",
    "ShipmentReply",
    "ShipmentSpecialServicesRequested",
    "ShippingDocument",
    "ShippingDocumentDispositionDetail",
    "ShippingDocumentEMailDetail",
    "ShippingDocumentEMailRecipient",
    "ShippingDocumentFormat",
    "ShippingDocumentPart",
    "ShippingDocumentPrintDetail",
    "ShippingDocumentSpecification",
    "ShippingDocumentStorageDetail",
    "SignatureOptionDetail",
    "SmartPostShipmentDetail",
    "SmartPostShipmentProcessingOptionsRequested",
    "StringBarcode",
    "Surcharge",
    "Tax",
    "TaxpayerIdentification",
    "TrackingId",
    "TransactionDetail",
    "UploadDocumentReferenceDetail",
    "ValidateShipmentRequest",
    "ValidatedHazardousCommodityContent",
    "ValidatedHazardousCommodityDescription",
    "ValidatedHazardousContainer",
    "VariableHandlingChargeDetail",
    "VariableHandlingCharges",
    "VersionId",
    "Volume",
    "WebAuthenticationCredential",
    "WebAuthenticationDetail",
    "Weight"
]
