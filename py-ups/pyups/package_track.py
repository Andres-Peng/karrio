#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Jun 12 20:24:39 2018 by generateDS.py version 2.29.14.
# Python 3.6.5 (default, May 19 2018, 11:27:13)  [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('-o', 'pyups/package_track.py')
#
# Command line arguments:
#    /UPS/Tracking/TrackingPACKAGE/TRACKINGWebServices/SCHEMAS-WSDLs/TrackWebServiceSchema.xsd
#
# Command line:
#    generateDS --no-namespace-defs -o "pyups/package_track.py"  /UPS/Tracking/TrackingPACKAGE/TRACKINGWebServices/SCHEMAS-WSDLs/TrackWebServiceSchema.xsd
#
# Current working directory (os.getcwd()):
#   py_ups
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class TrackRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Request=None, InquiryNumber=None, IncludeMailInnovationIndicator=None, TrackingOption=None, CandidateBookmark=None, ReferenceNumber=None, PickupDateRange=None, ShipperNumber=None, ShipFrom=None, ShipTo=None, ShipmentType=None, ShipperAccountInfo=None):
        self.original_tagname_ = None
        self.Request = Request
        self.InquiryNumber = InquiryNumber
        self.IncludeMailInnovationIndicator = IncludeMailInnovationIndicator
        self.TrackingOption = TrackingOption
        self.CandidateBookmark = CandidateBookmark
        self.ReferenceNumber = ReferenceNumber
        self.PickupDateRange = PickupDateRange
        self.ShipperNumber = ShipperNumber
        self.ShipFrom = ShipFrom
        self.ShipTo = ShipTo
        self.ShipmentType = ShipmentType
        self.ShipperAccountInfo = ShipperAccountInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrackRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrackRequest.subclass:
            return TrackRequest.subclass(*args_, **kwargs_)
        else:
            return TrackRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_InquiryNumber(self): return self.InquiryNumber
    def set_InquiryNumber(self, InquiryNumber): self.InquiryNumber = InquiryNumber
    def get_IncludeMailInnovationIndicator(self): return self.IncludeMailInnovationIndicator
    def set_IncludeMailInnovationIndicator(self, IncludeMailInnovationIndicator): self.IncludeMailInnovationIndicator = IncludeMailInnovationIndicator
    def get_TrackingOption(self): return self.TrackingOption
    def set_TrackingOption(self, TrackingOption): self.TrackingOption = TrackingOption
    def get_CandidateBookmark(self): return self.CandidateBookmark
    def set_CandidateBookmark(self, CandidateBookmark): self.CandidateBookmark = CandidateBookmark
    def get_ReferenceNumber(self): return self.ReferenceNumber
    def set_ReferenceNumber(self, ReferenceNumber): self.ReferenceNumber = ReferenceNumber
    def get_PickupDateRange(self): return self.PickupDateRange
    def set_PickupDateRange(self, PickupDateRange): self.PickupDateRange = PickupDateRange
    def get_ShipperNumber(self): return self.ShipperNumber
    def set_ShipperNumber(self, ShipperNumber): self.ShipperNumber = ShipperNumber
    def get_ShipFrom(self): return self.ShipFrom
    def set_ShipFrom(self, ShipFrom): self.ShipFrom = ShipFrom
    def get_ShipTo(self): return self.ShipTo
    def set_ShipTo(self, ShipTo): self.ShipTo = ShipTo
    def get_ShipmentType(self): return self.ShipmentType
    def set_ShipmentType(self, ShipmentType): self.ShipmentType = ShipmentType
    def get_ShipperAccountInfo(self): return self.ShipperAccountInfo
    def set_ShipperAccountInfo(self, ShipperAccountInfo): self.ShipperAccountInfo = ShipperAccountInfo
    def hasContent_(self):
        if (
            self.Request is not None or
            self.InquiryNumber is not None or
            self.IncludeMailInnovationIndicator is not None or
            self.TrackingOption is not None or
            self.CandidateBookmark is not None or
            self.ReferenceNumber is not None or
            self.PickupDateRange is not None or
            self.ShipperNumber is not None or
            self.ShipFrom is not None or
            self.ShipTo is not None or
            self.ShipmentType is not None or
            self.ShipperAccountInfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='TrackRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrackRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrackRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='TrackRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='TrackRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='TrackRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_='common:', name_='Request', pretty_print=pretty_print)
        if self.InquiryNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:InquiryNumber>%s</trk:InquiryNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.InquiryNumber), input_name='InquiryNumber')), eol_))
        if self.IncludeMailInnovationIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:IncludeMailInnovationIndicator>%s</trk:IncludeMailInnovationIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IncludeMailInnovationIndicator), input_name='IncludeMailInnovationIndicator')), eol_))
        if self.TrackingOption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:TrackingOption>%s</trk:TrackingOption>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TrackingOption), input_name='TrackingOption')), eol_))
        if self.CandidateBookmark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CandidateBookmark>%s</trk:CandidateBookmark>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CandidateBookmark), input_name='CandidateBookmark')), eol_))
        if self.ReferenceNumber is not None:
            self.ReferenceNumber.export(outfile, level, namespace_, name_='ReferenceNumber', pretty_print=pretty_print)
        if self.PickupDateRange is not None:
            self.PickupDateRange.export(outfile, level, namespace_, name_='PickupDateRange', pretty_print=pretty_print)
        if self.ShipperNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:ShipperNumber>%s</trk:ShipperNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShipperNumber), input_name='ShipperNumber')), eol_))
        if self.ShipFrom is not None:
            self.ShipFrom.export(outfile, level, namespace_, name_='ShipFrom', pretty_print=pretty_print)
        if self.ShipTo is not None:
            self.ShipTo.export(outfile, level, namespace_, name_='ShipTo', pretty_print=pretty_print)
        if self.ShipmentType is not None:
            self.ShipmentType.export(outfile, level, namespace_, name_='ShipmentType', pretty_print=pretty_print)
        if self.ShipperAccountInfo is not None:
            self.ShipperAccountInfo.export(outfile, level, namespace_, name_='ShipperAccountInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = RequestType.factory()
            obj_.build(child_)
            self.Request = obj_
            obj_.original_tagname_ = 'Request'
        elif nodeName_ == 'InquiryNumber':
            InquiryNumber_ = child_.text
            InquiryNumber_ = self.gds_validate_string(InquiryNumber_, node, 'InquiryNumber')
            self.InquiryNumber = InquiryNumber_
        elif nodeName_ == 'IncludeMailInnovationIndicator':
            IncludeMailInnovationIndicator_ = child_.text
            IncludeMailInnovationIndicator_ = self.gds_validate_string(IncludeMailInnovationIndicator_, node, 'IncludeMailInnovationIndicator')
            self.IncludeMailInnovationIndicator = IncludeMailInnovationIndicator_
        elif nodeName_ == 'TrackingOption':
            TrackingOption_ = child_.text
            TrackingOption_ = self.gds_validate_string(TrackingOption_, node, 'TrackingOption')
            self.TrackingOption = TrackingOption_
        elif nodeName_ == 'CandidateBookmark':
            CandidateBookmark_ = child_.text
            CandidateBookmark_ = self.gds_validate_string(CandidateBookmark_, node, 'CandidateBookmark')
            self.CandidateBookmark = CandidateBookmark_
        elif nodeName_ == 'ReferenceNumber':
            obj_ = ReferenceNumberType.factory()
            obj_.build(child_)
            self.ReferenceNumber = obj_
            obj_.original_tagname_ = 'ReferenceNumber'
        elif nodeName_ == 'PickupDateRange':
            obj_ = PickupDateRangeType.factory()
            obj_.build(child_)
            self.PickupDateRange = obj_
            obj_.original_tagname_ = 'PickupDateRange'
        elif nodeName_ == 'ShipperNumber':
            ShipperNumber_ = child_.text
            ShipperNumber_ = self.gds_validate_string(ShipperNumber_, node, 'ShipperNumber')
            self.ShipperNumber = ShipperNumber_
        elif nodeName_ == 'ShipFrom':
            obj_ = ShipFromRequestType.factory()
            obj_.build(child_)
            self.ShipFrom = obj_
            obj_.original_tagname_ = 'ShipFrom'
        elif nodeName_ == 'ShipTo':
            obj_ = ShipToRequestType.factory()
            obj_.build(child_)
            self.ShipTo = obj_
            obj_.original_tagname_ = 'ShipTo'
        elif nodeName_ == 'ShipmentType':
            obj_ = RefShipmentType.factory()
            obj_.build(child_)
            self.ShipmentType = obj_
            obj_.original_tagname_ = 'ShipmentType'
        elif nodeName_ == 'ShipperAccountInfo':
            obj_ = ShipperAccountInfoType.factory()
            obj_.build(child_)
            self.ShipperAccountInfo = obj_
            obj_.original_tagname_ = 'ShipperAccountInfo'
# end class TrackRequest


class AddressRequestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PostalCode=None, CountryCode=None):
        self.original_tagname_ = None
        self.PostalCode = PostalCode
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressRequestType.subclass:
            return AddressRequestType.subclass(*args_, **kwargs_)
        else:
            return AddressRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.PostalCode is not None or
            self.CountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='AddressRequestType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='AddressRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='AddressRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='AddressRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:PostalCode>%s</trk:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CountryCode>%s</trk:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class AddressRequestType


class RefShipmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefShipmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefShipmentType.subclass:
            return RefShipmentType.subclass(*args_, **kwargs_)
        else:
            return RefShipmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='RefShipmentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RefShipmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefShipmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='RefShipmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='RefShipmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='RefShipmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class RefShipmentType


class PickupDateRangeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BeginDate=None, EndDate=None):
        self.original_tagname_ = None
        self.BeginDate = BeginDate
        self.EndDate = EndDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupDateRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupDateRangeType.subclass:
            return PickupDateRangeType.subclass(*args_, **kwargs_)
        else:
            return PickupDateRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BeginDate(self): return self.BeginDate
    def set_BeginDate(self, BeginDate): self.BeginDate = BeginDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def hasContent_(self):
        if (
            self.BeginDate is not None or
            self.EndDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='PickupDateRangeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupDateRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupDateRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='PickupDateRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='PickupDateRangeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='PickupDateRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BeginDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:BeginDate>%s</trk:BeginDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BeginDate), input_name='BeginDate')), eol_))
        if self.EndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:EndDate>%s</trk:EndDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EndDate), input_name='EndDate')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BeginDate':
            BeginDate_ = child_.text
            BeginDate_ = self.gds_validate_string(BeginDate_, node, 'BeginDate')
            self.BeginDate = BeginDate_
        elif nodeName_ == 'EndDate':
            EndDate_ = child_.text
            EndDate_ = self.gds_validate_string(EndDate_, node, 'EndDate')
            self.EndDate = EndDate_
# end class PickupDateRangeType


class ReferenceNumberType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Value=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceNumberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceNumberType.subclass:
            return ReferenceNumberType.subclass(*args_, **kwargs_)
        else:
            return ReferenceNumberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ReferenceNumberType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceNumberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceNumberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ReferenceNumberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ReferenceNumberType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ReferenceNumberType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Value>%s</trk:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ReferenceNumberType


class RequestTransactionReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomerContext=None, TransactionIdentifierPlayback=None):
        self.original_tagname_ = None
        self.CustomerContext = CustomerContext
        self.TransactionIdentifierPlayback = TransactionIdentifierPlayback
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestTransactionReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestTransactionReferenceType.subclass:
            return RequestTransactionReferenceType.subclass(*args_, **kwargs_)
        else:
            return RequestTransactionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerContext(self): return self.CustomerContext
    def set_CustomerContext(self, CustomerContext): self.CustomerContext = CustomerContext
    def get_TransactionIdentifierPlayback(self): return self.TransactionIdentifierPlayback
    def set_TransactionIdentifierPlayback(self, TransactionIdentifierPlayback): self.TransactionIdentifierPlayback = TransactionIdentifierPlayback
    def hasContent_(self):
        if (
            self.CustomerContext is not None or
            self.TransactionIdentifierPlayback is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='RequestTransactionReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestTransactionReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestTransactionReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='RequestTransactionReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='RequestTransactionReferenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='RequestTransactionReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerContext is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CustomerContext>%s</trk:CustomerContext>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerContext), input_name='CustomerContext')), eol_))
        if self.TransactionIdentifierPlayback is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:TransactionIdentifierPlayback>%s</trk:TransactionIdentifierPlayback>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransactionIdentifierPlayback), input_name='TransactionIdentifierPlayback')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerContext':
            CustomerContext_ = child_.text
            CustomerContext_ = self.gds_validate_string(CustomerContext_, node, 'CustomerContext')
            self.CustomerContext = CustomerContext_
        elif nodeName_ == 'TransactionIdentifierPlayback':
            TransactionIdentifierPlayback_ = child_.text
            TransactionIdentifierPlayback_ = self.gds_validate_string(TransactionIdentifierPlayback_, node, 'TransactionIdentifierPlayback')
            self.TransactionIdentifierPlayback = TransactionIdentifierPlayback_
# end class RequestTransactionReferenceType


class ShipToRequestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Address=None):
        self.original_tagname_ = None
        self.Address = Address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipToRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipToRequestType.subclass:
            return ShipToRequestType.subclass(*args_, **kwargs_)
        else:
            return ShipToRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def hasContent_(self):
        if (
            self.Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ShipToRequestType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipToRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipToRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ShipToRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ShipToRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ShipToRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressRequestType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
# end class ShipToRequestType


class ShipFromRequestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Address=None):
        self.original_tagname_ = None
        self.Address = Address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipFromRequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipFromRequestType.subclass:
            return ShipFromRequestType.subclass(*args_, **kwargs_)
        else:
            return ShipFromRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def hasContent_(self):
        if (
            self.Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ShipFromRequestType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipFromRequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipFromRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ShipFromRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ShipFromRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ShipFromRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressRequestType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
# end class ShipFromRequestType


class TrackResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, Shipment=None, Disclaimer=None):
        self.original_tagname_ = None
        self.Response = Response
        if Shipment is None:
            self.Shipment = []
        else:
            self.Shipment = Shipment
        if Disclaimer is None:
            self.Disclaimer = []
        else:
            self.Disclaimer = Disclaimer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrackResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrackResponse.subclass:
            return TrackResponse.subclass(*args_, **kwargs_)
        else:
            return TrackResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_Shipment(self): return self.Shipment
    def set_Shipment(self, Shipment): self.Shipment = Shipment
    def add_Shipment(self, value): self.Shipment.append(value)
    def insert_Shipment_at(self, index, value): self.Shipment.insert(index, value)
    def replace_Shipment_at(self, index, value): self.Shipment[index] = value
    def get_Disclaimer(self): return self.Disclaimer
    def set_Disclaimer(self, Disclaimer): self.Disclaimer = Disclaimer
    def add_Disclaimer(self, value): self.Disclaimer.append(value)
    def insert_Disclaimer_at(self, index, value): self.Disclaimer.insert(index, value)
    def replace_Disclaimer_at(self, index, value): self.Disclaimer[index] = value
    def hasContent_(self):
        if (
            self.Response is not None or
            self.Shipment or
            self.Disclaimer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='TrackResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrackResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrackResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='TrackResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='TrackResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='TrackResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_='common:', name_='Response', pretty_print=pretty_print)
        for Shipment_ in self.Shipment:
            Shipment_.export(outfile, level, namespace_, name_='Shipment', pretty_print=pretty_print)
        for Disclaimer_ in self.Disclaimer:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Disclaimer>%s</trk:Disclaimer>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Disclaimer_), input_name='Disclaimer')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'Shipment':
            obj_ = ShipmentType.factory()
            obj_.build(child_)
            self.Shipment.append(obj_)
            obj_.original_tagname_ = 'Shipment'
        elif nodeName_ == 'Disclaimer':
            Disclaimer_ = child_.text
            Disclaimer_ = self.gds_validate_string(Disclaimer_, node, 'Disclaimer')
            self.Disclaimer.append(Disclaimer_)
# end class TrackResponse


class ActivityLocationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Address=None, TransportFacility=None, Code=None, Description=None, SignedForByName=None):
        self.original_tagname_ = None
        self.Address = Address
        self.TransportFacility = TransportFacility
        self.Code = Code
        self.Description = Description
        self.SignedForByName = SignedForByName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActivityLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActivityLocationType.subclass:
            return ActivityLocationType.subclass(*args_, **kwargs_)
        else:
            return ActivityLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_TransportFacility(self): return self.TransportFacility
    def set_TransportFacility(self, TransportFacility): self.TransportFacility = TransportFacility
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_SignedForByName(self): return self.SignedForByName
    def set_SignedForByName(self, SignedForByName): self.SignedForByName = SignedForByName
    def hasContent_(self):
        if (
            self.Address is not None or
            self.TransportFacility is not None or
            self.Code is not None or
            self.Description is not None or
            self.SignedForByName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ActivityLocationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActivityLocationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActivityLocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ActivityLocationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ActivityLocationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ActivityLocationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        if self.TransportFacility is not None:
            self.TransportFacility.export(outfile, level, namespace_, name_='TransportFacility', pretty_print=pretty_print)
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.SignedForByName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:SignedForByName>%s</trk:SignedForByName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SignedForByName), input_name='SignedForByName')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'TransportFacility':
            obj_ = TransportFacilityType.factory()
            obj_.build(child_)
            self.TransportFacility = obj_
            obj_.original_tagname_ = 'TransportFacility'
        elif nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'SignedForByName':
            SignedForByName_ = child_.text
            SignedForByName_ = self.gds_validate_string(SignedForByName_, node, 'SignedForByName')
            self.SignedForByName = SignedForByName_
# end class ActivityLocationType


class TransportFacilityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Code=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Code = Code
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransportFacilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransportFacilityType.subclass:
            return TransportFacilityType.subclass(*args_, **kwargs_)
        else:
            return TransportFacilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Code is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='TransportFacilityType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransportFacilityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransportFacilityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='TransportFacilityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='TransportFacilityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='TransportFacilityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Type>%s</trk:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
# end class TransportFacilityType


class ActivityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AlternateTrackingInfo=None, ActivityLocation=None, Status=None, Date=None, Time=None, DeliveryDateFromManifestIndicator=None, NextScheduleActivity=None, Document=None, AdditionalAttribute=None):
        self.original_tagname_ = None
        if AlternateTrackingInfo is None:
            self.AlternateTrackingInfo = []
        else:
            self.AlternateTrackingInfo = AlternateTrackingInfo
        self.ActivityLocation = ActivityLocation
        self.Status = Status
        self.Date = Date
        self.Time = Time
        self.DeliveryDateFromManifestIndicator = DeliveryDateFromManifestIndicator
        self.NextScheduleActivity = NextScheduleActivity
        if Document is None:
            self.Document = []
        else:
            self.Document = Document
        if AdditionalAttribute is None:
            self.AdditionalAttribute = []
        else:
            self.AdditionalAttribute = AdditionalAttribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActivityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActivityType.subclass:
            return ActivityType.subclass(*args_, **kwargs_)
        else:
            return ActivityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AlternateTrackingInfo(self): return self.AlternateTrackingInfo
    def set_AlternateTrackingInfo(self, AlternateTrackingInfo): self.AlternateTrackingInfo = AlternateTrackingInfo
    def add_AlternateTrackingInfo(self, value): self.AlternateTrackingInfo.append(value)
    def insert_AlternateTrackingInfo_at(self, index, value): self.AlternateTrackingInfo.insert(index, value)
    def replace_AlternateTrackingInfo_at(self, index, value): self.AlternateTrackingInfo[index] = value
    def get_ActivityLocation(self): return self.ActivityLocation
    def set_ActivityLocation(self, ActivityLocation): self.ActivityLocation = ActivityLocation
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_DeliveryDateFromManifestIndicator(self): return self.DeliveryDateFromManifestIndicator
    def set_DeliveryDateFromManifestIndicator(self, DeliveryDateFromManifestIndicator): self.DeliveryDateFromManifestIndicator = DeliveryDateFromManifestIndicator
    def get_NextScheduleActivity(self): return self.NextScheduleActivity
    def set_NextScheduleActivity(self, NextScheduleActivity): self.NextScheduleActivity = NextScheduleActivity
    def get_Document(self): return self.Document
    def set_Document(self, Document): self.Document = Document
    def add_Document(self, value): self.Document.append(value)
    def insert_Document_at(self, index, value): self.Document.insert(index, value)
    def replace_Document_at(self, index, value): self.Document[index] = value
    def get_AdditionalAttribute(self): return self.AdditionalAttribute
    def set_AdditionalAttribute(self, AdditionalAttribute): self.AdditionalAttribute = AdditionalAttribute
    def add_AdditionalAttribute(self, value): self.AdditionalAttribute.append(value)
    def insert_AdditionalAttribute_at(self, index, value): self.AdditionalAttribute.insert(index, value)
    def replace_AdditionalAttribute_at(self, index, value): self.AdditionalAttribute[index] = value
    def hasContent_(self):
        if (
            self.AlternateTrackingInfo or
            self.ActivityLocation is not None or
            self.Status is not None or
            self.Date is not None or
            self.Time is not None or
            self.DeliveryDateFromManifestIndicator is not None or
            self.NextScheduleActivity is not None or
            self.Document or
            self.AdditionalAttribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ActivityType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActivityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActivityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ActivityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ActivityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ActivityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AlternateTrackingInfo_ in self.AlternateTrackingInfo:
            AlternateTrackingInfo_.export(outfile, level, namespace_, name_='AlternateTrackingInfo', pretty_print=pretty_print)
        if self.ActivityLocation is not None:
            self.ActivityLocation.export(outfile, level, namespace_, name_='ActivityLocation', pretty_print=pretty_print)
        if self.Status is not None:
            self.Status.export(outfile, level, namespace_, name_='Status', pretty_print=pretty_print)
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Date>%s</trk:Date>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Date), input_name='Date')), eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Time>%s</trk:Time>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Time), input_name='Time')), eol_))
        if self.DeliveryDateFromManifestIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:DeliveryDateFromManifestIndicator>%s</trk:DeliveryDateFromManifestIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryDateFromManifestIndicator), input_name='DeliveryDateFromManifestIndicator')), eol_))
        if self.NextScheduleActivity is not None:
            self.NextScheduleActivity.export(outfile, level, namespace_, name_='NextScheduleActivity', pretty_print=pretty_print)
        for Document_ in self.Document:
            Document_.export(outfile, level, namespace_, name_='Document', pretty_print=pretty_print)
        for AdditionalAttribute_ in self.AdditionalAttribute:
            AdditionalAttribute_.export(outfile, level, namespace_, name_='AdditionalAttribute', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AlternateTrackingInfo':
            obj_ = AlternateTrackingInfoType.factory()
            obj_.build(child_)
            self.AlternateTrackingInfo.append(obj_)
            obj_.original_tagname_ = 'AlternateTrackingInfo'
        elif nodeName_ == 'ActivityLocation':
            obj_ = ActivityLocationType.factory()
            obj_.build(child_)
            self.ActivityLocation = obj_
            obj_.original_tagname_ = 'ActivityLocation'
        elif nodeName_ == 'Status':
            obj_ = StatusType.factory()
            obj_.build(child_)
            self.Status = obj_
            obj_.original_tagname_ = 'Status'
        elif nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
        elif nodeName_ == 'DeliveryDateFromManifestIndicator':
            DeliveryDateFromManifestIndicator_ = child_.text
            DeliveryDateFromManifestIndicator_ = self.gds_validate_string(DeliveryDateFromManifestIndicator_, node, 'DeliveryDateFromManifestIndicator')
            self.DeliveryDateFromManifestIndicator = DeliveryDateFromManifestIndicator_
        elif nodeName_ == 'NextScheduleActivity':
            obj_ = NextScheduleActivityType.factory()
            obj_.build(child_)
            self.NextScheduleActivity = obj_
            obj_.original_tagname_ = 'NextScheduleActivity'
        elif nodeName_ == 'Document':
            obj_ = DocumentType.factory()
            obj_.build(child_)
            self.Document.append(obj_)
            obj_.original_tagname_ = 'Document'
        elif nodeName_ == 'AdditionalAttribute':
            obj_ = AdditionalCodeDescriptionValueType.factory()
            obj_.build(child_)
            self.AdditionalAttribute.append(obj_)
            obj_.original_tagname_ = 'AdditionalAttribute'
# end class ActivityType


class NextScheduleActivityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Date=None, Time=None):
        self.original_tagname_ = None
        self.Date = Date
        self.Time = Time
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NextScheduleActivityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NextScheduleActivityType.subclass:
            return NextScheduleActivityType.subclass(*args_, **kwargs_)
        else:
            return NextScheduleActivityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def hasContent_(self):
        if (
            self.Date is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='NextScheduleActivityType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NextScheduleActivityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NextScheduleActivityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='NextScheduleActivityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='NextScheduleActivityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='NextScheduleActivityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Date>%s</trk:Date>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Date), input_name='Date')), eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Time>%s</trk:Time>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Time), input_name='Time')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
# end class NextScheduleActivityType


class AddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AddressLine=None, City=None, StateProvinceCode=None, PostalCode=None, CountryCode=None):
        self.original_tagname_ = None
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.City = City
        self.StateProvinceCode = StateProvinceCode
        self.PostalCode = PostalCode
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine_at(self, index, value): self.AddressLine.insert(index, value)
    def replace_AddressLine_at(self, index, value): self.AddressLine[index] = value
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_StateProvinceCode(self): return self.StateProvinceCode
    def set_StateProvinceCode(self, StateProvinceCode): self.StateProvinceCode = StateProvinceCode
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.AddressLine or
            self.City is not None or
            self.StateProvinceCode is not None or
            self.PostalCode is not None or
            self.CountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='AddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='AddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='AddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:AddressLine>%s</trk:AddressLine>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressLine_), input_name='AddressLine')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:City>%s</trk:City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.StateProvinceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:StateProvinceCode>%s</trk:StateProvinceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateProvinceCode), input_name='StateProvinceCode')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:PostalCode>%s</trk:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CountryCode>%s</trk:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressLine':
            AddressLine_ = child_.text
            AddressLine_ = self.gds_validate_string(AddressLine_, node, 'AddressLine')
            self.AddressLine.append(AddressLine_)
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'StateProvinceCode':
            StateProvinceCode_ = child_.text
            StateProvinceCode_ = self.gds_validate_string(StateProvinceCode_, node, 'StateProvinceCode')
            self.StateProvinceCode = StateProvinceCode_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class AddressType


class AmountType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CurrencyCode=None, MonetaryValue=None):
        self.original_tagname_ = None
        self.CurrencyCode = CurrencyCode
        self.MonetaryValue = MonetaryValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmountType.subclass:
            return AmountType.subclass(*args_, **kwargs_)
        else:
            return AmountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_MonetaryValue(self): return self.MonetaryValue
    def set_MonetaryValue(self, MonetaryValue): self.MonetaryValue = MonetaryValue
    def hasContent_(self):
        if (
            self.CurrencyCode is not None or
            self.MonetaryValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='AmountType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AmountType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='AmountType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='AmountType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='AmountType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CurrencyCode>%s</trk:CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.MonetaryValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:MonetaryValue>%s</trk:MonetaryValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MonetaryValue), input_name='MonetaryValue')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
        elif nodeName_ == 'MonetaryValue':
            MonetaryValue_ = child_.text
            MonetaryValue_ = self.gds_validate_string(MonetaryValue_, node, 'MonetaryValue')
            self.MonetaryValue = MonetaryValue_
# end class AmountType


class CommonCodeDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommonCodeDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommonCodeDescriptionType.subclass:
            return CommonCodeDescriptionType.subclass(*args_, **kwargs_)
        else:
            return CommonCodeDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='CommonCodeDescriptionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommonCodeDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommonCodeDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='CommonCodeDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='CommonCodeDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='CommonCodeDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class CommonCodeDescriptionType


class CODType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Amount=None, Status=None, ControlNumber=None):
        self.original_tagname_ = None
        self.Amount = Amount
        self.Status = Status
        self.ControlNumber = ControlNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CODType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CODType.subclass:
            return CODType.subclass(*args_, **kwargs_)
        else:
            return CODType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Amount(self): return self.Amount
    def set_Amount(self, Amount): self.Amount = Amount
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ControlNumber(self): return self.ControlNumber
    def set_ControlNumber(self, ControlNumber): self.ControlNumber = ControlNumber
    def hasContent_(self):
        if (
            self.Amount is not None or
            self.Status is not None or
            self.ControlNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='CODType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CODType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CODType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='CODType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='CODType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='CODType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Amount is not None:
            self.Amount.export(outfile, level, namespace_, name_='Amount', pretty_print=pretty_print)
        if self.Status is not None:
            self.Status.export(outfile, level, namespace_, name_='Status', pretty_print=pretty_print)
        if self.ControlNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:ControlNumber>%s</trk:ControlNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ControlNumber), input_name='ControlNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Amount':
            obj_ = AmountType.factory()
            obj_.build(child_)
            self.Amount = obj_
            obj_.original_tagname_ = 'Amount'
        elif nodeName_ == 'Status':
            obj_ = CODStatusType.factory()
            obj_.build(child_)
            self.Status = obj_
            obj_.original_tagname_ = 'Status'
        elif nodeName_ == 'ControlNumber':
            ControlNumber_ = child_.text
            ControlNumber_ = self.gds_validate_string(ControlNumber_, node, 'ControlNumber')
            self.ControlNumber = ControlNumber_
# end class CODType


class CODStatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CODStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CODStatusType.subclass:
            return CODStatusType.subclass(*args_, **kwargs_)
        else:
            return CODStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='CODStatusType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CODStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CODStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='CODStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='CODStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='CODStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class CODStatusType


class DeliveryDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Date=None, Time=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Date = Date
        self.Time = Time
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryDetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryDetailType.subclass:
            return DeliveryDetailType.subclass(*args_, **kwargs_)
        else:
            return DeliveryDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Date is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='DeliveryDetailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeliveryDetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryDetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='DeliveryDetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='DeliveryDetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='DeliveryDetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Date>%s</trk:Date>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Date), input_name='Date')), eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Time>%s</trk:Time>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Time), input_name='Time')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = CommonCodeDescriptionType.factory()
            obj_.build(child_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
# end class DeliveryDetailType


class ImageFormatType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImageFormatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImageFormatType.subclass:
            return ImageFormatType.subclass(*args_, **kwargs_)
        else:
            return ImageFormatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ImageFormatType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImageFormatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImageFormatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ImageFormatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ImageFormatType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ImageFormatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class ImageFormatType


class MessageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageType.subclass:
            return MessageType.subclass(*args_, **kwargs_)
        else:
            return MessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='MessageType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='MessageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='MessageType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='MessageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class MessageType


class NumberOfPackagingUnitType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfPackagingUnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfPackagingUnitType.subclass:
            return NumberOfPackagingUnitType.subclass(*args_, **kwargs_)
        else:
            return NumberOfPackagingUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='NumberOfPackagingUnitType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumberOfPackagingUnitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumberOfPackagingUnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='NumberOfPackagingUnitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='NumberOfPackagingUnitType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='NumberOfPackagingUnitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Value>%s</trk:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = CommonCodeDescriptionType.factory()
            obj_.build(child_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class NumberOfPackagingUnitType


class PackageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TrackingNumber=None, Redirect=None, DeliveryDetail=None, PackageAddress=None, PackageServiceOption=None, COD=None, Activity=None, Message=None, PackageWeight=None, ReferenceNumber=None, AlternateTrackingNumber=None, AlternateTrackingInfo=None, DimensionalWeightScanIndicator=None):
        self.original_tagname_ = None
        self.TrackingNumber = TrackingNumber
        self.Redirect = Redirect
        if DeliveryDetail is None:
            self.DeliveryDetail = []
        else:
            self.DeliveryDetail = DeliveryDetail
        if PackageAddress is None:
            self.PackageAddress = []
        else:
            self.PackageAddress = PackageAddress
        if PackageServiceOption is None:
            self.PackageServiceOption = []
        else:
            self.PackageServiceOption = PackageServiceOption
        self.COD = COD
        if Activity is None:
            self.Activity = []
        else:
            self.Activity = Activity
        if Message is None:
            self.Message = []
        else:
            self.Message = Message
        self.PackageWeight = PackageWeight
        if ReferenceNumber is None:
            self.ReferenceNumber = []
        else:
            self.ReferenceNumber = ReferenceNumber
        if AlternateTrackingNumber is None:
            self.AlternateTrackingNumber = []
        else:
            self.AlternateTrackingNumber = AlternateTrackingNumber
        if AlternateTrackingInfo is None:
            self.AlternateTrackingInfo = []
        else:
            self.AlternateTrackingInfo = AlternateTrackingInfo
        self.DimensionalWeightScanIndicator = DimensionalWeightScanIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageType.subclass:
            return PackageType.subclass(*args_, **kwargs_)
        else:
            return PackageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrackingNumber(self): return self.TrackingNumber
    def set_TrackingNumber(self, TrackingNumber): self.TrackingNumber = TrackingNumber
    def get_Redirect(self): return self.Redirect
    def set_Redirect(self, Redirect): self.Redirect = Redirect
    def get_DeliveryDetail(self): return self.DeliveryDetail
    def set_DeliveryDetail(self, DeliveryDetail): self.DeliveryDetail = DeliveryDetail
    def add_DeliveryDetail(self, value): self.DeliveryDetail.append(value)
    def insert_DeliveryDetail_at(self, index, value): self.DeliveryDetail.insert(index, value)
    def replace_DeliveryDetail_at(self, index, value): self.DeliveryDetail[index] = value
    def get_PackageAddress(self): return self.PackageAddress
    def set_PackageAddress(self, PackageAddress): self.PackageAddress = PackageAddress
    def add_PackageAddress(self, value): self.PackageAddress.append(value)
    def insert_PackageAddress_at(self, index, value): self.PackageAddress.insert(index, value)
    def replace_PackageAddress_at(self, index, value): self.PackageAddress[index] = value
    def get_PackageServiceOption(self): return self.PackageServiceOption
    def set_PackageServiceOption(self, PackageServiceOption): self.PackageServiceOption = PackageServiceOption
    def add_PackageServiceOption(self, value): self.PackageServiceOption.append(value)
    def insert_PackageServiceOption_at(self, index, value): self.PackageServiceOption.insert(index, value)
    def replace_PackageServiceOption_at(self, index, value): self.PackageServiceOption[index] = value
    def get_COD(self): return self.COD
    def set_COD(self, COD): self.COD = COD
    def get_Activity(self): return self.Activity
    def set_Activity(self, Activity): self.Activity = Activity
    def add_Activity(self, value): self.Activity.append(value)
    def insert_Activity_at(self, index, value): self.Activity.insert(index, value)
    def replace_Activity_at(self, index, value): self.Activity[index] = value
    def get_Message(self): return self.Message
    def set_Message(self, Message): self.Message = Message
    def add_Message(self, value): self.Message.append(value)
    def insert_Message_at(self, index, value): self.Message.insert(index, value)
    def replace_Message_at(self, index, value): self.Message[index] = value
    def get_PackageWeight(self): return self.PackageWeight
    def set_PackageWeight(self, PackageWeight): self.PackageWeight = PackageWeight
    def get_ReferenceNumber(self): return self.ReferenceNumber
    def set_ReferenceNumber(self, ReferenceNumber): self.ReferenceNumber = ReferenceNumber
    def add_ReferenceNumber(self, value): self.ReferenceNumber.append(value)
    def insert_ReferenceNumber_at(self, index, value): self.ReferenceNumber.insert(index, value)
    def replace_ReferenceNumber_at(self, index, value): self.ReferenceNumber[index] = value
    def get_AlternateTrackingNumber(self): return self.AlternateTrackingNumber
    def set_AlternateTrackingNumber(self, AlternateTrackingNumber): self.AlternateTrackingNumber = AlternateTrackingNumber
    def add_AlternateTrackingNumber(self, value): self.AlternateTrackingNumber.append(value)
    def insert_AlternateTrackingNumber_at(self, index, value): self.AlternateTrackingNumber.insert(index, value)
    def replace_AlternateTrackingNumber_at(self, index, value): self.AlternateTrackingNumber[index] = value
    def get_AlternateTrackingInfo(self): return self.AlternateTrackingInfo
    def set_AlternateTrackingInfo(self, AlternateTrackingInfo): self.AlternateTrackingInfo = AlternateTrackingInfo
    def add_AlternateTrackingInfo(self, value): self.AlternateTrackingInfo.append(value)
    def insert_AlternateTrackingInfo_at(self, index, value): self.AlternateTrackingInfo.insert(index, value)
    def replace_AlternateTrackingInfo_at(self, index, value): self.AlternateTrackingInfo[index] = value
    def get_DimensionalWeightScanIndicator(self): return self.DimensionalWeightScanIndicator
    def set_DimensionalWeightScanIndicator(self, DimensionalWeightScanIndicator): self.DimensionalWeightScanIndicator = DimensionalWeightScanIndicator
    def hasContent_(self):
        if (
            self.TrackingNumber is not None or
            self.Redirect is not None or
            self.DeliveryDetail or
            self.PackageAddress or
            self.PackageServiceOption or
            self.COD is not None or
            self.Activity or
            self.Message or
            self.PackageWeight is not None or
            self.ReferenceNumber or
            self.AlternateTrackingNumber or
            self.AlternateTrackingInfo or
            self.DimensionalWeightScanIndicator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='PackageType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PackageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='PackageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='PackageType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='PackageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrackingNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:TrackingNumber>%s</trk:TrackingNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TrackingNumber), input_name='TrackingNumber')), eol_))
        if self.Redirect is not None:
            self.Redirect.export(outfile, level, namespace_, name_='Redirect', pretty_print=pretty_print)
        for DeliveryDetail_ in self.DeliveryDetail:
            DeliveryDetail_.export(outfile, level, namespace_, name_='DeliveryDetail', pretty_print=pretty_print)
        for PackageAddress_ in self.PackageAddress:
            PackageAddress_.export(outfile, level, namespace_, name_='PackageAddress', pretty_print=pretty_print)
        for PackageServiceOption_ in self.PackageServiceOption:
            PackageServiceOption_.export(outfile, level, namespace_, name_='PackageServiceOption', pretty_print=pretty_print)
        if self.COD is not None:
            self.COD.export(outfile, level, namespace_, name_='COD', pretty_print=pretty_print)
        for Activity_ in self.Activity:
            Activity_.export(outfile, level, namespace_, name_='Activity', pretty_print=pretty_print)
        for Message_ in self.Message:
            Message_.export(outfile, level, namespace_, name_='Message', pretty_print=pretty_print)
        if self.PackageWeight is not None:
            self.PackageWeight.export(outfile, level, namespace_, name_='PackageWeight', pretty_print=pretty_print)
        for ReferenceNumber_ in self.ReferenceNumber:
            ReferenceNumber_.export(outfile, level, namespace_, name_='ReferenceNumber', pretty_print=pretty_print)
        for AlternateTrackingNumber_ in self.AlternateTrackingNumber:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:AlternateTrackingNumber>%s</trk:AlternateTrackingNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AlternateTrackingNumber_), input_name='AlternateTrackingNumber')), eol_))
        for AlternateTrackingInfo_ in self.AlternateTrackingInfo:
            AlternateTrackingInfo_.export(outfile, level, namespace_, name_='AlternateTrackingInfo', pretty_print=pretty_print)
        if self.DimensionalWeightScanIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:DimensionalWeightScanIndicator>%s</trk:DimensionalWeightScanIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DimensionalWeightScanIndicator), input_name='DimensionalWeightScanIndicator')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrackingNumber':
            TrackingNumber_ = child_.text
            TrackingNumber_ = self.gds_validate_string(TrackingNumber_, node, 'TrackingNumber')
            self.TrackingNumber = TrackingNumber_
        elif nodeName_ == 'Redirect':
            obj_ = RedirectType.factory()
            obj_.build(child_)
            self.Redirect = obj_
            obj_.original_tagname_ = 'Redirect'
        elif nodeName_ == 'DeliveryDetail':
            obj_ = DeliveryDetailType.factory()
            obj_.build(child_)
            self.DeliveryDetail.append(obj_)
            obj_.original_tagname_ = 'DeliveryDetail'
        elif nodeName_ == 'PackageAddress':
            obj_ = PackageAddressType.factory()
            obj_.build(child_)
            self.PackageAddress.append(obj_)
            obj_.original_tagname_ = 'PackageAddress'
        elif nodeName_ == 'PackageServiceOption':
            obj_ = ServiceOptionType.factory()
            obj_.build(child_)
            self.PackageServiceOption.append(obj_)
            obj_.original_tagname_ = 'PackageServiceOption'
        elif nodeName_ == 'COD':
            obj_ = CODType.factory()
            obj_.build(child_)
            self.COD = obj_
            obj_.original_tagname_ = 'COD'
        elif nodeName_ == 'Activity':
            obj_ = ActivityType.factory()
            obj_.build(child_)
            self.Activity.append(obj_)
            obj_.original_tagname_ = 'Activity'
        elif nodeName_ == 'Message':
            obj_ = MessageType.factory()
            obj_.build(child_)
            self.Message.append(obj_)
            obj_.original_tagname_ = 'Message'
        elif nodeName_ == 'PackageWeight':
            obj_ = WeightType.factory()
            obj_.build(child_)
            self.PackageWeight = obj_
            obj_.original_tagname_ = 'PackageWeight'
        elif nodeName_ == 'ReferenceNumber':
            obj_ = ReferenceNumberType.factory()
            obj_.build(child_)
            self.ReferenceNumber.append(obj_)
            obj_.original_tagname_ = 'ReferenceNumber'
        elif nodeName_ == 'AlternateTrackingNumber':
            AlternateTrackingNumber_ = child_.text
            AlternateTrackingNumber_ = self.gds_validate_string(AlternateTrackingNumber_, node, 'AlternateTrackingNumber')
            self.AlternateTrackingNumber.append(AlternateTrackingNumber_)
        elif nodeName_ == 'AlternateTrackingInfo':
            obj_ = AlternateTrackingInfoType.factory()
            obj_.build(child_)
            self.AlternateTrackingInfo.append(obj_)
            obj_.original_tagname_ = 'AlternateTrackingInfo'
        elif nodeName_ == 'DimensionalWeightScanIndicator':
            DimensionalWeightScanIndicator_ = child_.text
            DimensionalWeightScanIndicator_ = self.gds_validate_string(DimensionalWeightScanIndicator_, node, 'DimensionalWeightScanIndicator')
            self.DimensionalWeightScanIndicator = DimensionalWeightScanIndicator_
# end class PackageType


class RedirectType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CompanyName=None, LocationID=None, PickupDate=None):
        self.original_tagname_ = None
        self.CompanyName = CompanyName
        self.LocationID = LocationID
        self.PickupDate = PickupDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RedirectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RedirectType.subclass:
            return RedirectType.subclass(*args_, **kwargs_)
        else:
            return RedirectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompanyName(self): return self.CompanyName
    def set_CompanyName(self, CompanyName): self.CompanyName = CompanyName
    def get_LocationID(self): return self.LocationID
    def set_LocationID(self, LocationID): self.LocationID = LocationID
    def get_PickupDate(self): return self.PickupDate
    def set_PickupDate(self, PickupDate): self.PickupDate = PickupDate
    def hasContent_(self):
        if (
            self.CompanyName is not None or
            self.LocationID is not None or
            self.PickupDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='RedirectType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RedirectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RedirectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='RedirectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='RedirectType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='RedirectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompanyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CompanyName>%s</trk:CompanyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompanyName), input_name='CompanyName')), eol_))
        if self.LocationID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:LocationID>%s</trk:LocationID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationID), input_name='LocationID')), eol_))
        if self.PickupDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:PickupDate>%s</trk:PickupDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupDate), input_name='PickupDate')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompanyName':
            CompanyName_ = child_.text
            CompanyName_ = self.gds_validate_string(CompanyName_, node, 'CompanyName')
            self.CompanyName = CompanyName_
        elif nodeName_ == 'LocationID':
            LocationID_ = child_.text
            LocationID_ = self.gds_validate_string(LocationID_, node, 'LocationID')
            self.LocationID = LocationID_
        elif nodeName_ == 'PickupDate':
            PickupDate_ = child_.text
            PickupDate_ = self.gds_validate_string(PickupDate_, node, 'PickupDate')
            self.PickupDate = PickupDate_
# end class RedirectType


class DeliveryDateUnavailableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Description=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryDateUnavailableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryDateUnavailableType.subclass:
            return DeliveryDateUnavailableType.subclass(*args_, **kwargs_)
        else:
            return DeliveryDateUnavailableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='DeliveryDateUnavailableType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeliveryDateUnavailableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryDateUnavailableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='DeliveryDateUnavailableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='DeliveryDateUnavailableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='DeliveryDateUnavailableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Type>%s</trk:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class DeliveryDateUnavailableType


class PackageAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Address=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Address = Address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PackageAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PackageAddressType.subclass:
            return PackageAddressType.subclass(*args_, **kwargs_)
        else:
            return PackageAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='PackageAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PackageAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PackageAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='PackageAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='PackageAddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='PackageAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = CommonCodeDescriptionType.factory()
            obj_.build(child_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
# end class PackageAddressType


class ProductCodeDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductCodeDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductCodeDescriptionType.subclass:
            return ProductCodeDescriptionType.subclass(*args_, **kwargs_)
        else:
            return ProductCodeDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ProductCodeDescriptionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProductCodeDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductCodeDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ProductCodeDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ProductCodeDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ProductCodeDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class ProductCodeDescriptionType


class PODLetterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HTMLImage=None):
        self.original_tagname_ = None
        self.HTMLImage = HTMLImage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PODLetterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PODLetterType.subclass:
            return PODLetterType.subclass(*args_, **kwargs_)
        else:
            return PODLetterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HTMLImage(self): return self.HTMLImage
    def set_HTMLImage(self, HTMLImage): self.HTMLImage = HTMLImage
    def hasContent_(self):
        if (
            self.HTMLImage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='PODLetterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PODLetterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PODLetterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='PODLetterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='PODLetterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='PODLetterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HTMLImage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:HTMLImage>%s</trk:HTMLImage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HTMLImage), input_name='HTMLImage')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HTMLImage':
            HTMLImage_ = child_.text
            HTMLImage_ = self.gds_validate_string(HTMLImage_, node, 'HTMLImage')
            self.HTMLImage = HTMLImage_
# end class PODLetterType


class ResponseTransactionReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomerContext=None):
        self.original_tagname_ = None
        self.CustomerContext = CustomerContext
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseTransactionReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseTransactionReferenceType.subclass:
            return ResponseTransactionReferenceType.subclass(*args_, **kwargs_)
        else:
            return ResponseTransactionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerContext(self): return self.CustomerContext
    def set_CustomerContext(self, CustomerContext): self.CustomerContext = CustomerContext
    def hasContent_(self):
        if (
            self.CustomerContext is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ResponseTransactionReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseTransactionReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseTransactionReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ResponseTransactionReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ResponseTransactionReferenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ResponseTransactionReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerContext is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CustomerContext>%s</trk:CustomerContext>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerContext), input_name='CustomerContext')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerContext':
            CustomerContext_ = child_.text
            CustomerContext_ = self.gds_validate_string(CustomerContext_, node, 'CustomerContext')
            self.CustomerContext = CustomerContext_
# end class ResponseTransactionReferenceType


class ServiceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceType.subclass:
            return ServiceType.subclass(*args_, **kwargs_)
        else:
            return ServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ServiceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ServiceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ServiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class ServiceType


class ShipmentReferenceNumberType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None, Value=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentReferenceNumberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentReferenceNumberType.subclass:
            return ShipmentReferenceNumberType.subclass(*args_, **kwargs_)
        else:
            return ShipmentReferenceNumberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ShipmentReferenceNumberType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentReferenceNumberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentReferenceNumberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ShipmentReferenceNumberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ShipmentReferenceNumberType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ShipmentReferenceNumberType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Value>%s</trk:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ShipmentReferenceNumberType


class ShipmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InquiryNumber=None, ShipmentType_member=None, CandidateBookmark=None, ShipperNumber=None, ShipmentAddress=None, ShipmentWeight=None, Service=None, ReferenceNumber=None, CurrentStatus=None, PickupDate=None, ServiceCenter=None, DeliveryDateUnavailable=None, DeliveryDetail=None, Volume=None, BillToName=None, NumberOfPackagingUnit=None, COD=None, SignedForByName=None, Activity=None, OriginPortDetail=None, DestinationPortDetail=None, DescriptionOfGoods=None, CargoReady=None, Manifest=None, CarrierActivityInformation=None, Document=None, FileNumber=None, Appointment=None, Package=None, AdditionalAttribute=None):
        self.original_tagname_ = None
        self.InquiryNumber = InquiryNumber
        self.ShipmentType = ShipmentType_member
        self.CandidateBookmark = CandidateBookmark
        self.ShipperNumber = ShipperNumber
        if ShipmentAddress is None:
            self.ShipmentAddress = []
        else:
            self.ShipmentAddress = ShipmentAddress
        self.ShipmentWeight = ShipmentWeight
        self.Service = Service
        if ReferenceNumber is None:
            self.ReferenceNumber = []
        else:
            self.ReferenceNumber = ReferenceNumber
        self.CurrentStatus = CurrentStatus
        self.PickupDate = PickupDate
        if ServiceCenter is None:
            self.ServiceCenter = []
        else:
            self.ServiceCenter = ServiceCenter
        self.DeliveryDateUnavailable = DeliveryDateUnavailable
        if DeliveryDetail is None:
            self.DeliveryDetail = []
        else:
            self.DeliveryDetail = DeliveryDetail
        self.Volume = Volume
        self.BillToName = BillToName
        if NumberOfPackagingUnit is None:
            self.NumberOfPackagingUnit = []
        else:
            self.NumberOfPackagingUnit = NumberOfPackagingUnit
        self.COD = COD
        self.SignedForByName = SignedForByName
        if Activity is None:
            self.Activity = []
        else:
            self.Activity = Activity
        self.OriginPortDetail = OriginPortDetail
        self.DestinationPortDetail = DestinationPortDetail
        self.DescriptionOfGoods = DescriptionOfGoods
        self.CargoReady = CargoReady
        self.Manifest = Manifest
        if CarrierActivityInformation is None:
            self.CarrierActivityInformation = []
        else:
            self.CarrierActivityInformation = CarrierActivityInformation
        if Document is None:
            self.Document = []
        else:
            self.Document = Document
        self.FileNumber = FileNumber
        self.Appointment = Appointment
        if Package is None:
            self.Package = []
        else:
            self.Package = Package
        if AdditionalAttribute is None:
            self.AdditionalAttribute = []
        else:
            self.AdditionalAttribute = AdditionalAttribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentType.subclass:
            return ShipmentType.subclass(*args_, **kwargs_)
        else:
            return ShipmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InquiryNumber(self): return self.InquiryNumber
    def set_InquiryNumber(self, InquiryNumber): self.InquiryNumber = InquiryNumber
    def get_ShipmentType(self): return self.ShipmentType
    def set_ShipmentType(self, ShipmentType): self.ShipmentType = ShipmentType
    def get_CandidateBookmark(self): return self.CandidateBookmark
    def set_CandidateBookmark(self, CandidateBookmark): self.CandidateBookmark = CandidateBookmark
    def get_ShipperNumber(self): return self.ShipperNumber
    def set_ShipperNumber(self, ShipperNumber): self.ShipperNumber = ShipperNumber
    def get_ShipmentAddress(self): return self.ShipmentAddress
    def set_ShipmentAddress(self, ShipmentAddress): self.ShipmentAddress = ShipmentAddress
    def add_ShipmentAddress(self, value): self.ShipmentAddress.append(value)
    def insert_ShipmentAddress_at(self, index, value): self.ShipmentAddress.insert(index, value)
    def replace_ShipmentAddress_at(self, index, value): self.ShipmentAddress[index] = value
    def get_ShipmentWeight(self): return self.ShipmentWeight
    def set_ShipmentWeight(self, ShipmentWeight): self.ShipmentWeight = ShipmentWeight
    def get_Service(self): return self.Service
    def set_Service(self, Service): self.Service = Service
    def get_ReferenceNumber(self): return self.ReferenceNumber
    def set_ReferenceNumber(self, ReferenceNumber): self.ReferenceNumber = ReferenceNumber
    def add_ReferenceNumber(self, value): self.ReferenceNumber.append(value)
    def insert_ReferenceNumber_at(self, index, value): self.ReferenceNumber.insert(index, value)
    def replace_ReferenceNumber_at(self, index, value): self.ReferenceNumber[index] = value
    def get_CurrentStatus(self): return self.CurrentStatus
    def set_CurrentStatus(self, CurrentStatus): self.CurrentStatus = CurrentStatus
    def get_PickupDate(self): return self.PickupDate
    def set_PickupDate(self, PickupDate): self.PickupDate = PickupDate
    def get_ServiceCenter(self): return self.ServiceCenter
    def set_ServiceCenter(self, ServiceCenter): self.ServiceCenter = ServiceCenter
    def add_ServiceCenter(self, value): self.ServiceCenter.append(value)
    def insert_ServiceCenter_at(self, index, value): self.ServiceCenter.insert(index, value)
    def replace_ServiceCenter_at(self, index, value): self.ServiceCenter[index] = value
    def get_DeliveryDateUnavailable(self): return self.DeliveryDateUnavailable
    def set_DeliveryDateUnavailable(self, DeliveryDateUnavailable): self.DeliveryDateUnavailable = DeliveryDateUnavailable
    def get_DeliveryDetail(self): return self.DeliveryDetail
    def set_DeliveryDetail(self, DeliveryDetail): self.DeliveryDetail = DeliveryDetail
    def add_DeliveryDetail(self, value): self.DeliveryDetail.append(value)
    def insert_DeliveryDetail_at(self, index, value): self.DeliveryDetail.insert(index, value)
    def replace_DeliveryDetail_at(self, index, value): self.DeliveryDetail[index] = value
    def get_Volume(self): return self.Volume
    def set_Volume(self, Volume): self.Volume = Volume
    def get_BillToName(self): return self.BillToName
    def set_BillToName(self, BillToName): self.BillToName = BillToName
    def get_NumberOfPackagingUnit(self): return self.NumberOfPackagingUnit
    def set_NumberOfPackagingUnit(self, NumberOfPackagingUnit): self.NumberOfPackagingUnit = NumberOfPackagingUnit
    def add_NumberOfPackagingUnit(self, value): self.NumberOfPackagingUnit.append(value)
    def insert_NumberOfPackagingUnit_at(self, index, value): self.NumberOfPackagingUnit.insert(index, value)
    def replace_NumberOfPackagingUnit_at(self, index, value): self.NumberOfPackagingUnit[index] = value
    def get_COD(self): return self.COD
    def set_COD(self, COD): self.COD = COD
    def get_SignedForByName(self): return self.SignedForByName
    def set_SignedForByName(self, SignedForByName): self.SignedForByName = SignedForByName
    def get_Activity(self): return self.Activity
    def set_Activity(self, Activity): self.Activity = Activity
    def add_Activity(self, value): self.Activity.append(value)
    def insert_Activity_at(self, index, value): self.Activity.insert(index, value)
    def replace_Activity_at(self, index, value): self.Activity[index] = value
    def get_OriginPortDetail(self): return self.OriginPortDetail
    def set_OriginPortDetail(self, OriginPortDetail): self.OriginPortDetail = OriginPortDetail
    def get_DestinationPortDetail(self): return self.DestinationPortDetail
    def set_DestinationPortDetail(self, DestinationPortDetail): self.DestinationPortDetail = DestinationPortDetail
    def get_DescriptionOfGoods(self): return self.DescriptionOfGoods
    def set_DescriptionOfGoods(self, DescriptionOfGoods): self.DescriptionOfGoods = DescriptionOfGoods
    def get_CargoReady(self): return self.CargoReady
    def set_CargoReady(self, CargoReady): self.CargoReady = CargoReady
    def get_Manifest(self): return self.Manifest
    def set_Manifest(self, Manifest): self.Manifest = Manifest
    def get_CarrierActivityInformation(self): return self.CarrierActivityInformation
    def set_CarrierActivityInformation(self, CarrierActivityInformation): self.CarrierActivityInformation = CarrierActivityInformation
    def add_CarrierActivityInformation(self, value): self.CarrierActivityInformation.append(value)
    def insert_CarrierActivityInformation_at(self, index, value): self.CarrierActivityInformation.insert(index, value)
    def replace_CarrierActivityInformation_at(self, index, value): self.CarrierActivityInformation[index] = value
    def get_Document(self): return self.Document
    def set_Document(self, Document): self.Document = Document
    def add_Document(self, value): self.Document.append(value)
    def insert_Document_at(self, index, value): self.Document.insert(index, value)
    def replace_Document_at(self, index, value): self.Document[index] = value
    def get_FileNumber(self): return self.FileNumber
    def set_FileNumber(self, FileNumber): self.FileNumber = FileNumber
    def get_Appointment(self): return self.Appointment
    def set_Appointment(self, Appointment): self.Appointment = Appointment
    def get_Package(self): return self.Package
    def set_Package(self, Package): self.Package = Package
    def add_Package(self, value): self.Package.append(value)
    def insert_Package_at(self, index, value): self.Package.insert(index, value)
    def replace_Package_at(self, index, value): self.Package[index] = value
    def get_AdditionalAttribute(self): return self.AdditionalAttribute
    def set_AdditionalAttribute(self, AdditionalAttribute): self.AdditionalAttribute = AdditionalAttribute
    def add_AdditionalAttribute(self, value): self.AdditionalAttribute.append(value)
    def insert_AdditionalAttribute_at(self, index, value): self.AdditionalAttribute.insert(index, value)
    def replace_AdditionalAttribute_at(self, index, value): self.AdditionalAttribute[index] = value
    def hasContent_(self):
        if (
            self.InquiryNumber is not None or
            self.ShipmentType is not None or
            self.CandidateBookmark is not None or
            self.ShipperNumber is not None or
            self.ShipmentAddress or
            self.ShipmentWeight is not None or
            self.Service is not None or
            self.ReferenceNumber or
            self.CurrentStatus is not None or
            self.PickupDate is not None or
            self.ServiceCenter or
            self.DeliveryDateUnavailable is not None or
            self.DeliveryDetail or
            self.Volume is not None or
            self.BillToName is not None or
            self.NumberOfPackagingUnit or
            self.COD is not None or
            self.SignedForByName is not None or
            self.Activity or
            self.OriginPortDetail is not None or
            self.DestinationPortDetail is not None or
            self.DescriptionOfGoods is not None or
            self.CargoReady is not None or
            self.Manifest is not None or
            self.CarrierActivityInformation or
            self.Document or
            self.FileNumber is not None or
            self.Appointment is not None or
            self.Package or
            self.AdditionalAttribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ShipmentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ShipmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ShipmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ShipmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InquiryNumber is not None:
            self.InquiryNumber.export(outfile, level, namespace_, name_='InquiryNumber', pretty_print=pretty_print)
        if self.ShipmentType is not None:
            self.ShipmentType.export(outfile, level, namespace_, name_='ShipmentType', pretty_print=pretty_print)
        if self.CandidateBookmark is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CandidateBookmark>%s</trk:CandidateBookmark>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CandidateBookmark), input_name='CandidateBookmark')), eol_))
        if self.ShipperNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:ShipperNumber>%s</trk:ShipperNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShipperNumber), input_name='ShipperNumber')), eol_))
        for ShipmentAddress_ in self.ShipmentAddress:
            ShipmentAddress_.export(outfile, level, namespace_, name_='ShipmentAddress', pretty_print=pretty_print)
        if self.ShipmentWeight is not None:
            self.ShipmentWeight.export(outfile, level, namespace_, name_='ShipmentWeight', pretty_print=pretty_print)
        if self.Service is not None:
            self.Service.export(outfile, level, namespace_, name_='Service', pretty_print=pretty_print)
        for ReferenceNumber_ in self.ReferenceNumber:
            ReferenceNumber_.export(outfile, level, namespace_, name_='ReferenceNumber', pretty_print=pretty_print)
        if self.CurrentStatus is not None:
            self.CurrentStatus.export(outfile, level, namespace_, name_='CurrentStatus', pretty_print=pretty_print)
        if self.PickupDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:PickupDate>%s</trk:PickupDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupDate), input_name='PickupDate')), eol_))
        for ServiceCenter_ in self.ServiceCenter:
            ServiceCenter_.export(outfile, level, namespace_, name_='ServiceCenter', pretty_print=pretty_print)
        if self.DeliveryDateUnavailable is not None:
            self.DeliveryDateUnavailable.export(outfile, level, namespace_, name_='DeliveryDateUnavailable', pretty_print=pretty_print)
        for DeliveryDetail_ in self.DeliveryDetail:
            DeliveryDetail_.export(outfile, level, namespace_, name_='DeliveryDetail', pretty_print=pretty_print)
        if self.Volume is not None:
            self.Volume.export(outfile, level, namespace_, name_='Volume', pretty_print=pretty_print)
        if self.BillToName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:BillToName>%s</trk:BillToName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BillToName), input_name='BillToName')), eol_))
        for NumberOfPackagingUnit_ in self.NumberOfPackagingUnit:
            NumberOfPackagingUnit_.export(outfile, level, namespace_, name_='NumberOfPackagingUnit', pretty_print=pretty_print)
        if self.COD is not None:
            self.COD.export(outfile, level, namespace_, name_='COD', pretty_print=pretty_print)
        if self.SignedForByName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:SignedForByName>%s</trk:SignedForByName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SignedForByName), input_name='SignedForByName')), eol_))
        for Activity_ in self.Activity:
            Activity_.export(outfile, level, namespace_, name_='Activity', pretty_print=pretty_print)
        if self.OriginPortDetail is not None:
            self.OriginPortDetail.export(outfile, level, namespace_, name_='OriginPortDetail', pretty_print=pretty_print)
        if self.DestinationPortDetail is not None:
            self.DestinationPortDetail.export(outfile, level, namespace_, name_='DestinationPortDetail', pretty_print=pretty_print)
        if self.DescriptionOfGoods is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:DescriptionOfGoods>%s</trk:DescriptionOfGoods>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DescriptionOfGoods), input_name='DescriptionOfGoods')), eol_))
        if self.CargoReady is not None:
            self.CargoReady.export(outfile, level, namespace_, name_='CargoReady', pretty_print=pretty_print)
        if self.Manifest is not None:
            self.Manifest.export(outfile, level, namespace_, name_='Manifest', pretty_print=pretty_print)
        for CarrierActivityInformation_ in self.CarrierActivityInformation:
            CarrierActivityInformation_.export(outfile, level, namespace_, name_='CarrierActivityInformation', pretty_print=pretty_print)
        for Document_ in self.Document:
            Document_.export(outfile, level, namespace_, name_='Document', pretty_print=pretty_print)
        if self.FileNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:FileNumber>%s</trk:FileNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FileNumber), input_name='FileNumber')), eol_))
        if self.Appointment is not None:
            self.Appointment.export(outfile, level, namespace_, name_='Appointment', pretty_print=pretty_print)
        for Package_ in self.Package:
            Package_.export(outfile, level, namespace_, name_='Package', pretty_print=pretty_print)
        for AdditionalAttribute_ in self.AdditionalAttribute:
            AdditionalAttribute_.export(outfile, level, namespace_, name_='AdditionalAttribute', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InquiryNumber':
            obj_ = CodeDescriptionValueType.factory()
            obj_.build(child_)
            self.InquiryNumber = obj_
            obj_.original_tagname_ = 'InquiryNumber'
        elif nodeName_ == 'ShipmentType':
            obj_ = RefShipmentType.factory()
            obj_.build(child_)
            self.ShipmentType = obj_
            obj_.original_tagname_ = 'ShipmentType'
        elif nodeName_ == 'CandidateBookmark':
            CandidateBookmark_ = child_.text
            CandidateBookmark_ = self.gds_validate_string(CandidateBookmark_, node, 'CandidateBookmark')
            self.CandidateBookmark = CandidateBookmark_
        elif nodeName_ == 'ShipperNumber':
            ShipperNumber_ = child_.text
            ShipperNumber_ = self.gds_validate_string(ShipperNumber_, node, 'ShipperNumber')
            self.ShipperNumber = ShipperNumber_
        elif nodeName_ == 'ShipmentAddress':
            obj_ = ShipmentAddressType.factory()
            obj_.build(child_)
            self.ShipmentAddress.append(obj_)
            obj_.original_tagname_ = 'ShipmentAddress'
        elif nodeName_ == 'ShipmentWeight':
            obj_ = WeightType.factory()
            obj_.build(child_)
            self.ShipmentWeight = obj_
            obj_.original_tagname_ = 'ShipmentWeight'
        elif nodeName_ == 'Service':
            obj_ = ServiceType.factory()
            obj_.build(child_)
            self.Service = obj_
            obj_.original_tagname_ = 'Service'
        elif nodeName_ == 'ReferenceNumber':
            obj_ = ShipmentReferenceNumberType.factory()
            obj_.build(child_)
            self.ReferenceNumber.append(obj_)
            obj_.original_tagname_ = 'ReferenceNumber'
        elif nodeName_ == 'CurrentStatus':
            obj_ = CommonCodeDescriptionType.factory()
            obj_.build(child_)
            self.CurrentStatus = obj_
            obj_.original_tagname_ = 'CurrentStatus'
        elif nodeName_ == 'PickupDate':
            PickupDate_ = child_.text
            PickupDate_ = self.gds_validate_string(PickupDate_, node, 'PickupDate')
            self.PickupDate = PickupDate_
        elif nodeName_ == 'ServiceCenter':
            obj_ = ServiceCenterType.factory()
            obj_.build(child_)
            self.ServiceCenter.append(obj_)
            obj_.original_tagname_ = 'ServiceCenter'
        elif nodeName_ == 'DeliveryDateUnavailable':
            obj_ = DeliveryDateUnavailableType.factory()
            obj_.build(child_)
            self.DeliveryDateUnavailable = obj_
            obj_.original_tagname_ = 'DeliveryDateUnavailable'
        elif nodeName_ == 'DeliveryDetail':
            obj_ = DeliveryDetailType.factory()
            obj_.build(child_)
            self.DeliveryDetail.append(obj_)
            obj_.original_tagname_ = 'DeliveryDetail'
        elif nodeName_ == 'Volume':
            obj_ = VolumeType.factory()
            obj_.build(child_)
            self.Volume = obj_
            obj_.original_tagname_ = 'Volume'
        elif nodeName_ == 'BillToName':
            BillToName_ = child_.text
            BillToName_ = self.gds_validate_string(BillToName_, node, 'BillToName')
            self.BillToName = BillToName_
        elif nodeName_ == 'NumberOfPackagingUnit':
            obj_ = NumberOfPackagingUnitType.factory()
            obj_.build(child_)
            self.NumberOfPackagingUnit.append(obj_)
            obj_.original_tagname_ = 'NumberOfPackagingUnit'
        elif nodeName_ == 'COD':
            obj_ = CODType.factory()
            obj_.build(child_)
            self.COD = obj_
            obj_.original_tagname_ = 'COD'
        elif nodeName_ == 'SignedForByName':
            SignedForByName_ = child_.text
            SignedForByName_ = self.gds_validate_string(SignedForByName_, node, 'SignedForByName')
            self.SignedForByName = SignedForByName_
        elif nodeName_ == 'Activity':
            obj_ = ShipmentActivityType.factory()
            obj_.build(child_)
            self.Activity.append(obj_)
            obj_.original_tagname_ = 'Activity'
        elif nodeName_ == 'OriginPortDetail':
            obj_ = OriginPortDetailType.factory()
            obj_.build(child_)
            self.OriginPortDetail = obj_
            obj_.original_tagname_ = 'OriginPortDetail'
        elif nodeName_ == 'DestinationPortDetail':
            obj_ = DestinationPortDetailType.factory()
            obj_.build(child_)
            self.DestinationPortDetail = obj_
            obj_.original_tagname_ = 'DestinationPortDetail'
        elif nodeName_ == 'DescriptionOfGoods':
            DescriptionOfGoods_ = child_.text
            DescriptionOfGoods_ = self.gds_validate_string(DescriptionOfGoods_, node, 'DescriptionOfGoods')
            self.DescriptionOfGoods = DescriptionOfGoods_
        elif nodeName_ == 'CargoReady':
            obj_ = DateTimeType.factory()
            obj_.build(child_)
            self.CargoReady = obj_
            obj_.original_tagname_ = 'CargoReady'
        elif nodeName_ == 'Manifest':
            obj_ = DateTimeType.factory()
            obj_.build(child_)
            self.Manifest = obj_
            obj_.original_tagname_ = 'Manifest'
        elif nodeName_ == 'CarrierActivityInformation':
            obj_ = CarrierActivityInformationType.factory()
            obj_.build(child_)
            self.CarrierActivityInformation.append(obj_)
            obj_.original_tagname_ = 'CarrierActivityInformation'
        elif nodeName_ == 'Document':
            obj_ = DocumentType.factory()
            obj_.build(child_)
            self.Document.append(obj_)
            obj_.original_tagname_ = 'Document'
        elif nodeName_ == 'FileNumber':
            FileNumber_ = child_.text
            FileNumber_ = self.gds_validate_string(FileNumber_, node, 'FileNumber')
            self.FileNumber = FileNumber_
        elif nodeName_ == 'Appointment':
            obj_ = AppointmentType.factory()
            obj_.build(child_)
            self.Appointment = obj_
            obj_.original_tagname_ = 'Appointment'
        elif nodeName_ == 'Package':
            obj_ = PackageType.factory()
            obj_.build(child_)
            self.Package.append(obj_)
            obj_.original_tagname_ = 'Package'
        elif nodeName_ == 'AdditionalAttribute':
            obj_ = AdditionalCodeDescriptionValueType.factory()
            obj_.build(child_)
            self.AdditionalAttribute.append(obj_)
            obj_.original_tagname_ = 'AdditionalAttribute'
# end class ShipmentType


class ShipmentAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Address=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Address = Address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentAddressType.subclass:
            return ShipmentAddressType.subclass(*args_, **kwargs_)
        else:
            return ShipmentAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ShipmentAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ShipmentAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ShipmentAddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ShipmentAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = CommonCodeDescriptionType.factory()
            obj_.build(child_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
# end class ShipmentAddressType


class AppointmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Made=None, Requested=None, BeginTime=None, EndTime=None):
        self.original_tagname_ = None
        self.Made = Made
        self.Requested = Requested
        self.BeginTime = BeginTime
        self.EndTime = EndTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AppointmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AppointmentType.subclass:
            return AppointmentType.subclass(*args_, **kwargs_)
        else:
            return AppointmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Made(self): return self.Made
    def set_Made(self, Made): self.Made = Made
    def get_Requested(self): return self.Requested
    def set_Requested(self, Requested): self.Requested = Requested
    def get_BeginTime(self): return self.BeginTime
    def set_BeginTime(self, BeginTime): self.BeginTime = BeginTime
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    def hasContent_(self):
        if (
            self.Made is not None or
            self.Requested is not None or
            self.BeginTime is not None or
            self.EndTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='AppointmentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AppointmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AppointmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='AppointmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='AppointmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='AppointmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Made is not None:
            self.Made.export(outfile, level, namespace_, name_='Made', pretty_print=pretty_print)
        if self.Requested is not None:
            self.Requested.export(outfile, level, namespace_, name_='Requested', pretty_print=pretty_print)
        if self.BeginTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:BeginTime>%s</trk:BeginTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BeginTime), input_name='BeginTime')), eol_))
        if self.EndTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:EndTime>%s</trk:EndTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EndTime), input_name='EndTime')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Made':
            obj_ = DateTimeType.factory()
            obj_.build(child_)
            self.Made = obj_
            obj_.original_tagname_ = 'Made'
        elif nodeName_ == 'Requested':
            obj_ = DateTimeType.factory()
            obj_.build(child_)
            self.Requested = obj_
            obj_.original_tagname_ = 'Requested'
        elif nodeName_ == 'BeginTime':
            BeginTime_ = child_.text
            BeginTime_ = self.gds_validate_string(BeginTime_, node, 'BeginTime')
            self.BeginTime = BeginTime_
        elif nodeName_ == 'EndTime':
            EndTime_ = child_.text
            EndTime_ = self.gds_validate_string(EndTime_, node, 'EndTime')
            self.EndTime = EndTime_
# end class AppointmentType


class CodeDescriptionValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None, Value=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeDescriptionValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeDescriptionValueType.subclass:
            return CodeDescriptionValueType.subclass(*args_, **kwargs_)
        else:
            return CodeDescriptionValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='CodeDescriptionValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CodeDescriptionValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeDescriptionValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='CodeDescriptionValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='CodeDescriptionValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='CodeDescriptionValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Value>%s</trk:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class CodeDescriptionValueType


class AdditionalCodeDescriptionValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None, Value=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalCodeDescriptionValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalCodeDescriptionValueType.subclass:
            return AdditionalCodeDescriptionValueType.subclass(*args_, **kwargs_)
        else:
            return AdditionalCodeDescriptionValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='AdditionalCodeDescriptionValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalCodeDescriptionValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalCodeDescriptionValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='AdditionalCodeDescriptionValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='AdditionalCodeDescriptionValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='AdditionalCodeDescriptionValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Value>%s</trk:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class AdditionalCodeDescriptionValueType


class SignatureImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GraphicImage=None, ImageFormat=None):
        self.original_tagname_ = None
        self.GraphicImage = GraphicImage
        self.ImageFormat = ImageFormat
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureImageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureImageType.subclass:
            return SignatureImageType.subclass(*args_, **kwargs_)
        else:
            return SignatureImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GraphicImage(self): return self.GraphicImage
    def set_GraphicImage(self, GraphicImage): self.GraphicImage = GraphicImage
    def get_ImageFormat(self): return self.ImageFormat
    def set_ImageFormat(self, ImageFormat): self.ImageFormat = ImageFormat
    def hasContent_(self):
        if (
            self.GraphicImage is not None or
            self.ImageFormat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='SignatureImageType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureImageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignatureImageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='SignatureImageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='SignatureImageType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='SignatureImageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GraphicImage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:GraphicImage>%s</trk:GraphicImage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GraphicImage), input_name='GraphicImage')), eol_))
        if self.ImageFormat is not None:
            self.ImageFormat.export(outfile, level, namespace_, name_='ImageFormat', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GraphicImage':
            GraphicImage_ = child_.text
            GraphicImage_ = self.gds_validate_string(GraphicImage_, node, 'GraphicImage')
            self.GraphicImage = GraphicImage_
        elif nodeName_ == 'ImageFormat':
            obj_ = ImageFormatType.factory()
            obj_.build(child_)
            self.ImageFormat = obj_
            obj_.original_tagname_ = 'ImageFormat'
# end class SignatureImageType


class StatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Description=None, Code=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Description = Description
        self.Code = Code
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatusType.subclass:
            return StatusType.subclass(*args_, **kwargs_)
        else:
            return StatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Description is not None or
            self.Code is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='StatusType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='StatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='StatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='StatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Type>%s</trk:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
# end class StatusType


class UnitOfMeasurementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitOfMeasurementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitOfMeasurementType.subclass:
            return UnitOfMeasurementType.subclass(*args_, **kwargs_)
        else:
            return UnitOfMeasurementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='UnitOfMeasurementType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitOfMeasurementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitOfMeasurementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='UnitOfMeasurementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='UnitOfMeasurementType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='UnitOfMeasurementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Code>%s</trk:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class UnitOfMeasurementType


class VolumeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UnitOfMeasurement=None, Value=None):
        self.original_tagname_ = None
        self.UnitOfMeasurement = UnitOfMeasurement
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeType.subclass:
            return VolumeType.subclass(*args_, **kwargs_)
        else:
            return VolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitOfMeasurement(self): return self.UnitOfMeasurement
    def set_UnitOfMeasurement(self, UnitOfMeasurement): self.UnitOfMeasurement = UnitOfMeasurement
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.UnitOfMeasurement is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='VolumeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VolumeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VolumeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='VolumeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='VolumeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='VolumeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UnitOfMeasurement is not None:
            self.UnitOfMeasurement.export(outfile, level, namespace_, name_='UnitOfMeasurement', pretty_print=pretty_print)
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Value>%s</trk:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitOfMeasurement':
            obj_ = UnitOfMeasurementType.factory()
            obj_.build(child_)
            self.UnitOfMeasurement = obj_
            obj_.original_tagname_ = 'UnitOfMeasurement'
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class VolumeType


class WeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UnitOfMeasurement=None, Weight=None):
        self.original_tagname_ = None
        self.UnitOfMeasurement = UnitOfMeasurement
        self.Weight = Weight
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightType.subclass:
            return WeightType.subclass(*args_, **kwargs_)
        else:
            return WeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitOfMeasurement(self): return self.UnitOfMeasurement
    def set_UnitOfMeasurement(self, UnitOfMeasurement): self.UnitOfMeasurement = UnitOfMeasurement
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def hasContent_(self):
        if (
            self.UnitOfMeasurement is not None or
            self.Weight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='WeightType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='WeightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='WeightType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='WeightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UnitOfMeasurement is not None:
            self.UnitOfMeasurement.export(outfile, level, namespace_, name_='UnitOfMeasurement', pretty_print=pretty_print)
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Weight>%s</trk:Weight>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Weight), input_name='Weight')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitOfMeasurement':
            obj_ = UnitOfMeasurementType.factory()
            obj_.build(child_)
            self.UnitOfMeasurement = obj_
            obj_.original_tagname_ = 'UnitOfMeasurement'
        elif nodeName_ == 'Weight':
            Weight_ = child_.text
            Weight_ = self.gds_validate_string(Weight_, node, 'Weight')
            self.Weight = Weight_
# end class WeightType


class DateTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Date=None, Time=None):
        self.original_tagname_ = None
        self.Date = Date
        self.Time = Time
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTimeType.subclass:
            return DateTimeType.subclass(*args_, **kwargs_)
        else:
            return DateTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def hasContent_(self):
        if (
            self.Date is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='DateTimeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='DateTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='DateTimeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='DateTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Date>%s</trk:Date>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Date), input_name='Date')), eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Time>%s</trk:Time>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Time), input_name='Time')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
# end class DateTimeType


class ServiceCenterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Address=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Address = Address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceCenterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceCenterType.subclass:
            return ServiceCenterType.subclass(*args_, **kwargs_)
        else:
            return ServiceCenterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ServiceCenterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceCenterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceCenterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ServiceCenterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ServiceCenterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ServiceCenterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = CommonCodeDescriptionType.factory()
            obj_.build(child_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
# end class ServiceCenterType


class ServiceOptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceOptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceOptionType.subclass:
            return ServiceOptionType.subclass(*args_, **kwargs_)
        else:
            return ServiceOptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ServiceOptionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceOptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceOptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ServiceOptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ServiceOptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ServiceOptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Value>%s</trk:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = CommonCodeDescriptionType.factory()
            obj_.build(child_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ServiceOptionType


class DocumentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Content=None, Format=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Content = Content
        self.Format = Format
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentType.subclass:
            return DocumentType.subclass(*args_, **kwargs_)
        else:
            return DocumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Content(self): return self.Content
    def set_Content(self, Content): self.Content = Content
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Content is not None or
            self.Format is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='DocumentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='DocumentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='DocumentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='DocumentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            self.Type.export(outfile, level, namespace_, name_='Type', pretty_print=pretty_print)
        if self.Content is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Content>%s</trk:Content>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Content), input_name='Content')), eol_))
        if self.Format is not None:
            self.Format.export(outfile, level, namespace_, name_='Format', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            obj_ = CommonCodeDescriptionType.factory()
            obj_.build(child_)
            self.Type = obj_
            obj_.original_tagname_ = 'Type'
        elif nodeName_ == 'Content':
            Content_ = child_.text
            Content_ = self.gds_validate_string(Content_, node, 'Content')
            self.Content = Content_
        elif nodeName_ == 'Format':
            obj_ = CommonCodeDescriptionType.factory()
            obj_.build(child_)
            self.Format = obj_
            obj_.original_tagname_ = 'Format'
# end class DocumentType


class ShipmentActivityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ActivityLocation=None, Description=None, Date=None, Time=None, Trailer=None):
        self.original_tagname_ = None
        self.ActivityLocation = ActivityLocation
        self.Description = Description
        self.Date = Date
        self.Time = Time
        self.Trailer = Trailer
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentActivityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentActivityType.subclass:
            return ShipmentActivityType.subclass(*args_, **kwargs_)
        else:
            return ShipmentActivityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActivityLocation(self): return self.ActivityLocation
    def set_ActivityLocation(self, ActivityLocation): self.ActivityLocation = ActivityLocation
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Trailer(self): return self.Trailer
    def set_Trailer(self, Trailer): self.Trailer = Trailer
    def hasContent_(self):
        if (
            self.ActivityLocation is not None or
            self.Description is not None or
            self.Date is not None or
            self.Time is not None or
            self.Trailer is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ShipmentActivityType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentActivityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentActivityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ShipmentActivityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ShipmentActivityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ShipmentActivityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActivityLocation is not None:
            self.ActivityLocation.export(outfile, level, namespace_, name_='ActivityLocation', pretty_print=pretty_print)
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Date>%s</trk:Date>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Date), input_name='Date')), eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Time>%s</trk:Time>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Time), input_name='Time')), eol_))
        if self.Trailer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Trailer>%s</trk:Trailer>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Trailer), input_name='Trailer')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActivityLocation':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.ActivityLocation = obj_
            obj_.original_tagname_ = 'ActivityLocation'
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
        elif nodeName_ == 'Trailer':
            Trailer_ = child_.text
            Trailer_ = self.gds_validate_string(Trailer_, node, 'Trailer')
            self.Trailer = Trailer_
# end class ShipmentActivityType


class OriginPortDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OriginPort=None, EstimatedDeparture=None):
        self.original_tagname_ = None
        self.OriginPort = OriginPort
        self.EstimatedDeparture = EstimatedDeparture
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OriginPortDetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OriginPortDetailType.subclass:
            return OriginPortDetailType.subclass(*args_, **kwargs_)
        else:
            return OriginPortDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OriginPort(self): return self.OriginPort
    def set_OriginPort(self, OriginPort): self.OriginPort = OriginPort
    def get_EstimatedDeparture(self): return self.EstimatedDeparture
    def set_EstimatedDeparture(self, EstimatedDeparture): self.EstimatedDeparture = EstimatedDeparture
    def hasContent_(self):
        if (
            self.OriginPort is not None or
            self.EstimatedDeparture is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='OriginPortDetailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OriginPortDetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OriginPortDetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='OriginPortDetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='OriginPortDetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='OriginPortDetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OriginPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:OriginPort>%s</trk:OriginPort>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginPort), input_name='OriginPort')), eol_))
        if self.EstimatedDeparture is not None:
            self.EstimatedDeparture.export(outfile, level, namespace_, name_='EstimatedDeparture', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OriginPort':
            OriginPort_ = child_.text
            OriginPort_ = self.gds_validate_string(OriginPort_, node, 'OriginPort')
            self.OriginPort = OriginPort_
        elif nodeName_ == 'EstimatedDeparture':
            obj_ = DateTimeType.factory()
            obj_.build(child_)
            self.EstimatedDeparture = obj_
            obj_.original_tagname_ = 'EstimatedDeparture'
# end class OriginPortDetailType


class DestinationPortDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DestinationPort=None, EstimatedArrival=None):
        self.original_tagname_ = None
        self.DestinationPort = DestinationPort
        self.EstimatedArrival = EstimatedArrival
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DestinationPortDetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DestinationPortDetailType.subclass:
            return DestinationPortDetailType.subclass(*args_, **kwargs_)
        else:
            return DestinationPortDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DestinationPort(self): return self.DestinationPort
    def set_DestinationPort(self, DestinationPort): self.DestinationPort = DestinationPort
    def get_EstimatedArrival(self): return self.EstimatedArrival
    def set_EstimatedArrival(self, EstimatedArrival): self.EstimatedArrival = EstimatedArrival
    def hasContent_(self):
        if (
            self.DestinationPort is not None or
            self.EstimatedArrival is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='DestinationPortDetailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DestinationPortDetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestinationPortDetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='DestinationPortDetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='DestinationPortDetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='DestinationPortDetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DestinationPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:DestinationPort>%s</trk:DestinationPort>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationPort), input_name='DestinationPort')), eol_))
        if self.EstimatedArrival is not None:
            self.EstimatedArrival.export(outfile, level, namespace_, name_='EstimatedArrival', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DestinationPort':
            DestinationPort_ = child_.text
            DestinationPort_ = self.gds_validate_string(DestinationPort_, node, 'DestinationPort')
            self.DestinationPort = DestinationPort_
        elif nodeName_ == 'EstimatedArrival':
            obj_ = DateTimeType.factory()
            obj_.build(child_)
            self.EstimatedArrival = obj_
            obj_.original_tagname_ = 'EstimatedArrival'
# end class DestinationPortDetailType


class CarrierActivityInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CarrierId=None, Description=None, Status=None, Arrival=None, Departure=None, OriginPort=None, DestinationPort=None):
        self.original_tagname_ = None
        self.CarrierId = CarrierId
        self.Description = Description
        self.Status = Status
        self.Arrival = Arrival
        self.Departure = Departure
        self.OriginPort = OriginPort
        self.DestinationPort = DestinationPort
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CarrierActivityInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CarrierActivityInformationType.subclass:
            return CarrierActivityInformationType.subclass(*args_, **kwargs_)
        else:
            return CarrierActivityInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CarrierId(self): return self.CarrierId
    def set_CarrierId(self, CarrierId): self.CarrierId = CarrierId
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Arrival(self): return self.Arrival
    def set_Arrival(self, Arrival): self.Arrival = Arrival
    def get_Departure(self): return self.Departure
    def set_Departure(self, Departure): self.Departure = Departure
    def get_OriginPort(self): return self.OriginPort
    def set_OriginPort(self, OriginPort): self.OriginPort = OriginPort
    def get_DestinationPort(self): return self.DestinationPort
    def set_DestinationPort(self, DestinationPort): self.DestinationPort = DestinationPort
    def hasContent_(self):
        if (
            self.CarrierId is not None or
            self.Description is not None or
            self.Status is not None or
            self.Arrival is not None or
            self.Departure is not None or
            self.OriginPort is not None or
            self.DestinationPort is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='CarrierActivityInformationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CarrierActivityInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CarrierActivityInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='CarrierActivityInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='CarrierActivityInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='CarrierActivityInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CarrierId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CarrierId>%s</trk:CarrierId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CarrierId), input_name='CarrierId')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Description>%s</trk:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Status>%s</trk:Status>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Status), input_name='Status')), eol_))
        if self.Arrival is not None:
            self.Arrival.export(outfile, level, namespace_, name_='Arrival', pretty_print=pretty_print)
        if self.Departure is not None:
            self.Departure.export(outfile, level, namespace_, name_='Departure', pretty_print=pretty_print)
        if self.OriginPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:OriginPort>%s</trk:OriginPort>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginPort), input_name='OriginPort')), eol_))
        if self.DestinationPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:DestinationPort>%s</trk:DestinationPort>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationPort), input_name='DestinationPort')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CarrierId':
            CarrierId_ = child_.text
            CarrierId_ = self.gds_validate_string(CarrierId_, node, 'CarrierId')
            self.CarrierId = CarrierId_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Status':
            Status_ = child_.text
            Status_ = self.gds_validate_string(Status_, node, 'Status')
            self.Status = Status_
        elif nodeName_ == 'Arrival':
            obj_ = DateTimeType.factory()
            obj_.build(child_)
            self.Arrival = obj_
            obj_.original_tagname_ = 'Arrival'
        elif nodeName_ == 'Departure':
            obj_ = DateTimeType.factory()
            obj_.build(child_)
            self.Departure = obj_
            obj_.original_tagname_ = 'Departure'
        elif nodeName_ == 'OriginPort':
            OriginPort_ = child_.text
            OriginPort_ = self.gds_validate_string(OriginPort_, node, 'OriginPort')
            self.OriginPort = OriginPort_
        elif nodeName_ == 'DestinationPort':
            DestinationPort_ = child_.text
            DestinationPort_ = self.gds_validate_string(DestinationPort_, node, 'DestinationPort')
            self.DestinationPort = DestinationPort_
# end class CarrierActivityInformationType


class ShipperAccountInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PostalCode=None, CountryCode=None):
        self.original_tagname_ = None
        self.PostalCode = PostalCode
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipperAccountInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipperAccountInfoType.subclass:
            return ShipperAccountInfoType.subclass(*args_, **kwargs_)
        else:
            return ShipperAccountInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.PostalCode is not None or
            self.CountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='ShipperAccountInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipperAccountInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipperAccountInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='ShipperAccountInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='ShipperAccountInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='ShipperAccountInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:PostalCode>%s</trk:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:CountryCode>%s</trk:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class ShipperAccountInfoType


class AlternateTrackingInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None):
        self.original_tagname_ = None
        self.Type = Type
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AlternateTrackingInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AlternateTrackingInfoType.subclass:
            return AlternateTrackingInfoType.subclass(*args_, **kwargs_)
        else:
            return AlternateTrackingInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='AlternateTrackingInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AlternateTrackingInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlternateTrackingInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='AlternateTrackingInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='AlternateTrackingInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='trk:', name_='AlternateTrackingInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Type>%s</trk:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<trk:Value>%s</trk:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class AlternateTrackingInfoType


class ClientInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        self.original_tagname_ = None
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClientInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClientInformationType.subclass:
            return ClientInformationType.subclass(*args_, **kwargs_)
        else:
            return ClientInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property_at(self, index, value): self.Property.insert(index, value)
    def replace_Property_at(self, index, value): self.Property[index] = value
    def hasContent_(self):
        if (
            self.Property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ClientInformationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClientInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClientInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ClientInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ClientInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ClientInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
# end class ClientInformationType


class RequestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RequestOption=None, SubVersion=None, TransactionReference=None):
        self.original_tagname_ = None
        if RequestOption is None:
            self.RequestOption = []
        else:
            self.RequestOption = RequestOption
        self.SubVersion = SubVersion
        self.TransactionReference = TransactionReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestType.subclass:
            return RequestType.subclass(*args_, **kwargs_)
        else:
            return RequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RequestOption(self): return self.RequestOption
    def set_RequestOption(self, RequestOption): self.RequestOption = RequestOption
    def add_RequestOption(self, value): self.RequestOption.append(value)
    def insert_RequestOption_at(self, index, value): self.RequestOption.insert(index, value)
    def replace_RequestOption_at(self, index, value): self.RequestOption[index] = value
    def get_SubVersion(self): return self.SubVersion
    def set_SubVersion(self, SubVersion): self.SubVersion = SubVersion
    def get_TransactionReference(self): return self.TransactionReference
    def set_TransactionReference(self, TransactionReference): self.TransactionReference = TransactionReference
    def hasContent_(self):
        if (
            self.RequestOption or
            self.SubVersion is not None or
            self.TransactionReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='RequestType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='RequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='RequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='RequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RequestOption_ in self.RequestOption:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:RequestOption>%s</common:RequestOption>%s' % (self.gds_encode(self.gds_format_string(quote_xml(RequestOption_), input_name='RequestOption')), eol_))
        if self.SubVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:SubVersion>%s</common:SubVersion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SubVersion), input_name='SubVersion')), eol_))
        if self.TransactionReference is not None:
            self.TransactionReference.export(outfile, level, namespace_, name_='TransactionReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RequestOption':
            RequestOption_ = child_.text
            RequestOption_ = self.gds_validate_string(RequestOption_, node, 'RequestOption')
            self.RequestOption.append(RequestOption_)
        elif nodeName_ == 'SubVersion':
            SubVersion_ = child_.text
            SubVersion_ = self.gds_validate_string(SubVersion_, node, 'SubVersion')
            self.SubVersion = SubVersion_
        elif nodeName_ == 'TransactionReference':
            obj_ = TransactionReferenceType.factory()
            obj_.build(child_)
            self.TransactionReference = obj_
            obj_.original_tagname_ = 'TransactionReference'
# end class RequestType


class TransactionReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomerContext=None, TransactionIdentifier=None):
        self.original_tagname_ = None
        self.CustomerContext = CustomerContext
        self.TransactionIdentifier = TransactionIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransactionReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransactionReferenceType.subclass:
            return TransactionReferenceType.subclass(*args_, **kwargs_)
        else:
            return TransactionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerContext(self): return self.CustomerContext
    def set_CustomerContext(self, CustomerContext): self.CustomerContext = CustomerContext
    def get_TransactionIdentifier(self): return self.TransactionIdentifier
    def set_TransactionIdentifier(self, TransactionIdentifier): self.TransactionIdentifier = TransactionIdentifier
    def hasContent_(self):
        if (
            self.CustomerContext is not None or
            self.TransactionIdentifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='TransactionReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransactionReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransactionReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='TransactionReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='TransactionReferenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='TransactionReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerContext is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:CustomerContext>%s</common:CustomerContext>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerContext), input_name='CustomerContext')), eol_))
        if self.TransactionIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:TransactionIdentifier>%s</common:TransactionIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransactionIdentifier), input_name='TransactionIdentifier')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerContext':
            CustomerContext_ = child_.text
            CustomerContext_ = self.gds_validate_string(CustomerContext_, node, 'CustomerContext')
            self.CustomerContext = CustomerContext_
        elif nodeName_ == 'TransactionIdentifier':
            TransactionIdentifier_ = child_.text
            TransactionIdentifier_ = self.gds_validate_string(TransactionIdentifier_, node, 'TransactionIdentifier')
            self.TransactionIdentifier = TransactionIdentifier_
# end class TransactionReferenceType


class ResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ResponseStatus=None, Alert=None, AlertDetail=None, TransactionReference=None):
        self.original_tagname_ = None
        self.ResponseStatus = ResponseStatus
        if Alert is None:
            self.Alert = []
        else:
            self.Alert = Alert
        if AlertDetail is None:
            self.AlertDetail = []
        else:
            self.AlertDetail = AlertDetail
        self.TransactionReference = TransactionReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseType.subclass:
            return ResponseType.subclass(*args_, **kwargs_)
        else:
            return ResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResponseStatus(self): return self.ResponseStatus
    def set_ResponseStatus(self, ResponseStatus): self.ResponseStatus = ResponseStatus
    def get_Alert(self): return self.Alert
    def set_Alert(self, Alert): self.Alert = Alert
    def add_Alert(self, value): self.Alert.append(value)
    def insert_Alert_at(self, index, value): self.Alert.insert(index, value)
    def replace_Alert_at(self, index, value): self.Alert[index] = value
    def get_AlertDetail(self): return self.AlertDetail
    def set_AlertDetail(self, AlertDetail): self.AlertDetail = AlertDetail
    def add_AlertDetail(self, value): self.AlertDetail.append(value)
    def insert_AlertDetail_at(self, index, value): self.AlertDetail.insert(index, value)
    def replace_AlertDetail_at(self, index, value): self.AlertDetail[index] = value
    def get_TransactionReference(self): return self.TransactionReference
    def set_TransactionReference(self, TransactionReference): self.TransactionReference = TransactionReference
    def hasContent_(self):
        if (
            self.ResponseStatus is not None or
            self.Alert or
            self.AlertDetail or
            self.TransactionReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ResponseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ResponseStatus is not None:
            self.ResponseStatus.export(outfile, level, namespace_, name_='ResponseStatus', pretty_print=pretty_print)
        for Alert_ in self.Alert:
            Alert_.export(outfile, level, namespace_, name_='Alert', pretty_print=pretty_print)
        for AlertDetail_ in self.AlertDetail:
            AlertDetail_.export(outfile, level, namespace_, name_='AlertDetail', pretty_print=pretty_print)
        if self.TransactionReference is not None:
            self.TransactionReference.export(outfile, level, namespace_, name_='TransactionReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResponseStatus':
            obj_ = CodeDescriptionType.factory()
            obj_.build(child_)
            self.ResponseStatus = obj_
            obj_.original_tagname_ = 'ResponseStatus'
        elif nodeName_ == 'Alert':
            obj_ = CodeDescriptionType.factory()
            obj_.build(child_)
            self.Alert.append(obj_)
            obj_.original_tagname_ = 'Alert'
        elif nodeName_ == 'AlertDetail':
            obj_ = DetailType.factory()
            obj_.build(child_)
            self.AlertDetail.append(obj_)
            obj_.original_tagname_ = 'AlertDetail'
        elif nodeName_ == 'TransactionReference':
            obj_ = TransactionReferenceType.factory()
            obj_.build(child_)
            self.TransactionReference = obj_
            obj_.original_tagname_ = 'TransactionReference'
# end class ResponseType


class CodeDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeDescriptionType.subclass:
            return CodeDescriptionType.subclass(*args_, **kwargs_)
        else:
            return CodeDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='CodeDescriptionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CodeDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='CodeDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='CodeDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='CodeDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Code>%s</common:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Description>%s</common:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class CodeDescriptionType


class DetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None, ElementLevelInformation=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
        self.ElementLevelInformation = ElementLevelInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailType.subclass:
            return DetailType.subclass(*args_, **kwargs_)
        else:
            return DetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ElementLevelInformation(self): return self.ElementLevelInformation
    def set_ElementLevelInformation(self, ElementLevelInformation): self.ElementLevelInformation = ElementLevelInformation
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None or
            self.ElementLevelInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='DetailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='DetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='DetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='DetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Code>%s</common:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Description>%s</common:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.ElementLevelInformation is not None:
            self.ElementLevelInformation.export(outfile, level, namespace_, name_='ElementLevelInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'ElementLevelInformation':
            obj_ = ElementLevelInformationType.factory()
            obj_.build(child_)
            self.ElementLevelInformation = obj_
            obj_.original_tagname_ = 'ElementLevelInformation'
# end class DetailType


class ElementLevelInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Level=None, ElementIdentifier=None):
        self.original_tagname_ = None
        self.Level = Level
        if ElementIdentifier is None:
            self.ElementIdentifier = []
        else:
            self.ElementIdentifier = ElementIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementLevelInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementLevelInformationType.subclass:
            return ElementLevelInformationType.subclass(*args_, **kwargs_)
        else:
            return ElementLevelInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    def get_ElementIdentifier(self): return self.ElementIdentifier
    def set_ElementIdentifier(self, ElementIdentifier): self.ElementIdentifier = ElementIdentifier
    def add_ElementIdentifier(self, value): self.ElementIdentifier.append(value)
    def insert_ElementIdentifier_at(self, index, value): self.ElementIdentifier.insert(index, value)
    def replace_ElementIdentifier_at(self, index, value): self.ElementIdentifier[index] = value
    def hasContent_(self):
        if (
            self.Level is not None or
            self.ElementIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ElementLevelInformationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementLevelInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElementLevelInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ElementLevelInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ElementLevelInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ElementLevelInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Level>%s</common:Level>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Level), input_name='Level')), eol_))
        for ElementIdentifier_ in self.ElementIdentifier:
            ElementIdentifier_.export(outfile, level, namespace_, name_='ElementIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Level':
            Level_ = child_.text
            Level_ = self.gds_validate_string(Level_, node, 'Level')
            self.Level = Level_
        elif nodeName_ == 'ElementIdentifier':
            obj_ = ElementIdentifierType.factory()
            obj_.build(child_)
            self.ElementIdentifier.append(obj_)
            obj_.original_tagname_ = 'ElementIdentifier'
# end class ElementLevelInformationType


class ElementIdentifierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Value=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementIdentifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementIdentifierType.subclass:
            return ElementIdentifierType.subclass(*args_, **kwargs_)
        else:
            return ElementIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ElementIdentifierType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementIdentifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElementIdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ElementIdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ElementIdentifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ElementIdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Code>%s</common:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Value>%s</common:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ElementIdentifierType


class PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Key=None, valueOf_=None):
        self.original_tagname_ = None
        self.Key = _cast(None, Key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PropertyType.subclass:
            return PropertyType.subclass(*args_, **kwargs_)
        else:
            return PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='trk:', name_='PropertyType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PropertyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='trk:', name_='PropertyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='trk:', name_='PropertyType'):
        if self.Key is not None and 'Key' not in already_processed:
            already_processed.add('Key')
            outfile.write(' Key=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Key), input_name='Key')), ))
    def exportChildren(self, outfile, level, namespace_='trk:', name_='PropertyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Key', node)
        if value is not None and 'Key' not in already_processed:
            already_processed.add('Key')
            self.Key = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PropertyType


GDSClassesMapping = {
    'ClientInformation': ClientInformationType,
    'Request': RequestType,
    'Response': ResponseType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TrackRequest'
        rootClass = TrackRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:trk="http://www.ups.com/XMLSchema/XOLTWS/Track/v2.0"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TrackRequest'
        rootClass = TrackRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TrackRequest'
        rootClass = TrackRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:trk="http://www.ups.com/XMLSchema/XOLTWS/Track/v2.0"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TrackRequest'
        rootClass = TrackRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from package_track import *\n\n')
        sys.stdout.write('import package_track as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ActivityLocationType",
    "ActivityType",
    "AdditionalCodeDescriptionValueType",
    "AddressRequestType",
    "AddressType",
    "AlternateTrackingInfoType",
    "AmountType",
    "AppointmentType",
    "CODStatusType",
    "CODType",
    "CarrierActivityInformationType",
    "ClientInformationType",
    "CodeDescriptionType",
    "CodeDescriptionValueType",
    "CommonCodeDescriptionType",
    "DateTimeType",
    "DeliveryDateUnavailableType",
    "DeliveryDetailType",
    "DestinationPortDetailType",
    "DetailType",
    "DocumentType",
    "ElementIdentifierType",
    "ElementLevelInformationType",
    "ImageFormatType",
    "MessageType",
    "NextScheduleActivityType",
    "NumberOfPackagingUnitType",
    "OriginPortDetailType",
    "PODLetterType",
    "PackageAddressType",
    "PackageType",
    "PickupDateRangeType",
    "ProductCodeDescriptionType",
    "PropertyType",
    "RedirectType",
    "RefShipmentType",
    "ReferenceNumberType",
    "RequestTransactionReferenceType",
    "RequestType",
    "ResponseTransactionReferenceType",
    "ResponseType",
    "ServiceCenterType",
    "ServiceOptionType",
    "ServiceType",
    "ShipFromRequestType",
    "ShipToRequestType",
    "ShipmentActivityType",
    "ShipmentAddressType",
    "ShipmentReferenceNumberType",
    "ShipmentType",
    "ShipperAccountInfoType",
    "SignatureImageType",
    "StatusType",
    "TrackRequest",
    "TrackResponse",
    "TransactionReferenceType",
    "TransportFacilityType",
    "UnitOfMeasurementType",
    "VolumeType",
    "WeightType"
]
