#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Jun 12 20:14:55 2018 by generateDS.py version 2.29.14.
# Python 3.6.5 (default, May 19 2018, 11:27:13)  [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('-o', 'pyups/package_pickup.py')
#
# Command line arguments:
#    /UPS/Pickup_Pkg_Gnd/PickupforPACKAGEWebService/SCHEMAS-WSDLs/PickupWebServiceSchema.xsd
#
# Command line:
#    generateDS --no-namespace-defs -o "pyups/package_pickup.py"  /UPS/Pickup_Pkg_Gnd/PickupforPACKAGEWebService/SCHEMAS-WSDLs/PickupWebServiceSchema.xsd
#
# Current working directory (os.getcwd()):
#   py_ups
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class PickupGetPoliticalDivision1ListRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Request=None, CountryCode=None):
        self.original_tagname_ = None
        self.Request = Request
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupGetPoliticalDivision1ListRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupGetPoliticalDivision1ListRequest.subclass:
            return PickupGetPoliticalDivision1ListRequest.subclass(*args_, **kwargs_)
        else:
            return PickupGetPoliticalDivision1ListRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.Request is not None or
            self.CountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupGetPoliticalDivision1ListRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupGetPoliticalDivision1ListRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupGetPoliticalDivision1ListRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupGetPoliticalDivision1ListRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupGetPoliticalDivision1ListRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupGetPoliticalDivision1ListRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_='common:', name_='Request', pretty_print=pretty_print)
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CountryCode>%s</pkup:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = RequestType.factory()
            obj_.build(child_)
            self.Request = obj_
            obj_.original_tagname_ = 'Request'
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class PickupGetPoliticalDivision1ListRequest


class PickupCreationRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Request=None, RatePickupIndicator='N', TaxInformationIndicator='N', UserLevelDiscountIndicator='N', Shipper=None, PickupDateInfo=None, PickupAddress=None, AlternateAddressIndicator='N', PickupPiece=None, TotalWeight=None, OverweightIndicator='N', TrackingData=None, TrackingDataWithReferenceNumber=None, PaymentMethod='00', SpecialInstruction=None, ReferenceNumber=None, FreightOptions=None, ServiceCategory=None, CashType=None, ShippingLabelsAvailable=None):
        self.original_tagname_ = None
        self.Request = Request
        self.RatePickupIndicator = RatePickupIndicator
        self.TaxInformationIndicator = TaxInformationIndicator
        self.UserLevelDiscountIndicator = UserLevelDiscountIndicator
        self.Shipper = Shipper
        self.PickupDateInfo = PickupDateInfo
        self.PickupAddress = PickupAddress
        self.AlternateAddressIndicator = AlternateAddressIndicator
        if PickupPiece is None:
            self.PickupPiece = []
        else:
            self.PickupPiece = PickupPiece
        self.TotalWeight = TotalWeight
        self.OverweightIndicator = OverweightIndicator
        if TrackingData is None:
            self.TrackingData = []
        else:
            self.TrackingData = TrackingData
        self.TrackingDataWithReferenceNumber = TrackingDataWithReferenceNumber
        self.PaymentMethod = PaymentMethod
        self.SpecialInstruction = SpecialInstruction
        self.ReferenceNumber = ReferenceNumber
        self.FreightOptions = FreightOptions
        self.ServiceCategory = ServiceCategory
        self.CashType = CashType
        self.ShippingLabelsAvailable = ShippingLabelsAvailable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupCreationRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupCreationRequest.subclass:
            return PickupCreationRequest.subclass(*args_, **kwargs_)
        else:
            return PickupCreationRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_RatePickupIndicator(self): return self.RatePickupIndicator
    def set_RatePickupIndicator(self, RatePickupIndicator): self.RatePickupIndicator = RatePickupIndicator
    def get_TaxInformationIndicator(self): return self.TaxInformationIndicator
    def set_TaxInformationIndicator(self, TaxInformationIndicator): self.TaxInformationIndicator = TaxInformationIndicator
    def get_UserLevelDiscountIndicator(self): return self.UserLevelDiscountIndicator
    def set_UserLevelDiscountIndicator(self, UserLevelDiscountIndicator): self.UserLevelDiscountIndicator = UserLevelDiscountIndicator
    def get_Shipper(self): return self.Shipper
    def set_Shipper(self, Shipper): self.Shipper = Shipper
    def get_PickupDateInfo(self): return self.PickupDateInfo
    def set_PickupDateInfo(self, PickupDateInfo): self.PickupDateInfo = PickupDateInfo
    def get_PickupAddress(self): return self.PickupAddress
    def set_PickupAddress(self, PickupAddress): self.PickupAddress = PickupAddress
    def get_AlternateAddressIndicator(self): return self.AlternateAddressIndicator
    def set_AlternateAddressIndicator(self, AlternateAddressIndicator): self.AlternateAddressIndicator = AlternateAddressIndicator
    def get_PickupPiece(self): return self.PickupPiece
    def set_PickupPiece(self, PickupPiece): self.PickupPiece = PickupPiece
    def add_PickupPiece(self, value): self.PickupPiece.append(value)
    def insert_PickupPiece_at(self, index, value): self.PickupPiece.insert(index, value)
    def replace_PickupPiece_at(self, index, value): self.PickupPiece[index] = value
    def get_TotalWeight(self): return self.TotalWeight
    def set_TotalWeight(self, TotalWeight): self.TotalWeight = TotalWeight
    def get_OverweightIndicator(self): return self.OverweightIndicator
    def set_OverweightIndicator(self, OverweightIndicator): self.OverweightIndicator = OverweightIndicator
    def get_TrackingData(self): return self.TrackingData
    def set_TrackingData(self, TrackingData): self.TrackingData = TrackingData
    def add_TrackingData(self, value): self.TrackingData.append(value)
    def insert_TrackingData_at(self, index, value): self.TrackingData.insert(index, value)
    def replace_TrackingData_at(self, index, value): self.TrackingData[index] = value
    def get_TrackingDataWithReferenceNumber(self): return self.TrackingDataWithReferenceNumber
    def set_TrackingDataWithReferenceNumber(self, TrackingDataWithReferenceNumber): self.TrackingDataWithReferenceNumber = TrackingDataWithReferenceNumber
    def get_PaymentMethod(self): return self.PaymentMethod
    def set_PaymentMethod(self, PaymentMethod): self.PaymentMethod = PaymentMethod
    def get_SpecialInstruction(self): return self.SpecialInstruction
    def set_SpecialInstruction(self, SpecialInstruction): self.SpecialInstruction = SpecialInstruction
    def get_ReferenceNumber(self): return self.ReferenceNumber
    def set_ReferenceNumber(self, ReferenceNumber): self.ReferenceNumber = ReferenceNumber
    def get_FreightOptions(self): return self.FreightOptions
    def set_FreightOptions(self, FreightOptions): self.FreightOptions = FreightOptions
    def get_ServiceCategory(self): return self.ServiceCategory
    def set_ServiceCategory(self, ServiceCategory): self.ServiceCategory = ServiceCategory
    def get_CashType(self): return self.CashType
    def set_CashType(self, CashType): self.CashType = CashType
    def get_ShippingLabelsAvailable(self): return self.ShippingLabelsAvailable
    def set_ShippingLabelsAvailable(self, ShippingLabelsAvailable): self.ShippingLabelsAvailable = ShippingLabelsAvailable
    def hasContent_(self):
        if (
            self.Request is not None or
            self.RatePickupIndicator != "N" or
            self.TaxInformationIndicator != "N" or
            self.UserLevelDiscountIndicator != "N" or
            self.Shipper is not None or
            self.PickupDateInfo is not None or
            self.PickupAddress is not None or
            self.AlternateAddressIndicator != "N" or
            self.PickupPiece or
            self.TotalWeight is not None or
            self.OverweightIndicator != "N" or
            self.TrackingData or
            self.TrackingDataWithReferenceNumber is not None or
            self.PaymentMethod != "00" or
            self.SpecialInstruction is not None or
            self.ReferenceNumber is not None or
            self.FreightOptions is not None or
            self.ServiceCategory is not None or
            self.CashType is not None or
            self.ShippingLabelsAvailable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupCreationRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupCreationRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupCreationRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupCreationRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupCreationRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupCreationRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_='common:', name_='Request', pretty_print=pretty_print)
        if self.RatePickupIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:RatePickupIndicator>%s</pkup:RatePickupIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RatePickupIndicator), input_name='RatePickupIndicator')), eol_))
        if self.TaxInformationIndicator != "N":
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:TaxInformationIndicator>%s</pkup:TaxInformationIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxInformationIndicator), input_name='TaxInformationIndicator')), eol_))
        if self.UserLevelDiscountIndicator != "N":
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:UserLevelDiscountIndicator>%s</pkup:UserLevelDiscountIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UserLevelDiscountIndicator), input_name='UserLevelDiscountIndicator')), eol_))
        if self.Shipper is not None:
            self.Shipper.export(outfile, level, namespace_, name_='Shipper', pretty_print=pretty_print)
        if self.PickupDateInfo is not None:
            self.PickupDateInfo.export(outfile, level, namespace_, name_='PickupDateInfo', pretty_print=pretty_print)
        if self.PickupAddress is not None:
            self.PickupAddress.export(outfile, level, namespace_, name_='PickupAddress', pretty_print=pretty_print)
        if self.AlternateAddressIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:AlternateAddressIndicator>%s</pkup:AlternateAddressIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AlternateAddressIndicator), input_name='AlternateAddressIndicator')), eol_))
        for PickupPiece_ in self.PickupPiece:
            PickupPiece_.export(outfile, level, namespace_, name_='PickupPiece', pretty_print=pretty_print)
        if self.TotalWeight is not None:
            self.TotalWeight.export(outfile, level, namespace_, name_='TotalWeight', pretty_print=pretty_print)
        if self.OverweightIndicator != "N":
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:OverweightIndicator>%s</pkup:OverweightIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OverweightIndicator), input_name='OverweightIndicator')), eol_))
        for TrackingData_ in self.TrackingData:
            TrackingData_.export(outfile, level, namespace_, name_='TrackingData', pretty_print=pretty_print)
        if self.TrackingDataWithReferenceNumber is not None:
            self.TrackingDataWithReferenceNumber.export(outfile, level, namespace_, name_='TrackingDataWithReferenceNumber', pretty_print=pretty_print)
        if self.PaymentMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PaymentMethod>%s</pkup:PaymentMethod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PaymentMethod), input_name='PaymentMethod')), eol_))
        if self.SpecialInstruction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:SpecialInstruction>%s</pkup:SpecialInstruction>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialInstruction), input_name='SpecialInstruction')), eol_))
        if self.ReferenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ReferenceNumber>%s</pkup:ReferenceNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceNumber), input_name='ReferenceNumber')), eol_))
        if self.FreightOptions is not None:
            self.FreightOptions.export(outfile, level, namespace_, name_='FreightOptions', pretty_print=pretty_print)
        if self.ServiceCategory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ServiceCategory>%s</pkup:ServiceCategory>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceCategory), input_name='ServiceCategory')), eol_))
        if self.CashType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CashType>%s</pkup:CashType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CashType), input_name='CashType')), eol_))
        if self.ShippingLabelsAvailable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ShippingLabelsAvailable>%s</pkup:ShippingLabelsAvailable>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShippingLabelsAvailable), input_name='ShippingLabelsAvailable')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = RequestType.factory()
            obj_.build(child_)
            self.Request = obj_
            obj_.original_tagname_ = 'Request'
        elif nodeName_ == 'RatePickupIndicator':
            RatePickupIndicator_ = child_.text
            RatePickupIndicator_ = self.gds_validate_string(RatePickupIndicator_, node, 'RatePickupIndicator')
            self.RatePickupIndicator = RatePickupIndicator_
        elif nodeName_ == 'TaxInformationIndicator':
            TaxInformationIndicator_ = child_.text
            TaxInformationIndicator_ = self.gds_validate_string(TaxInformationIndicator_, node, 'TaxInformationIndicator')
            self.TaxInformationIndicator = TaxInformationIndicator_
        elif nodeName_ == 'UserLevelDiscountIndicator':
            UserLevelDiscountIndicator_ = child_.text
            UserLevelDiscountIndicator_ = self.gds_validate_string(UserLevelDiscountIndicator_, node, 'UserLevelDiscountIndicator')
            self.UserLevelDiscountIndicator = UserLevelDiscountIndicator_
        elif nodeName_ == 'Shipper':
            obj_ = ShipperType.factory()
            obj_.build(child_)
            self.Shipper = obj_
            obj_.original_tagname_ = 'Shipper'
        elif nodeName_ == 'PickupDateInfo':
            obj_ = PickupDateInfoType.factory()
            obj_.build(child_)
            self.PickupDateInfo = obj_
            obj_.original_tagname_ = 'PickupDateInfo'
        elif nodeName_ == 'PickupAddress':
            obj_ = PickupAddressType.factory()
            obj_.build(child_)
            self.PickupAddress = obj_
            obj_.original_tagname_ = 'PickupAddress'
        elif nodeName_ == 'AlternateAddressIndicator':
            AlternateAddressIndicator_ = child_.text
            AlternateAddressIndicator_ = self.gds_validate_string(AlternateAddressIndicator_, node, 'AlternateAddressIndicator')
            self.AlternateAddressIndicator = AlternateAddressIndicator_
        elif nodeName_ == 'PickupPiece':
            obj_ = PickupPieceType.factory()
            obj_.build(child_)
            self.PickupPiece.append(obj_)
            obj_.original_tagname_ = 'PickupPiece'
        elif nodeName_ == 'TotalWeight':
            obj_ = WeightType.factory()
            obj_.build(child_)
            self.TotalWeight = obj_
            obj_.original_tagname_ = 'TotalWeight'
        elif nodeName_ == 'OverweightIndicator':
            OverweightIndicator_ = child_.text
            OverweightIndicator_ = self.gds_validate_string(OverweightIndicator_, node, 'OverweightIndicator')
            self.OverweightIndicator = OverweightIndicator_
        elif nodeName_ == 'TrackingData':
            obj_ = TrackingDataType.factory()
            obj_.build(child_)
            self.TrackingData.append(obj_)
            obj_.original_tagname_ = 'TrackingData'
        elif nodeName_ == 'TrackingDataWithReferenceNumber':
            obj_ = TrackingDataWithReferenceNumberType.factory()
            obj_.build(child_)
            self.TrackingDataWithReferenceNumber = obj_
            obj_.original_tagname_ = 'TrackingDataWithReferenceNumber'
        elif nodeName_ == 'PaymentMethod':
            PaymentMethod_ = child_.text
            PaymentMethod_ = self.gds_validate_string(PaymentMethod_, node, 'PaymentMethod')
            self.PaymentMethod = PaymentMethod_
        elif nodeName_ == 'SpecialInstruction':
            SpecialInstruction_ = child_.text
            SpecialInstruction_ = self.gds_validate_string(SpecialInstruction_, node, 'SpecialInstruction')
            self.SpecialInstruction = SpecialInstruction_
        elif nodeName_ == 'ReferenceNumber':
            ReferenceNumber_ = child_.text
            ReferenceNumber_ = self.gds_validate_string(ReferenceNumber_, node, 'ReferenceNumber')
            self.ReferenceNumber = ReferenceNumber_
        elif nodeName_ == 'FreightOptions':
            obj_ = FreightOptionsType.factory()
            obj_.build(child_)
            self.FreightOptions = obj_
            obj_.original_tagname_ = 'FreightOptions'
        elif nodeName_ == 'ServiceCategory':
            ServiceCategory_ = child_.text
            ServiceCategory_ = self.gds_validate_string(ServiceCategory_, node, 'ServiceCategory')
            self.ServiceCategory = ServiceCategory_
        elif nodeName_ == 'CashType':
            CashType_ = child_.text
            CashType_ = self.gds_validate_string(CashType_, node, 'CashType')
            self.CashType = CashType_
        elif nodeName_ == 'ShippingLabelsAvailable':
            ShippingLabelsAvailable_ = child_.text
            ShippingLabelsAvailable_ = self.gds_validate_string(ShippingLabelsAvailable_, node, 'ShippingLabelsAvailable')
            self.ShippingLabelsAvailable = ShippingLabelsAvailable_
# end class PickupCreationRequest


class PickupGetServiceCenterFacilitiesRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Request=None, PickupPiece=None, OriginAddress=None, DestinationAddress=None, Locale=None, ProximitySearchIndicator=None):
        self.original_tagname_ = None
        self.Request = Request
        if PickupPiece is None:
            self.PickupPiece = []
        else:
            self.PickupPiece = PickupPiece
        self.OriginAddress = OriginAddress
        self.DestinationAddress = DestinationAddress
        self.Locale = Locale
        self.ProximitySearchIndicator = ProximitySearchIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupGetServiceCenterFacilitiesRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupGetServiceCenterFacilitiesRequest.subclass:
            return PickupGetServiceCenterFacilitiesRequest.subclass(*args_, **kwargs_)
        else:
            return PickupGetServiceCenterFacilitiesRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_PickupPiece(self): return self.PickupPiece
    def set_PickupPiece(self, PickupPiece): self.PickupPiece = PickupPiece
    def add_PickupPiece(self, value): self.PickupPiece.append(value)
    def insert_PickupPiece_at(self, index, value): self.PickupPiece.insert(index, value)
    def replace_PickupPiece_at(self, index, value): self.PickupPiece[index] = value
    def get_OriginAddress(self): return self.OriginAddress
    def set_OriginAddress(self, OriginAddress): self.OriginAddress = OriginAddress
    def get_DestinationAddress(self): return self.DestinationAddress
    def set_DestinationAddress(self, DestinationAddress): self.DestinationAddress = DestinationAddress
    def get_Locale(self): return self.Locale
    def set_Locale(self, Locale): self.Locale = Locale
    def get_ProximitySearchIndicator(self): return self.ProximitySearchIndicator
    def set_ProximitySearchIndicator(self, ProximitySearchIndicator): self.ProximitySearchIndicator = ProximitySearchIndicator
    def hasContent_(self):
        if (
            self.Request is not None or
            self.PickupPiece or
            self.OriginAddress is not None or
            self.DestinationAddress is not None or
            self.Locale is not None or
            self.ProximitySearchIndicator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupGetServiceCenterFacilitiesRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupGetServiceCenterFacilitiesRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupGetServiceCenterFacilitiesRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupGetServiceCenterFacilitiesRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupGetServiceCenterFacilitiesRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupGetServiceCenterFacilitiesRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_='common:', name_='Request', pretty_print=pretty_print)
        for PickupPiece_ in self.PickupPiece:
            PickupPiece_.export(outfile, level, namespace_, name_='PickupPiece', pretty_print=pretty_print)
        if self.OriginAddress is not None:
            self.OriginAddress.export(outfile, level, namespace_, name_='OriginAddress', pretty_print=pretty_print)
        if self.DestinationAddress is not None:
            self.DestinationAddress.export(outfile, level, namespace_, name_='DestinationAddress', pretty_print=pretty_print)
        if self.Locale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Locale>%s</pkup:Locale>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Locale), input_name='Locale')), eol_))
        if self.ProximitySearchIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ProximitySearchIndicator>%s</pkup:ProximitySearchIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProximitySearchIndicator), input_name='ProximitySearchIndicator')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = RequestType.factory()
            obj_.build(child_)
            self.Request = obj_
            obj_.original_tagname_ = 'Request'
        elif nodeName_ == 'PickupPiece':
            obj_ = PickupPieceServiceType.factory()
            obj_.build(child_)
            self.PickupPiece.append(obj_)
            obj_.original_tagname_ = 'PickupPiece'
        elif nodeName_ == 'OriginAddress':
            obj_ = OriginAddressType.factory()
            obj_.build(child_)
            self.OriginAddress = obj_
            obj_.original_tagname_ = 'OriginAddress'
        elif nodeName_ == 'DestinationAddress':
            obj_ = DestinationAddressType.factory()
            obj_.build(child_)
            self.DestinationAddress = obj_
            obj_.original_tagname_ = 'DestinationAddress'
        elif nodeName_ == 'Locale':
            Locale_ = child_.text
            Locale_ = self.gds_validate_string(Locale_, node, 'Locale')
            self.Locale = Locale_
        elif nodeName_ == 'ProximitySearchIndicator':
            ProximitySearchIndicator_ = child_.text
            ProximitySearchIndicator_ = self.gds_validate_string(ProximitySearchIndicator_, node, 'ProximitySearchIndicator')
            self.ProximitySearchIndicator = ProximitySearchIndicator_
# end class PickupGetServiceCenterFacilitiesRequest


class PickupRateRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Request=None, PickupAddress=None, AlternateAddressIndicator='N', ServiceDateOption=None, PickupDateInfo=None, TaxInformationIndicator='N', UserLevelDiscountIndicator='N'):
        self.original_tagname_ = None
        self.Request = Request
        self.PickupAddress = PickupAddress
        self.AlternateAddressIndicator = AlternateAddressIndicator
        self.ServiceDateOption = ServiceDateOption
        self.PickupDateInfo = PickupDateInfo
        self.TaxInformationIndicator = TaxInformationIndicator
        self.UserLevelDiscountIndicator = UserLevelDiscountIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupRateRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupRateRequest.subclass:
            return PickupRateRequest.subclass(*args_, **kwargs_)
        else:
            return PickupRateRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_PickupAddress(self): return self.PickupAddress
    def set_PickupAddress(self, PickupAddress): self.PickupAddress = PickupAddress
    def get_AlternateAddressIndicator(self): return self.AlternateAddressIndicator
    def set_AlternateAddressIndicator(self, AlternateAddressIndicator): self.AlternateAddressIndicator = AlternateAddressIndicator
    def get_ServiceDateOption(self): return self.ServiceDateOption
    def set_ServiceDateOption(self, ServiceDateOption): self.ServiceDateOption = ServiceDateOption
    def get_PickupDateInfo(self): return self.PickupDateInfo
    def set_PickupDateInfo(self, PickupDateInfo): self.PickupDateInfo = PickupDateInfo
    def get_TaxInformationIndicator(self): return self.TaxInformationIndicator
    def set_TaxInformationIndicator(self, TaxInformationIndicator): self.TaxInformationIndicator = TaxInformationIndicator
    def get_UserLevelDiscountIndicator(self): return self.UserLevelDiscountIndicator
    def set_UserLevelDiscountIndicator(self, UserLevelDiscountIndicator): self.UserLevelDiscountIndicator = UserLevelDiscountIndicator
    def hasContent_(self):
        if (
            self.Request is not None or
            self.PickupAddress is not None or
            self.AlternateAddressIndicator != "N" or
            self.ServiceDateOption is not None or
            self.PickupDateInfo is not None or
            self.TaxInformationIndicator != "N" or
            self.UserLevelDiscountIndicator != "N"
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupRateRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupRateRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupRateRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupRateRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupRateRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupRateRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_='common:', name_='Request', pretty_print=pretty_print)
        if self.PickupAddress is not None:
            self.PickupAddress.export(outfile, level, namespace_, name_='PickupAddress', pretty_print=pretty_print)
        if self.AlternateAddressIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:AlternateAddressIndicator>%s</pkup:AlternateAddressIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AlternateAddressIndicator), input_name='AlternateAddressIndicator')), eol_))
        if self.ServiceDateOption is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ServiceDateOption>%s</pkup:ServiceDateOption>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceDateOption), input_name='ServiceDateOption')), eol_))
        if self.PickupDateInfo is not None:
            self.PickupDateInfo.export(outfile, level, namespace_, name_='PickupDateInfo', pretty_print=pretty_print)
        if self.TaxInformationIndicator != "N":
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:TaxInformationIndicator>%s</pkup:TaxInformationIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxInformationIndicator), input_name='TaxInformationIndicator')), eol_))
        if self.UserLevelDiscountIndicator != "N":
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:UserLevelDiscountIndicator>%s</pkup:UserLevelDiscountIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UserLevelDiscountIndicator), input_name='UserLevelDiscountIndicator')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = RequestType.factory()
            obj_.build(child_)
            self.Request = obj_
            obj_.original_tagname_ = 'Request'
        elif nodeName_ == 'PickupAddress':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.PickupAddress = obj_
            obj_.original_tagname_ = 'PickupAddress'
        elif nodeName_ == 'AlternateAddressIndicator':
            AlternateAddressIndicator_ = child_.text
            AlternateAddressIndicator_ = self.gds_validate_string(AlternateAddressIndicator_, node, 'AlternateAddressIndicator')
            self.AlternateAddressIndicator = AlternateAddressIndicator_
        elif nodeName_ == 'ServiceDateOption':
            ServiceDateOption_ = child_.text
            ServiceDateOption_ = self.gds_validate_string(ServiceDateOption_, node, 'ServiceDateOption')
            self.ServiceDateOption = ServiceDateOption_
        elif nodeName_ == 'PickupDateInfo':
            obj_ = PickupDateInfoType.factory()
            obj_.build(child_)
            self.PickupDateInfo = obj_
            obj_.original_tagname_ = 'PickupDateInfo'
        elif nodeName_ == 'TaxInformationIndicator':
            TaxInformationIndicator_ = child_.text
            TaxInformationIndicator_ = self.gds_validate_string(TaxInformationIndicator_, node, 'TaxInformationIndicator')
            self.TaxInformationIndicator = TaxInformationIndicator_
        elif nodeName_ == 'UserLevelDiscountIndicator':
            UserLevelDiscountIndicator_ = child_.text
            UserLevelDiscountIndicator_ = self.gds_validate_string(UserLevelDiscountIndicator_, node, 'UserLevelDiscountIndicator')
            self.UserLevelDiscountIndicator = UserLevelDiscountIndicator_
# end class PickupRateRequest


class PickupCancelRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Request=None, CancelBy=None, PRN=None):
        self.original_tagname_ = None
        self.Request = Request
        self.CancelBy = CancelBy
        self.PRN = PRN
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupCancelRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupCancelRequest.subclass:
            return PickupCancelRequest.subclass(*args_, **kwargs_)
        else:
            return PickupCancelRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_CancelBy(self): return self.CancelBy
    def set_CancelBy(self, CancelBy): self.CancelBy = CancelBy
    def get_PRN(self): return self.PRN
    def set_PRN(self, PRN): self.PRN = PRN
    def hasContent_(self):
        if (
            self.Request is not None or
            self.CancelBy is not None or
            self.PRN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupCancelRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupCancelRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupCancelRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupCancelRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupCancelRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupCancelRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_='common:', name_='Request', pretty_print=pretty_print)
        if self.CancelBy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CancelBy>%s</pkup:CancelBy>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CancelBy), input_name='CancelBy')), eol_))
        if self.PRN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PRN>%s</pkup:PRN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PRN), input_name='PRN')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = RequestType.factory()
            obj_.build(child_)
            self.Request = obj_
            obj_.original_tagname_ = 'Request'
        elif nodeName_ == 'CancelBy':
            CancelBy_ = child_.text
            CancelBy_ = self.gds_validate_string(CancelBy_, node, 'CancelBy')
            self.CancelBy = CancelBy_
        elif nodeName_ == 'PRN':
            PRN_ = child_.text
            PRN_ = self.gds_validate_string(PRN_, node, 'PRN')
            self.PRN = PRN_
# end class PickupCancelRequest


class PickupPendingStatusRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Request=None, PickupType=None, AccountNumber=None):
        self.original_tagname_ = None
        self.Request = Request
        self.PickupType = PickupType
        self.AccountNumber = AccountNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupPendingStatusRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupPendingStatusRequest.subclass:
            return PickupPendingStatusRequest.subclass(*args_, **kwargs_)
        else:
            return PickupPendingStatusRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_PickupType(self): return self.PickupType
    def set_PickupType(self, PickupType): self.PickupType = PickupType
    def get_AccountNumber(self): return self.AccountNumber
    def set_AccountNumber(self, AccountNumber): self.AccountNumber = AccountNumber
    def hasContent_(self):
        if (
            self.Request is not None or
            self.PickupType is not None or
            self.AccountNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupPendingStatusRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupPendingStatusRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupPendingStatusRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupPendingStatusRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupPendingStatusRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupPendingStatusRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_='common:', name_='Request', pretty_print=pretty_print)
        if self.PickupType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PickupType>%s</pkup:PickupType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupType), input_name='PickupType')), eol_))
        if self.AccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:AccountNumber>%s</pkup:AccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AccountNumber), input_name='AccountNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = RequestType.factory()
            obj_.build(child_)
            self.Request = obj_
            obj_.original_tagname_ = 'Request'
        elif nodeName_ == 'PickupType':
            PickupType_ = child_.text
            PickupType_ = self.gds_validate_string(PickupType_, node, 'PickupType')
            self.PickupType = PickupType_
        elif nodeName_ == 'AccountNumber':
            AccountNumber_ = child_.text
            AccountNumber_ = self.gds_validate_string(AccountNumber_, node, 'AccountNumber')
            self.AccountNumber = AccountNumber_
# end class PickupPendingStatusRequest


class PickupGetPoliticalDivision1ListResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, PoliticalDivision1=None):
        self.original_tagname_ = None
        self.Response = Response
        if PoliticalDivision1 is None:
            self.PoliticalDivision1 = []
        else:
            self.PoliticalDivision1 = PoliticalDivision1
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupGetPoliticalDivision1ListResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupGetPoliticalDivision1ListResponse.subclass:
            return PickupGetPoliticalDivision1ListResponse.subclass(*args_, **kwargs_)
        else:
            return PickupGetPoliticalDivision1ListResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_PoliticalDivision1(self): return self.PoliticalDivision1
    def set_PoliticalDivision1(self, PoliticalDivision1): self.PoliticalDivision1 = PoliticalDivision1
    def add_PoliticalDivision1(self, value): self.PoliticalDivision1.append(value)
    def insert_PoliticalDivision1_at(self, index, value): self.PoliticalDivision1.insert(index, value)
    def replace_PoliticalDivision1_at(self, index, value): self.PoliticalDivision1[index] = value
    def hasContent_(self):
        if (
            self.Response is not None or
            self.PoliticalDivision1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupGetPoliticalDivision1ListResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupGetPoliticalDivision1ListResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupGetPoliticalDivision1ListResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupGetPoliticalDivision1ListResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupGetPoliticalDivision1ListResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupGetPoliticalDivision1ListResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_='common:', name_='Response', pretty_print=pretty_print)
        for PoliticalDivision1_ in self.PoliticalDivision1:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PoliticalDivision1>%s</pkup:PoliticalDivision1>%s' % (self.gds_encode(self.gds_format_string(quote_xml(PoliticalDivision1_), input_name='PoliticalDivision1')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'PoliticalDivision1':
            PoliticalDivision1_ = child_.text
            PoliticalDivision1_ = self.gds_validate_string(PoliticalDivision1_, node, 'PoliticalDivision1')
            self.PoliticalDivision1.append(PoliticalDivision1_)
# end class PickupGetPoliticalDivision1ListResponse


class PickupCreationResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, PRN=None, WeekendServiceTerritoryIndicator='N', RateStatus=None, RateResult=None):
        self.original_tagname_ = None
        self.Response = Response
        self.PRN = PRN
        self.WeekendServiceTerritoryIndicator = WeekendServiceTerritoryIndicator
        self.RateStatus = RateStatus
        self.RateResult = RateResult
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupCreationResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupCreationResponse.subclass:
            return PickupCreationResponse.subclass(*args_, **kwargs_)
        else:
            return PickupCreationResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_PRN(self): return self.PRN
    def set_PRN(self, PRN): self.PRN = PRN
    def get_WeekendServiceTerritoryIndicator(self): return self.WeekendServiceTerritoryIndicator
    def set_WeekendServiceTerritoryIndicator(self, WeekendServiceTerritoryIndicator): self.WeekendServiceTerritoryIndicator = WeekendServiceTerritoryIndicator
    def get_RateStatus(self): return self.RateStatus
    def set_RateStatus(self, RateStatus): self.RateStatus = RateStatus
    def get_RateResult(self): return self.RateResult
    def set_RateResult(self, RateResult): self.RateResult = RateResult
    def hasContent_(self):
        if (
            self.Response is not None or
            self.PRN is not None or
            self.WeekendServiceTerritoryIndicator != "N" or
            self.RateStatus is not None or
            self.RateResult is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupCreationResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupCreationResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupCreationResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupCreationResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupCreationResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupCreationResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_='common:', name_='Response', pretty_print=pretty_print)
        if self.PRN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PRN>%s</pkup:PRN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PRN), input_name='PRN')), eol_))
        if self.WeekendServiceTerritoryIndicator != "N":
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:WeekendServiceTerritoryIndicator>%s</pkup:WeekendServiceTerritoryIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeekendServiceTerritoryIndicator), input_name='WeekendServiceTerritoryIndicator')), eol_))
        if self.RateStatus is not None:
            self.RateStatus.export(outfile, level, namespace_, name_='RateStatus', pretty_print=pretty_print)
        if self.RateResult is not None:
            self.RateResult.export(outfile, level, namespace_, name_='RateResult', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'PRN':
            PRN_ = child_.text
            PRN_ = self.gds_validate_string(PRN_, node, 'PRN')
            self.PRN = PRN_
        elif nodeName_ == 'WeekendServiceTerritoryIndicator':
            WeekendServiceTerritoryIndicator_ = child_.text
            WeekendServiceTerritoryIndicator_ = self.gds_validate_string(WeekendServiceTerritoryIndicator_, node, 'WeekendServiceTerritoryIndicator')
            self.WeekendServiceTerritoryIndicator = WeekendServiceTerritoryIndicator_
        elif nodeName_ == 'RateStatus':
            obj_ = StatusCodeDescriptionType.factory()
            obj_.build(child_)
            self.RateStatus = obj_
            obj_.original_tagname_ = 'RateStatus'
        elif nodeName_ == 'RateResult':
            obj_ = RateResultType.factory()
            obj_.build(child_)
            self.RateResult = obj_
            obj_.original_tagname_ = 'RateResult'
# end class PickupCreationResponse


class PickupRateResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, RateResult=None, WeekendServiceTerritoryIndicator='N'):
        self.original_tagname_ = None
        self.Response = Response
        self.RateResult = RateResult
        self.WeekendServiceTerritoryIndicator = WeekendServiceTerritoryIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupRateResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupRateResponse.subclass:
            return PickupRateResponse.subclass(*args_, **kwargs_)
        else:
            return PickupRateResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_RateResult(self): return self.RateResult
    def set_RateResult(self, RateResult): self.RateResult = RateResult
    def get_WeekendServiceTerritoryIndicator(self): return self.WeekendServiceTerritoryIndicator
    def set_WeekendServiceTerritoryIndicator(self, WeekendServiceTerritoryIndicator): self.WeekendServiceTerritoryIndicator = WeekendServiceTerritoryIndicator
    def hasContent_(self):
        if (
            self.Response is not None or
            self.RateResult is not None or
            self.WeekendServiceTerritoryIndicator != "N"
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupRateResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupRateResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupRateResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupRateResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupRateResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupRateResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_='common:', name_='Response', pretty_print=pretty_print)
        if self.RateResult is not None:
            self.RateResult.export(outfile, level, namespace_, name_='RateResult', pretty_print=pretty_print)
        if self.WeekendServiceTerritoryIndicator != "N":
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:WeekendServiceTerritoryIndicator>%s</pkup:WeekendServiceTerritoryIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeekendServiceTerritoryIndicator), input_name='WeekendServiceTerritoryIndicator')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'RateResult':
            obj_ = RateResultType.factory()
            obj_.build(child_)
            self.RateResult = obj_
            obj_.original_tagname_ = 'RateResult'
        elif nodeName_ == 'WeekendServiceTerritoryIndicator':
            WeekendServiceTerritoryIndicator_ = child_.text
            WeekendServiceTerritoryIndicator_ = self.gds_validate_string(WeekendServiceTerritoryIndicator_, node, 'WeekendServiceTerritoryIndicator')
            self.WeekendServiceTerritoryIndicator = WeekendServiceTerritoryIndicator_
# end class PickupRateResponse


class PickupCancelResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, PickupType=None, GWNStatus=None):
        self.original_tagname_ = None
        self.Response = Response
        self.PickupType = PickupType
        self.GWNStatus = GWNStatus
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupCancelResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupCancelResponse.subclass:
            return PickupCancelResponse.subclass(*args_, **kwargs_)
        else:
            return PickupCancelResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_PickupType(self): return self.PickupType
    def set_PickupType(self, PickupType): self.PickupType = PickupType
    def get_GWNStatus(self): return self.GWNStatus
    def set_GWNStatus(self, GWNStatus): self.GWNStatus = GWNStatus
    def hasContent_(self):
        if (
            self.Response is not None or
            self.PickupType is not None or
            self.GWNStatus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupCancelResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupCancelResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupCancelResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupCancelResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupCancelResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupCancelResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_='common:', name_='Response', pretty_print=pretty_print)
        if self.PickupType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PickupType>%s</pkup:PickupType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupType), input_name='PickupType')), eol_))
        if self.GWNStatus is not None:
            self.GWNStatus.export(outfile, level, namespace_, name_='GWNStatus', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'PickupType':
            PickupType_ = child_.text
            PickupType_ = self.gds_validate_string(PickupType_, node, 'PickupType')
            self.PickupType = PickupType_
        elif nodeName_ == 'GWNStatus':
            obj_ = StatusCodeDescriptionType.factory()
            obj_.build(child_)
            self.GWNStatus = obj_
            obj_.original_tagname_ = 'GWNStatus'
# end class PickupCancelResponse


class PickupPendingStatusResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, PendingStatus=None):
        self.original_tagname_ = None
        self.Response = Response
        if PendingStatus is None:
            self.PendingStatus = []
        else:
            self.PendingStatus = PendingStatus
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupPendingStatusResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupPendingStatusResponse.subclass:
            return PickupPendingStatusResponse.subclass(*args_, **kwargs_)
        else:
            return PickupPendingStatusResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_PendingStatus(self): return self.PendingStatus
    def set_PendingStatus(self, PendingStatus): self.PendingStatus = PendingStatus
    def add_PendingStatus(self, value): self.PendingStatus.append(value)
    def insert_PendingStatus_at(self, index, value): self.PendingStatus.insert(index, value)
    def replace_PendingStatus_at(self, index, value): self.PendingStatus[index] = value
    def hasContent_(self):
        if (
            self.Response is not None or
            self.PendingStatus
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupPendingStatusResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupPendingStatusResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupPendingStatusResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupPendingStatusResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupPendingStatusResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupPendingStatusResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_='common:', name_='Response', pretty_print=pretty_print)
        for PendingStatus_ in self.PendingStatus:
            PendingStatus_.export(outfile, level, namespace_, name_='PendingStatus', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'PendingStatus':
            obj_ = PendingStatusType.factory()
            obj_.build(child_)
            self.PendingStatus.append(obj_)
            obj_.original_tagname_ = 'PendingStatus'
# end class PickupPendingStatusResponse


class PickupGetServiceCenterFacilitiesResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, ServiceCenterLocation=None):
        self.original_tagname_ = None
        self.Response = Response
        self.ServiceCenterLocation = ServiceCenterLocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupGetServiceCenterFacilitiesResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupGetServiceCenterFacilitiesResponse.subclass:
            return PickupGetServiceCenterFacilitiesResponse.subclass(*args_, **kwargs_)
        else:
            return PickupGetServiceCenterFacilitiesResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_ServiceCenterLocation(self): return self.ServiceCenterLocation
    def set_ServiceCenterLocation(self, ServiceCenterLocation): self.ServiceCenterLocation = ServiceCenterLocation
    def hasContent_(self):
        if (
            self.Response is not None or
            self.ServiceCenterLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupGetServiceCenterFacilitiesResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupGetServiceCenterFacilitiesResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupGetServiceCenterFacilitiesResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupGetServiceCenterFacilitiesResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupGetServiceCenterFacilitiesResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupGetServiceCenterFacilitiesResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_='common:', name_='Response', pretty_print=pretty_print)
        if self.ServiceCenterLocation is not None:
            self.ServiceCenterLocation.export(outfile, level, namespace_, name_='ServiceCenterLocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'ServiceCenterLocation':
            obj_ = ServiceCenterLocationsType.factory()
            obj_.build(child_)
            self.ServiceCenterLocation = obj_
            obj_.original_tagname_ = 'ServiceCenterLocation'
# end class PickupGetServiceCenterFacilitiesResponse


class ServiceCenterLocationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DropOffFacilities=None, PickupFacilities=None):
        self.original_tagname_ = None
        if DropOffFacilities is None:
            self.DropOffFacilities = []
        else:
            self.DropOffFacilities = DropOffFacilities
        self.PickupFacilities = PickupFacilities
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceCenterLocationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceCenterLocationsType.subclass:
            return ServiceCenterLocationsType.subclass(*args_, **kwargs_)
        else:
            return ServiceCenterLocationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DropOffFacilities(self): return self.DropOffFacilities
    def set_DropOffFacilities(self, DropOffFacilities): self.DropOffFacilities = DropOffFacilities
    def add_DropOffFacilities(self, value): self.DropOffFacilities.append(value)
    def insert_DropOffFacilities_at(self, index, value): self.DropOffFacilities.insert(index, value)
    def replace_DropOffFacilities_at(self, index, value): self.DropOffFacilities[index] = value
    def get_PickupFacilities(self): return self.PickupFacilities
    def set_PickupFacilities(self, PickupFacilities): self.PickupFacilities = PickupFacilities
    def hasContent_(self):
        if (
            self.DropOffFacilities or
            self.PickupFacilities is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='ServiceCenterLocationsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceCenterLocationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceCenterLocationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='ServiceCenterLocationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='ServiceCenterLocationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='ServiceCenterLocationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DropOffFacilities_ in self.DropOffFacilities:
            DropOffFacilities_.export(outfile, level, namespace_, name_='DropOffFacilities', pretty_print=pretty_print)
        if self.PickupFacilities is not None:
            self.PickupFacilities.export(outfile, level, namespace_, name_='PickupFacilities', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DropOffFacilities':
            obj_ = DropOffFacilitiesType.factory()
            obj_.build(child_)
            self.DropOffFacilities.append(obj_)
            obj_.original_tagname_ = 'DropOffFacilities'
        elif nodeName_ == 'PickupFacilities':
            obj_ = PickupFacilitiesType.factory()
            obj_.build(child_)
            self.PickupFacilities = obj_
            obj_.original_tagname_ = 'PickupFacilities'
# end class ServiceCenterLocationsType


class DropOffFacilitiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Address=None, SLIC=None, Type=None, Timezone=None, Phone=None, Fax=None, FacilityTime=None, OriginOrDestination=None, LocalizedInstruction=None, Distance=None):
        self.original_tagname_ = None
        self.Name = Name
        self.Address = Address
        self.SLIC = SLIC
        self.Type = Type
        self.Timezone = Timezone
        self.Phone = Phone
        self.Fax = Fax
        self.FacilityTime = FacilityTime
        self.OriginOrDestination = OriginOrDestination
        if LocalizedInstruction is None:
            self.LocalizedInstruction = []
        else:
            self.LocalizedInstruction = LocalizedInstruction
        self.Distance = Distance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DropOffFacilitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DropOffFacilitiesType.subclass:
            return DropOffFacilitiesType.subclass(*args_, **kwargs_)
        else:
            return DropOffFacilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_SLIC(self): return self.SLIC
    def set_SLIC(self, SLIC): self.SLIC = SLIC
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Timezone(self): return self.Timezone
    def set_Timezone(self, Timezone): self.Timezone = Timezone
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_Fax(self): return self.Fax
    def set_Fax(self, Fax): self.Fax = Fax
    def get_FacilityTime(self): return self.FacilityTime
    def set_FacilityTime(self, FacilityTime): self.FacilityTime = FacilityTime
    def get_OriginOrDestination(self): return self.OriginOrDestination
    def set_OriginOrDestination(self, OriginOrDestination): self.OriginOrDestination = OriginOrDestination
    def get_LocalizedInstruction(self): return self.LocalizedInstruction
    def set_LocalizedInstruction(self, LocalizedInstruction): self.LocalizedInstruction = LocalizedInstruction
    def add_LocalizedInstruction(self, value): self.LocalizedInstruction.append(value)
    def insert_LocalizedInstruction_at(self, index, value): self.LocalizedInstruction.insert(index, value)
    def replace_LocalizedInstruction_at(self, index, value): self.LocalizedInstruction[index] = value
    def get_Distance(self): return self.Distance
    def set_Distance(self, Distance): self.Distance = Distance
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Address is not None or
            self.SLIC is not None or
            self.Type is not None or
            self.Timezone is not None or
            self.Phone is not None or
            self.Fax is not None or
            self.FacilityTime is not None or
            self.OriginOrDestination is not None or
            self.LocalizedInstruction or
            self.Distance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='DropOffFacilitiesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DropOffFacilitiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DropOffFacilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='DropOffFacilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='DropOffFacilitiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='DropOffFacilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Name>%s</pkup:Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        if self.SLIC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:SLIC>%s</pkup:SLIC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SLIC), input_name='SLIC')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Type>%s</pkup:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Timezone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Timezone>%s</pkup:Timezone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Timezone), input_name='Timezone')), eol_))
        if self.Phone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Phone>%s</pkup:Phone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Phone), input_name='Phone')), eol_))
        if self.Fax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Fax>%s</pkup:Fax>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Fax), input_name='Fax')), eol_))
        if self.FacilityTime is not None:
            self.FacilityTime.export(outfile, level, namespace_, name_='FacilityTime', pretty_print=pretty_print)
        if self.OriginOrDestination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:OriginOrDestination>%s</pkup:OriginOrDestination>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginOrDestination), input_name='OriginOrDestination')), eol_))
        for LocalizedInstruction_ in self.LocalizedInstruction:
            LocalizedInstruction_.export(outfile, level, namespace_, name_='LocalizedInstruction', pretty_print=pretty_print)
        if self.Distance is not None:
            self.Distance.export(outfile, level, namespace_, name_='Distance', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'SLIC':
            SLIC_ = child_.text
            SLIC_ = self.gds_validate_string(SLIC_, node, 'SLIC')
            self.SLIC = SLIC_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Timezone':
            Timezone_ = child_.text
            Timezone_ = self.gds_validate_string(Timezone_, node, 'Timezone')
            self.Timezone = Timezone_
        elif nodeName_ == 'Phone':
            Phone_ = child_.text
            Phone_ = self.gds_validate_string(Phone_, node, 'Phone')
            self.Phone = Phone_
        elif nodeName_ == 'Fax':
            Fax_ = child_.text
            Fax_ = self.gds_validate_string(Fax_, node, 'Fax')
            self.Fax = Fax_
        elif nodeName_ == 'FacilityTime':
            obj_ = FacilityTimeType.factory()
            obj_.build(child_)
            self.FacilityTime = obj_
            obj_.original_tagname_ = 'FacilityTime'
        elif nodeName_ == 'OriginOrDestination':
            OriginOrDestination_ = child_.text
            OriginOrDestination_ = self.gds_validate_string(OriginOrDestination_, node, 'OriginOrDestination')
            self.OriginOrDestination = OriginOrDestination_
        elif nodeName_ == 'LocalizedInstruction':
            obj_ = LocalizedInstructionType.factory()
            obj_.build(child_)
            self.LocalizedInstruction.append(obj_)
            obj_.original_tagname_ = 'LocalizedInstruction'
        elif nodeName_ == 'Distance':
            obj_ = DistanceType.factory()
            obj_.build(child_)
            self.Distance = obj_
            obj_.original_tagname_ = 'Distance'
# end class DropOffFacilitiesType


class PickupFacilitiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Address=None, SLIC=None, Type=None, Timezone=None, Phone=None, Fax=None, FacilityTime=None, OriginOrDestination=None, AirportCode=None, SortCode=None):
        self.original_tagname_ = None
        self.Name = Name
        self.Address = Address
        self.SLIC = SLIC
        self.Type = Type
        self.Timezone = Timezone
        self.Phone = Phone
        self.Fax = Fax
        self.FacilityTime = FacilityTime
        self.OriginOrDestination = OriginOrDestination
        self.AirportCode = AirportCode
        self.SortCode = SortCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupFacilitiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupFacilitiesType.subclass:
            return PickupFacilitiesType.subclass(*args_, **kwargs_)
        else:
            return PickupFacilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_SLIC(self): return self.SLIC
    def set_SLIC(self, SLIC): self.SLIC = SLIC
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Timezone(self): return self.Timezone
    def set_Timezone(self, Timezone): self.Timezone = Timezone
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_Fax(self): return self.Fax
    def set_Fax(self, Fax): self.Fax = Fax
    def get_FacilityTime(self): return self.FacilityTime
    def set_FacilityTime(self, FacilityTime): self.FacilityTime = FacilityTime
    def get_OriginOrDestination(self): return self.OriginOrDestination
    def set_OriginOrDestination(self, OriginOrDestination): self.OriginOrDestination = OriginOrDestination
    def get_AirportCode(self): return self.AirportCode
    def set_AirportCode(self, AirportCode): self.AirportCode = AirportCode
    def get_SortCode(self): return self.SortCode
    def set_SortCode(self, SortCode): self.SortCode = SortCode
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Address is not None or
            self.SLIC is not None or
            self.Type is not None or
            self.Timezone is not None or
            self.Phone is not None or
            self.Fax is not None or
            self.FacilityTime is not None or
            self.OriginOrDestination is not None or
            self.AirportCode is not None or
            self.SortCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupFacilitiesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupFacilitiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupFacilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupFacilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupFacilitiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupFacilitiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Name>%s</pkup:Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        if self.SLIC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:SLIC>%s</pkup:SLIC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SLIC), input_name='SLIC')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Type>%s</pkup:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Timezone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Timezone>%s</pkup:Timezone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Timezone), input_name='Timezone')), eol_))
        if self.Phone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Phone>%s</pkup:Phone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Phone), input_name='Phone')), eol_))
        if self.Fax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Fax>%s</pkup:Fax>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Fax), input_name='Fax')), eol_))
        if self.FacilityTime is not None:
            self.FacilityTime.export(outfile, level, namespace_, name_='FacilityTime', pretty_print=pretty_print)
        if self.OriginOrDestination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:OriginOrDestination>%s</pkup:OriginOrDestination>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginOrDestination), input_name='OriginOrDestination')), eol_))
        if self.AirportCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:AirportCode>%s</pkup:AirportCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AirportCode), input_name='AirportCode')), eol_))
        if self.SortCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:SortCode>%s</pkup:SortCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SortCode), input_name='SortCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'SLIC':
            SLIC_ = child_.text
            SLIC_ = self.gds_validate_string(SLIC_, node, 'SLIC')
            self.SLIC = SLIC_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Timezone':
            Timezone_ = child_.text
            Timezone_ = self.gds_validate_string(Timezone_, node, 'Timezone')
            self.Timezone = Timezone_
        elif nodeName_ == 'Phone':
            Phone_ = child_.text
            Phone_ = self.gds_validate_string(Phone_, node, 'Phone')
            self.Phone = Phone_
        elif nodeName_ == 'Fax':
            Fax_ = child_.text
            Fax_ = self.gds_validate_string(Fax_, node, 'Fax')
            self.Fax = Fax_
        elif nodeName_ == 'FacilityTime':
            obj_ = FacilityTimeType.factory()
            obj_.build(child_)
            self.FacilityTime = obj_
            obj_.original_tagname_ = 'FacilityTime'
        elif nodeName_ == 'OriginOrDestination':
            OriginOrDestination_ = child_.text
            OriginOrDestination_ = self.gds_validate_string(OriginOrDestination_, node, 'OriginOrDestination')
            self.OriginOrDestination = OriginOrDestination_
        elif nodeName_ == 'AirportCode':
            AirportCode_ = child_.text
            AirportCode_ = self.gds_validate_string(AirportCode_, node, 'AirportCode')
            self.AirportCode = AirportCode_
        elif nodeName_ == 'SortCode':
            SortCode_ = child_.text
            SortCode_ = self.gds_validate_string(SortCode_, node, 'SortCode')
            self.SortCode = SortCode_
# end class PickupFacilitiesType


class FacilityTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DayOfWeek=None):
        self.original_tagname_ = None
        if DayOfWeek is None:
            self.DayOfWeek = []
        else:
            self.DayOfWeek = DayOfWeek
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FacilityTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FacilityTimeType.subclass:
            return FacilityTimeType.subclass(*args_, **kwargs_)
        else:
            return FacilityTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DayOfWeek(self): return self.DayOfWeek
    def set_DayOfWeek(self, DayOfWeek): self.DayOfWeek = DayOfWeek
    def add_DayOfWeek(self, value): self.DayOfWeek.append(value)
    def insert_DayOfWeek_at(self, index, value): self.DayOfWeek.insert(index, value)
    def replace_DayOfWeek_at(self, index, value): self.DayOfWeek[index] = value
    def hasContent_(self):
        if (
            self.DayOfWeek
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='FacilityTimeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FacilityTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FacilityTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='FacilityTimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='FacilityTimeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='FacilityTimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DayOfWeek_ in self.DayOfWeek:
            DayOfWeek_.export(outfile, level, namespace_, name_='DayOfWeek', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DayOfWeek':
            obj_ = DayOfWeekType.factory()
            obj_.build(child_)
            self.DayOfWeek.append(obj_)
            obj_.original_tagname_ = 'DayOfWeek'
# end class FacilityTimeType


class DayOfWeekType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Day=None, EarliestDropOfforPickup=None, LatestDropOfforPickup=None, OpenHours=None, CloseHours=None, PrepTime=None, LastDrop=None):
        self.original_tagname_ = None
        self.Day = Day
        self.EarliestDropOfforPickup = EarliestDropOfforPickup
        self.LatestDropOfforPickup = LatestDropOfforPickup
        self.OpenHours = OpenHours
        self.CloseHours = CloseHours
        self.PrepTime = PrepTime
        self.LastDrop = LastDrop
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DayOfWeekType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DayOfWeekType.subclass:
            return DayOfWeekType.subclass(*args_, **kwargs_)
        else:
            return DayOfWeekType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Day(self): return self.Day
    def set_Day(self, Day): self.Day = Day
    def get_EarliestDropOfforPickup(self): return self.EarliestDropOfforPickup
    def set_EarliestDropOfforPickup(self, EarliestDropOfforPickup): self.EarliestDropOfforPickup = EarliestDropOfforPickup
    def get_LatestDropOfforPickup(self): return self.LatestDropOfforPickup
    def set_LatestDropOfforPickup(self, LatestDropOfforPickup): self.LatestDropOfforPickup = LatestDropOfforPickup
    def get_OpenHours(self): return self.OpenHours
    def set_OpenHours(self, OpenHours): self.OpenHours = OpenHours
    def get_CloseHours(self): return self.CloseHours
    def set_CloseHours(self, CloseHours): self.CloseHours = CloseHours
    def get_PrepTime(self): return self.PrepTime
    def set_PrepTime(self, PrepTime): self.PrepTime = PrepTime
    def get_LastDrop(self): return self.LastDrop
    def set_LastDrop(self, LastDrop): self.LastDrop = LastDrop
    def hasContent_(self):
        if (
            self.Day is not None or
            self.EarliestDropOfforPickup is not None or
            self.LatestDropOfforPickup is not None or
            self.OpenHours is not None or
            self.CloseHours is not None or
            self.PrepTime is not None or
            self.LastDrop is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='DayOfWeekType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DayOfWeekType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DayOfWeekType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='DayOfWeekType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='DayOfWeekType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='DayOfWeekType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Day is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Day>%s</pkup:Day>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Day), input_name='Day')), eol_))
        if self.EarliestDropOfforPickup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:EarliestDropOfforPickup>%s</pkup:EarliestDropOfforPickup>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EarliestDropOfforPickup), input_name='EarliestDropOfforPickup')), eol_))
        if self.LatestDropOfforPickup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:LatestDropOfforPickup>%s</pkup:LatestDropOfforPickup>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LatestDropOfforPickup), input_name='LatestDropOfforPickup')), eol_))
        if self.OpenHours is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:OpenHours>%s</pkup:OpenHours>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OpenHours), input_name='OpenHours')), eol_))
        if self.CloseHours is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CloseHours>%s</pkup:CloseHours>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CloseHours), input_name='CloseHours')), eol_))
        if self.PrepTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PrepTime>%s</pkup:PrepTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PrepTime), input_name='PrepTime')), eol_))
        if self.LastDrop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:LastDrop>%s</pkup:LastDrop>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LastDrop), input_name='LastDrop')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Day':
            Day_ = child_.text
            Day_ = self.gds_validate_string(Day_, node, 'Day')
            self.Day = Day_
        elif nodeName_ == 'EarliestDropOfforPickup':
            EarliestDropOfforPickup_ = child_.text
            EarliestDropOfforPickup_ = self.gds_validate_string(EarliestDropOfforPickup_, node, 'EarliestDropOfforPickup')
            self.EarliestDropOfforPickup = EarliestDropOfforPickup_
        elif nodeName_ == 'LatestDropOfforPickup':
            LatestDropOfforPickup_ = child_.text
            LatestDropOfforPickup_ = self.gds_validate_string(LatestDropOfforPickup_, node, 'LatestDropOfforPickup')
            self.LatestDropOfforPickup = LatestDropOfforPickup_
        elif nodeName_ == 'OpenHours':
            OpenHours_ = child_.text
            OpenHours_ = self.gds_validate_string(OpenHours_, node, 'OpenHours')
            self.OpenHours = OpenHours_
        elif nodeName_ == 'CloseHours':
            CloseHours_ = child_.text
            CloseHours_ = self.gds_validate_string(CloseHours_, node, 'CloseHours')
            self.CloseHours = CloseHours_
        elif nodeName_ == 'PrepTime':
            PrepTime_ = child_.text
            PrepTime_ = self.gds_validate_string(PrepTime_, node, 'PrepTime')
            self.PrepTime = PrepTime_
        elif nodeName_ == 'LastDrop':
            LastDrop_ = child_.text
            LastDrop_ = self.gds_validate_string(LastDrop_, node, 'LastDrop')
            self.LastDrop = LastDrop_
# end class DayOfWeekType


class PickupPieceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceCode=None, Quantity=None, DestinationCountryCode=None, ContainerCode=None):
        self.original_tagname_ = None
        self.ServiceCode = ServiceCode
        self.Quantity = Quantity
        self.DestinationCountryCode = DestinationCountryCode
        self.ContainerCode = ContainerCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupPieceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupPieceType.subclass:
            return PickupPieceType.subclass(*args_, **kwargs_)
        else:
            return PickupPieceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceCode(self): return self.ServiceCode
    def set_ServiceCode(self, ServiceCode): self.ServiceCode = ServiceCode
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def get_DestinationCountryCode(self): return self.DestinationCountryCode
    def set_DestinationCountryCode(self, DestinationCountryCode): self.DestinationCountryCode = DestinationCountryCode
    def get_ContainerCode(self): return self.ContainerCode
    def set_ContainerCode(self, ContainerCode): self.ContainerCode = ContainerCode
    def hasContent_(self):
        if (
            self.ServiceCode is not None or
            self.Quantity is not None or
            self.DestinationCountryCode is not None or
            self.ContainerCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupPieceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupPieceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupPieceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupPieceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupPieceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupPieceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ServiceCode>%s</pkup:ServiceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceCode), input_name='ServiceCode')), eol_))
        if self.Quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Quantity>%s</pkup:Quantity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Quantity), input_name='Quantity')), eol_))
        if self.DestinationCountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:DestinationCountryCode>%s</pkup:DestinationCountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationCountryCode), input_name='DestinationCountryCode')), eol_))
        if self.ContainerCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ContainerCode>%s</pkup:ContainerCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ContainerCode), input_name='ContainerCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceCode':
            ServiceCode_ = child_.text
            ServiceCode_ = self.gds_validate_string(ServiceCode_, node, 'ServiceCode')
            self.ServiceCode = ServiceCode_
        elif nodeName_ == 'Quantity':
            Quantity_ = child_.text
            Quantity_ = self.gds_validate_string(Quantity_, node, 'Quantity')
            self.Quantity = Quantity_
        elif nodeName_ == 'DestinationCountryCode':
            DestinationCountryCode_ = child_.text
            DestinationCountryCode_ = self.gds_validate_string(DestinationCountryCode_, node, 'DestinationCountryCode')
            self.DestinationCountryCode = DestinationCountryCode_
        elif nodeName_ == 'ContainerCode':
            ContainerCode_ = child_.text
            ContainerCode_ = self.gds_validate_string(ContainerCode_, node, 'ContainerCode')
            self.ContainerCode = ContainerCode_
# end class PickupPieceType


class PickupPieceServiceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceCode=None, Quantity=None, DestinationCountryCode=None, ContainerCode=None):
        self.original_tagname_ = None
        self.ServiceCode = ServiceCode
        self.Quantity = Quantity
        self.DestinationCountryCode = DestinationCountryCode
        self.ContainerCode = ContainerCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupPieceServiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupPieceServiceType.subclass:
            return PickupPieceServiceType.subclass(*args_, **kwargs_)
        else:
            return PickupPieceServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceCode(self): return self.ServiceCode
    def set_ServiceCode(self, ServiceCode): self.ServiceCode = ServiceCode
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def get_DestinationCountryCode(self): return self.DestinationCountryCode
    def set_DestinationCountryCode(self, DestinationCountryCode): self.DestinationCountryCode = DestinationCountryCode
    def get_ContainerCode(self): return self.ContainerCode
    def set_ContainerCode(self, ContainerCode): self.ContainerCode = ContainerCode
    def hasContent_(self):
        if (
            self.ServiceCode is not None or
            self.Quantity is not None or
            self.DestinationCountryCode is not None or
            self.ContainerCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupPieceServiceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupPieceServiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupPieceServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupPieceServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupPieceServiceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupPieceServiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ServiceCode>%s</pkup:ServiceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceCode), input_name='ServiceCode')), eol_))
        if self.Quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Quantity>%s</pkup:Quantity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Quantity), input_name='Quantity')), eol_))
        if self.DestinationCountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:DestinationCountryCode>%s</pkup:DestinationCountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationCountryCode), input_name='DestinationCountryCode')), eol_))
        if self.ContainerCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ContainerCode>%s</pkup:ContainerCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ContainerCode), input_name='ContainerCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceCode':
            ServiceCode_ = child_.text
            ServiceCode_ = self.gds_validate_string(ServiceCode_, node, 'ServiceCode')
            self.ServiceCode = ServiceCode_
        elif nodeName_ == 'Quantity':
            Quantity_ = child_.text
            Quantity_ = self.gds_validate_string(Quantity_, node, 'Quantity')
            self.Quantity = Quantity_
        elif nodeName_ == 'DestinationCountryCode':
            DestinationCountryCode_ = child_.text
            DestinationCountryCode_ = self.gds_validate_string(DestinationCountryCode_, node, 'DestinationCountryCode')
            self.DestinationCountryCode = DestinationCountryCode_
        elif nodeName_ == 'ContainerCode':
            ContainerCode_ = child_.text
            ContainerCode_ = self.gds_validate_string(ContainerCode_, node, 'ContainerCode')
            self.ContainerCode = ContainerCode_
# end class PickupPieceServiceType


class TodayType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LocalDate=None, LocalTime=None, CallByTime=None, EarliestCloseTime=None, LeadTime=None, GWNIndicator='N'):
        self.original_tagname_ = None
        self.LocalDate = LocalDate
        self.LocalTime = LocalTime
        self.CallByTime = CallByTime
        self.EarliestCloseTime = EarliestCloseTime
        self.LeadTime = LeadTime
        self.GWNIndicator = GWNIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TodayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TodayType.subclass:
            return TodayType.subclass(*args_, **kwargs_)
        else:
            return TodayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocalDate(self): return self.LocalDate
    def set_LocalDate(self, LocalDate): self.LocalDate = LocalDate
    def get_LocalTime(self): return self.LocalTime
    def set_LocalTime(self, LocalTime): self.LocalTime = LocalTime
    def get_CallByTime(self): return self.CallByTime
    def set_CallByTime(self, CallByTime): self.CallByTime = CallByTime
    def get_EarliestCloseTime(self): return self.EarliestCloseTime
    def set_EarliestCloseTime(self, EarliestCloseTime): self.EarliestCloseTime = EarliestCloseTime
    def get_LeadTime(self): return self.LeadTime
    def set_LeadTime(self, LeadTime): self.LeadTime = LeadTime
    def get_GWNIndicator(self): return self.GWNIndicator
    def set_GWNIndicator(self, GWNIndicator): self.GWNIndicator = GWNIndicator
    def hasContent_(self):
        if (
            self.LocalDate is not None or
            self.LocalTime is not None or
            self.CallByTime is not None or
            self.EarliestCloseTime is not None or
            self.LeadTime is not None or
            self.GWNIndicator != "N"
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='TodayType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TodayType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TodayType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='TodayType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='TodayType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='TodayType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocalDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:LocalDate>%s</pkup:LocalDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalDate), input_name='LocalDate')), eol_))
        if self.LocalTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:LocalTime>%s</pkup:LocalTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalTime), input_name='LocalTime')), eol_))
        if self.CallByTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CallByTime>%s</pkup:CallByTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CallByTime), input_name='CallByTime')), eol_))
        if self.EarliestCloseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:EarliestCloseTime>%s</pkup:EarliestCloseTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EarliestCloseTime), input_name='EarliestCloseTime')), eol_))
        if self.LeadTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:LeadTime>%s</pkup:LeadTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LeadTime), input_name='LeadTime')), eol_))
        if self.GWNIndicator != "N":
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:GWNIndicator>%s</pkup:GWNIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GWNIndicator), input_name='GWNIndicator')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocalDate':
            LocalDate_ = child_.text
            LocalDate_ = self.gds_validate_string(LocalDate_, node, 'LocalDate')
            self.LocalDate = LocalDate_
        elif nodeName_ == 'LocalTime':
            LocalTime_ = child_.text
            LocalTime_ = self.gds_validate_string(LocalTime_, node, 'LocalTime')
            self.LocalTime = LocalTime_
        elif nodeName_ == 'CallByTime':
            CallByTime_ = child_.text
            CallByTime_ = self.gds_validate_string(CallByTime_, node, 'CallByTime')
            self.CallByTime = CallByTime_
        elif nodeName_ == 'EarliestCloseTime':
            EarliestCloseTime_ = child_.text
            EarliestCloseTime_ = self.gds_validate_string(EarliestCloseTime_, node, 'EarliestCloseTime')
            self.EarliestCloseTime = EarliestCloseTime_
        elif nodeName_ == 'LeadTime':
            LeadTime_ = child_.text
            LeadTime_ = self.gds_validate_string(LeadTime_, node, 'LeadTime')
            self.LeadTime = LeadTime_
        elif nodeName_ == 'GWNIndicator':
            GWNIndicator_ = child_.text
            GWNIndicator_ = self.gds_validate_string(GWNIndicator_, node, 'GWNIndicator')
            self.GWNIndicator = GWNIndicator_
# end class TodayType


class FutureServiceDateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceDate=None, CallByTime=None, EarliestCloseTime=None, LeadTime=None, GWNIndicator=None):
        self.original_tagname_ = None
        self.ServiceDate = ServiceDate
        self.CallByTime = CallByTime
        self.EarliestCloseTime = EarliestCloseTime
        self.LeadTime = LeadTime
        self.GWNIndicator = GWNIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FutureServiceDateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FutureServiceDateType.subclass:
            return FutureServiceDateType.subclass(*args_, **kwargs_)
        else:
            return FutureServiceDateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceDate(self): return self.ServiceDate
    def set_ServiceDate(self, ServiceDate): self.ServiceDate = ServiceDate
    def get_CallByTime(self): return self.CallByTime
    def set_CallByTime(self, CallByTime): self.CallByTime = CallByTime
    def get_EarliestCloseTime(self): return self.EarliestCloseTime
    def set_EarliestCloseTime(self, EarliestCloseTime): self.EarliestCloseTime = EarliestCloseTime
    def get_LeadTime(self): return self.LeadTime
    def set_LeadTime(self, LeadTime): self.LeadTime = LeadTime
    def get_GWNIndicator(self): return self.GWNIndicator
    def set_GWNIndicator(self, GWNIndicator): self.GWNIndicator = GWNIndicator
    def hasContent_(self):
        if (
            self.ServiceDate is not None or
            self.CallByTime is not None or
            self.EarliestCloseTime is not None or
            self.LeadTime is not None or
            self.GWNIndicator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='FutureServiceDateType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FutureServiceDateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FutureServiceDateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='FutureServiceDateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='FutureServiceDateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='FutureServiceDateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ServiceDate>%s</pkup:ServiceDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceDate), input_name='ServiceDate')), eol_))
        if self.CallByTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CallByTime>%s</pkup:CallByTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CallByTime), input_name='CallByTime')), eol_))
        if self.EarliestCloseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:EarliestCloseTime>%s</pkup:EarliestCloseTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EarliestCloseTime), input_name='EarliestCloseTime')), eol_))
        if self.LeadTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:LeadTime>%s</pkup:LeadTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LeadTime), input_name='LeadTime')), eol_))
        if self.GWNIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:GWNIndicator>%s</pkup:GWNIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GWNIndicator), input_name='GWNIndicator')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceDate':
            ServiceDate_ = child_.text
            ServiceDate_ = self.gds_validate_string(ServiceDate_, node, 'ServiceDate')
            self.ServiceDate = ServiceDate_
        elif nodeName_ == 'CallByTime':
            CallByTime_ = child_.text
            CallByTime_ = self.gds_validate_string(CallByTime_, node, 'CallByTime')
            self.CallByTime = CallByTime_
        elif nodeName_ == 'EarliestCloseTime':
            EarliestCloseTime_ = child_.text
            EarliestCloseTime_ = self.gds_validate_string(EarliestCloseTime_, node, 'EarliestCloseTime')
            self.EarliestCloseTime = EarliestCloseTime_
        elif nodeName_ == 'LeadTime':
            LeadTime_ = child_.text
            LeadTime_ = self.gds_validate_string(LeadTime_, node, 'LeadTime')
            self.LeadTime = LeadTime_
        elif nodeName_ == 'GWNIndicator':
            GWNIndicator_ = child_.text
            GWNIndicator_ = self.gds_validate_string(GWNIndicator_, node, 'GWNIndicator')
            self.GWNIndicator = GWNIndicator_
# end class FutureServiceDateType


class PickupDateInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CloseTime=None, ReadyTime=None, PickupDate=None):
        self.original_tagname_ = None
        self.CloseTime = CloseTime
        self.ReadyTime = ReadyTime
        self.PickupDate = PickupDate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupDateInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupDateInfoType.subclass:
            return PickupDateInfoType.subclass(*args_, **kwargs_)
        else:
            return PickupDateInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CloseTime(self): return self.CloseTime
    def set_CloseTime(self, CloseTime): self.CloseTime = CloseTime
    def get_ReadyTime(self): return self.ReadyTime
    def set_ReadyTime(self, ReadyTime): self.ReadyTime = ReadyTime
    def get_PickupDate(self): return self.PickupDate
    def set_PickupDate(self, PickupDate): self.PickupDate = PickupDate
    def hasContent_(self):
        if (
            self.CloseTime is not None or
            self.ReadyTime is not None or
            self.PickupDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupDateInfoType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupDateInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupDateInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupDateInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupDateInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupDateInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CloseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CloseTime>%s</pkup:CloseTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CloseTime), input_name='CloseTime')), eol_))
        if self.ReadyTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ReadyTime>%s</pkup:ReadyTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReadyTime), input_name='ReadyTime')), eol_))
        if self.PickupDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PickupDate>%s</pkup:PickupDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupDate), input_name='PickupDate')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CloseTime':
            CloseTime_ = child_.text
            CloseTime_ = self.gds_validate_string(CloseTime_, node, 'CloseTime')
            self.CloseTime = CloseTime_
        elif nodeName_ == 'ReadyTime':
            ReadyTime_ = child_.text
            ReadyTime_ = self.gds_validate_string(ReadyTime_, node, 'ReadyTime')
            self.ReadyTime = ReadyTime_
        elif nodeName_ == 'PickupDate':
            PickupDate_ = child_.text
            PickupDate_ = self.gds_validate_string(PickupDate_, node, 'PickupDate')
            self.PickupDate = PickupDate_
# end class PickupDateInfoType


class WeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Weight=None, UnitOfMeasurement=None):
        self.original_tagname_ = None
        self.Weight = Weight
        self.UnitOfMeasurement = UnitOfMeasurement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightType.subclass:
            return WeightType.subclass(*args_, **kwargs_)
        else:
            return WeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_UnitOfMeasurement(self): return self.UnitOfMeasurement
    def set_UnitOfMeasurement(self, UnitOfMeasurement): self.UnitOfMeasurement = UnitOfMeasurement
    def hasContent_(self):
        if (
            self.Weight is not None or
            self.UnitOfMeasurement is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='WeightType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='WeightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='WeightType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='WeightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Weight>%s</pkup:Weight>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Weight), input_name='Weight')), eol_))
        if self.UnitOfMeasurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:UnitOfMeasurement>%s</pkup:UnitOfMeasurement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UnitOfMeasurement), input_name='UnitOfMeasurement')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Weight':
            Weight_ = child_.text
            Weight_ = self.gds_validate_string(Weight_, node, 'Weight')
            self.Weight = Weight_
        elif nodeName_ == 'UnitOfMeasurement':
            UnitOfMeasurement_ = child_.text
            UnitOfMeasurement_ = self.gds_validate_string(UnitOfMeasurement_, node, 'UnitOfMeasurement')
            self.UnitOfMeasurement = UnitOfMeasurement_
# end class WeightType


class ShipperType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Account=None, ChargeCard=None):
        self.original_tagname_ = None
        self.Account = Account
        self.ChargeCard = ChargeCard
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipperType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipperType.subclass:
            return ShipperType.subclass(*args_, **kwargs_)
        else:
            return ShipperType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Account(self): return self.Account
    def set_Account(self, Account): self.Account = Account
    def get_ChargeCard(self): return self.ChargeCard
    def set_ChargeCard(self, ChargeCard): self.ChargeCard = ChargeCard
    def hasContent_(self):
        if (
            self.Account is not None or
            self.ChargeCard is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='ShipperType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipperType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipperType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='ShipperType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='ShipperType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='ShipperType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Account is not None:
            self.Account.export(outfile, level, namespace_, name_='Account', pretty_print=pretty_print)
        if self.ChargeCard is not None:
            self.ChargeCard.export(outfile, level, namespace_, name_='ChargeCard', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Account':
            obj_ = AccountType.factory()
            obj_.build(child_)
            self.Account = obj_
            obj_.original_tagname_ = 'Account'
        elif nodeName_ == 'ChargeCard':
            obj_ = ChargeCardType.factory()
            obj_.build(child_)
            self.ChargeCard = obj_
            obj_.original_tagname_ = 'ChargeCard'
# end class ShipperType


class AccountType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AccountNumber=None, AccountCountryCode=None):
        self.original_tagname_ = None
        self.AccountNumber = AccountNumber
        self.AccountCountryCode = AccountCountryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountType.subclass:
            return AccountType.subclass(*args_, **kwargs_)
        else:
            return AccountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccountNumber(self): return self.AccountNumber
    def set_AccountNumber(self, AccountNumber): self.AccountNumber = AccountNumber
    def get_AccountCountryCode(self): return self.AccountCountryCode
    def set_AccountCountryCode(self, AccountCountryCode): self.AccountCountryCode = AccountCountryCode
    def hasContent_(self):
        if (
            self.AccountNumber is not None or
            self.AccountCountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='AccountType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccountType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='AccountType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='AccountType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='AccountType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:AccountNumber>%s</pkup:AccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AccountNumber), input_name='AccountNumber')), eol_))
        if self.AccountCountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:AccountCountryCode>%s</pkup:AccountCountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AccountCountryCode), input_name='AccountCountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccountNumber':
            AccountNumber_ = child_.text
            AccountNumber_ = self.gds_validate_string(AccountNumber_, node, 'AccountNumber')
            self.AccountNumber = AccountNumber_
        elif nodeName_ == 'AccountCountryCode':
            AccountCountryCode_ = child_.text
            AccountCountryCode_ = self.gds_validate_string(AccountCountryCode_, node, 'AccountCountryCode')
            self.AccountCountryCode = AccountCountryCode_
# end class AccountType


class ChargeCardType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CardHolderName=None, CardType=None, CardNumber=None, ExpirationDate=None, SecurityCode=None, CardAddress=None):
        self.original_tagname_ = None
        self.CardHolderName = CardHolderName
        self.CardType = CardType
        self.CardNumber = CardNumber
        self.ExpirationDate = ExpirationDate
        self.SecurityCode = SecurityCode
        self.CardAddress = CardAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChargeCardType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChargeCardType.subclass:
            return ChargeCardType.subclass(*args_, **kwargs_)
        else:
            return ChargeCardType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CardHolderName(self): return self.CardHolderName
    def set_CardHolderName(self, CardHolderName): self.CardHolderName = CardHolderName
    def get_CardType(self): return self.CardType
    def set_CardType(self, CardType): self.CardType = CardType
    def get_CardNumber(self): return self.CardNumber
    def set_CardNumber(self, CardNumber): self.CardNumber = CardNumber
    def get_ExpirationDate(self): return self.ExpirationDate
    def set_ExpirationDate(self, ExpirationDate): self.ExpirationDate = ExpirationDate
    def get_SecurityCode(self): return self.SecurityCode
    def set_SecurityCode(self, SecurityCode): self.SecurityCode = SecurityCode
    def get_CardAddress(self): return self.CardAddress
    def set_CardAddress(self, CardAddress): self.CardAddress = CardAddress
    def hasContent_(self):
        if (
            self.CardHolderName is not None or
            self.CardType is not None or
            self.CardNumber is not None or
            self.ExpirationDate is not None or
            self.SecurityCode is not None or
            self.CardAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='ChargeCardType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChargeCardType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChargeCardType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='ChargeCardType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='ChargeCardType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='ChargeCardType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CardHolderName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CardHolderName>%s</pkup:CardHolderName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CardHolderName), input_name='CardHolderName')), eol_))
        if self.CardType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CardType>%s</pkup:CardType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CardType), input_name='CardType')), eol_))
        if self.CardNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CardNumber>%s</pkup:CardNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CardNumber), input_name='CardNumber')), eol_))
        if self.ExpirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ExpirationDate>%s</pkup:ExpirationDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ExpirationDate), input_name='ExpirationDate')), eol_))
        if self.SecurityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:SecurityCode>%s</pkup:SecurityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SecurityCode), input_name='SecurityCode')), eol_))
        if self.CardAddress is not None:
            self.CardAddress.export(outfile, level, namespace_, name_='CardAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CardHolderName':
            CardHolderName_ = child_.text
            CardHolderName_ = self.gds_validate_string(CardHolderName_, node, 'CardHolderName')
            self.CardHolderName = CardHolderName_
        elif nodeName_ == 'CardType':
            CardType_ = child_.text
            CardType_ = self.gds_validate_string(CardType_, node, 'CardType')
            self.CardType = CardType_
        elif nodeName_ == 'CardNumber':
            CardNumber_ = child_.text
            CardNumber_ = self.gds_validate_string(CardNumber_, node, 'CardNumber')
            self.CardNumber = CardNumber_
        elif nodeName_ == 'ExpirationDate':
            ExpirationDate_ = child_.text
            ExpirationDate_ = self.gds_validate_string(ExpirationDate_, node, 'ExpirationDate')
            self.ExpirationDate = ExpirationDate_
        elif nodeName_ == 'SecurityCode':
            SecurityCode_ = child_.text
            SecurityCode_ = self.gds_validate_string(SecurityCode_, node, 'SecurityCode')
            self.SecurityCode = SecurityCode_
        elif nodeName_ == 'CardAddress':
            obj_ = ChargeCardAddressType.factory()
            obj_.build(child_)
            self.CardAddress = obj_
            obj_.original_tagname_ = 'CardAddress'
# end class ChargeCardType


class ChargeCardAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AddressLine=None, City=None, StateProvince=None, PostalCode=None, CountryCode=None):
        self.original_tagname_ = None
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.City = City
        self.StateProvince = StateProvince
        self.PostalCode = PostalCode
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChargeCardAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChargeCardAddressType.subclass:
            return ChargeCardAddressType.subclass(*args_, **kwargs_)
        else:
            return ChargeCardAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine_at(self, index, value): self.AddressLine.insert(index, value)
    def replace_AddressLine_at(self, index, value): self.AddressLine[index] = value
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_StateProvince(self): return self.StateProvince
    def set_StateProvince(self, StateProvince): self.StateProvince = StateProvince
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.AddressLine or
            self.City is not None or
            self.StateProvince is not None or
            self.PostalCode is not None or
            self.CountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='ChargeCardAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChargeCardAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChargeCardAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='ChargeCardAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='ChargeCardAddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='ChargeCardAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:AddressLine>%s</pkup:AddressLine>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressLine_), input_name='AddressLine')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:City>%s</pkup:City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.StateProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StateProvince>%s</pkup:StateProvince>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateProvince), input_name='StateProvince')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PostalCode>%s</pkup:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CountryCode>%s</pkup:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressLine':
            AddressLine_ = child_.text
            AddressLine_ = self.gds_validate_string(AddressLine_, node, 'AddressLine')
            self.AddressLine.append(AddressLine_)
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'StateProvince':
            StateProvince_ = child_.text
            StateProvince_ = self.gds_validate_string(StateProvince_, node, 'StateProvince')
            self.StateProvince = StateProvince_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class ChargeCardAddressType


class OriginAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StreetAddress=None, City=None, StateProvince=None, PostalCode=None, CountryCode=None, OriginSearchCriteria=None):
        self.original_tagname_ = None
        self.StreetAddress = StreetAddress
        self.City = City
        self.StateProvince = StateProvince
        self.PostalCode = PostalCode
        self.CountryCode = CountryCode
        self.OriginSearchCriteria = OriginSearchCriteria
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OriginAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OriginAddressType.subclass:
            return OriginAddressType.subclass(*args_, **kwargs_)
        else:
            return OriginAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StreetAddress(self): return self.StreetAddress
    def set_StreetAddress(self, StreetAddress): self.StreetAddress = StreetAddress
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_StateProvince(self): return self.StateProvince
    def set_StateProvince(self, StateProvince): self.StateProvince = StateProvince
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_OriginSearchCriteria(self): return self.OriginSearchCriteria
    def set_OriginSearchCriteria(self, OriginSearchCriteria): self.OriginSearchCriteria = OriginSearchCriteria
    def hasContent_(self):
        if (
            self.StreetAddress is not None or
            self.City is not None or
            self.StateProvince is not None or
            self.PostalCode is not None or
            self.CountryCode is not None or
            self.OriginSearchCriteria is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='OriginAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OriginAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OriginAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='OriginAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='OriginAddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='OriginAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StreetAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StreetAddress>%s</pkup:StreetAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StreetAddress), input_name='StreetAddress')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:City>%s</pkup:City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.StateProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StateProvince>%s</pkup:StateProvince>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateProvince), input_name='StateProvince')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PostalCode>%s</pkup:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CountryCode>%s</pkup:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.OriginSearchCriteria is not None:
            self.OriginSearchCriteria.export(outfile, level, namespace_, name_='OriginSearchCriteria', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StreetAddress':
            StreetAddress_ = child_.text
            StreetAddress_ = self.gds_validate_string(StreetAddress_, node, 'StreetAddress')
            self.StreetAddress = StreetAddress_
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'StateProvince':
            StateProvince_ = child_.text
            StateProvince_ = self.gds_validate_string(StateProvince_, node, 'StateProvince')
            self.StateProvince = StateProvince_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
        elif nodeName_ == 'OriginSearchCriteria':
            obj_ = OriginSearchCriteriaType.factory()
            obj_.build(child_)
            self.OriginSearchCriteria = obj_
            obj_.original_tagname_ = 'OriginSearchCriteria'
# end class OriginAddressType


class DestinationAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, City=None, StateProvince=None, PostalCode=None, CountryCode=None):
        self.original_tagname_ = None
        self.City = City
        self.StateProvince = StateProvince
        self.PostalCode = PostalCode
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DestinationAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DestinationAddressType.subclass:
            return DestinationAddressType.subclass(*args_, **kwargs_)
        else:
            return DestinationAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_StateProvince(self): return self.StateProvince
    def set_StateProvince(self, StateProvince): self.StateProvince = StateProvince
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.City is not None or
            self.StateProvince is not None or
            self.PostalCode is not None or
            self.CountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='DestinationAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DestinationAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestinationAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='DestinationAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='DestinationAddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='DestinationAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:City>%s</pkup:City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.StateProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StateProvince>%s</pkup:StateProvince>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateProvince), input_name='StateProvince')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PostalCode>%s</pkup:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CountryCode>%s</pkup:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'StateProvince':
            StateProvince_ = child_.text
            StateProvince_ = self.gds_validate_string(StateProvince_, node, 'StateProvince')
            self.StateProvince = StateProvince_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class DestinationAddressType


class AddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AddressLine=None, City=None, StateProvince=None, PostalCode=None, CountryCode=None, ResidentialIndicator='N'):
        self.original_tagname_ = None
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.City = City
        self.StateProvince = StateProvince
        self.PostalCode = PostalCode
        self.CountryCode = CountryCode
        self.ResidentialIndicator = ResidentialIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine_at(self, index, value): self.AddressLine.insert(index, value)
    def replace_AddressLine_at(self, index, value): self.AddressLine[index] = value
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_StateProvince(self): return self.StateProvince
    def set_StateProvince(self, StateProvince): self.StateProvince = StateProvince
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_ResidentialIndicator(self): return self.ResidentialIndicator
    def set_ResidentialIndicator(self, ResidentialIndicator): self.ResidentialIndicator = ResidentialIndicator
    def hasContent_(self):
        if (
            self.AddressLine or
            self.City is not None or
            self.StateProvince is not None or
            self.PostalCode is not None or
            self.CountryCode is not None or
            self.ResidentialIndicator != "N"
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='AddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='AddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='AddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:AddressLine>%s</pkup:AddressLine>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressLine_), input_name='AddressLine')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:City>%s</pkup:City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.StateProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StateProvince>%s</pkup:StateProvince>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateProvince), input_name='StateProvince')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PostalCode>%s</pkup:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CountryCode>%s</pkup:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.ResidentialIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ResidentialIndicator>%s</pkup:ResidentialIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ResidentialIndicator), input_name='ResidentialIndicator')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressLine':
            AddressLine_ = child_.text
            AddressLine_ = self.gds_validate_string(AddressLine_, node, 'AddressLine')
            self.AddressLine.append(AddressLine_)
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'StateProvince':
            StateProvince_ = child_.text
            StateProvince_ = self.gds_validate_string(StateProvince_, node, 'StateProvince')
            self.StateProvince = StateProvince_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
        elif nodeName_ == 'ResidentialIndicator':
            ResidentialIndicator_ = child_.text
            ResidentialIndicator_ = self.gds_validate_string(ResidentialIndicator_, node, 'ResidentialIndicator')
            self.ResidentialIndicator = ResidentialIndicator_
# end class AddressType


class PickupAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CompanyName=None, ContactName=None, AddressLine=None, Room=None, Floor=None, City=None, StateProvince=None, Urbanization=None, PostalCode=None, CountryCode=None, ResidentialIndicator='N', PickupPoint=None, Phone=None):
        self.original_tagname_ = None
        self.CompanyName = CompanyName
        self.ContactName = ContactName
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.Room = Room
        self.Floor = Floor
        self.City = City
        self.StateProvince = StateProvince
        self.Urbanization = Urbanization
        self.PostalCode = PostalCode
        self.CountryCode = CountryCode
        self.ResidentialIndicator = ResidentialIndicator
        self.PickupPoint = PickupPoint
        self.Phone = Phone
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupAddressType.subclass:
            return PickupAddressType.subclass(*args_, **kwargs_)
        else:
            return PickupAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompanyName(self): return self.CompanyName
    def set_CompanyName(self, CompanyName): self.CompanyName = CompanyName
    def get_ContactName(self): return self.ContactName
    def set_ContactName(self, ContactName): self.ContactName = ContactName
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine_at(self, index, value): self.AddressLine.insert(index, value)
    def replace_AddressLine_at(self, index, value): self.AddressLine[index] = value
    def get_Room(self): return self.Room
    def set_Room(self, Room): self.Room = Room
    def get_Floor(self): return self.Floor
    def set_Floor(self, Floor): self.Floor = Floor
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_StateProvince(self): return self.StateProvince
    def set_StateProvince(self, StateProvince): self.StateProvince = StateProvince
    def get_Urbanization(self): return self.Urbanization
    def set_Urbanization(self, Urbanization): self.Urbanization = Urbanization
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_ResidentialIndicator(self): return self.ResidentialIndicator
    def set_ResidentialIndicator(self, ResidentialIndicator): self.ResidentialIndicator = ResidentialIndicator
    def get_PickupPoint(self): return self.PickupPoint
    def set_PickupPoint(self, PickupPoint): self.PickupPoint = PickupPoint
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def hasContent_(self):
        if (
            self.CompanyName is not None or
            self.ContactName is not None or
            self.AddressLine or
            self.Room is not None or
            self.Floor is not None or
            self.City is not None or
            self.StateProvince is not None or
            self.Urbanization is not None or
            self.PostalCode is not None or
            self.CountryCode is not None or
            self.ResidentialIndicator != "N" or
            self.PickupPoint is not None or
            self.Phone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PickupAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PickupAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PickupAddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PickupAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompanyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CompanyName>%s</pkup:CompanyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompanyName), input_name='CompanyName')), eol_))
        if self.ContactName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ContactName>%s</pkup:ContactName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ContactName), input_name='ContactName')), eol_))
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:AddressLine>%s</pkup:AddressLine>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressLine_), input_name='AddressLine')), eol_))
        if self.Room is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Room>%s</pkup:Room>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Room), input_name='Room')), eol_))
        if self.Floor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Floor>%s</pkup:Floor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Floor), input_name='Floor')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:City>%s</pkup:City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.StateProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StateProvince>%s</pkup:StateProvince>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateProvince), input_name='StateProvince')), eol_))
        if self.Urbanization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Urbanization>%s</pkup:Urbanization>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Urbanization), input_name='Urbanization')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PostalCode>%s</pkup:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CountryCode>%s</pkup:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.ResidentialIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ResidentialIndicator>%s</pkup:ResidentialIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ResidentialIndicator), input_name='ResidentialIndicator')), eol_))
        if self.PickupPoint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PickupPoint>%s</pkup:PickupPoint>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupPoint), input_name='PickupPoint')), eol_))
        if self.Phone is not None:
            self.Phone.export(outfile, level, namespace_, name_='Phone', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompanyName':
            CompanyName_ = child_.text
            CompanyName_ = self.gds_validate_string(CompanyName_, node, 'CompanyName')
            self.CompanyName = CompanyName_
        elif nodeName_ == 'ContactName':
            ContactName_ = child_.text
            ContactName_ = self.gds_validate_string(ContactName_, node, 'ContactName')
            self.ContactName = ContactName_
        elif nodeName_ == 'AddressLine':
            AddressLine_ = child_.text
            AddressLine_ = self.gds_validate_string(AddressLine_, node, 'AddressLine')
            self.AddressLine.append(AddressLine_)
        elif nodeName_ == 'Room':
            Room_ = child_.text
            Room_ = self.gds_validate_string(Room_, node, 'Room')
            self.Room = Room_
        elif nodeName_ == 'Floor':
            Floor_ = child_.text
            Floor_ = self.gds_validate_string(Floor_, node, 'Floor')
            self.Floor = Floor_
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'StateProvince':
            StateProvince_ = child_.text
            StateProvince_ = self.gds_validate_string(StateProvince_, node, 'StateProvince')
            self.StateProvince = StateProvince_
        elif nodeName_ == 'Urbanization':
            Urbanization_ = child_.text
            Urbanization_ = self.gds_validate_string(Urbanization_, node, 'Urbanization')
            self.Urbanization = Urbanization_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
        elif nodeName_ == 'ResidentialIndicator':
            ResidentialIndicator_ = child_.text
            ResidentialIndicator_ = self.gds_validate_string(ResidentialIndicator_, node, 'ResidentialIndicator')
            self.ResidentialIndicator = ResidentialIndicator_
        elif nodeName_ == 'PickupPoint':
            PickupPoint_ = child_.text
            PickupPoint_ = self.gds_validate_string(PickupPoint_, node, 'PickupPoint')
            self.PickupPoint = PickupPoint_
        elif nodeName_ == 'Phone':
            obj_ = PhoneType.factory()
            obj_.build(child_)
            self.Phone = obj_
            obj_.original_tagname_ = 'Phone'
# end class PickupAddressType


class StreetAddressArtifactType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StreetNumber=None, StreetPrefix=None, StreetName=None, StreetType=None, StreetSuffix=None, UnparsedStreetAddress=None, StreetAddressArtifactSource=None, StreetAddressMatchCode=None):
        self.original_tagname_ = None
        self.StreetNumber = StreetNumber
        self.StreetPrefix = StreetPrefix
        self.StreetName = StreetName
        self.StreetType = StreetType
        self.StreetSuffix = StreetSuffix
        self.UnparsedStreetAddress = UnparsedStreetAddress
        self.StreetAddressArtifactSource = StreetAddressArtifactSource
        self.StreetAddressMatchCode = StreetAddressMatchCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetAddressArtifactType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetAddressArtifactType.subclass:
            return StreetAddressArtifactType.subclass(*args_, **kwargs_)
        else:
            return StreetAddressArtifactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StreetNumber(self): return self.StreetNumber
    def set_StreetNumber(self, StreetNumber): self.StreetNumber = StreetNumber
    def get_StreetPrefix(self): return self.StreetPrefix
    def set_StreetPrefix(self, StreetPrefix): self.StreetPrefix = StreetPrefix
    def get_StreetName(self): return self.StreetName
    def set_StreetName(self, StreetName): self.StreetName = StreetName
    def get_StreetType(self): return self.StreetType
    def set_StreetType(self, StreetType): self.StreetType = StreetType
    def get_StreetSuffix(self): return self.StreetSuffix
    def set_StreetSuffix(self, StreetSuffix): self.StreetSuffix = StreetSuffix
    def get_UnparsedStreetAddress(self): return self.UnparsedStreetAddress
    def set_UnparsedStreetAddress(self, UnparsedStreetAddress): self.UnparsedStreetAddress = UnparsedStreetAddress
    def get_StreetAddressArtifactSource(self): return self.StreetAddressArtifactSource
    def set_StreetAddressArtifactSource(self, StreetAddressArtifactSource): self.StreetAddressArtifactSource = StreetAddressArtifactSource
    def get_StreetAddressMatchCode(self): return self.StreetAddressMatchCode
    def set_StreetAddressMatchCode(self, StreetAddressMatchCode): self.StreetAddressMatchCode = StreetAddressMatchCode
    def hasContent_(self):
        if (
            self.StreetNumber is not None or
            self.StreetPrefix is not None or
            self.StreetName is not None or
            self.StreetType is not None or
            self.StreetSuffix is not None or
            self.UnparsedStreetAddress is not None or
            self.StreetAddressArtifactSource is not None or
            self.StreetAddressMatchCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='StreetAddressArtifactType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreetAddressArtifactType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StreetAddressArtifactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='StreetAddressArtifactType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='StreetAddressArtifactType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='StreetAddressArtifactType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StreetNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StreetNumber>%s</pkup:StreetNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StreetNumber), input_name='StreetNumber')), eol_))
        if self.StreetPrefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StreetPrefix>%s</pkup:StreetPrefix>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StreetPrefix), input_name='StreetPrefix')), eol_))
        if self.StreetName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StreetName>%s</pkup:StreetName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StreetName), input_name='StreetName')), eol_))
        if self.StreetType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StreetType>%s</pkup:StreetType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StreetType), input_name='StreetType')), eol_))
        if self.StreetSuffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StreetSuffix>%s</pkup:StreetSuffix>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StreetSuffix), input_name='StreetSuffix')), eol_))
        if self.UnparsedStreetAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:UnparsedStreetAddress>%s</pkup:UnparsedStreetAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UnparsedStreetAddress), input_name='UnparsedStreetAddress')), eol_))
        if self.StreetAddressArtifactSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StreetAddressArtifactSource>%s</pkup:StreetAddressArtifactSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StreetAddressArtifactSource), input_name='StreetAddressArtifactSource')), eol_))
        if self.StreetAddressMatchCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:StreetAddressMatchCode>%s</pkup:StreetAddressMatchCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StreetAddressMatchCode), input_name='StreetAddressMatchCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StreetNumber':
            StreetNumber_ = child_.text
            StreetNumber_ = self.gds_validate_string(StreetNumber_, node, 'StreetNumber')
            self.StreetNumber = StreetNumber_
        elif nodeName_ == 'StreetPrefix':
            StreetPrefix_ = child_.text
            StreetPrefix_ = self.gds_validate_string(StreetPrefix_, node, 'StreetPrefix')
            self.StreetPrefix = StreetPrefix_
        elif nodeName_ == 'StreetName':
            StreetName_ = child_.text
            StreetName_ = self.gds_validate_string(StreetName_, node, 'StreetName')
            self.StreetName = StreetName_
        elif nodeName_ == 'StreetType':
            StreetType_ = child_.text
            StreetType_ = self.gds_validate_string(StreetType_, node, 'StreetType')
            self.StreetType = StreetType_
        elif nodeName_ == 'StreetSuffix':
            StreetSuffix_ = child_.text
            StreetSuffix_ = self.gds_validate_string(StreetSuffix_, node, 'StreetSuffix')
            self.StreetSuffix = StreetSuffix_
        elif nodeName_ == 'UnparsedStreetAddress':
            UnparsedStreetAddress_ = child_.text
            UnparsedStreetAddress_ = self.gds_validate_string(UnparsedStreetAddress_, node, 'UnparsedStreetAddress')
            self.UnparsedStreetAddress = UnparsedStreetAddress_
        elif nodeName_ == 'StreetAddressArtifactSource':
            StreetAddressArtifactSource_ = child_.text
            StreetAddressArtifactSource_ = self.gds_validate_string(StreetAddressArtifactSource_, node, 'StreetAddressArtifactSource')
            self.StreetAddressArtifactSource = StreetAddressArtifactSource_
        elif nodeName_ == 'StreetAddressMatchCode':
            StreetAddressMatchCode_ = child_.text
            StreetAddressMatchCode_ = self.gds_validate_string(StreetAddressMatchCode_, node, 'StreetAddressMatchCode')
            self.StreetAddressMatchCode = StreetAddressMatchCode_
# end class StreetAddressArtifactType


class PhoneType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Number=None, Extension=None):
        self.original_tagname_ = None
        self.Number = Number
        self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhoneType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhoneType.subclass:
            return PhoneType.subclass(*args_, **kwargs_)
        else:
            return PhoneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def hasContent_(self):
        if (
            self.Number is not None or
            self.Extension is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PhoneType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhoneType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhoneType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PhoneType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PhoneType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PhoneType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Number>%s</pkup:Number>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Number), input_name='Number')), eol_))
        if self.Extension is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Extension>%s</pkup:Extension>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Extension), input_name='Extension')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Number':
            Number_ = child_.text
            Number_ = self.gds_validate_string(Number_, node, 'Number')
            self.Number = Number_
        elif nodeName_ == 'Extension':
            Extension_ = child_.text
            Extension_ = self.gds_validate_string(Extension_, node, 'Extension')
            self.Extension = Extension_
# end class PhoneType


class CSRType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ProfileId=None, ProfileCountryCode=None):
        self.original_tagname_ = None
        self.ProfileId = ProfileId
        self.ProfileCountryCode = ProfileCountryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CSRType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CSRType.subclass:
            return CSRType.subclass(*args_, **kwargs_)
        else:
            return CSRType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProfileId(self): return self.ProfileId
    def set_ProfileId(self, ProfileId): self.ProfileId = ProfileId
    def get_ProfileCountryCode(self): return self.ProfileCountryCode
    def set_ProfileCountryCode(self, ProfileCountryCode): self.ProfileCountryCode = ProfileCountryCode
    def hasContent_(self):
        if (
            self.ProfileId is not None or
            self.ProfileCountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='CSRType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CSRType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CSRType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='CSRType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='CSRType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='CSRType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProfileId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ProfileId>%s</pkup:ProfileId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProfileId), input_name='ProfileId')), eol_))
        if self.ProfileCountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ProfileCountryCode>%s</pkup:ProfileCountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProfileCountryCode), input_name='ProfileCountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProfileId':
            ProfileId_ = child_.text
            ProfileId_ = self.gds_validate_string(ProfileId_, node, 'ProfileId')
            self.ProfileId = ProfileId_
        elif nodeName_ == 'ProfileCountryCode':
            ProfileCountryCode_ = child_.text
            ProfileCountryCode_ = self.gds_validate_string(ProfileCountryCode_, node, 'ProfileCountryCode')
            self.ProfileCountryCode = ProfileCountryCode_
# end class CSRType


class StatusCodeDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StatusCodeDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StatusCodeDescriptionType.subclass:
            return StatusCodeDescriptionType.subclass(*args_, **kwargs_)
        else:
            return StatusCodeDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='StatusCodeDescriptionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StatusCodeDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StatusCodeDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='StatusCodeDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='StatusCodeDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='StatusCodeDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Code>%s</pkup:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Description>%s</pkup:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class StatusCodeDescriptionType


class RateResultType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Disclaimer=None, RateType=None, CurrencyCode=None, ChargeDetail=None, TaxCharges=None, TotalTax=None, GrandTotalOfAllCharge=None, GrandTotalOfAllIncentedCharge=None, PreTaxTotalCharge=None, PreTaxTotalIncentedCharge=None):
        self.original_tagname_ = None
        self.Disclaimer = Disclaimer
        self.RateType = RateType
        self.CurrencyCode = CurrencyCode
        if ChargeDetail is None:
            self.ChargeDetail = []
        else:
            self.ChargeDetail = ChargeDetail
        if TaxCharges is None:
            self.TaxCharges = []
        else:
            self.TaxCharges = TaxCharges
        self.TotalTax = TotalTax
        self.GrandTotalOfAllCharge = GrandTotalOfAllCharge
        self.GrandTotalOfAllIncentedCharge = GrandTotalOfAllIncentedCharge
        self.PreTaxTotalCharge = PreTaxTotalCharge
        self.PreTaxTotalIncentedCharge = PreTaxTotalIncentedCharge
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateResultType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateResultType.subclass:
            return RateResultType.subclass(*args_, **kwargs_)
        else:
            return RateResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Disclaimer(self): return self.Disclaimer
    def set_Disclaimer(self, Disclaimer): self.Disclaimer = Disclaimer
    def get_RateType(self): return self.RateType
    def set_RateType(self, RateType): self.RateType = RateType
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_ChargeDetail(self): return self.ChargeDetail
    def set_ChargeDetail(self, ChargeDetail): self.ChargeDetail = ChargeDetail
    def add_ChargeDetail(self, value): self.ChargeDetail.append(value)
    def insert_ChargeDetail_at(self, index, value): self.ChargeDetail.insert(index, value)
    def replace_ChargeDetail_at(self, index, value): self.ChargeDetail[index] = value
    def get_TaxCharges(self): return self.TaxCharges
    def set_TaxCharges(self, TaxCharges): self.TaxCharges = TaxCharges
    def add_TaxCharges(self, value): self.TaxCharges.append(value)
    def insert_TaxCharges_at(self, index, value): self.TaxCharges.insert(index, value)
    def replace_TaxCharges_at(self, index, value): self.TaxCharges[index] = value
    def get_TotalTax(self): return self.TotalTax
    def set_TotalTax(self, TotalTax): self.TotalTax = TotalTax
    def get_GrandTotalOfAllCharge(self): return self.GrandTotalOfAllCharge
    def set_GrandTotalOfAllCharge(self, GrandTotalOfAllCharge): self.GrandTotalOfAllCharge = GrandTotalOfAllCharge
    def get_GrandTotalOfAllIncentedCharge(self): return self.GrandTotalOfAllIncentedCharge
    def set_GrandTotalOfAllIncentedCharge(self, GrandTotalOfAllIncentedCharge): self.GrandTotalOfAllIncentedCharge = GrandTotalOfAllIncentedCharge
    def get_PreTaxTotalCharge(self): return self.PreTaxTotalCharge
    def set_PreTaxTotalCharge(self, PreTaxTotalCharge): self.PreTaxTotalCharge = PreTaxTotalCharge
    def get_PreTaxTotalIncentedCharge(self): return self.PreTaxTotalIncentedCharge
    def set_PreTaxTotalIncentedCharge(self, PreTaxTotalIncentedCharge): self.PreTaxTotalIncentedCharge = PreTaxTotalIncentedCharge
    def hasContent_(self):
        if (
            self.Disclaimer is not None or
            self.RateType is not None or
            self.CurrencyCode is not None or
            self.ChargeDetail or
            self.TaxCharges or
            self.TotalTax is not None or
            self.GrandTotalOfAllCharge is not None or
            self.GrandTotalOfAllIncentedCharge is not None or
            self.PreTaxTotalCharge is not None or
            self.PreTaxTotalIncentedCharge is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='RateResultType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RateResultType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateResultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='RateResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='RateResultType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='RateResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Disclaimer is not None:
            self.Disclaimer.export(outfile, level, namespace_, name_='Disclaimer', pretty_print=pretty_print)
        if self.RateType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:RateType>%s</pkup:RateType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RateType), input_name='RateType')), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:CurrencyCode>%s</pkup:CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        for ChargeDetail_ in self.ChargeDetail:
            ChargeDetail_.export(outfile, level, namespace_, name_='ChargeDetail', pretty_print=pretty_print)
        for TaxCharges_ in self.TaxCharges:
            TaxCharges_.export(outfile, level, namespace_, name_='TaxCharges', pretty_print=pretty_print)
        if self.TotalTax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:TotalTax>%s</pkup:TotalTax>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TotalTax), input_name='TotalTax')), eol_))
        if self.GrandTotalOfAllCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:GrandTotalOfAllCharge>%s</pkup:GrandTotalOfAllCharge>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GrandTotalOfAllCharge), input_name='GrandTotalOfAllCharge')), eol_))
        if self.GrandTotalOfAllIncentedCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:GrandTotalOfAllIncentedCharge>%s</pkup:GrandTotalOfAllIncentedCharge>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GrandTotalOfAllIncentedCharge), input_name='GrandTotalOfAllIncentedCharge')), eol_))
        if self.PreTaxTotalCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PreTaxTotalCharge>%s</pkup:PreTaxTotalCharge>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PreTaxTotalCharge), input_name='PreTaxTotalCharge')), eol_))
        if self.PreTaxTotalIncentedCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PreTaxTotalIncentedCharge>%s</pkup:PreTaxTotalIncentedCharge>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PreTaxTotalIncentedCharge), input_name='PreTaxTotalIncentedCharge')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Disclaimer':
            obj_ = DisclaimerType.factory()
            obj_.build(child_)
            self.Disclaimer = obj_
            obj_.original_tagname_ = 'Disclaimer'
        elif nodeName_ == 'RateType':
            RateType_ = child_.text
            RateType_ = self.gds_validate_string(RateType_, node, 'RateType')
            self.RateType = RateType_
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
        elif nodeName_ == 'ChargeDetail':
            obj_ = ChargeDetailType.factory()
            obj_.build(child_)
            self.ChargeDetail.append(obj_)
            obj_.original_tagname_ = 'ChargeDetail'
        elif nodeName_ == 'TaxCharges':
            obj_ = TaxChargeType.factory()
            obj_.build(child_)
            self.TaxCharges.append(obj_)
            obj_.original_tagname_ = 'TaxCharges'
        elif nodeName_ == 'TotalTax':
            TotalTax_ = child_.text
            TotalTax_ = self.gds_validate_string(TotalTax_, node, 'TotalTax')
            self.TotalTax = TotalTax_
        elif nodeName_ == 'GrandTotalOfAllCharge':
            GrandTotalOfAllCharge_ = child_.text
            GrandTotalOfAllCharge_ = self.gds_validate_string(GrandTotalOfAllCharge_, node, 'GrandTotalOfAllCharge')
            self.GrandTotalOfAllCharge = GrandTotalOfAllCharge_
        elif nodeName_ == 'GrandTotalOfAllIncentedCharge':
            GrandTotalOfAllIncentedCharge_ = child_.text
            GrandTotalOfAllIncentedCharge_ = self.gds_validate_string(GrandTotalOfAllIncentedCharge_, node, 'GrandTotalOfAllIncentedCharge')
            self.GrandTotalOfAllIncentedCharge = GrandTotalOfAllIncentedCharge_
        elif nodeName_ == 'PreTaxTotalCharge':
            PreTaxTotalCharge_ = child_.text
            PreTaxTotalCharge_ = self.gds_validate_string(PreTaxTotalCharge_, node, 'PreTaxTotalCharge')
            self.PreTaxTotalCharge = PreTaxTotalCharge_
        elif nodeName_ == 'PreTaxTotalIncentedCharge':
            PreTaxTotalIncentedCharge_ = child_.text
            PreTaxTotalIncentedCharge_ = self.gds_validate_string(PreTaxTotalIncentedCharge_, node, 'PreTaxTotalIncentedCharge')
            self.PreTaxTotalIncentedCharge = PreTaxTotalIncentedCharge_
# end class RateResultType


class ChargeDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChargeCode=None, ChargeDescription=None, ChargeAmount=None, IncentedAmount=None, TaxAmount=None):
        self.original_tagname_ = None
        self.ChargeCode = ChargeCode
        self.ChargeDescription = ChargeDescription
        self.ChargeAmount = ChargeAmount
        self.IncentedAmount = IncentedAmount
        self.TaxAmount = TaxAmount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChargeDetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChargeDetailType.subclass:
            return ChargeDetailType.subclass(*args_, **kwargs_)
        else:
            return ChargeDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChargeCode(self): return self.ChargeCode
    def set_ChargeCode(self, ChargeCode): self.ChargeCode = ChargeCode
    def get_ChargeDescription(self): return self.ChargeDescription
    def set_ChargeDescription(self, ChargeDescription): self.ChargeDescription = ChargeDescription
    def get_ChargeAmount(self): return self.ChargeAmount
    def set_ChargeAmount(self, ChargeAmount): self.ChargeAmount = ChargeAmount
    def get_IncentedAmount(self): return self.IncentedAmount
    def set_IncentedAmount(self, IncentedAmount): self.IncentedAmount = IncentedAmount
    def get_TaxAmount(self): return self.TaxAmount
    def set_TaxAmount(self, TaxAmount): self.TaxAmount = TaxAmount
    def hasContent_(self):
        if (
            self.ChargeCode is not None or
            self.ChargeDescription is not None or
            self.ChargeAmount is not None or
            self.IncentedAmount is not None or
            self.TaxAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='ChargeDetailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChargeDetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChargeDetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='ChargeDetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='ChargeDetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='ChargeDetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChargeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ChargeCode>%s</pkup:ChargeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeCode), input_name='ChargeCode')), eol_))
        if self.ChargeDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ChargeDescription>%s</pkup:ChargeDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeDescription), input_name='ChargeDescription')), eol_))
        if self.ChargeAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ChargeAmount>%s</pkup:ChargeAmount>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeAmount), input_name='ChargeAmount')), eol_))
        if self.IncentedAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:IncentedAmount>%s</pkup:IncentedAmount>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IncentedAmount), input_name='IncentedAmount')), eol_))
        if self.TaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:TaxAmount>%s</pkup:TaxAmount>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxAmount), input_name='TaxAmount')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChargeCode':
            ChargeCode_ = child_.text
            ChargeCode_ = self.gds_validate_string(ChargeCode_, node, 'ChargeCode')
            self.ChargeCode = ChargeCode_
        elif nodeName_ == 'ChargeDescription':
            ChargeDescription_ = child_.text
            ChargeDescription_ = self.gds_validate_string(ChargeDescription_, node, 'ChargeDescription')
            self.ChargeDescription = ChargeDescription_
        elif nodeName_ == 'ChargeAmount':
            ChargeAmount_ = child_.text
            ChargeAmount_ = self.gds_validate_string(ChargeAmount_, node, 'ChargeAmount')
            self.ChargeAmount = ChargeAmount_
        elif nodeName_ == 'IncentedAmount':
            IncentedAmount_ = child_.text
            IncentedAmount_ = self.gds_validate_string(IncentedAmount_, node, 'IncentedAmount')
            self.IncentedAmount = IncentedAmount_
        elif nodeName_ == 'TaxAmount':
            TaxAmount_ = child_.text
            TaxAmount_ = self.gds_validate_string(TaxAmount_, node, 'TaxAmount')
            self.TaxAmount = TaxAmount_
# end class ChargeDetailType


class PendingStatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PickupType=None, ServiceDate=None, PRN=None, GWNStatusCode=None, OnCallStatusCode=None, PickupStatusMessage=None, BillingCode=None, ContactName=None, ReferenceNumber=None):
        self.original_tagname_ = None
        self.PickupType = PickupType
        self.ServiceDate = ServiceDate
        self.PRN = PRN
        self.GWNStatusCode = GWNStatusCode
        self.OnCallStatusCode = OnCallStatusCode
        self.PickupStatusMessage = PickupStatusMessage
        self.BillingCode = BillingCode
        self.ContactName = ContactName
        self.ReferenceNumber = ReferenceNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PendingStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PendingStatusType.subclass:
            return PendingStatusType.subclass(*args_, **kwargs_)
        else:
            return PendingStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PickupType(self): return self.PickupType
    def set_PickupType(self, PickupType): self.PickupType = PickupType
    def get_ServiceDate(self): return self.ServiceDate
    def set_ServiceDate(self, ServiceDate): self.ServiceDate = ServiceDate
    def get_PRN(self): return self.PRN
    def set_PRN(self, PRN): self.PRN = PRN
    def get_GWNStatusCode(self): return self.GWNStatusCode
    def set_GWNStatusCode(self, GWNStatusCode): self.GWNStatusCode = GWNStatusCode
    def get_OnCallStatusCode(self): return self.OnCallStatusCode
    def set_OnCallStatusCode(self, OnCallStatusCode): self.OnCallStatusCode = OnCallStatusCode
    def get_PickupStatusMessage(self): return self.PickupStatusMessage
    def set_PickupStatusMessage(self, PickupStatusMessage): self.PickupStatusMessage = PickupStatusMessage
    def get_BillingCode(self): return self.BillingCode
    def set_BillingCode(self, BillingCode): self.BillingCode = BillingCode
    def get_ContactName(self): return self.ContactName
    def set_ContactName(self, ContactName): self.ContactName = ContactName
    def get_ReferenceNumber(self): return self.ReferenceNumber
    def set_ReferenceNumber(self, ReferenceNumber): self.ReferenceNumber = ReferenceNumber
    def hasContent_(self):
        if (
            self.PickupType is not None or
            self.ServiceDate is not None or
            self.PRN is not None or
            self.GWNStatusCode is not None or
            self.OnCallStatusCode is not None or
            self.PickupStatusMessage is not None or
            self.BillingCode is not None or
            self.ContactName is not None or
            self.ReferenceNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PendingStatusType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PendingStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PendingStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PendingStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PendingStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PendingStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PickupType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PickupType>%s</pkup:PickupType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupType), input_name='PickupType')), eol_))
        if self.ServiceDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ServiceDate>%s</pkup:ServiceDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceDate), input_name='ServiceDate')), eol_))
        if self.PRN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PRN>%s</pkup:PRN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PRN), input_name='PRN')), eol_))
        if self.GWNStatusCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:GWNStatusCode>%s</pkup:GWNStatusCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GWNStatusCode), input_name='GWNStatusCode')), eol_))
        if self.OnCallStatusCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:OnCallStatusCode>%s</pkup:OnCallStatusCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OnCallStatusCode), input_name='OnCallStatusCode')), eol_))
        if self.PickupStatusMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:PickupStatusMessage>%s</pkup:PickupStatusMessage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupStatusMessage), input_name='PickupStatusMessage')), eol_))
        if self.BillingCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:BillingCode>%s</pkup:BillingCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BillingCode), input_name='BillingCode')), eol_))
        if self.ContactName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ContactName>%s</pkup:ContactName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ContactName), input_name='ContactName')), eol_))
        if self.ReferenceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ReferenceNumber>%s</pkup:ReferenceNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceNumber), input_name='ReferenceNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PickupType':
            PickupType_ = child_.text
            PickupType_ = self.gds_validate_string(PickupType_, node, 'PickupType')
            self.PickupType = PickupType_
        elif nodeName_ == 'ServiceDate':
            ServiceDate_ = child_.text
            ServiceDate_ = self.gds_validate_string(ServiceDate_, node, 'ServiceDate')
            self.ServiceDate = ServiceDate_
        elif nodeName_ == 'PRN':
            PRN_ = child_.text
            PRN_ = self.gds_validate_string(PRN_, node, 'PRN')
            self.PRN = PRN_
        elif nodeName_ == 'GWNStatusCode':
            GWNStatusCode_ = child_.text
            GWNStatusCode_ = self.gds_validate_string(GWNStatusCode_, node, 'GWNStatusCode')
            self.GWNStatusCode = GWNStatusCode_
        elif nodeName_ == 'OnCallStatusCode':
            OnCallStatusCode_ = child_.text
            OnCallStatusCode_ = self.gds_validate_string(OnCallStatusCode_, node, 'OnCallStatusCode')
            self.OnCallStatusCode = OnCallStatusCode_
        elif nodeName_ == 'PickupStatusMessage':
            PickupStatusMessage_ = child_.text
            PickupStatusMessage_ = self.gds_validate_string(PickupStatusMessage_, node, 'PickupStatusMessage')
            self.PickupStatusMessage = PickupStatusMessage_
        elif nodeName_ == 'BillingCode':
            BillingCode_ = child_.text
            BillingCode_ = self.gds_validate_string(BillingCode_, node, 'BillingCode')
            self.BillingCode = BillingCode_
        elif nodeName_ == 'ContactName':
            ContactName_ = child_.text
            ContactName_ = self.gds_validate_string(ContactName_, node, 'ContactName')
            self.ContactName = ContactName_
        elif nodeName_ == 'ReferenceNumber':
            ReferenceNumber_ = child_.text
            ReferenceNumber_ = self.gds_validate_string(ReferenceNumber_, node, 'ReferenceNumber')
            self.ReferenceNumber = ReferenceNumber_
# end class PendingStatusType


class TrackingDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TrackingNumber=None):
        self.original_tagname_ = None
        self.TrackingNumber = TrackingNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrackingDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrackingDataType.subclass:
            return TrackingDataType.subclass(*args_, **kwargs_)
        else:
            return TrackingDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrackingNumber(self): return self.TrackingNumber
    def set_TrackingNumber(self, TrackingNumber): self.TrackingNumber = TrackingNumber
    def hasContent_(self):
        if (
            self.TrackingNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='TrackingDataType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrackingDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrackingDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='TrackingDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='TrackingDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='TrackingDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrackingNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:TrackingNumber>%s</pkup:TrackingNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TrackingNumber), input_name='TrackingNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrackingNumber':
            TrackingNumber_ = child_.text
            TrackingNumber_ = self.gds_validate_string(TrackingNumber_, node, 'TrackingNumber')
            self.TrackingNumber = TrackingNumber_
# end class TrackingDataType


class TrackingDataWithReferenceNumberType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TrackingNumber=None, ReferenceNumber=None):
        self.original_tagname_ = None
        self.TrackingNumber = TrackingNumber
        if ReferenceNumber is None:
            self.ReferenceNumber = []
        else:
            self.ReferenceNumber = ReferenceNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrackingDataWithReferenceNumberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrackingDataWithReferenceNumberType.subclass:
            return TrackingDataWithReferenceNumberType.subclass(*args_, **kwargs_)
        else:
            return TrackingDataWithReferenceNumberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrackingNumber(self): return self.TrackingNumber
    def set_TrackingNumber(self, TrackingNumber): self.TrackingNumber = TrackingNumber
    def get_ReferenceNumber(self): return self.ReferenceNumber
    def set_ReferenceNumber(self, ReferenceNumber): self.ReferenceNumber = ReferenceNumber
    def add_ReferenceNumber(self, value): self.ReferenceNumber.append(value)
    def insert_ReferenceNumber_at(self, index, value): self.ReferenceNumber.insert(index, value)
    def replace_ReferenceNumber_at(self, index, value): self.ReferenceNumber[index] = value
    def hasContent_(self):
        if (
            self.TrackingNumber is not None or
            self.ReferenceNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='TrackingDataWithReferenceNumberType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrackingDataWithReferenceNumberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrackingDataWithReferenceNumberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='TrackingDataWithReferenceNumberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='TrackingDataWithReferenceNumberType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='TrackingDataWithReferenceNumberType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrackingNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:TrackingNumber>%s</pkup:TrackingNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TrackingNumber), input_name='TrackingNumber')), eol_))
        for ReferenceNumber_ in self.ReferenceNumber:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:ReferenceNumber>%s</pkup:ReferenceNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(ReferenceNumber_), input_name='ReferenceNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrackingNumber':
            TrackingNumber_ = child_.text
            TrackingNumber_ = self.gds_validate_string(TrackingNumber_, node, 'TrackingNumber')
            self.TrackingNumber = TrackingNumber_
        elif nodeName_ == 'ReferenceNumber':
            ReferenceNumber_ = child_.text
            ReferenceNumber_ = self.gds_validate_string(ReferenceNumber_, node, 'ReferenceNumber')
            self.ReferenceNumber.append(ReferenceNumber_)
# end class TrackingDataWithReferenceNumberType


class FreightOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ShipmentServiceOptions=None, OriginServiceCenterCode=None, OriginServiceCountryCode=None, DestinationAddress=None, ShipmentDetail=None):
        self.original_tagname_ = None
        self.ShipmentServiceOptions = ShipmentServiceOptions
        self.OriginServiceCenterCode = OriginServiceCenterCode
        self.OriginServiceCountryCode = OriginServiceCountryCode
        self.DestinationAddress = DestinationAddress
        self.ShipmentDetail = ShipmentDetail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightOptionsType.subclass:
            return FreightOptionsType.subclass(*args_, **kwargs_)
        else:
            return FreightOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShipmentServiceOptions(self): return self.ShipmentServiceOptions
    def set_ShipmentServiceOptions(self, ShipmentServiceOptions): self.ShipmentServiceOptions = ShipmentServiceOptions
    def get_OriginServiceCenterCode(self): return self.OriginServiceCenterCode
    def set_OriginServiceCenterCode(self, OriginServiceCenterCode): self.OriginServiceCenterCode = OriginServiceCenterCode
    def get_OriginServiceCountryCode(self): return self.OriginServiceCountryCode
    def set_OriginServiceCountryCode(self, OriginServiceCountryCode): self.OriginServiceCountryCode = OriginServiceCountryCode
    def get_DestinationAddress(self): return self.DestinationAddress
    def set_DestinationAddress(self, DestinationAddress): self.DestinationAddress = DestinationAddress
    def get_ShipmentDetail(self): return self.ShipmentDetail
    def set_ShipmentDetail(self, ShipmentDetail): self.ShipmentDetail = ShipmentDetail
    def hasContent_(self):
        if (
            self.ShipmentServiceOptions is not None or
            self.OriginServiceCenterCode is not None or
            self.OriginServiceCountryCode is not None or
            self.DestinationAddress is not None or
            self.ShipmentDetail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='FreightOptionsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='FreightOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='FreightOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='FreightOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ShipmentServiceOptions is not None:
            self.ShipmentServiceOptions.export(outfile, level, namespace_, name_='ShipmentServiceOptions', pretty_print=pretty_print)
        if self.OriginServiceCenterCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:OriginServiceCenterCode>%s</pkup:OriginServiceCenterCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginServiceCenterCode), input_name='OriginServiceCenterCode')), eol_))
        if self.OriginServiceCountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:OriginServiceCountryCode>%s</pkup:OriginServiceCountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginServiceCountryCode), input_name='OriginServiceCountryCode')), eol_))
        if self.DestinationAddress is not None:
            self.DestinationAddress.export(outfile, level, namespace_, name_='DestinationAddress', pretty_print=pretty_print)
        if self.ShipmentDetail is not None:
            self.ShipmentDetail.export(outfile, level, namespace_, name_='ShipmentDetail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ShipmentServiceOptions':
            obj_ = ShipmentServiceOptionsType.factory()
            obj_.build(child_)
            self.ShipmentServiceOptions = obj_
            obj_.original_tagname_ = 'ShipmentServiceOptions'
        elif nodeName_ == 'OriginServiceCenterCode':
            OriginServiceCenterCode_ = child_.text
            OriginServiceCenterCode_ = self.gds_validate_string(OriginServiceCenterCode_, node, 'OriginServiceCenterCode')
            self.OriginServiceCenterCode = OriginServiceCenterCode_
        elif nodeName_ == 'OriginServiceCountryCode':
            OriginServiceCountryCode_ = child_.text
            OriginServiceCountryCode_ = self.gds_validate_string(OriginServiceCountryCode_, node, 'OriginServiceCountryCode')
            self.OriginServiceCountryCode = OriginServiceCountryCode_
        elif nodeName_ == 'DestinationAddress':
            obj_ = DestinationAddressType.factory()
            obj_.build(child_)
            self.DestinationAddress = obj_
            obj_.original_tagname_ = 'DestinationAddress'
        elif nodeName_ == 'ShipmentDetail':
            obj_ = ShipmentDetailType.factory()
            obj_.build(child_)
            self.ShipmentDetail = obj_
            obj_.original_tagname_ = 'ShipmentDetail'
# end class FreightOptionsType


class ServiceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceType.subclass:
            return ServiceType.subclass(*args_, **kwargs_)
        else:
            return ServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='ServiceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='ServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='ServiceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='ServiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Code>%s</pkup:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Description>%s</pkup:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class ServiceType


class ShipmentServiceOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OriginLiftGateIndicator=None, DropoffAtUPSFacilityIndicator=None, HoldForPickupIndicator=None):
        self.original_tagname_ = None
        self.OriginLiftGateIndicator = OriginLiftGateIndicator
        self.DropoffAtUPSFacilityIndicator = DropoffAtUPSFacilityIndicator
        self.HoldForPickupIndicator = HoldForPickupIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentServiceOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentServiceOptionsType.subclass:
            return ShipmentServiceOptionsType.subclass(*args_, **kwargs_)
        else:
            return ShipmentServiceOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OriginLiftGateIndicator(self): return self.OriginLiftGateIndicator
    def set_OriginLiftGateIndicator(self, OriginLiftGateIndicator): self.OriginLiftGateIndicator = OriginLiftGateIndicator
    def get_DropoffAtUPSFacilityIndicator(self): return self.DropoffAtUPSFacilityIndicator
    def set_DropoffAtUPSFacilityIndicator(self, DropoffAtUPSFacilityIndicator): self.DropoffAtUPSFacilityIndicator = DropoffAtUPSFacilityIndicator
    def get_HoldForPickupIndicator(self): return self.HoldForPickupIndicator
    def set_HoldForPickupIndicator(self, HoldForPickupIndicator): self.HoldForPickupIndicator = HoldForPickupIndicator
    def hasContent_(self):
        if (
            self.OriginLiftGateIndicator is not None or
            self.DropoffAtUPSFacilityIndicator is not None or
            self.HoldForPickupIndicator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='ShipmentServiceOptionsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentServiceOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentServiceOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='ShipmentServiceOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='ShipmentServiceOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='ShipmentServiceOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OriginLiftGateIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:OriginLiftGateIndicator>%s</pkup:OriginLiftGateIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginLiftGateIndicator), input_name='OriginLiftGateIndicator')), eol_))
        if self.DropoffAtUPSFacilityIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:DropoffAtUPSFacilityIndicator>%s</pkup:DropoffAtUPSFacilityIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DropoffAtUPSFacilityIndicator), input_name='DropoffAtUPSFacilityIndicator')), eol_))
        if self.HoldForPickupIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:HoldForPickupIndicator>%s</pkup:HoldForPickupIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HoldForPickupIndicator), input_name='HoldForPickupIndicator')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OriginLiftGateIndicator':
            OriginLiftGateIndicator_ = child_.text
            OriginLiftGateIndicator_ = self.gds_validate_string(OriginLiftGateIndicator_, node, 'OriginLiftGateIndicator')
            self.OriginLiftGateIndicator = OriginLiftGateIndicator_
        elif nodeName_ == 'DropoffAtUPSFacilityIndicator':
            DropoffAtUPSFacilityIndicator_ = child_.text
            DropoffAtUPSFacilityIndicator_ = self.gds_validate_string(DropoffAtUPSFacilityIndicator_, node, 'DropoffAtUPSFacilityIndicator')
            self.DropoffAtUPSFacilityIndicator = DropoffAtUPSFacilityIndicator_
        elif nodeName_ == 'HoldForPickupIndicator':
            HoldForPickupIndicator_ = child_.text
            HoldForPickupIndicator_ = self.gds_validate_string(HoldForPickupIndicator_, node, 'HoldForPickupIndicator')
            self.HoldForPickupIndicator = HoldForPickupIndicator_
# end class ShipmentServiceOptionsType


class ShipmentDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HazmatIndicator=None, PalletInformation=None):
        self.original_tagname_ = None
        self.HazmatIndicator = HazmatIndicator
        self.PalletInformation = PalletInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentDetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentDetailType.subclass:
            return ShipmentDetailType.subclass(*args_, **kwargs_)
        else:
            return ShipmentDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HazmatIndicator(self): return self.HazmatIndicator
    def set_HazmatIndicator(self, HazmatIndicator): self.HazmatIndicator = HazmatIndicator
    def get_PalletInformation(self): return self.PalletInformation
    def set_PalletInformation(self, PalletInformation): self.PalletInformation = PalletInformation
    def hasContent_(self):
        if (
            self.HazmatIndicator is not None or
            self.PalletInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='ShipmentDetailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentDetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentDetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='ShipmentDetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='ShipmentDetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='ShipmentDetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HazmatIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:HazmatIndicator>%s</pkup:HazmatIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HazmatIndicator), input_name='HazmatIndicator')), eol_))
        if self.PalletInformation is not None:
            self.PalletInformation.export(outfile, level, namespace_, name_='PalletInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HazmatIndicator':
            HazmatIndicator_ = child_.text
            HazmatIndicator_ = self.gds_validate_string(HazmatIndicator_, node, 'HazmatIndicator')
            self.HazmatIndicator = HazmatIndicator_
        elif nodeName_ == 'PalletInformation':
            obj_ = PalletInformationType.factory()
            obj_.build(child_)
            self.PalletInformation = obj_
            obj_.original_tagname_ = 'PalletInformation'
# end class ShipmentDetailType


class PalletInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Dimensions=None):
        self.original_tagname_ = None
        self.Dimensions = Dimensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PalletInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PalletInformationType.subclass:
            return PalletInformationType.subclass(*args_, **kwargs_)
        else:
            return PalletInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dimensions(self): return self.Dimensions
    def set_Dimensions(self, Dimensions): self.Dimensions = Dimensions
    def hasContent_(self):
        if (
            self.Dimensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PalletInformationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PalletInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PalletInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PalletInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PalletInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PalletInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Dimensions is not None:
            self.Dimensions.export(outfile, level, namespace_, name_='Dimensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dimensions':
            obj_ = DimensionsType.factory()
            obj_.build(child_)
            self.Dimensions = obj_
            obj_.original_tagname_ = 'Dimensions'
# end class PalletInformationType


class DimensionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UnitOfMeasurement=None, Length=None, Width=None, Height=None):
        self.original_tagname_ = None
        self.UnitOfMeasurement = UnitOfMeasurement
        self.Length = Length
        self.Width = Width
        self.Height = Height
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DimensionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DimensionsType.subclass:
            return DimensionsType.subclass(*args_, **kwargs_)
        else:
            return DimensionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitOfMeasurement(self): return self.UnitOfMeasurement
    def set_UnitOfMeasurement(self, UnitOfMeasurement): self.UnitOfMeasurement = UnitOfMeasurement
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def hasContent_(self):
        if (
            self.UnitOfMeasurement is not None or
            self.Length is not None or
            self.Width is not None or
            self.Height is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='DimensionsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DimensionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DimensionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='DimensionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='DimensionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='DimensionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UnitOfMeasurement is not None:
            self.UnitOfMeasurement.export(outfile, level, namespace_, name_='UnitOfMeasurement', pretty_print=pretty_print)
        if self.Length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Length>%s</pkup:Length>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Length), input_name='Length')), eol_))
        if self.Width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Width>%s</pkup:Width>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Width), input_name='Width')), eol_))
        if self.Height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Height>%s</pkup:Height>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Height), input_name='Height')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitOfMeasurement':
            obj_ = UnitOfMeasurementType.factory()
            obj_.build(child_)
            self.UnitOfMeasurement = obj_
            obj_.original_tagname_ = 'UnitOfMeasurement'
        elif nodeName_ == 'Length':
            Length_ = child_.text
            Length_ = self.gds_validate_string(Length_, node, 'Length')
            self.Length = Length_
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width = Width_
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height = Height_
# end class DimensionsType


class UnitOfMeasurementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitOfMeasurementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitOfMeasurementType.subclass:
            return UnitOfMeasurementType.subclass(*args_, **kwargs_)
        else:
            return UnitOfMeasurementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='UnitOfMeasurementType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitOfMeasurementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitOfMeasurementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='UnitOfMeasurementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='UnitOfMeasurementType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='UnitOfMeasurementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Code>%s</pkup:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Description>%s</pkup:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class UnitOfMeasurementType


class OriginSearchCriteriaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SearchRadius=None, DistanceUnitOfMeasure=None, MaximumLocation=None):
        self.original_tagname_ = None
        self.SearchRadius = SearchRadius
        self.DistanceUnitOfMeasure = DistanceUnitOfMeasure
        self.MaximumLocation = MaximumLocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OriginSearchCriteriaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OriginSearchCriteriaType.subclass:
            return OriginSearchCriteriaType.subclass(*args_, **kwargs_)
        else:
            return OriginSearchCriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SearchRadius(self): return self.SearchRadius
    def set_SearchRadius(self, SearchRadius): self.SearchRadius = SearchRadius
    def get_DistanceUnitOfMeasure(self): return self.DistanceUnitOfMeasure
    def set_DistanceUnitOfMeasure(self, DistanceUnitOfMeasure): self.DistanceUnitOfMeasure = DistanceUnitOfMeasure
    def get_MaximumLocation(self): return self.MaximumLocation
    def set_MaximumLocation(self, MaximumLocation): self.MaximumLocation = MaximumLocation
    def hasContent_(self):
        if (
            self.SearchRadius is not None or
            self.DistanceUnitOfMeasure is not None or
            self.MaximumLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='OriginSearchCriteriaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OriginSearchCriteriaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OriginSearchCriteriaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='OriginSearchCriteriaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='OriginSearchCriteriaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='OriginSearchCriteriaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SearchRadius is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:SearchRadius>%s</pkup:SearchRadius>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SearchRadius), input_name='SearchRadius')), eol_))
        if self.DistanceUnitOfMeasure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:DistanceUnitOfMeasure>%s</pkup:DistanceUnitOfMeasure>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DistanceUnitOfMeasure), input_name='DistanceUnitOfMeasure')), eol_))
        if self.MaximumLocation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:MaximumLocation>%s</pkup:MaximumLocation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MaximumLocation), input_name='MaximumLocation')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SearchRadius':
            SearchRadius_ = child_.text
            SearchRadius_ = self.gds_validate_string(SearchRadius_, node, 'SearchRadius')
            self.SearchRadius = SearchRadius_
        elif nodeName_ == 'DistanceUnitOfMeasure':
            DistanceUnitOfMeasure_ = child_.text
            DistanceUnitOfMeasure_ = self.gds_validate_string(DistanceUnitOfMeasure_, node, 'DistanceUnitOfMeasure')
            self.DistanceUnitOfMeasure = DistanceUnitOfMeasure_
        elif nodeName_ == 'MaximumLocation':
            MaximumLocation_ = child_.text
            MaximumLocation_ = self.gds_validate_string(MaximumLocation_, node, 'MaximumLocation')
            self.MaximumLocation = MaximumLocation_
# end class OriginSearchCriteriaType


class LocalizedInstructionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Locale=None, Last50ftInstruction=None):
        self.original_tagname_ = None
        self.Locale = Locale
        self.Last50ftInstruction = Last50ftInstruction
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalizedInstructionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalizedInstructionType.subclass:
            return LocalizedInstructionType.subclass(*args_, **kwargs_)
        else:
            return LocalizedInstructionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Locale(self): return self.Locale
    def set_Locale(self, Locale): self.Locale = Locale
    def get_Last50ftInstruction(self): return self.Last50ftInstruction
    def set_Last50ftInstruction(self, Last50ftInstruction): self.Last50ftInstruction = Last50ftInstruction
    def hasContent_(self):
        if (
            self.Locale is not None or
            self.Last50ftInstruction is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='LocalizedInstructionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalizedInstructionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalizedInstructionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='LocalizedInstructionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='LocalizedInstructionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='LocalizedInstructionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Locale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Locale>%s</pkup:Locale>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Locale), input_name='Locale')), eol_))
        if self.Last50ftInstruction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Last50ftInstruction>%s</pkup:Last50ftInstruction>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Last50ftInstruction), input_name='Last50ftInstruction')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Locale':
            Locale_ = child_.text
            Locale_ = self.gds_validate_string(Locale_, node, 'Locale')
            self.Locale = Locale_
        elif nodeName_ == 'Last50ftInstruction':
            Last50ftInstruction_ = child_.text
            Last50ftInstruction_ = self.gds_validate_string(Last50ftInstruction_, node, 'Last50ftInstruction')
            self.Last50ftInstruction = Last50ftInstruction_
# end class LocalizedInstructionType


class DistanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Value=None, UnitOfMeasurement=None):
        self.original_tagname_ = None
        self.Value = Value
        self.UnitOfMeasurement = UnitOfMeasurement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistanceType.subclass:
            return DistanceType.subclass(*args_, **kwargs_)
        else:
            return DistanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_UnitOfMeasurement(self): return self.UnitOfMeasurement
    def set_UnitOfMeasurement(self, UnitOfMeasurement): self.UnitOfMeasurement = UnitOfMeasurement
    def hasContent_(self):
        if (
            self.Value is not None or
            self.UnitOfMeasurement is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='DistanceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DistanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DistanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='DistanceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='DistanceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='DistanceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Value>%s</pkup:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
        if self.UnitOfMeasurement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:UnitOfMeasurement>%s</pkup:UnitOfMeasurement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UnitOfMeasurement), input_name='UnitOfMeasurement')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'UnitOfMeasurement':
            UnitOfMeasurement_ = child_.text
            UnitOfMeasurement_ = self.gds_validate_string(UnitOfMeasurement_, node, 'UnitOfMeasurement')
            self.UnitOfMeasurement = UnitOfMeasurement_
# end class DistanceType


class DisclaimerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DisclaimerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DisclaimerType.subclass:
            return DisclaimerType.subclass(*args_, **kwargs_)
        else:
            return DisclaimerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='DisclaimerType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DisclaimerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DisclaimerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='DisclaimerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='DisclaimerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='DisclaimerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Code>%s</pkup:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Description>%s</pkup:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class DisclaimerType


class TaxChargeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, MonetaryValue=None):
        self.original_tagname_ = None
        self.Type = Type
        self.MonetaryValue = MonetaryValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TaxChargeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TaxChargeType.subclass:
            return TaxChargeType.subclass(*args_, **kwargs_)
        else:
            return TaxChargeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_MonetaryValue(self): return self.MonetaryValue
    def set_MonetaryValue(self, MonetaryValue): self.MonetaryValue = MonetaryValue
    def hasContent_(self):
        if (
            self.Type is not None or
            self.MonetaryValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='TaxChargeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TaxChargeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxChargeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='TaxChargeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='TaxChargeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='TaxChargeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:Type>%s</pkup:Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.MonetaryValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<pkup:MonetaryValue>%s</pkup:MonetaryValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MonetaryValue), input_name='MonetaryValue')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'MonetaryValue':
            MonetaryValue_ = child_.text
            MonetaryValue_ = self.gds_validate_string(MonetaryValue_, node, 'MonetaryValue')
            self.MonetaryValue = MonetaryValue_
# end class TaxChargeType


class ClientInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        self.original_tagname_ = None
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClientInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClientInformationType.subclass:
            return ClientInformationType.subclass(*args_, **kwargs_)
        else:
            return ClientInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property_at(self, index, value): self.Property.insert(index, value)
    def replace_Property_at(self, index, value): self.Property[index] = value
    def hasContent_(self):
        if (
            self.Property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ClientInformationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClientInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClientInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ClientInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ClientInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ClientInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
# end class ClientInformationType


class RequestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RequestOption=None, SubVersion=None, TransactionReference=None):
        self.original_tagname_ = None
        if RequestOption is None:
            self.RequestOption = []
        else:
            self.RequestOption = RequestOption
        self.SubVersion = SubVersion
        self.TransactionReference = TransactionReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestType.subclass:
            return RequestType.subclass(*args_, **kwargs_)
        else:
            return RequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RequestOption(self): return self.RequestOption
    def set_RequestOption(self, RequestOption): self.RequestOption = RequestOption
    def add_RequestOption(self, value): self.RequestOption.append(value)
    def insert_RequestOption_at(self, index, value): self.RequestOption.insert(index, value)
    def replace_RequestOption_at(self, index, value): self.RequestOption[index] = value
    def get_SubVersion(self): return self.SubVersion
    def set_SubVersion(self, SubVersion): self.SubVersion = SubVersion
    def get_TransactionReference(self): return self.TransactionReference
    def set_TransactionReference(self, TransactionReference): self.TransactionReference = TransactionReference
    def hasContent_(self):
        if (
            self.RequestOption or
            self.SubVersion is not None or
            self.TransactionReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='RequestType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='RequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='RequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='RequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RequestOption_ in self.RequestOption:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:RequestOption>%s</common:RequestOption>%s' % (self.gds_encode(self.gds_format_string(quote_xml(RequestOption_), input_name='RequestOption')), eol_))
        if self.SubVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:SubVersion>%s</common:SubVersion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SubVersion), input_name='SubVersion')), eol_))
        if self.TransactionReference is not None:
            self.TransactionReference.export(outfile, level, namespace_, name_='TransactionReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RequestOption':
            RequestOption_ = child_.text
            RequestOption_ = self.gds_validate_string(RequestOption_, node, 'RequestOption')
            self.RequestOption.append(RequestOption_)
        elif nodeName_ == 'SubVersion':
            SubVersion_ = child_.text
            SubVersion_ = self.gds_validate_string(SubVersion_, node, 'SubVersion')
            self.SubVersion = SubVersion_
        elif nodeName_ == 'TransactionReference':
            obj_ = TransactionReferenceType.factory()
            obj_.build(child_)
            self.TransactionReference = obj_
            obj_.original_tagname_ = 'TransactionReference'
# end class RequestType


class TransactionReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomerContext=None, TransactionIdentifier=None):
        self.original_tagname_ = None
        self.CustomerContext = CustomerContext
        self.TransactionIdentifier = TransactionIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransactionReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransactionReferenceType.subclass:
            return TransactionReferenceType.subclass(*args_, **kwargs_)
        else:
            return TransactionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerContext(self): return self.CustomerContext
    def set_CustomerContext(self, CustomerContext): self.CustomerContext = CustomerContext
    def get_TransactionIdentifier(self): return self.TransactionIdentifier
    def set_TransactionIdentifier(self, TransactionIdentifier): self.TransactionIdentifier = TransactionIdentifier
    def hasContent_(self):
        if (
            self.CustomerContext is not None or
            self.TransactionIdentifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='TransactionReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransactionReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransactionReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='TransactionReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='TransactionReferenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='TransactionReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerContext is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:CustomerContext>%s</common:CustomerContext>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerContext), input_name='CustomerContext')), eol_))
        if self.TransactionIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:TransactionIdentifier>%s</common:TransactionIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransactionIdentifier), input_name='TransactionIdentifier')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerContext':
            CustomerContext_ = child_.text
            CustomerContext_ = self.gds_validate_string(CustomerContext_, node, 'CustomerContext')
            self.CustomerContext = CustomerContext_
        elif nodeName_ == 'TransactionIdentifier':
            TransactionIdentifier_ = child_.text
            TransactionIdentifier_ = self.gds_validate_string(TransactionIdentifier_, node, 'TransactionIdentifier')
            self.TransactionIdentifier = TransactionIdentifier_
# end class TransactionReferenceType


class ResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ResponseStatus=None, Alert=None, AlertDetail=None, TransactionReference=None):
        self.original_tagname_ = None
        self.ResponseStatus = ResponseStatus
        if Alert is None:
            self.Alert = []
        else:
            self.Alert = Alert
        if AlertDetail is None:
            self.AlertDetail = []
        else:
            self.AlertDetail = AlertDetail
        self.TransactionReference = TransactionReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseType.subclass:
            return ResponseType.subclass(*args_, **kwargs_)
        else:
            return ResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResponseStatus(self): return self.ResponseStatus
    def set_ResponseStatus(self, ResponseStatus): self.ResponseStatus = ResponseStatus
    def get_Alert(self): return self.Alert
    def set_Alert(self, Alert): self.Alert = Alert
    def add_Alert(self, value): self.Alert.append(value)
    def insert_Alert_at(self, index, value): self.Alert.insert(index, value)
    def replace_Alert_at(self, index, value): self.Alert[index] = value
    def get_AlertDetail(self): return self.AlertDetail
    def set_AlertDetail(self, AlertDetail): self.AlertDetail = AlertDetail
    def add_AlertDetail(self, value): self.AlertDetail.append(value)
    def insert_AlertDetail_at(self, index, value): self.AlertDetail.insert(index, value)
    def replace_AlertDetail_at(self, index, value): self.AlertDetail[index] = value
    def get_TransactionReference(self): return self.TransactionReference
    def set_TransactionReference(self, TransactionReference): self.TransactionReference = TransactionReference
    def hasContent_(self):
        if (
            self.ResponseStatus is not None or
            self.Alert or
            self.AlertDetail or
            self.TransactionReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ResponseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ResponseStatus is not None:
            self.ResponseStatus.export(outfile, level, namespace_, name_='ResponseStatus', pretty_print=pretty_print)
        for Alert_ in self.Alert:
            Alert_.export(outfile, level, namespace_, name_='Alert', pretty_print=pretty_print)
        for AlertDetail_ in self.AlertDetail:
            AlertDetail_.export(outfile, level, namespace_, name_='AlertDetail', pretty_print=pretty_print)
        if self.TransactionReference is not None:
            self.TransactionReference.export(outfile, level, namespace_, name_='TransactionReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResponseStatus':
            obj_ = CodeDescriptionType.factory()
            obj_.build(child_)
            self.ResponseStatus = obj_
            obj_.original_tagname_ = 'ResponseStatus'
        elif nodeName_ == 'Alert':
            obj_ = CodeDescriptionType.factory()
            obj_.build(child_)
            self.Alert.append(obj_)
            obj_.original_tagname_ = 'Alert'
        elif nodeName_ == 'AlertDetail':
            obj_ = DetailType.factory()
            obj_.build(child_)
            self.AlertDetail.append(obj_)
            obj_.original_tagname_ = 'AlertDetail'
        elif nodeName_ == 'TransactionReference':
            obj_ = TransactionReferenceType.factory()
            obj_.build(child_)
            self.TransactionReference = obj_
            obj_.original_tagname_ = 'TransactionReference'
# end class ResponseType


class CodeDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeDescriptionType.subclass:
            return CodeDescriptionType.subclass(*args_, **kwargs_)
        else:
            return CodeDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='CodeDescriptionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CodeDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='CodeDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='CodeDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='CodeDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Code>%s</common:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Description>%s</common:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class CodeDescriptionType


class DetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None, ElementLevelInformation=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
        self.ElementLevelInformation = ElementLevelInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailType.subclass:
            return DetailType.subclass(*args_, **kwargs_)
        else:
            return DetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ElementLevelInformation(self): return self.ElementLevelInformation
    def set_ElementLevelInformation(self, ElementLevelInformation): self.ElementLevelInformation = ElementLevelInformation
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None or
            self.ElementLevelInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='DetailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='DetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='DetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='DetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Code>%s</common:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Description>%s</common:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.ElementLevelInformation is not None:
            self.ElementLevelInformation.export(outfile, level, namespace_, name_='ElementLevelInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'ElementLevelInformation':
            obj_ = ElementLevelInformationType.factory()
            obj_.build(child_)
            self.ElementLevelInformation = obj_
            obj_.original_tagname_ = 'ElementLevelInformation'
# end class DetailType


class ElementLevelInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Level=None, ElementIdentifier=None):
        self.original_tagname_ = None
        self.Level = Level
        if ElementIdentifier is None:
            self.ElementIdentifier = []
        else:
            self.ElementIdentifier = ElementIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementLevelInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementLevelInformationType.subclass:
            return ElementLevelInformationType.subclass(*args_, **kwargs_)
        else:
            return ElementLevelInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    def get_ElementIdentifier(self): return self.ElementIdentifier
    def set_ElementIdentifier(self, ElementIdentifier): self.ElementIdentifier = ElementIdentifier
    def add_ElementIdentifier(self, value): self.ElementIdentifier.append(value)
    def insert_ElementIdentifier_at(self, index, value): self.ElementIdentifier.insert(index, value)
    def replace_ElementIdentifier_at(self, index, value): self.ElementIdentifier[index] = value
    def hasContent_(self):
        if (
            self.Level is not None or
            self.ElementIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ElementLevelInformationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementLevelInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElementLevelInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ElementLevelInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ElementLevelInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ElementLevelInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Level>%s</common:Level>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Level), input_name='Level')), eol_))
        for ElementIdentifier_ in self.ElementIdentifier:
            ElementIdentifier_.export(outfile, level, namespace_, name_='ElementIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Level':
            Level_ = child_.text
            Level_ = self.gds_validate_string(Level_, node, 'Level')
            self.Level = Level_
        elif nodeName_ == 'ElementIdentifier':
            obj_ = ElementIdentifierType.factory()
            obj_.build(child_)
            self.ElementIdentifier.append(obj_)
            obj_.original_tagname_ = 'ElementIdentifier'
# end class ElementLevelInformationType


class ElementIdentifierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Value=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementIdentifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementIdentifierType.subclass:
            return ElementIdentifierType.subclass(*args_, **kwargs_)
        else:
            return ElementIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ElementIdentifierType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementIdentifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElementIdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ElementIdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ElementIdentifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ElementIdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Code>%s</common:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Value>%s</common:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ElementIdentifierType


class PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Key=None, valueOf_=None):
        self.original_tagname_ = None
        self.Key = _cast(None, Key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PropertyType.subclass:
            return PropertyType.subclass(*args_, **kwargs_)
        else:
            return PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pkup:', name_='PropertyType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PropertyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='pkup:', name_='PropertyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pkup:', name_='PropertyType'):
        if self.Key is not None and 'Key' not in already_processed:
            already_processed.add('Key')
            outfile.write(' Key=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Key), input_name='Key')), ))
    def exportChildren(self, outfile, level, namespace_='pkup:', name_='PropertyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Key', node)
        if value is not None and 'Key' not in already_processed:
            already_processed.add('Key')
            self.Key = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PropertyType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PickupGetPoliticalDivision1ListRequest'
        rootClass = PickupGetPoliticalDivision1ListRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:pkup="http://www.ups.com/XMLSchema/XOLTWS/Pickup/v1.1"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PickupGetPoliticalDivision1ListRequest'
        rootClass = PickupGetPoliticalDivision1ListRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PickupGetPoliticalDivision1ListRequest'
        rootClass = PickupGetPoliticalDivision1ListRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:pkup="http://www.ups.com/XMLSchema/XOLTWS/Pickup/v1.1"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PickupGetPoliticalDivision1ListRequest'
        rootClass = PickupGetPoliticalDivision1ListRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from package_pickup import *\n\n')
        sys.stdout.write('import package_pickup as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AccountType",
    "AddressType",
    "CSRType",
    "ChargeCardAddressType",
    "ChargeCardType",
    "ChargeDetailType",
    "ClientInformationType",
    "CodeDescriptionType",
    "DayOfWeekType",
    "DestinationAddressType",
    "DetailType",
    "DimensionsType",
    "DisclaimerType",
    "DistanceType",
    "DropOffFacilitiesType",
    "ElementIdentifierType",
    "ElementLevelInformationType",
    "FacilityTimeType",
    "FreightOptionsType",
    "FutureServiceDateType",
    "LocalizedInstructionType",
    "OriginAddressType",
    "OriginSearchCriteriaType",
    "PalletInformationType",
    "PendingStatusType",
    "PhoneType",
    "PickupAddressType",
    "PickupCancelRequest",
    "PickupCancelResponse",
    "PickupCreationRequest",
    "PickupCreationResponse",
    "PickupDateInfoType",
    "PickupFacilitiesType",
    "PickupGetPoliticalDivision1ListRequest",
    "PickupGetPoliticalDivision1ListResponse",
    "PickupGetServiceCenterFacilitiesRequest",
    "PickupGetServiceCenterFacilitiesResponse",
    "PickupPendingStatusRequest",
    "PickupPendingStatusResponse",
    "PickupPieceServiceType",
    "PickupPieceType",
    "PickupRateRequest",
    "PickupRateResponse",
    "PropertyType",
    "RateResultType",
    "RequestType",
    "ResponseType",
    "ServiceCenterLocationsType",
    "ServiceType",
    "ShipmentDetailType",
    "ShipmentServiceOptionsType",
    "ShipperType",
    "StatusCodeDescriptionType",
    "StreetAddressArtifactType",
    "TaxChargeType",
    "TodayType",
    "TrackingDataType",
    "TrackingDataWithReferenceNumberType",
    "TransactionReferenceType",
    "UnitOfMeasurementType",
    "WeightType"
]
