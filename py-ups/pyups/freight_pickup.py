#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Jun 12 20:13:57 2018 by generateDS.py version 2.29.14.
# Python 3.6.5 (default, May 19 2018, 11:27:13)  [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('-o', 'pyups/freight_pickup.py')
#
# Command line arguments:
#    /UPS/Pickup_Pkg_Gnd/PickupforGROUNDFREIGHTWebService/SCHEMAS-WSDLS/FreightPickupWebServiceSchema.xsd
#
# Command line:
#    generateDS --no-namespace-defs -o "pyups/freight_pickup.py"  /UPS/Pickup_Pkg_Gnd/PickupforGROUNDFREIGHTWebService/SCHEMAS-WSDLS/FreightPickupWebServiceSchema.xsd
#
# Current working directory (os.getcwd()):
#   py_ups
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class FreightPickupRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Request=None, PickupRequestConfirmationNumber=None, DestinationPostalCode=None, DestinationCountryCode=None, Requester=None, ShipFrom=None, ShipTo=None, PickupDate=None, EarliestTimeReady=None, LatestTimeReady=None, ShipmentServiceOptions=None, ShipmentDetail=None, ExistingShipmentID=None, POM=None, PickupInstructions=None, AdditionalComments=None, HandlingInstructions=None, SpecialInstructions=None, DeliveryInstructions=None):
        self.original_tagname_ = None
        self.Request = Request
        self.PickupRequestConfirmationNumber = PickupRequestConfirmationNumber
        self.DestinationPostalCode = DestinationPostalCode
        self.DestinationCountryCode = DestinationCountryCode
        self.Requester = Requester
        self.ShipFrom = ShipFrom
        self.ShipTo = ShipTo
        self.PickupDate = PickupDate
        self.EarliestTimeReady = EarliestTimeReady
        self.LatestTimeReady = LatestTimeReady
        self.ShipmentServiceOptions = ShipmentServiceOptions
        if ShipmentDetail is None:
            self.ShipmentDetail = []
        else:
            self.ShipmentDetail = ShipmentDetail
        self.ExistingShipmentID = ExistingShipmentID
        self.POM = POM
        self.PickupInstructions = PickupInstructions
        self.AdditionalComments = AdditionalComments
        self.HandlingInstructions = HandlingInstructions
        self.SpecialInstructions = SpecialInstructions
        self.DeliveryInstructions = DeliveryInstructions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightPickupRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightPickupRequest.subclass:
            return FreightPickupRequest.subclass(*args_, **kwargs_)
        else:
            return FreightPickupRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_PickupRequestConfirmationNumber(self): return self.PickupRequestConfirmationNumber
    def set_PickupRequestConfirmationNumber(self, PickupRequestConfirmationNumber): self.PickupRequestConfirmationNumber = PickupRequestConfirmationNumber
    def get_DestinationPostalCode(self): return self.DestinationPostalCode
    def set_DestinationPostalCode(self, DestinationPostalCode): self.DestinationPostalCode = DestinationPostalCode
    def get_DestinationCountryCode(self): return self.DestinationCountryCode
    def set_DestinationCountryCode(self, DestinationCountryCode): self.DestinationCountryCode = DestinationCountryCode
    def get_Requester(self): return self.Requester
    def set_Requester(self, Requester): self.Requester = Requester
    def get_ShipFrom(self): return self.ShipFrom
    def set_ShipFrom(self, ShipFrom): self.ShipFrom = ShipFrom
    def get_ShipTo(self): return self.ShipTo
    def set_ShipTo(self, ShipTo): self.ShipTo = ShipTo
    def get_PickupDate(self): return self.PickupDate
    def set_PickupDate(self, PickupDate): self.PickupDate = PickupDate
    def get_EarliestTimeReady(self): return self.EarliestTimeReady
    def set_EarliestTimeReady(self, EarliestTimeReady): self.EarliestTimeReady = EarliestTimeReady
    def get_LatestTimeReady(self): return self.LatestTimeReady
    def set_LatestTimeReady(self, LatestTimeReady): self.LatestTimeReady = LatestTimeReady
    def get_ShipmentServiceOptions(self): return self.ShipmentServiceOptions
    def set_ShipmentServiceOptions(self, ShipmentServiceOptions): self.ShipmentServiceOptions = ShipmentServiceOptions
    def get_ShipmentDetail(self): return self.ShipmentDetail
    def set_ShipmentDetail(self, ShipmentDetail): self.ShipmentDetail = ShipmentDetail
    def add_ShipmentDetail(self, value): self.ShipmentDetail.append(value)
    def insert_ShipmentDetail_at(self, index, value): self.ShipmentDetail.insert(index, value)
    def replace_ShipmentDetail_at(self, index, value): self.ShipmentDetail[index] = value
    def get_ExistingShipmentID(self): return self.ExistingShipmentID
    def set_ExistingShipmentID(self, ExistingShipmentID): self.ExistingShipmentID = ExistingShipmentID
    def get_POM(self): return self.POM
    def set_POM(self, POM): self.POM = POM
    def get_PickupInstructions(self): return self.PickupInstructions
    def set_PickupInstructions(self, PickupInstructions): self.PickupInstructions = PickupInstructions
    def get_AdditionalComments(self): return self.AdditionalComments
    def set_AdditionalComments(self, AdditionalComments): self.AdditionalComments = AdditionalComments
    def get_HandlingInstructions(self): return self.HandlingInstructions
    def set_HandlingInstructions(self, HandlingInstructions): self.HandlingInstructions = HandlingInstructions
    def get_SpecialInstructions(self): return self.SpecialInstructions
    def set_SpecialInstructions(self, SpecialInstructions): self.SpecialInstructions = SpecialInstructions
    def get_DeliveryInstructions(self): return self.DeliveryInstructions
    def set_DeliveryInstructions(self, DeliveryInstructions): self.DeliveryInstructions = DeliveryInstructions
    def hasContent_(self):
        if (
            self.Request is not None or
            self.PickupRequestConfirmationNumber is not None or
            self.DestinationPostalCode is not None or
            self.DestinationCountryCode is not None or
            self.Requester is not None or
            self.ShipFrom is not None or
            self.ShipTo is not None or
            self.PickupDate is not None or
            self.EarliestTimeReady is not None or
            self.LatestTimeReady is not None or
            self.ShipmentServiceOptions is not None or
            self.ShipmentDetail or
            self.ExistingShipmentID is not None or
            self.POM is not None or
            self.PickupInstructions is not None or
            self.AdditionalComments is not None or
            self.HandlingInstructions is not None or
            self.SpecialInstructions is not None or
            self.DeliveryInstructions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='FreightPickupRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightPickupRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightPickupRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='FreightPickupRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='FreightPickupRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='FreightPickupRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_='common:', name_='Request', pretty_print=pretty_print)
        if self.PickupRequestConfirmationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:PickupRequestConfirmationNumber>%s</fpu:PickupRequestConfirmationNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupRequestConfirmationNumber), input_name='PickupRequestConfirmationNumber')), eol_))
        if self.DestinationPostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:DestinationPostalCode>%s</fpu:DestinationPostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationPostalCode), input_name='DestinationPostalCode')), eol_))
        if self.DestinationCountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:DestinationCountryCode>%s</fpu:DestinationCountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationCountryCode), input_name='DestinationCountryCode')), eol_))
        if self.Requester is not None:
            self.Requester.export(outfile, level, namespace_, name_='Requester', pretty_print=pretty_print)
        if self.ShipFrom is not None:
            self.ShipFrom.export(outfile, level, namespace_, name_='ShipFrom', pretty_print=pretty_print)
        if self.ShipTo is not None:
            self.ShipTo.export(outfile, level, namespace_, name_='ShipTo', pretty_print=pretty_print)
        if self.PickupDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:PickupDate>%s</fpu:PickupDate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupDate), input_name='PickupDate')), eol_))
        if self.EarliestTimeReady is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:EarliestTimeReady>%s</fpu:EarliestTimeReady>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EarliestTimeReady), input_name='EarliestTimeReady')), eol_))
        if self.LatestTimeReady is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:LatestTimeReady>%s</fpu:LatestTimeReady>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LatestTimeReady), input_name='LatestTimeReady')), eol_))
        if self.ShipmentServiceOptions is not None:
            self.ShipmentServiceOptions.export(outfile, level, namespace_, name_='ShipmentServiceOptions', pretty_print=pretty_print)
        for ShipmentDetail_ in self.ShipmentDetail:
            ShipmentDetail_.export(outfile, level, namespace_, name_='ShipmentDetail', pretty_print=pretty_print)
        if self.ExistingShipmentID is not None:
            self.ExistingShipmentID.export(outfile, level, namespace_, name_='ExistingShipmentID', pretty_print=pretty_print)
        if self.POM is not None:
            self.POM.export(outfile, level, namespace_, name_='POM', pretty_print=pretty_print)
        if self.PickupInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:PickupInstructions>%s</fpu:PickupInstructions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupInstructions), input_name='PickupInstructions')), eol_))
        if self.AdditionalComments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:AdditionalComments>%s</fpu:AdditionalComments>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AdditionalComments), input_name='AdditionalComments')), eol_))
        if self.HandlingInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:HandlingInstructions>%s</fpu:HandlingInstructions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HandlingInstructions), input_name='HandlingInstructions')), eol_))
        if self.SpecialInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:SpecialInstructions>%s</fpu:SpecialInstructions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialInstructions), input_name='SpecialInstructions')), eol_))
        if self.DeliveryInstructions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:DeliveryInstructions>%s</fpu:DeliveryInstructions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryInstructions), input_name='DeliveryInstructions')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = RequestType.factory()
            obj_.build(child_)
            self.Request = obj_
            obj_.original_tagname_ = 'Request'
        elif nodeName_ == 'PickupRequestConfirmationNumber':
            PickupRequestConfirmationNumber_ = child_.text
            PickupRequestConfirmationNumber_ = self.gds_validate_string(PickupRequestConfirmationNumber_, node, 'PickupRequestConfirmationNumber')
            self.PickupRequestConfirmationNumber = PickupRequestConfirmationNumber_
        elif nodeName_ == 'DestinationPostalCode':
            DestinationPostalCode_ = child_.text
            DestinationPostalCode_ = self.gds_validate_string(DestinationPostalCode_, node, 'DestinationPostalCode')
            self.DestinationPostalCode = DestinationPostalCode_
        elif nodeName_ == 'DestinationCountryCode':
            DestinationCountryCode_ = child_.text
            DestinationCountryCode_ = self.gds_validate_string(DestinationCountryCode_, node, 'DestinationCountryCode')
            self.DestinationCountryCode = DestinationCountryCode_
        elif nodeName_ == 'Requester':
            obj_ = RequesterType.factory()
            obj_.build(child_)
            self.Requester = obj_
            obj_.original_tagname_ = 'Requester'
        elif nodeName_ == 'ShipFrom':
            obj_ = ShipFromType.factory()
            obj_.build(child_)
            self.ShipFrom = obj_
            obj_.original_tagname_ = 'ShipFrom'
        elif nodeName_ == 'ShipTo':
            obj_ = ShipToType.factory()
            obj_.build(child_)
            self.ShipTo = obj_
            obj_.original_tagname_ = 'ShipTo'
        elif nodeName_ == 'PickupDate':
            PickupDate_ = child_.text
            PickupDate_ = self.gds_validate_string(PickupDate_, node, 'PickupDate')
            self.PickupDate = PickupDate_
        elif nodeName_ == 'EarliestTimeReady':
            EarliestTimeReady_ = child_.text
            EarliestTimeReady_ = self.gds_validate_string(EarliestTimeReady_, node, 'EarliestTimeReady')
            self.EarliestTimeReady = EarliestTimeReady_
        elif nodeName_ == 'LatestTimeReady':
            LatestTimeReady_ = child_.text
            LatestTimeReady_ = self.gds_validate_string(LatestTimeReady_, node, 'LatestTimeReady')
            self.LatestTimeReady = LatestTimeReady_
        elif nodeName_ == 'ShipmentServiceOptions':
            obj_ = ShipmentServiceOptionsType.factory()
            obj_.build(child_)
            self.ShipmentServiceOptions = obj_
            obj_.original_tagname_ = 'ShipmentServiceOptions'
        elif nodeName_ == 'ShipmentDetail':
            obj_ = ShipmentDetailType.factory()
            obj_.build(child_)
            self.ShipmentDetail.append(obj_)
            obj_.original_tagname_ = 'ShipmentDetail'
        elif nodeName_ == 'ExistingShipmentID':
            obj_ = ExistingShipmentIDType.factory()
            obj_.build(child_)
            self.ExistingShipmentID = obj_
            obj_.original_tagname_ = 'ExistingShipmentID'
        elif nodeName_ == 'POM':
            obj_ = POMType.factory()
            obj_.build(child_)
            self.POM = obj_
            obj_.original_tagname_ = 'POM'
        elif nodeName_ == 'PickupInstructions':
            PickupInstructions_ = child_.text
            PickupInstructions_ = self.gds_validate_string(PickupInstructions_, node, 'PickupInstructions')
            self.PickupInstructions = PickupInstructions_
        elif nodeName_ == 'AdditionalComments':
            AdditionalComments_ = child_.text
            AdditionalComments_ = self.gds_validate_string(AdditionalComments_, node, 'AdditionalComments')
            self.AdditionalComments = AdditionalComments_
        elif nodeName_ == 'HandlingInstructions':
            HandlingInstructions_ = child_.text
            HandlingInstructions_ = self.gds_validate_string(HandlingInstructions_, node, 'HandlingInstructions')
            self.HandlingInstructions = HandlingInstructions_
        elif nodeName_ == 'SpecialInstructions':
            SpecialInstructions_ = child_.text
            SpecialInstructions_ = self.gds_validate_string(SpecialInstructions_, node, 'SpecialInstructions')
            self.SpecialInstructions = SpecialInstructions_
        elif nodeName_ == 'DeliveryInstructions':
            DeliveryInstructions_ = child_.text
            DeliveryInstructions_ = self.gds_validate_string(DeliveryInstructions_, node, 'DeliveryInstructions')
            self.DeliveryInstructions = DeliveryInstructions_
# end class FreightPickupRequest


class FreightCancelPickupRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Request=None, PickupRequestConfirmationNumber=None):
        self.original_tagname_ = None
        self.Request = Request
        self.PickupRequestConfirmationNumber = PickupRequestConfirmationNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightCancelPickupRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightCancelPickupRequest.subclass:
            return FreightCancelPickupRequest.subclass(*args_, **kwargs_)
        else:
            return FreightCancelPickupRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Request(self): return self.Request
    def set_Request(self, Request): self.Request = Request
    def get_PickupRequestConfirmationNumber(self): return self.PickupRequestConfirmationNumber
    def set_PickupRequestConfirmationNumber(self, PickupRequestConfirmationNumber): self.PickupRequestConfirmationNumber = PickupRequestConfirmationNumber
    def hasContent_(self):
        if (
            self.Request is not None or
            self.PickupRequestConfirmationNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='FreightCancelPickupRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightCancelPickupRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightCancelPickupRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='FreightCancelPickupRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='FreightCancelPickupRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='FreightCancelPickupRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Request is not None:
            self.Request.export(outfile, level, namespace_='common:', name_='Request', pretty_print=pretty_print)
        if self.PickupRequestConfirmationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:PickupRequestConfirmationNumber>%s</fpu:PickupRequestConfirmationNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupRequestConfirmationNumber), input_name='PickupRequestConfirmationNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Request':
            obj_ = RequestType.factory()
            obj_.build(child_)
            self.Request = obj_
            obj_.original_tagname_ = 'Request'
        elif nodeName_ == 'PickupRequestConfirmationNumber':
            PickupRequestConfirmationNumber_ = child_.text
            PickupRequestConfirmationNumber_ = self.gds_validate_string(PickupRequestConfirmationNumber_, node, 'PickupRequestConfirmationNumber')
            self.PickupRequestConfirmationNumber = PickupRequestConfirmationNumber_
# end class FreightCancelPickupRequest


class FreightPickupResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, PickupRequestConfirmationNumber=None):
        self.original_tagname_ = None
        self.Response = Response
        self.PickupRequestConfirmationNumber = PickupRequestConfirmationNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightPickupResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightPickupResponse.subclass:
            return FreightPickupResponse.subclass(*args_, **kwargs_)
        else:
            return FreightPickupResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_PickupRequestConfirmationNumber(self): return self.PickupRequestConfirmationNumber
    def set_PickupRequestConfirmationNumber(self, PickupRequestConfirmationNumber): self.PickupRequestConfirmationNumber = PickupRequestConfirmationNumber
    def hasContent_(self):
        if (
            self.Response is not None or
            self.PickupRequestConfirmationNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='FreightPickupResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightPickupResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightPickupResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='FreightPickupResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='FreightPickupResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='FreightPickupResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_='common:', name_='Response', pretty_print=pretty_print)
        if self.PickupRequestConfirmationNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:PickupRequestConfirmationNumber>%s</fpu:PickupRequestConfirmationNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupRequestConfirmationNumber), input_name='PickupRequestConfirmationNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'PickupRequestConfirmationNumber':
            PickupRequestConfirmationNumber_ = child_.text
            PickupRequestConfirmationNumber_ = self.gds_validate_string(PickupRequestConfirmationNumber_, node, 'PickupRequestConfirmationNumber')
            self.PickupRequestConfirmationNumber = PickupRequestConfirmationNumber_
# end class FreightPickupResponse


class FreightCancelPickupResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, FreightCancelStatus=None):
        self.original_tagname_ = None
        self.Response = Response
        self.FreightCancelStatus = FreightCancelStatus
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreightCancelPickupResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreightCancelPickupResponse.subclass:
            return FreightCancelPickupResponse.subclass(*args_, **kwargs_)
        else:
            return FreightCancelPickupResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_FreightCancelStatus(self): return self.FreightCancelStatus
    def set_FreightCancelStatus(self, FreightCancelStatus): self.FreightCancelStatus = FreightCancelStatus
    def hasContent_(self):
        if (
            self.Response is not None or
            self.FreightCancelStatus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='FreightCancelPickupResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreightCancelPickupResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreightCancelPickupResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='FreightCancelPickupResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='FreightCancelPickupResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='FreightCancelPickupResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_='common:', name_='Response', pretty_print=pretty_print)
        if self.FreightCancelStatus is not None:
            self.FreightCancelStatus.export(outfile, level, namespace_, name_='FreightCancelStatus', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'FreightCancelStatus':
            obj_ = CancelStatusCodeDescriptionType.factory()
            obj_.build(child_)
            self.FreightCancelStatus = obj_
            obj_.original_tagname_ = 'FreightCancelStatus'
# end class FreightCancelPickupResponse


class RequesterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ThirdPartyIndicator=None, AttentionName=None, EMailAddress=None, Name=None, Phone=None):
        self.original_tagname_ = None
        self.ThirdPartyIndicator = ThirdPartyIndicator
        self.AttentionName = AttentionName
        self.EMailAddress = EMailAddress
        self.Name = Name
        self.Phone = Phone
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequesterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequesterType.subclass:
            return RequesterType.subclass(*args_, **kwargs_)
        else:
            return RequesterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ThirdPartyIndicator(self): return self.ThirdPartyIndicator
    def set_ThirdPartyIndicator(self, ThirdPartyIndicator): self.ThirdPartyIndicator = ThirdPartyIndicator
    def get_AttentionName(self): return self.AttentionName
    def set_AttentionName(self, AttentionName): self.AttentionName = AttentionName
    def get_EMailAddress(self): return self.EMailAddress
    def set_EMailAddress(self, EMailAddress): self.EMailAddress = EMailAddress
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def hasContent_(self):
        if (
            self.ThirdPartyIndicator is not None or
            self.AttentionName is not None or
            self.EMailAddress is not None or
            self.Name is not None or
            self.Phone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='RequesterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequesterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequesterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='RequesterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='RequesterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='RequesterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ThirdPartyIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:ThirdPartyIndicator>%s</fpu:ThirdPartyIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ThirdPartyIndicator), input_name='ThirdPartyIndicator')), eol_))
        if self.AttentionName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:AttentionName>%s</fpu:AttentionName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AttentionName), input_name='AttentionName')), eol_))
        if self.EMailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:EMailAddress>%s</fpu:EMailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EMailAddress), input_name='EMailAddress')), eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Name>%s</fpu:Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.Phone is not None:
            self.Phone.export(outfile, level, namespace_, name_='Phone', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ThirdPartyIndicator':
            ThirdPartyIndicator_ = child_.text
            ThirdPartyIndicator_ = self.gds_validate_string(ThirdPartyIndicator_, node, 'ThirdPartyIndicator')
            self.ThirdPartyIndicator = ThirdPartyIndicator_
        elif nodeName_ == 'AttentionName':
            AttentionName_ = child_.text
            AttentionName_ = self.gds_validate_string(AttentionName_, node, 'AttentionName')
            self.AttentionName = AttentionName_
        elif nodeName_ == 'EMailAddress':
            EMailAddress_ = child_.text
            EMailAddress_ = self.gds_validate_string(EMailAddress_, node, 'EMailAddress')
            self.EMailAddress = EMailAddress_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Phone':
            obj_ = PhoneType.factory()
            obj_.build(child_)
            self.Phone = obj_
            obj_.original_tagname_ = 'Phone'
# end class RequesterType


class AddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AddressLine=None, City=None, StateProvinceCode=None, PostalCode=None, CountryCode=None):
        self.original_tagname_ = None
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.City = City
        self.StateProvinceCode = StateProvinceCode
        self.PostalCode = PostalCode
        self.CountryCode = CountryCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine_at(self, index, value): self.AddressLine.insert(index, value)
    def replace_AddressLine_at(self, index, value): self.AddressLine[index] = value
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_StateProvinceCode(self): return self.StateProvinceCode
    def set_StateProvinceCode(self, StateProvinceCode): self.StateProvinceCode = StateProvinceCode
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def hasContent_(self):
        if (
            self.AddressLine or
            self.City is not None or
            self.StateProvinceCode is not None or
            self.PostalCode is not None or
            self.CountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='AddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='AddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='AddressType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:AddressLine>%s</fpu:AddressLine>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressLine_), input_name='AddressLine')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:City>%s</fpu:City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.StateProvinceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:StateProvinceCode>%s</fpu:StateProvinceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateProvinceCode), input_name='StateProvinceCode')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:PostalCode>%s</fpu:PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:CountryCode>%s</fpu:CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressLine':
            AddressLine_ = child_.text
            AddressLine_ = self.gds_validate_string(AddressLine_, node, 'AddressLine')
            self.AddressLine.append(AddressLine_)
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
        elif nodeName_ == 'StateProvinceCode':
            StateProvinceCode_ = child_.text
            StateProvinceCode_ = self.gds_validate_string(StateProvinceCode_, node, 'StateProvinceCode')
            self.StateProvinceCode = StateProvinceCode_
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
# end class AddressType


class PhoneType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Number=None, Extension=None):
        self.original_tagname_ = None
        self.Number = Number
        self.Extension = Extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhoneType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhoneType.subclass:
            return PhoneType.subclass(*args_, **kwargs_)
        else:
            return PhoneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def hasContent_(self):
        if (
            self.Number is not None or
            self.Extension is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='PhoneType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhoneType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhoneType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='PhoneType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='PhoneType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='PhoneType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Number>%s</fpu:Number>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Number), input_name='Number')), eol_))
        if self.Extension is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Extension>%s</fpu:Extension>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Extension), input_name='Extension')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Number':
            Number_ = child_.text
            Number_ = self.gds_validate_string(Number_, node, 'Number')
            self.Number = Number_
        elif nodeName_ == 'Extension':
            Extension_ = child_.text
            Extension_ = self.gds_validate_string(Extension_, node, 'Extension')
            self.Extension = Extension_
# end class PhoneType


class ShipFromType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AttentionName=None, Name=None, Address=None, Phone=None, EMailAddress=None):
        self.original_tagname_ = None
        self.AttentionName = AttentionName
        self.Name = Name
        self.Address = Address
        self.Phone = Phone
        self.EMailAddress = EMailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipFromType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipFromType.subclass:
            return ShipFromType.subclass(*args_, **kwargs_)
        else:
            return ShipFromType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttentionName(self): return self.AttentionName
    def set_AttentionName(self, AttentionName): self.AttentionName = AttentionName
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_EMailAddress(self): return self.EMailAddress
    def set_EMailAddress(self, EMailAddress): self.EMailAddress = EMailAddress
    def hasContent_(self):
        if (
            self.AttentionName is not None or
            self.Name is not None or
            self.Address is not None or
            self.Phone is not None or
            self.EMailAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='ShipFromType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipFromType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipFromType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='ShipFromType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='ShipFromType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='ShipFromType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AttentionName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:AttentionName>%s</fpu:AttentionName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AttentionName), input_name='AttentionName')), eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Name>%s</fpu:Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        if self.Phone is not None:
            self.Phone.export(outfile, level, namespace_, name_='Phone', pretty_print=pretty_print)
        if self.EMailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:EMailAddress>%s</fpu:EMailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EMailAddress), input_name='EMailAddress')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttentionName':
            AttentionName_ = child_.text
            AttentionName_ = self.gds_validate_string(AttentionName_, node, 'AttentionName')
            self.AttentionName = AttentionName_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Phone':
            obj_ = PhoneType.factory()
            obj_.build(child_)
            self.Phone = obj_
            obj_.original_tagname_ = 'Phone'
        elif nodeName_ == 'EMailAddress':
            EMailAddress_ = child_.text
            EMailAddress_ = self.gds_validate_string(EMailAddress_, node, 'EMailAddress')
            self.EMailAddress = EMailAddress_
# end class ShipFromType


class ShipToType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AttentionName=None, Address=None, Phone=None, EMailAddress=None):
        self.original_tagname_ = None
        self.AttentionName = AttentionName
        self.Address = Address
        self.Phone = Phone
        self.EMailAddress = EMailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipToType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipToType.subclass:
            return ShipToType.subclass(*args_, **kwargs_)
        else:
            return ShipToType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttentionName(self): return self.AttentionName
    def set_AttentionName(self, AttentionName): self.AttentionName = AttentionName
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_EMailAddress(self): return self.EMailAddress
    def set_EMailAddress(self, EMailAddress): self.EMailAddress = EMailAddress
    def hasContent_(self):
        if (
            self.AttentionName is not None or
            self.Address is not None or
            self.Phone is not None or
            self.EMailAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='ShipToType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipToType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipToType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='ShipToType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='ShipToType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='ShipToType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AttentionName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:AttentionName>%s</fpu:AttentionName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AttentionName), input_name='AttentionName')), eol_))
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        if self.Phone is not None:
            self.Phone.export(outfile, level, namespace_, name_='Phone', pretty_print=pretty_print)
        if self.EMailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:EMailAddress>%s</fpu:EMailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EMailAddress), input_name='EMailAddress')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttentionName':
            AttentionName_ = child_.text
            AttentionName_ = self.gds_validate_string(AttentionName_, node, 'AttentionName')
            self.AttentionName = AttentionName_
        elif nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Phone':
            obj_ = PhoneType.factory()
            obj_.build(child_)
            self.Phone = obj_
            obj_.original_tagname_ = 'Phone'
        elif nodeName_ == 'EMailAddress':
            EMailAddress_ = child_.text
            EMailAddress_ = self.gds_validate_string(EMailAddress_, node, 'EMailAddress')
            self.EMailAddress = EMailAddress_
# end class ShipToType


class ShipmentServiceOptionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FreezableProtectionIndicator=None, LimitedAccessPickupIndicator=None, LimitedAccessDeliveryIndicator=None, ExtremeLengthIndicator=None):
        self.original_tagname_ = None
        self.FreezableProtectionIndicator = FreezableProtectionIndicator
        self.LimitedAccessPickupIndicator = LimitedAccessPickupIndicator
        self.LimitedAccessDeliveryIndicator = LimitedAccessDeliveryIndicator
        self.ExtremeLengthIndicator = ExtremeLengthIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentServiceOptionsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentServiceOptionsType.subclass:
            return ShipmentServiceOptionsType.subclass(*args_, **kwargs_)
        else:
            return ShipmentServiceOptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreezableProtectionIndicator(self): return self.FreezableProtectionIndicator
    def set_FreezableProtectionIndicator(self, FreezableProtectionIndicator): self.FreezableProtectionIndicator = FreezableProtectionIndicator
    def get_LimitedAccessPickupIndicator(self): return self.LimitedAccessPickupIndicator
    def set_LimitedAccessPickupIndicator(self, LimitedAccessPickupIndicator): self.LimitedAccessPickupIndicator = LimitedAccessPickupIndicator
    def get_LimitedAccessDeliveryIndicator(self): return self.LimitedAccessDeliveryIndicator
    def set_LimitedAccessDeliveryIndicator(self, LimitedAccessDeliveryIndicator): self.LimitedAccessDeliveryIndicator = LimitedAccessDeliveryIndicator
    def get_ExtremeLengthIndicator(self): return self.ExtremeLengthIndicator
    def set_ExtremeLengthIndicator(self, ExtremeLengthIndicator): self.ExtremeLengthIndicator = ExtremeLengthIndicator
    def hasContent_(self):
        if (
            self.FreezableProtectionIndicator is not None or
            self.LimitedAccessPickupIndicator is not None or
            self.LimitedAccessDeliveryIndicator is not None or
            self.ExtremeLengthIndicator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='ShipmentServiceOptionsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentServiceOptionsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentServiceOptionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='ShipmentServiceOptionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='ShipmentServiceOptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='ShipmentServiceOptionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FreezableProtectionIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:FreezableProtectionIndicator>%s</fpu:FreezableProtectionIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FreezableProtectionIndicator), input_name='FreezableProtectionIndicator')), eol_))
        if self.LimitedAccessPickupIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:LimitedAccessPickupIndicator>%s</fpu:LimitedAccessPickupIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LimitedAccessPickupIndicator), input_name='LimitedAccessPickupIndicator')), eol_))
        if self.LimitedAccessDeliveryIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:LimitedAccessDeliveryIndicator>%s</fpu:LimitedAccessDeliveryIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LimitedAccessDeliveryIndicator), input_name='LimitedAccessDeliveryIndicator')), eol_))
        if self.ExtremeLengthIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:ExtremeLengthIndicator>%s</fpu:ExtremeLengthIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ExtremeLengthIndicator), input_name='ExtremeLengthIndicator')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreezableProtectionIndicator':
            FreezableProtectionIndicator_ = child_.text
            FreezableProtectionIndicator_ = self.gds_validate_string(FreezableProtectionIndicator_, node, 'FreezableProtectionIndicator')
            self.FreezableProtectionIndicator = FreezableProtectionIndicator_
        elif nodeName_ == 'LimitedAccessPickupIndicator':
            LimitedAccessPickupIndicator_ = child_.text
            LimitedAccessPickupIndicator_ = self.gds_validate_string(LimitedAccessPickupIndicator_, node, 'LimitedAccessPickupIndicator')
            self.LimitedAccessPickupIndicator = LimitedAccessPickupIndicator_
        elif nodeName_ == 'LimitedAccessDeliveryIndicator':
            LimitedAccessDeliveryIndicator_ = child_.text
            LimitedAccessDeliveryIndicator_ = self.gds_validate_string(LimitedAccessDeliveryIndicator_, node, 'LimitedAccessDeliveryIndicator')
            self.LimitedAccessDeliveryIndicator = LimitedAccessDeliveryIndicator_
        elif nodeName_ == 'ExtremeLengthIndicator':
            ExtremeLengthIndicator_ = child_.text
            ExtremeLengthIndicator_ = self.gds_validate_string(ExtremeLengthIndicator_, node, 'ExtremeLengthIndicator')
            self.ExtremeLengthIndicator = ExtremeLengthIndicator_
# end class ShipmentServiceOptionsType


class ShipmentDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HazmatIndicator=None, PackagingType=None, NumberOfPieces=None, DescriptionOfCommodity=None, Weight=None):
        self.original_tagname_ = None
        self.HazmatIndicator = HazmatIndicator
        self.PackagingType = PackagingType
        self.NumberOfPieces = NumberOfPieces
        self.DescriptionOfCommodity = DescriptionOfCommodity
        self.Weight = Weight
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentDetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentDetailType.subclass:
            return ShipmentDetailType.subclass(*args_, **kwargs_)
        else:
            return ShipmentDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HazmatIndicator(self): return self.HazmatIndicator
    def set_HazmatIndicator(self, HazmatIndicator): self.HazmatIndicator = HazmatIndicator
    def get_PackagingType(self): return self.PackagingType
    def set_PackagingType(self, PackagingType): self.PackagingType = PackagingType
    def get_NumberOfPieces(self): return self.NumberOfPieces
    def set_NumberOfPieces(self, NumberOfPieces): self.NumberOfPieces = NumberOfPieces
    def get_DescriptionOfCommodity(self): return self.DescriptionOfCommodity
    def set_DescriptionOfCommodity(self, DescriptionOfCommodity): self.DescriptionOfCommodity = DescriptionOfCommodity
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def hasContent_(self):
        if (
            self.HazmatIndicator is not None or
            self.PackagingType is not None or
            self.NumberOfPieces is not None or
            self.DescriptionOfCommodity is not None or
            self.Weight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='ShipmentDetailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentDetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentDetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='ShipmentDetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='ShipmentDetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='ShipmentDetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HazmatIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:HazmatIndicator>%s</fpu:HazmatIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HazmatIndicator), input_name='HazmatIndicator')), eol_))
        if self.PackagingType is not None:
            self.PackagingType.export(outfile, level, namespace_, name_='PackagingType', pretty_print=pretty_print)
        if self.NumberOfPieces is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:NumberOfPieces>%s</fpu:NumberOfPieces>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NumberOfPieces), input_name='NumberOfPieces')), eol_))
        if self.DescriptionOfCommodity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:DescriptionOfCommodity>%s</fpu:DescriptionOfCommodity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DescriptionOfCommodity), input_name='DescriptionOfCommodity')), eol_))
        if self.Weight is not None:
            self.Weight.export(outfile, level, namespace_, name_='Weight', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HazmatIndicator':
            HazmatIndicator_ = child_.text
            HazmatIndicator_ = self.gds_validate_string(HazmatIndicator_, node, 'HazmatIndicator')
            self.HazmatIndicator = HazmatIndicator_
        elif nodeName_ == 'PackagingType':
            obj_ = PickupCodeDescriptionType.factory()
            obj_.build(child_)
            self.PackagingType = obj_
            obj_.original_tagname_ = 'PackagingType'
        elif nodeName_ == 'NumberOfPieces':
            NumberOfPieces_ = child_.text
            NumberOfPieces_ = self.gds_validate_string(NumberOfPieces_, node, 'NumberOfPieces')
            self.NumberOfPieces = NumberOfPieces_
        elif nodeName_ == 'DescriptionOfCommodity':
            DescriptionOfCommodity_ = child_.text
            DescriptionOfCommodity_ = self.gds_validate_string(DescriptionOfCommodity_, node, 'DescriptionOfCommodity')
            self.DescriptionOfCommodity = DescriptionOfCommodity_
        elif nodeName_ == 'Weight':
            obj_ = WeightType.factory()
            obj_.build(child_)
            self.Weight = obj_
            obj_.original_tagname_ = 'Weight'
# end class ShipmentDetailType


class PickupCodeDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupCodeDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupCodeDescriptionType.subclass:
            return PickupCodeDescriptionType.subclass(*args_, **kwargs_)
        else:
            return PickupCodeDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='PickupCodeDescriptionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupCodeDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupCodeDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='PickupCodeDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='PickupCodeDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='PickupCodeDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Code>%s</fpu:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Description>%s</fpu:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class PickupCodeDescriptionType


class POMType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, POMNumber=None, POMNumberType=None, PickupNotifications=None):
        self.original_tagname_ = None
        self.POMNumber = POMNumber
        self.POMNumberType = POMNumberType
        self.PickupNotifications = PickupNotifications
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POMType.subclass:
            return POMType.subclass(*args_, **kwargs_)
        else:
            return POMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_POMNumber(self): return self.POMNumber
    def set_POMNumber(self, POMNumber): self.POMNumber = POMNumber
    def get_POMNumberType(self): return self.POMNumberType
    def set_POMNumberType(self, POMNumberType): self.POMNumberType = POMNumberType
    def get_PickupNotifications(self): return self.PickupNotifications
    def set_PickupNotifications(self, PickupNotifications): self.PickupNotifications = PickupNotifications
    def hasContent_(self):
        if (
            self.POMNumber is not None or
            self.POMNumberType is not None or
            self.PickupNotifications is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='POMType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POMType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='POMType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='POMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='POMType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='POMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.POMNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:POMNumber>%s</fpu:POMNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.POMNumber), input_name='POMNumber')), eol_))
        if self.POMNumberType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:POMNumberType>%s</fpu:POMNumberType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.POMNumberType), input_name='POMNumberType')), eol_))
        if self.PickupNotifications is not None:
            self.PickupNotifications.export(outfile, level, namespace_, name_='PickupNotifications', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'POMNumber':
            POMNumber_ = child_.text
            POMNumber_ = self.gds_validate_string(POMNumber_, node, 'POMNumber')
            self.POMNumber = POMNumber_
        elif nodeName_ == 'POMNumberType':
            POMNumberType_ = child_.text
            POMNumberType_ = self.gds_validate_string(POMNumberType_, node, 'POMNumberType')
            self.POMNumberType = POMNumberType_
        elif nodeName_ == 'PickupNotifications':
            obj_ = PickupNotificationsType.factory()
            obj_.build(child_)
            self.PickupNotifications = obj_
            obj_.original_tagname_ = 'PickupNotifications'
# end class POMType


class PickupNotificationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CompanyName=None, EMailNotification=None, FailedEMail=None):
        self.original_tagname_ = None
        self.CompanyName = CompanyName
        if EMailNotification is None:
            self.EMailNotification = []
        else:
            self.EMailNotification = EMailNotification
        self.FailedEMail = FailedEMail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PickupNotificationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PickupNotificationsType.subclass:
            return PickupNotificationsType.subclass(*args_, **kwargs_)
        else:
            return PickupNotificationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompanyName(self): return self.CompanyName
    def set_CompanyName(self, CompanyName): self.CompanyName = CompanyName
    def get_EMailNotification(self): return self.EMailNotification
    def set_EMailNotification(self, EMailNotification): self.EMailNotification = EMailNotification
    def add_EMailNotification(self, value): self.EMailNotification.append(value)
    def insert_EMailNotification_at(self, index, value): self.EMailNotification.insert(index, value)
    def replace_EMailNotification_at(self, index, value): self.EMailNotification[index] = value
    def get_FailedEMail(self): return self.FailedEMail
    def set_FailedEMail(self, FailedEMail): self.FailedEMail = FailedEMail
    def hasContent_(self):
        if (
            self.CompanyName is not None or
            self.EMailNotification or
            self.FailedEMail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='PickupNotificationsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PickupNotificationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PickupNotificationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='PickupNotificationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='PickupNotificationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='PickupNotificationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompanyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:CompanyName>%s</fpu:CompanyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompanyName), input_name='CompanyName')), eol_))
        for EMailNotification_ in self.EMailNotification:
            EMailNotification_.export(outfile, level, namespace_, name_='EMailNotification', pretty_print=pretty_print)
        if self.FailedEMail is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:FailedEMail>%s</fpu:FailedEMail>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FailedEMail), input_name='FailedEMail')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompanyName':
            CompanyName_ = child_.text
            CompanyName_ = self.gds_validate_string(CompanyName_, node, 'CompanyName')
            self.CompanyName = CompanyName_
        elif nodeName_ == 'EMailNotification':
            obj_ = EMailNotificationType.factory()
            obj_.build(child_)
            self.EMailNotification.append(obj_)
            obj_.original_tagname_ = 'EMailNotification'
        elif nodeName_ == 'FailedEMail':
            FailedEMail_ = child_.text
            FailedEMail_ = self.gds_validate_string(FailedEMail_, node, 'FailedEMail')
            self.FailedEMail = FailedEMail_
# end class PickupNotificationsType


class WeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UnitOfMeasurement=None, Value=None):
        self.original_tagname_ = None
        self.UnitOfMeasurement = UnitOfMeasurement
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightType.subclass:
            return WeightType.subclass(*args_, **kwargs_)
        else:
            return WeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UnitOfMeasurement(self): return self.UnitOfMeasurement
    def set_UnitOfMeasurement(self, UnitOfMeasurement): self.UnitOfMeasurement = UnitOfMeasurement
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.UnitOfMeasurement is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='WeightType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='WeightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='WeightType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='WeightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UnitOfMeasurement is not None:
            self.UnitOfMeasurement.export(outfile, level, namespace_, name_='UnitOfMeasurement', pretty_print=pretty_print)
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Value>%s</fpu:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UnitOfMeasurement':
            obj_ = UnitOfMeasurementType.factory()
            obj_.build(child_)
            self.UnitOfMeasurement = obj_
            obj_.original_tagname_ = 'UnitOfMeasurement'
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class WeightType


class UnitOfMeasurementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitOfMeasurementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitOfMeasurementType.subclass:
            return UnitOfMeasurementType.subclass(*args_, **kwargs_)
        else:
            return UnitOfMeasurementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='UnitOfMeasurementType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitOfMeasurementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitOfMeasurementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='UnitOfMeasurementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='UnitOfMeasurementType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='UnitOfMeasurementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Code>%s</fpu:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Description>%s</fpu:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class UnitOfMeasurementType


class ExistingShipmentIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ShipmentNumber=None, BOLID=None):
        self.original_tagname_ = None
        self.ShipmentNumber = ShipmentNumber
        self.BOLID = BOLID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExistingShipmentIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExistingShipmentIDType.subclass:
            return ExistingShipmentIDType.subclass(*args_, **kwargs_)
        else:
            return ExistingShipmentIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShipmentNumber(self): return self.ShipmentNumber
    def set_ShipmentNumber(self, ShipmentNumber): self.ShipmentNumber = ShipmentNumber
    def get_BOLID(self): return self.BOLID
    def set_BOLID(self, BOLID): self.BOLID = BOLID
    def hasContent_(self):
        if (
            self.ShipmentNumber is not None or
            self.BOLID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='ExistingShipmentIDType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExistingShipmentIDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExistingShipmentIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='ExistingShipmentIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='ExistingShipmentIDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='ExistingShipmentIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ShipmentNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:ShipmentNumber>%s</fpu:ShipmentNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShipmentNumber), input_name='ShipmentNumber')), eol_))
        if self.BOLID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:BOLID>%s</fpu:BOLID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BOLID), input_name='BOLID')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ShipmentNumber':
            ShipmentNumber_ = child_.text
            ShipmentNumber_ = self.gds_validate_string(ShipmentNumber_, node, 'ShipmentNumber')
            self.ShipmentNumber = ShipmentNumber_
        elif nodeName_ == 'BOLID':
            BOLID_ = child_.text
            BOLID_ = self.gds_validate_string(BOLID_, node, 'BOLID')
            self.BOLID = BOLID_
# end class ExistingShipmentIDType


class EMailNotificationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EMailAddress=None, EventType=None):
        self.original_tagname_ = None
        self.EMailAddress = EMailAddress
        if EventType is None:
            self.EventType = []
        else:
            self.EventType = EventType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EMailNotificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EMailNotificationType.subclass:
            return EMailNotificationType.subclass(*args_, **kwargs_)
        else:
            return EMailNotificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EMailAddress(self): return self.EMailAddress
    def set_EMailAddress(self, EMailAddress): self.EMailAddress = EMailAddress
    def get_EventType(self): return self.EventType
    def set_EventType(self, EventType): self.EventType = EventType
    def add_EventType(self, value): self.EventType.append(value)
    def insert_EventType_at(self, index, value): self.EventType.insert(index, value)
    def replace_EventType_at(self, index, value): self.EventType[index] = value
    def hasContent_(self):
        if (
            self.EMailAddress is not None or
            self.EventType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='EMailNotificationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EMailNotificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EMailNotificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='EMailNotificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='EMailNotificationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='EMailNotificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EMailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:EMailAddress>%s</fpu:EMailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EMailAddress), input_name='EMailAddress')), eol_))
        for EventType_ in self.EventType:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:EventType>%s</fpu:EventType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(EventType_), input_name='EventType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EMailAddress':
            EMailAddress_ = child_.text
            EMailAddress_ = self.gds_validate_string(EMailAddress_, node, 'EMailAddress')
            self.EMailAddress = EMailAddress_
        elif nodeName_ == 'EventType':
            EventType_ = child_.text
            EventType_ = self.gds_validate_string(EventType_, node, 'EventType')
            self.EventType.append(EventType_)
# end class EMailNotificationType


class CancelStatusCodeDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CancelStatusCodeDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CancelStatusCodeDescriptionType.subclass:
            return CancelStatusCodeDescriptionType.subclass(*args_, **kwargs_)
        else:
            return CancelStatusCodeDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='CancelStatusCodeDescriptionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CancelStatusCodeDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CancelStatusCodeDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='CancelStatusCodeDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='CancelStatusCodeDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='CancelStatusCodeDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Code>%s</fpu:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fpu:Description>%s</fpu:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class CancelStatusCodeDescriptionType


class ClientInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        self.original_tagname_ = None
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClientInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClientInformationType.subclass:
            return ClientInformationType.subclass(*args_, **kwargs_)
        else:
            return ClientInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property_at(self, index, value): self.Property.insert(index, value)
    def replace_Property_at(self, index, value): self.Property[index] = value
    def hasContent_(self):
        if (
            self.Property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ClientInformationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClientInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClientInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ClientInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ClientInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ClientInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
# end class ClientInformationType


class RequestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RequestOption=None, SubVersion=None, TransactionReference=None):
        self.original_tagname_ = None
        if RequestOption is None:
            self.RequestOption = []
        else:
            self.RequestOption = RequestOption
        self.SubVersion = SubVersion
        self.TransactionReference = TransactionReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestType.subclass:
            return RequestType.subclass(*args_, **kwargs_)
        else:
            return RequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RequestOption(self): return self.RequestOption
    def set_RequestOption(self, RequestOption): self.RequestOption = RequestOption
    def add_RequestOption(self, value): self.RequestOption.append(value)
    def insert_RequestOption_at(self, index, value): self.RequestOption.insert(index, value)
    def replace_RequestOption_at(self, index, value): self.RequestOption[index] = value
    def get_SubVersion(self): return self.SubVersion
    def set_SubVersion(self, SubVersion): self.SubVersion = SubVersion
    def get_TransactionReference(self): return self.TransactionReference
    def set_TransactionReference(self, TransactionReference): self.TransactionReference = TransactionReference
    def hasContent_(self):
        if (
            self.RequestOption or
            self.SubVersion is not None or
            self.TransactionReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='RequestType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='RequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='RequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='RequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RequestOption_ in self.RequestOption:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:RequestOption>%s</common:RequestOption>%s' % (self.gds_encode(self.gds_format_string(quote_xml(RequestOption_), input_name='RequestOption')), eol_))
        if self.SubVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:SubVersion>%s</common:SubVersion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SubVersion), input_name='SubVersion')), eol_))
        if self.TransactionReference is not None:
            self.TransactionReference.export(outfile, level, namespace_, name_='TransactionReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RequestOption':
            RequestOption_ = child_.text
            RequestOption_ = self.gds_validate_string(RequestOption_, node, 'RequestOption')
            self.RequestOption.append(RequestOption_)
        elif nodeName_ == 'SubVersion':
            SubVersion_ = child_.text
            SubVersion_ = self.gds_validate_string(SubVersion_, node, 'SubVersion')
            self.SubVersion = SubVersion_
        elif nodeName_ == 'TransactionReference':
            obj_ = TransactionReferenceType.factory()
            obj_.build(child_)
            self.TransactionReference = obj_
            obj_.original_tagname_ = 'TransactionReference'
# end class RequestType


class TransactionReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomerContext=None, TransactionIdentifier=None):
        self.original_tagname_ = None
        self.CustomerContext = CustomerContext
        self.TransactionIdentifier = TransactionIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransactionReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransactionReferenceType.subclass:
            return TransactionReferenceType.subclass(*args_, **kwargs_)
        else:
            return TransactionReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerContext(self): return self.CustomerContext
    def set_CustomerContext(self, CustomerContext): self.CustomerContext = CustomerContext
    def get_TransactionIdentifier(self): return self.TransactionIdentifier
    def set_TransactionIdentifier(self, TransactionIdentifier): self.TransactionIdentifier = TransactionIdentifier
    def hasContent_(self):
        if (
            self.CustomerContext is not None or
            self.TransactionIdentifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='TransactionReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransactionReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransactionReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='TransactionReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='TransactionReferenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='TransactionReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerContext is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:CustomerContext>%s</common:CustomerContext>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerContext), input_name='CustomerContext')), eol_))
        if self.TransactionIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:TransactionIdentifier>%s</common:TransactionIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransactionIdentifier), input_name='TransactionIdentifier')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerContext':
            CustomerContext_ = child_.text
            CustomerContext_ = self.gds_validate_string(CustomerContext_, node, 'CustomerContext')
            self.CustomerContext = CustomerContext_
        elif nodeName_ == 'TransactionIdentifier':
            TransactionIdentifier_ = child_.text
            TransactionIdentifier_ = self.gds_validate_string(TransactionIdentifier_, node, 'TransactionIdentifier')
            self.TransactionIdentifier = TransactionIdentifier_
# end class TransactionReferenceType


class ResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ResponseStatus=None, Alert=None, AlertDetail=None, TransactionReference=None):
        self.original_tagname_ = None
        self.ResponseStatus = ResponseStatus
        if Alert is None:
            self.Alert = []
        else:
            self.Alert = Alert
        if AlertDetail is None:
            self.AlertDetail = []
        else:
            self.AlertDetail = AlertDetail
        self.TransactionReference = TransactionReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseType.subclass:
            return ResponseType.subclass(*args_, **kwargs_)
        else:
            return ResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResponseStatus(self): return self.ResponseStatus
    def set_ResponseStatus(self, ResponseStatus): self.ResponseStatus = ResponseStatus
    def get_Alert(self): return self.Alert
    def set_Alert(self, Alert): self.Alert = Alert
    def add_Alert(self, value): self.Alert.append(value)
    def insert_Alert_at(self, index, value): self.Alert.insert(index, value)
    def replace_Alert_at(self, index, value): self.Alert[index] = value
    def get_AlertDetail(self): return self.AlertDetail
    def set_AlertDetail(self, AlertDetail): self.AlertDetail = AlertDetail
    def add_AlertDetail(self, value): self.AlertDetail.append(value)
    def insert_AlertDetail_at(self, index, value): self.AlertDetail.insert(index, value)
    def replace_AlertDetail_at(self, index, value): self.AlertDetail[index] = value
    def get_TransactionReference(self): return self.TransactionReference
    def set_TransactionReference(self, TransactionReference): self.TransactionReference = TransactionReference
    def hasContent_(self):
        if (
            self.ResponseStatus is not None or
            self.Alert or
            self.AlertDetail or
            self.TransactionReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ResponseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ResponseStatus is not None:
            self.ResponseStatus.export(outfile, level, namespace_, name_='ResponseStatus', pretty_print=pretty_print)
        for Alert_ in self.Alert:
            Alert_.export(outfile, level, namespace_, name_='Alert', pretty_print=pretty_print)
        for AlertDetail_ in self.AlertDetail:
            AlertDetail_.export(outfile, level, namespace_, name_='AlertDetail', pretty_print=pretty_print)
        if self.TransactionReference is not None:
            self.TransactionReference.export(outfile, level, namespace_, name_='TransactionReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResponseStatus':
            obj_ = CodeDescriptionType.factory()
            obj_.build(child_)
            self.ResponseStatus = obj_
            obj_.original_tagname_ = 'ResponseStatus'
        elif nodeName_ == 'Alert':
            obj_ = CodeDescriptionType.factory()
            obj_.build(child_)
            self.Alert.append(obj_)
            obj_.original_tagname_ = 'Alert'
        elif nodeName_ == 'AlertDetail':
            obj_ = DetailType.factory()
            obj_.build(child_)
            self.AlertDetail.append(obj_)
            obj_.original_tagname_ = 'AlertDetail'
        elif nodeName_ == 'TransactionReference':
            obj_ = TransactionReferenceType.factory()
            obj_.build(child_)
            self.TransactionReference = obj_
            obj_.original_tagname_ = 'TransactionReference'
# end class ResponseType


class CodeDescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodeDescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodeDescriptionType.subclass:
            return CodeDescriptionType.subclass(*args_, **kwargs_)
        else:
            return CodeDescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='CodeDescriptionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CodeDescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeDescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='CodeDescriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='CodeDescriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='CodeDescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Code>%s</common:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Description>%s</common:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class CodeDescriptionType


class DetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Description=None, ElementLevelInformation=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Description = Description
        self.ElementLevelInformation = ElementLevelInformation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailType.subclass:
            return DetailType.subclass(*args_, **kwargs_)
        else:
            return DetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ElementLevelInformation(self): return self.ElementLevelInformation
    def set_ElementLevelInformation(self, ElementLevelInformation): self.ElementLevelInformation = ElementLevelInformation
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Description is not None or
            self.ElementLevelInformation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='DetailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DetailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='DetailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='DetailType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='DetailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Code>%s</common:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Description>%s</common:Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.ElementLevelInformation is not None:
            self.ElementLevelInformation.export(outfile, level, namespace_, name_='ElementLevelInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'ElementLevelInformation':
            obj_ = ElementLevelInformationType.factory()
            obj_.build(child_)
            self.ElementLevelInformation = obj_
            obj_.original_tagname_ = 'ElementLevelInformation'
# end class DetailType


class ElementLevelInformationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Level=None, ElementIdentifier=None):
        self.original_tagname_ = None
        self.Level = Level
        if ElementIdentifier is None:
            self.ElementIdentifier = []
        else:
            self.ElementIdentifier = ElementIdentifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementLevelInformationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementLevelInformationType.subclass:
            return ElementLevelInformationType.subclass(*args_, **kwargs_)
        else:
            return ElementLevelInformationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    def get_ElementIdentifier(self): return self.ElementIdentifier
    def set_ElementIdentifier(self, ElementIdentifier): self.ElementIdentifier = ElementIdentifier
    def add_ElementIdentifier(self, value): self.ElementIdentifier.append(value)
    def insert_ElementIdentifier_at(self, index, value): self.ElementIdentifier.insert(index, value)
    def replace_ElementIdentifier_at(self, index, value): self.ElementIdentifier[index] = value
    def hasContent_(self):
        if (
            self.Level is not None or
            self.ElementIdentifier
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ElementLevelInformationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementLevelInformationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElementLevelInformationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ElementLevelInformationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ElementLevelInformationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ElementLevelInformationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Level>%s</common:Level>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Level), input_name='Level')), eol_))
        for ElementIdentifier_ in self.ElementIdentifier:
            ElementIdentifier_.export(outfile, level, namespace_, name_='ElementIdentifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Level':
            Level_ = child_.text
            Level_ = self.gds_validate_string(Level_, node, 'Level')
            self.Level = Level_
        elif nodeName_ == 'ElementIdentifier':
            obj_ = ElementIdentifierType.factory()
            obj_.build(child_)
            self.ElementIdentifier.append(obj_)
            obj_.original_tagname_ = 'ElementIdentifier'
# end class ElementLevelInformationType


class ElementIdentifierType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Value=None):
        self.original_tagname_ = None
        self.Code = Code
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElementIdentifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElementIdentifierType.subclass:
            return ElementIdentifierType.subclass(*args_, **kwargs_)
        else:
            return ElementIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='common:', name_='ElementIdentifierType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElementIdentifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElementIdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='common:', name_='ElementIdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='common:', name_='ElementIdentifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='common:', name_='ElementIdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Code>%s</common:Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<common:Value>%s</common:Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ElementIdentifierType


class PropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Key=None, valueOf_=None):
        self.original_tagname_ = None
        self.Key = _cast(None, Key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PropertyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PropertyType.subclass:
            return PropertyType.subclass(*args_, **kwargs_)
        else:
            return PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fpu:', name_='PropertyType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PropertyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='fpu:', name_='PropertyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fpu:', name_='PropertyType'):
        if self.Key is not None and 'Key' not in already_processed:
            already_processed.add('Key')
            outfile.write(' Key=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Key), input_name='Key')), ))
    def exportChildren(self, outfile, level, namespace_='fpu:', name_='PropertyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Key', node)
        if value is not None and 'Key' not in already_processed:
            already_processed.add('Key')
            self.Key = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PropertyType


GDSClassesMapping = {
    'ClientInformation': ClientInformationType,
    'Request': RequestType,
    'Response': ResponseType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'FreightPickupRequest'
        rootClass = FreightPickupRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:fpu="http://www.ups.com/XMLSchema/XOLTWS/FreightPickup/v1.0"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'FreightPickupRequest'
        rootClass = FreightPickupRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'FreightPickupRequest'
        rootClass = FreightPickupRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:fpu="http://www.ups.com/XMLSchema/XOLTWS/FreightPickup/v1.0"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'FreightPickupRequest'
        rootClass = FreightPickupRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from freight_pickup import *\n\n')
        sys.stdout.write('import freight_pickup as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AddressType",
    "CancelStatusCodeDescriptionType",
    "ClientInformationType",
    "CodeDescriptionType",
    "DetailType",
    "EMailNotificationType",
    "ElementIdentifierType",
    "ElementLevelInformationType",
    "ExistingShipmentIDType",
    "FreightCancelPickupRequest",
    "FreightCancelPickupResponse",
    "FreightPickupRequest",
    "FreightPickupResponse",
    "POMType",
    "PhoneType",
    "PickupCodeDescriptionType",
    "PickupNotificationsType",
    "PropertyType",
    "RequestType",
    "RequesterType",
    "ResponseType",
    "ShipFromType",
    "ShipToType",
    "ShipmentDetailType",
    "ShipmentServiceOptionsType",
    "TransactionReferenceType",
    "UnitOfMeasurementType",
    "WeightType"
]
