/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Purplship Open Source Multi-carrier Shipping API
 *  Purplship is an open source multi-carrier shipping API that simplifies the integration of logistic carrier services  The **proxy** endpoints are stateless and forwards calls to carriers web services. 
 *
 * OpenAPI spec version: 2021.2.1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

 import * as url from "url";
 import * as portableFetch from "portable-fetch";
 import { Configuration } from "./configuration";
 
 const BASE_PATH = "https://app.purplship.com/v1".replace(/\/+$/, "");
 
 /**
  *
  * @export
  */
 export const COLLECTION_FORMATS = {
     csv: ",",
     ssv: " ",
     tsv: "\t",
     pipes: "|",
 };
 
 /**
  *
  * @export
  * @interface FetchAPI
  */
 export interface FetchAPI {
     (url: string, init?: any): Promise<Response>;
 }
 
 /**
  *
  * @export
  * @interface FetchArgs
  */
 export interface FetchArgs {
     url: string;
     options: any;
 }
 
 /**
  *
  * @export
  * @class BaseAPI
  */
 export class BaseAPI {
     protected configuration: Configuration;
 
     constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
         if (configuration) {
             this.configuration = configuration;
             this.basePath = configuration.basePath || this.basePath;
         }
     }
 };
 
 /**
  *
  * @export
  * @class RequiredError
  * @extends {Error}
  */
 export class RequiredError extends Error {
     name: "RequiredError"
     constructor(public field: string, msg?: string) {
         super(msg);
     }
 }
 
 /**
  * 
  * @export
  * @interface Address
  */
 export interface Address {
     /**
      * A unique identifier
      * @type {string}
      * @memberof Address
      */
     id?: string;
     /**
      *  The address postal code  **(required for shipment purchase)** 
      * @type {string}
      * @memberof Address
      */
     postal_code?: string;
     /**
      *  The address city.  **(required for shipment purchase)** 
      * @type {string}
      * @memberof Address
      */
     city?: string;
     /**
      * The party frederal tax id
      * @type {string}
      * @memberof Address
      */
     federal_tax_id?: string;
     /**
      * The party state id
      * @type {string}
      * @memberof Address
      */
     state_tax_id?: string;
     /**
      *  attention to  **(required for shipment purchase)** 
      * @type {string}
      * @memberof Address
      */
     person_name?: string;
     /**
      * The company name if the party is a company
      * @type {string}
      * @memberof Address
      */
     company_name?: string;
     /**
      * The address country code
      * @type {string}
      * @memberof Address
      */
     country_code: Address.CountryCodeEnum;
     /**
      * The party email
      * @type {string}
      * @memberof Address
      */
     email?: string;
     /**
      * The party phone number.
      * @type {string}
      * @memberof Address
      */
     phone_number?: string;
     /**
      * The address state code
      * @type {string}
      * @memberof Address
      */
     state_code?: string;
     /**
      * The address suburb if known
      * @type {string}
      * @memberof Address
      */
     suburb?: string;
     /**
      * Indicate if the address is residential or commercial (enterprise)
      * @type {boolean}
      * @memberof Address
      */
     residential?: boolean;
     /**
      *  The address line with street number <br/> **(required for shipment purchase)** 
      * @type {string}
      * @memberof Address
      */
     address_line1?: string;
     /**
      * The address line with suite number
      * @type {string}
      * @memberof Address
      */
     address_line2?: string;
 }
 
 /**
  * @export
  * @namespace Address
  */
 export namespace Address {
     /**
      * @export
      * @enum {string}
      */
     export enum CountryCodeEnum {
         AD = <any> 'AD',
         AE = <any> 'AE',
         AF = <any> 'AF',
         AG = <any> 'AG',
         AI = <any> 'AI',
         AL = <any> 'AL',
         AM = <any> 'AM',
         AN = <any> 'AN',
         AO = <any> 'AO',
         AR = <any> 'AR',
         AS = <any> 'AS',
         AT = <any> 'AT',
         AU = <any> 'AU',
         AW = <any> 'AW',
         AZ = <any> 'AZ',
         BA = <any> 'BA',
         BB = <any> 'BB',
         BD = <any> 'BD',
         BE = <any> 'BE',
         BF = <any> 'BF',
         BG = <any> 'BG',
         BH = <any> 'BH',
         BI = <any> 'BI',
         BJ = <any> 'BJ',
         BM = <any> 'BM',
         BN = <any> 'BN',
         BO = <any> 'BO',
         BR = <any> 'BR',
         BS = <any> 'BS',
         BT = <any> 'BT',
         BW = <any> 'BW',
         BY = <any> 'BY',
         BZ = <any> 'BZ',
         CA = <any> 'CA',
         CD = <any> 'CD',
         CF = <any> 'CF',
         CG = <any> 'CG',
         CH = <any> 'CH',
         CI = <any> 'CI',
         CK = <any> 'CK',
         CL = <any> 'CL',
         CM = <any> 'CM',
         CN = <any> 'CN',
         CO = <any> 'CO',
         CR = <any> 'CR',
         CU = <any> 'CU',
         CV = <any> 'CV',
         CY = <any> 'CY',
         CZ = <any> 'CZ',
         DE = <any> 'DE',
         DJ = <any> 'DJ',
         DK = <any> 'DK',
         DM = <any> 'DM',
         DO = <any> 'DO',
         DZ = <any> 'DZ',
         EC = <any> 'EC',
         EE = <any> 'EE',
         EG = <any> 'EG',
         ER = <any> 'ER',
         ES = <any> 'ES',
         ET = <any> 'ET',
         FI = <any> 'FI',
         FJ = <any> 'FJ',
         FK = <any> 'FK',
         FM = <any> 'FM',
         FO = <any> 'FO',
         FR = <any> 'FR',
         GA = <any> 'GA',
         GB = <any> 'GB',
         GD = <any> 'GD',
         GE = <any> 'GE',
         GF = <any> 'GF',
         GG = <any> 'GG',
         GH = <any> 'GH',
         GI = <any> 'GI',
         GL = <any> 'GL',
         GM = <any> 'GM',
         GN = <any> 'GN',
         GP = <any> 'GP',
         GQ = <any> 'GQ',
         GR = <any> 'GR',
         GT = <any> 'GT',
         GU = <any> 'GU',
         GW = <any> 'GW',
         GY = <any> 'GY',
         HK = <any> 'HK',
         HN = <any> 'HN',
         HR = <any> 'HR',
         HT = <any> 'HT',
         HU = <any> 'HU',
         IC = <any> 'IC',
         ID = <any> 'ID',
         IE = <any> 'IE',
         IL = <any> 'IL',
         IN = <any> 'IN',
         IQ = <any> 'IQ',
         IR = <any> 'IR',
         IS = <any> 'IS',
         IT = <any> 'IT',
         JE = <any> 'JE',
         JM = <any> 'JM',
         JO = <any> 'JO',
         JP = <any> 'JP',
         KE = <any> 'KE',
         KG = <any> 'KG',
         KH = <any> 'KH',
         KI = <any> 'KI',
         KM = <any> 'KM',
         KN = <any> 'KN',
         KP = <any> 'KP',
         KR = <any> 'KR',
         KV = <any> 'KV',
         KW = <any> 'KW',
         KY = <any> 'KY',
         KZ = <any> 'KZ',
         LA = <any> 'LA',
         LB = <any> 'LB',
         LC = <any> 'LC',
         LI = <any> 'LI',
         LK = <any> 'LK',
         LR = <any> 'LR',
         LS = <any> 'LS',
         LT = <any> 'LT',
         LU = <any> 'LU',
         LV = <any> 'LV',
         LY = <any> 'LY',
         MA = <any> 'MA',
         MC = <any> 'MC',
         MD = <any> 'MD',
         ME = <any> 'ME',
         MG = <any> 'MG',
         MH = <any> 'MH',
         MK = <any> 'MK',
         ML = <any> 'ML',
         MM = <any> 'MM',
         MN = <any> 'MN',
         MO = <any> 'MO',
         MP = <any> 'MP',
         MQ = <any> 'MQ',
         MR = <any> 'MR',
         MS = <any> 'MS',
         MT = <any> 'MT',
         MU = <any> 'MU',
         MV = <any> 'MV',
         MW = <any> 'MW',
         MX = <any> 'MX',
         MY = <any> 'MY',
         MZ = <any> 'MZ',
         NA = <any> 'NA',
         NC = <any> 'NC',
         NE = <any> 'NE',
         NG = <any> 'NG',
         NI = <any> 'NI',
         NL = <any> 'NL',
         NO = <any> 'NO',
         NP = <any> 'NP',
         NR = <any> 'NR',
         NU = <any> 'NU',
         NZ = <any> 'NZ',
         OM = <any> 'OM',
         PA = <any> 'PA',
         PE = <any> 'PE',
         PF = <any> 'PF',
         PG = <any> 'PG',
         PH = <any> 'PH',
         PK = <any> 'PK',
         PL = <any> 'PL',
         PR = <any> 'PR',
         PT = <any> 'PT',
         PW = <any> 'PW',
         PY = <any> 'PY',
         QA = <any> 'QA',
         RE = <any> 'RE',
         RO = <any> 'RO',
         RS = <any> 'RS',
         RU = <any> 'RU',
         RW = <any> 'RW',
         SA = <any> 'SA',
         SB = <any> 'SB',
         SC = <any> 'SC',
         SD = <any> 'SD',
         SE = <any> 'SE',
         SG = <any> 'SG',
         SH = <any> 'SH',
         SI = <any> 'SI',
         SK = <any> 'SK',
         SL = <any> 'SL',
         SM = <any> 'SM',
         SN = <any> 'SN',
         SO = <any> 'SO',
         SR = <any> 'SR',
         SS = <any> 'SS',
         ST = <any> 'ST',
         SV = <any> 'SV',
         SY = <any> 'SY',
         SZ = <any> 'SZ',
         TC = <any> 'TC',
         TD = <any> 'TD',
         TG = <any> 'TG',
         TH = <any> 'TH',
         TJ = <any> 'TJ',
         TL = <any> 'TL',
         TN = <any> 'TN',
         TO = <any> 'TO',
         TR = <any> 'TR',
         TT = <any> 'TT',
         TV = <any> 'TV',
         TW = <any> 'TW',
         TZ = <any> 'TZ',
         UA = <any> 'UA',
         UG = <any> 'UG',
         US = <any> 'US',
         UY = <any> 'UY',
         UZ = <any> 'UZ',
         VA = <any> 'VA',
         VC = <any> 'VC',
         VE = <any> 'VE',
         VG = <any> 'VG',
         VI = <any> 'VI',
         VN = <any> 'VN',
         VU = <any> 'VU',
         WS = <any> 'WS',
         XB = <any> 'XB',
         XC = <any> 'XC',
         XE = <any> 'XE',
         XM = <any> 'XM',
         XN = <any> 'XN',
         XS = <any> 'XS',
         XY = <any> 'XY',
         YE = <any> 'YE',
         YT = <any> 'YT',
         ZA = <any> 'ZA',
         ZM = <any> 'ZM',
         ZW = <any> 'ZW'
     }
 }
 /**
  * 
  * @export
  * @interface AddressData
  */
 export interface AddressData {
     /**
      *  The address postal code  **(required for shipment purchase)** 
      * @type {string}
      * @memberof AddressData
      */
     postal_code?: string;
     /**
      *  The address city.  **(required for shipment purchase)** 
      * @type {string}
      * @memberof AddressData
      */
     city?: string;
     /**
      * The party frederal tax id
      * @type {string}
      * @memberof AddressData
      */
     federal_tax_id?: string;
     /**
      * The party state id
      * @type {string}
      * @memberof AddressData
      */
     state_tax_id?: string;
     /**
      *  attention to  **(required for shipment purchase)** 
      * @type {string}
      * @memberof AddressData
      */
     person_name?: string;
     /**
      * The company name if the party is a company
      * @type {string}
      * @memberof AddressData
      */
     company_name?: string;
     /**
      * The address country code
      * @type {string}
      * @memberof AddressData
      */
     country_code: AddressData.CountryCodeEnum;
     /**
      * The party email
      * @type {string}
      * @memberof AddressData
      */
     email?: string;
     /**
      * The party phone number.
      * @type {string}
      * @memberof AddressData
      */
     phone_number?: string;
     /**
      * The address state code
      * @type {string}
      * @memberof AddressData
      */
     state_code?: string;
     /**
      * The address suburb if known
      * @type {string}
      * @memberof AddressData
      */
     suburb?: string;
     /**
      * Indicate if the address is residential or commercial (enterprise)
      * @type {boolean}
      * @memberof AddressData
      */
     residential?: boolean;
     /**
      *  The address line with street number <br/> **(required for shipment purchase)** 
      * @type {string}
      * @memberof AddressData
      */
     address_line1?: string;
     /**
      * The address line with suite number
      * @type {string}
      * @memberof AddressData
      */
     address_line2?: string;
 }
 
 /**
  * @export
  * @namespace AddressData
  */
 export namespace AddressData {
     /**
      * @export
      * @enum {string}
      */
     export enum CountryCodeEnum {
         AD = <any> 'AD',
         AE = <any> 'AE',
         AF = <any> 'AF',
         AG = <any> 'AG',
         AI = <any> 'AI',
         AL = <any> 'AL',
         AM = <any> 'AM',
         AN = <any> 'AN',
         AO = <any> 'AO',
         AR = <any> 'AR',
         AS = <any> 'AS',
         AT = <any> 'AT',
         AU = <any> 'AU',
         AW = <any> 'AW',
         AZ = <any> 'AZ',
         BA = <any> 'BA',
         BB = <any> 'BB',
         BD = <any> 'BD',
         BE = <any> 'BE',
         BF = <any> 'BF',
         BG = <any> 'BG',
         BH = <any> 'BH',
         BI = <any> 'BI',
         BJ = <any> 'BJ',
         BM = <any> 'BM',
         BN = <any> 'BN',
         BO = <any> 'BO',
         BR = <any> 'BR',
         BS = <any> 'BS',
         BT = <any> 'BT',
         BW = <any> 'BW',
         BY = <any> 'BY',
         BZ = <any> 'BZ',
         CA = <any> 'CA',
         CD = <any> 'CD',
         CF = <any> 'CF',
         CG = <any> 'CG',
         CH = <any> 'CH',
         CI = <any> 'CI',
         CK = <any> 'CK',
         CL = <any> 'CL',
         CM = <any> 'CM',
         CN = <any> 'CN',
         CO = <any> 'CO',
         CR = <any> 'CR',
         CU = <any> 'CU',
         CV = <any> 'CV',
         CY = <any> 'CY',
         CZ = <any> 'CZ',
         DE = <any> 'DE',
         DJ = <any> 'DJ',
         DK = <any> 'DK',
         DM = <any> 'DM',
         DO = <any> 'DO',
         DZ = <any> 'DZ',
         EC = <any> 'EC',
         EE = <any> 'EE',
         EG = <any> 'EG',
         ER = <any> 'ER',
         ES = <any> 'ES',
         ET = <any> 'ET',
         FI = <any> 'FI',
         FJ = <any> 'FJ',
         FK = <any> 'FK',
         FM = <any> 'FM',
         FO = <any> 'FO',
         FR = <any> 'FR',
         GA = <any> 'GA',
         GB = <any> 'GB',
         GD = <any> 'GD',
         GE = <any> 'GE',
         GF = <any> 'GF',
         GG = <any> 'GG',
         GH = <any> 'GH',
         GI = <any> 'GI',
         GL = <any> 'GL',
         GM = <any> 'GM',
         GN = <any> 'GN',
         GP = <any> 'GP',
         GQ = <any> 'GQ',
         GR = <any> 'GR',
         GT = <any> 'GT',
         GU = <any> 'GU',
         GW = <any> 'GW',
         GY = <any> 'GY',
         HK = <any> 'HK',
         HN = <any> 'HN',
         HR = <any> 'HR',
         HT = <any> 'HT',
         HU = <any> 'HU',
         IC = <any> 'IC',
         ID = <any> 'ID',
         IE = <any> 'IE',
         IL = <any> 'IL',
         IN = <any> 'IN',
         IQ = <any> 'IQ',
         IR = <any> 'IR',
         IS = <any> 'IS',
         IT = <any> 'IT',
         JE = <any> 'JE',
         JM = <any> 'JM',
         JO = <any> 'JO',
         JP = <any> 'JP',
         KE = <any> 'KE',
         KG = <any> 'KG',
         KH = <any> 'KH',
         KI = <any> 'KI',
         KM = <any> 'KM',
         KN = <any> 'KN',
         KP = <any> 'KP',
         KR = <any> 'KR',
         KV = <any> 'KV',
         KW = <any> 'KW',
         KY = <any> 'KY',
         KZ = <any> 'KZ',
         LA = <any> 'LA',
         LB = <any> 'LB',
         LC = <any> 'LC',
         LI = <any> 'LI',
         LK = <any> 'LK',
         LR = <any> 'LR',
         LS = <any> 'LS',
         LT = <any> 'LT',
         LU = <any> 'LU',
         LV = <any> 'LV',
         LY = <any> 'LY',
         MA = <any> 'MA',
         MC = <any> 'MC',
         MD = <any> 'MD',
         ME = <any> 'ME',
         MG = <any> 'MG',
         MH = <any> 'MH',
         MK = <any> 'MK',
         ML = <any> 'ML',
         MM = <any> 'MM',
         MN = <any> 'MN',
         MO = <any> 'MO',
         MP = <any> 'MP',
         MQ = <any> 'MQ',
         MR = <any> 'MR',
         MS = <any> 'MS',
         MT = <any> 'MT',
         MU = <any> 'MU',
         MV = <any> 'MV',
         MW = <any> 'MW',
         MX = <any> 'MX',
         MY = <any> 'MY',
         MZ = <any> 'MZ',
         NA = <any> 'NA',
         NC = <any> 'NC',
         NE = <any> 'NE',
         NG = <any> 'NG',
         NI = <any> 'NI',
         NL = <any> 'NL',
         NO = <any> 'NO',
         NP = <any> 'NP',
         NR = <any> 'NR',
         NU = <any> 'NU',
         NZ = <any> 'NZ',
         OM = <any> 'OM',
         PA = <any> 'PA',
         PE = <any> 'PE',
         PF = <any> 'PF',
         PG = <any> 'PG',
         PH = <any> 'PH',
         PK = <any> 'PK',
         PL = <any> 'PL',
         PR = <any> 'PR',
         PT = <any> 'PT',
         PW = <any> 'PW',
         PY = <any> 'PY',
         QA = <any> 'QA',
         RE = <any> 'RE',
         RO = <any> 'RO',
         RS = <any> 'RS',
         RU = <any> 'RU',
         RW = <any> 'RW',
         SA = <any> 'SA',
         SB = <any> 'SB',
         SC = <any> 'SC',
         SD = <any> 'SD',
         SE = <any> 'SE',
         SG = <any> 'SG',
         SH = <any> 'SH',
         SI = <any> 'SI',
         SK = <any> 'SK',
         SL = <any> 'SL',
         SM = <any> 'SM',
         SN = <any> 'SN',
         SO = <any> 'SO',
         SR = <any> 'SR',
         SS = <any> 'SS',
         ST = <any> 'ST',
         SV = <any> 'SV',
         SY = <any> 'SY',
         SZ = <any> 'SZ',
         TC = <any> 'TC',
         TD = <any> 'TD',
         TG = <any> 'TG',
         TH = <any> 'TH',
         TJ = <any> 'TJ',
         TL = <any> 'TL',
         TN = <any> 'TN',
         TO = <any> 'TO',
         TR = <any> 'TR',
         TT = <any> 'TT',
         TV = <any> 'TV',
         TW = <any> 'TW',
         TZ = <any> 'TZ',
         UA = <any> 'UA',
         UG = <any> 'UG',
         US = <any> 'US',
         UY = <any> 'UY',
         UZ = <any> 'UZ',
         VA = <any> 'VA',
         VC = <any> 'VC',
         VE = <any> 'VE',
         VG = <any> 'VG',
         VI = <any> 'VI',
         VN = <any> 'VN',
         VU = <any> 'VU',
         WS = <any> 'WS',
         XB = <any> 'XB',
         XC = <any> 'XC',
         XE = <any> 'XE',
         XM = <any> 'XM',
         XN = <any> 'XN',
         XS = <any> 'XS',
         XY = <any> 'XY',
         YE = <any> 'YE',
         YT = <any> 'YT',
         ZA = <any> 'ZA',
         ZM = <any> 'ZM',
         ZW = <any> 'ZW'
     }
 }
 /**
  * 
  * @export
  * @interface AddressList
  */
 export interface AddressList {
     /**
      * 
      * @type {string}
      * @memberof AddressList
      */
     next?: string;
     /**
      * 
      * @type {string}
      * @memberof AddressList
      */
     previous?: string;
     /**
      * 
      * @type {Array<Address>}
      * @memberof AddressList
      */
     results: Array<Address>;
 }
 /**
  * 
  * @export
  * @interface CarrierList
  */
 export interface CarrierList {
     /**
      * 
      * @type {string}
      * @memberof CarrierList
      */
     next?: string;
     /**
      * 
      * @type {string}
      * @memberof CarrierList
      */
     previous?: string;
     /**
      * 
      * @type {Array<CarrierSettings>}
      * @memberof CarrierList
      */
     results: Array<CarrierSettings>;
 }
 /**
  * 
  * @export
  * @interface CarrierSettings
  */
 export interface CarrierSettings {
     /**
      * A unique address identifier
      * @type {string}
      * @memberof CarrierSettings
      */
     id: string;
     /**
      * Indicates a carrier (type)
      * @type {string}
      * @memberof CarrierSettings
      */
     carrier_name: CarrierSettings.CarrierNameEnum;
     /**
      * Indicates a specific carrier configuration name.
      * @type {string}
      * @memberof CarrierSettings
      */
     carrier_id: string;
     /**
      *  The test flag indicates whether to use a carrier configured for test.  
      * @type {boolean}
      * @memberof CarrierSettings
      */
     test: boolean;
     /**
      *  The active flag indicates whether the carrier account is active or not.  
      * @type {boolean}
      * @memberof CarrierSettings
      */
     active: boolean;
 }
 
 /**
  * @export
  * @namespace CarrierSettings
  */
 export namespace CarrierSettings {
     /**
      * @export
      * @enum {string}
      */
     export enum CarrierNameEnum {
         Aramex = <any> 'aramex',
         Australiapost = <any> 'australiapost',
         Canadapost = <any> 'canadapost',
         Canpar = <any> 'canpar',
         DhlExpress = <any> 'dhl_express',
         DhlUniversal = <any> 'dhl_universal',
         Dicom = <any> 'dicom',
         FedexExpress = <any> 'fedex_express',
         PurolatorCourier = <any> 'purolator_courier',
         Royalmail = <any> 'royalmail',
         Sendle = <any> 'sendle',
         SfExpress = <any> 'sf_express',
         UpsPackage = <any> 'ups_package',
         Usps = <any> 'usps',
         Yanwen = <any> 'yanwen',
         Yunexpress = <any> 'yunexpress',
         Eshipper = <any> 'eshipper',
         Freightcom = <any> 'freightcom'
     }
 }
 /**
  * The pickup cost details
  * @export
  * @interface Charge
  */
 export interface Charge {
     /**
      * The charge description
      * @type {string}
      * @memberof Charge
      */
     name?: string;
     /**
      * The charge monetary value
      * @type {number}
      * @memberof Charge
      */
     amount?: number;
     /**
      * The charge amount currency
      * @type {string}
      * @memberof Charge
      */
     currency?: string;
 }
 /**
  * The parcel content items
  * @export
  * @interface Commodity
  */
 export interface Commodity {
     /**
      * A unique identifier
      * @type {string}
      * @memberof Commodity
      */
     id?: string;
     /**
      * The commodity's weight
      * @type {number}
      * @memberof Commodity
      */
     weight: number;
     /**
      * The commodity's weight unit
      * @type {string}
      * @memberof Commodity
      */
     weight_unit: Commodity.WeightUnitEnum;
     /**
      * A description of the commodity
      * @type {string}
      * @memberof Commodity
      */
     description?: string;
     /**
      * The commodity's quantity (number or item)
      * @type {number}
      * @memberof Commodity
      */
     quantity?: number;
     /**
      * The commodity's sku number
      * @type {string}
      * @memberof Commodity
      */
     sku?: string;
     /**
      * The monetary value of the commodity
      * @type {number}
      * @memberof Commodity
      */
     value_amount?: number;
     /**
      * The currency of the commodity value amount
      * @type {string}
      * @memberof Commodity
      */
     value_currency?: string;
     /**
      * The origin or manufacture country
      * @type {string}
      * @memberof Commodity
      */
     origin_country?: string;
 }
 
 /**
  * @export
  * @namespace Commodity
  */
 export namespace Commodity {
     /**
      * @export
      * @enum {string}
      */
     export enum WeightUnitEnum {
         KG = <any> 'KG',
         LB = <any> 'LB'
     }
 }
 /**
  * 
  * @export
  * @interface Customs
  */
 export interface Customs {
     /**
      * A unique identifier
      * @type {string}
      * @memberof Customs
      */
     id?: string;
     /**
      * 
      * @type {string}
      * @memberof Customs
      */
     aes?: string;
     /**
      * 
      * @type {string}
      * @memberof Customs
      */
     eel_pfc?: string;
     /**
      * 
      * @type {string}
      * @memberof Customs
      */
     content_type?: Customs.ContentTypeEnum;
     /**
      * 
      * @type {string}
      * @memberof Customs
      */
     content_description?: string;
     /**
      * The customs 'term of trade' also known as 'incoterm'
      * @type {string}
      * @memberof Customs
      */
     incoterm?: Customs.IncotermEnum;
     /**
      * The parcel content items
      * @type {Array<Commodity>}
      * @memberof Customs
      */
     commodities?: Array<Commodity>;
     /**
      * 
      * @type {Payment}
      * @memberof Customs
      */
     duty?: Payment;
     /**
      * The invoice reference number
      * @type {string}
      * @memberof Customs
      */
     invoice?: string;
     /**
      * Indicates if the shipment is commercial
      * @type {boolean}
      * @memberof Customs
      */
     commercial_invoice?: boolean;
     /**
      * Indicate that signer certified confirmed all
      * @type {boolean}
      * @memberof Customs
      */
     certify?: boolean;
     /**
      * 
      * @type {string}
      * @memberof Customs
      */
     signer?: string;
     /**
      * 
      * @type {string}
      * @memberof Customs
      */
     certificate_number?: string;
     /**
      * 
      * @type {any}
      * @memberof Customs
      */
     options?: any;
 }
 
 /**
  * @export
  * @namespace Customs
  */
 export namespace Customs {
     /**
      * @export
      * @enum {string}
      */
     export enum ContentTypeEnum {
         Documents = <any> 'documents',
         Gift = <any> 'gift',
         Sample = <any> 'sample',
         Merchandise = <any> 'merchandise',
         ReturnMerchandise = <any> 'return_merchandise',
         Other = <any> 'other'
     }
     /**
      * @export
      * @enum {string}
      */
     export enum IncotermEnum {
         CFR = <any> 'CFR',
         CIF = <any> 'CIF',
         CIP = <any> 'CIP',
         CPT = <any> 'CPT',
         DAF = <any> 'DAF',
         DDP = <any> 'DDP',
         DDU = <any> 'DDU',
         DEQ = <any> 'DEQ',
         DES = <any> 'DES',
         EXW = <any> 'EXW',
         FAS = <any> 'FAS',
         FCA = <any> 'FCA',
         FOB = <any> 'FOB'
     }
 }
 /**
  * 
  * @export
  * @interface CustomsData
  */
 export interface CustomsData {
     /**
      * 
      * @type {string}
      * @memberof CustomsData
      */
     aes?: string;
     /**
      * 
      * @type {string}
      * @memberof CustomsData
      */
     eel_pfc?: string;
     /**
      * 
      * @type {string}
      * @memberof CustomsData
      */
     content_type?: CustomsData.ContentTypeEnum;
     /**
      * 
      * @type {string}
      * @memberof CustomsData
      */
     content_description?: string;
     /**
      * The customs 'term of trade' also known as 'incoterm'
      * @type {string}
      * @memberof CustomsData
      */
     incoterm?: CustomsData.IncotermEnum;
     /**
      * The parcel content items
      * @type {Array<Commodity>}
      * @memberof CustomsData
      */
     commodities?: Array<Commodity>;
     /**
      * 
      * @type {Payment}
      * @memberof CustomsData
      */
     duty?: Payment;
     /**
      * The invoice reference number
      * @type {string}
      * @memberof CustomsData
      */
     invoice?: string;
     /**
      * Indicates if the shipment is commercial
      * @type {boolean}
      * @memberof CustomsData
      */
     commercial_invoice?: boolean;
     /**
      * Indicate that signer certified confirmed all
      * @type {boolean}
      * @memberof CustomsData
      */
     certify?: boolean;
     /**
      * 
      * @type {string}
      * @memberof CustomsData
      */
     signer?: string;
     /**
      * 
      * @type {string}
      * @memberof CustomsData
      */
     certificate_number?: string;
     /**
      * 
      * @type {any}
      * @memberof CustomsData
      */
     options?: any;
 }
 
 /**
  * @export
  * @namespace CustomsData
  */
 export namespace CustomsData {
     /**
      * @export
      * @enum {string}
      */
     export enum ContentTypeEnum {
         Documents = <any> 'documents',
         Gift = <any> 'gift',
         Sample = <any> 'sample',
         Merchandise = <any> 'merchandise',
         ReturnMerchandise = <any> 'return_merchandise',
         Other = <any> 'other'
     }
     /**
      * @export
      * @enum {string}
      */
     export enum IncotermEnum {
         CFR = <any> 'CFR',
         CIF = <any> 'CIF',
         CIP = <any> 'CIP',
         CPT = <any> 'CPT',
         DAF = <any> 'DAF',
         DDP = <any> 'DDP',
         DDU = <any> 'DDU',
         DEQ = <any> 'DEQ',
         DES = <any> 'DES',
         EXW = <any> 'EXW',
         FAS = <any> 'FAS',
         FCA = <any> 'FCA',
         FOB = <any> 'FOB'
     }
 }
 /**
  * 
  * @export
  * @interface CustomsList
  */
 export interface CustomsList {
     /**
      * 
      * @type {string}
      * @memberof CustomsList
      */
     next?: string;
     /**
      * 
      * @type {string}
      * @memberof CustomsList
      */
     previous?: string;
     /**
      * 
      * @type {Array<Customs>}
      * @memberof CustomsList
      */
     results: Array<Customs>;
 }
 /**
  * 
  * @export
  * @interface ErrorResponse
  */
 export interface ErrorResponse {
     /**
      * The list of error messages
      * @type {Array<Message>}
      * @memberof ErrorResponse
      */
     messages?: Array<Message>;
 }
 /**
  * 
  * @export
  * @interface LabelPrintingRequest
  */
 export interface LabelPrintingRequest {
     /**
      *  PDF file name.  eg: shipment-[trackingNumber] 
      * @type {string}
      * @memberof LabelPrintingRequest
      */
     name: string;
     /**
      * Shipment base64 label
      * @type {string}
      * @memberof LabelPrintingRequest
      */
     label: string;
 }
 /**
  * The list of error messages
  * @export
  * @interface Message
  */
 export interface Message {
     /**
      * The targeted carrier
      * @type {string}
      * @memberof Message
      */
     carrier_name: string;
     /**
      * The targeted carrier name (unique identifier)
      * @type {string}
      * @memberof Message
      */
     carrier_id: string;
     /**
      * The error or warning message
      * @type {string}
      * @memberof Message
      */
     message?: string;
     /**
      * The message code
      * @type {string}
      * @memberof Message
      */
     code?: string;
     /**
      * any additional details
      * @type {{ [key: string]: string; }}
      * @memberof Message
      */
     details?: { [key: string]: string; };
 }
 /**
  * 
  * @export
  * @interface Operation
  */
 export interface Operation {
     /**
      * Operation performed
      * @type {string}
      * @memberof Operation
      */
     operation: string;
     /**
      * Specify whether the operation was successful
      * @type {boolean}
      * @memberof Operation
      */
     success: boolean;
 }
 /**
  * 
  * @export
  * @interface OperationConfirmation
  */
 export interface OperationConfirmation {
     /**
      * Operation performed
      * @type {string}
      * @memberof OperationConfirmation
      */
     operation: string;
     /**
      * Specify whether the operation was successful
      * @type {boolean}
      * @memberof OperationConfirmation
      */
     success: boolean;
     /**
      * The operation carrier
      * @type {string}
      * @memberof OperationConfirmation
      */
     carrier_name: string;
     /**
      * The targeted carrier's name (unique identifier)
      * @type {string}
      * @memberof OperationConfirmation
      */
     carrier_id: string;
 }
 /**
  * 
  * @export
  * @interface OperationResponse
  */
 export interface OperationResponse {
     /**
      * The list of note or warning messages
      * @type {Array<Message>}
      * @memberof OperationResponse
      */
     messages?: Array<Message>;
     /**
      * 
      * @type {OperationConfirmation}
      * @memberof OperationResponse
      */
     confirmation?: OperationConfirmation;
 }
 /**
  * 
  * @export
  * @interface Parcel
  */
 export interface Parcel {
     /**
      * A unique identifier
      * @type {string}
      * @memberof Parcel
      */
     id?: string;
     /**
      * The parcel's weight
      * @type {number}
      * @memberof Parcel
      */
     weight: number;
     /**
      * The parcel's width
      * @type {number}
      * @memberof Parcel
      */
     width?: number;
     /**
      * The parcel's height
      * @type {number}
      * @memberof Parcel
      */
     height?: number;
     /**
      * The parcel's length
      * @type {number}
      * @memberof Parcel
      */
     length?: number;
     /**
      *  The parcel's packaging type.  **Note that the packaging is optional when using a package preset**  values: <br/>- **envelope**<br/>- **pak**<br/>- **tube**<br/>- **pallet**<br/>- **small_box**<br/>- **medium_box**<br/>- **your_packaging**  For specific carriers packaging type, please consult [the reference](#operation/references). 
      * @type {string}
      * @memberof Parcel
      */
     packaging_type?: string;
     /**
      *  The parcel's package preset.  For specific carriers package preset, please consult [the reference](#operation/references). 
      * @type {string}
      * @memberof Parcel
      */
     package_preset?: string;
     /**
      * The parcel's description
      * @type {string}
      * @memberof Parcel
      */
     description?: string;
     /**
      * The parcel's content description
      * @type {string}
      * @memberof Parcel
      */
     content?: string;
     /**
      * Indicates if the parcel is composed of documents only
      * @type {boolean}
      * @memberof Parcel
      */
     is_document?: boolean;
     /**
      * The parcel's weight unit
      * @type {string}
      * @memberof Parcel
      */
     weight_unit: Parcel.WeightUnitEnum;
     /**
      * The parcel's dimension unit
      * @type {string}
      * @memberof Parcel
      */
     dimension_unit?: Parcel.DimensionUnitEnum;
 }
 
 /**
  * @export
  * @namespace Parcel
  */
 export namespace Parcel {
     /**
      * @export
      * @enum {string}
      */
     export enum WeightUnitEnum {
         KG = <any> 'KG',
         LB = <any> 'LB'
     }
     /**
      * @export
      * @enum {string}
      */
     export enum DimensionUnitEnum {
         CM = <any> 'CM',
         IN = <any> 'IN'
     }
 }
 /**
  * 
  * @export
  * @interface ParcelData
  */
 export interface ParcelData {
     /**
      * The parcel's weight
      * @type {number}
      * @memberof ParcelData
      */
     weight: number;
     /**
      * The parcel's width
      * @type {number}
      * @memberof ParcelData
      */
     width?: number;
     /**
      * The parcel's height
      * @type {number}
      * @memberof ParcelData
      */
     height?: number;
     /**
      * The parcel's length
      * @type {number}
      * @memberof ParcelData
      */
     length?: number;
     /**
      *  The parcel's packaging type.  **Note that the packaging is optional when using a package preset**  values: <br/>- **envelope**<br/>- **pak**<br/>- **tube**<br/>- **pallet**<br/>- **small_box**<br/>- **medium_box**<br/>- **your_packaging**  For specific carriers packaging type, please consult [the reference](#operation/references). 
      * @type {string}
      * @memberof ParcelData
      */
     packaging_type?: string;
     /**
      *  The parcel's package preset.  For specific carriers package preset, please consult [the reference](#operation/references). 
      * @type {string}
      * @memberof ParcelData
      */
     package_preset?: string;
     /**
      * The parcel's description
      * @type {string}
      * @memberof ParcelData
      */
     description?: string;
     /**
      * The parcel's content description
      * @type {string}
      * @memberof ParcelData
      */
     content?: string;
     /**
      * Indicates if the parcel is composed of documents only
      * @type {boolean}
      * @memberof ParcelData
      */
     is_document?: boolean;
     /**
      * The parcel's weight unit
      * @type {string}
      * @memberof ParcelData
      */
     weight_unit: ParcelData.WeightUnitEnum;
     /**
      * The parcel's dimension unit
      * @type {string}
      * @memberof ParcelData
      */
     dimension_unit?: ParcelData.DimensionUnitEnum;
 }
 
 /**
  * @export
  * @namespace ParcelData
  */
 export namespace ParcelData {
     /**
      * @export
      * @enum {string}
      */
     export enum WeightUnitEnum {
         KG = <any> 'KG',
         LB = <any> 'LB'
     }
     /**
      * @export
      * @enum {string}
      */
     export enum DimensionUnitEnum {
         CM = <any> 'CM',
         IN = <any> 'IN'
     }
 }
 /**
  * 
  * @export
  * @interface ParcelList
  */
 export interface ParcelList {
     /**
      * 
      * @type {string}
      * @memberof ParcelList
      */
     next?: string;
     /**
      * 
      * @type {string}
      * @memberof ParcelList
      */
     previous?: string;
     /**
      * 
      * @type {Array<Parcel>}
      * @memberof ParcelList
      */
     results: Array<Parcel>;
 }
 /**
  *  The payment details.<br/> Note that this is required for a Dutiable parcel shipped internationally. 
  * @export
  * @interface Payment
  */
 export interface Payment {
     /**
      * A unique identifier
      * @type {string}
      * @memberof Payment
      */
     id?: string;
     /**
      * The payment payer
      * @type {string}
      * @memberof Payment
      */
     paid_by?: Payment.PaidByEnum;
     /**
      * The payment amount if known
      * @type {number}
      * @memberof Payment
      */
     amount?: number;
     /**
      * The payment amount currency
      * @type {string}
      * @memberof Payment
      */
     currency: Payment.CurrencyEnum;
     /**
      * The selected rate carrier payer account number
      * @type {string}
      * @memberof Payment
      */
     account_number?: string;
     /**
      * 
      * @type {Address}
      * @memberof Payment
      */
     contact?: Address;
 }
 
 /**
  * @export
  * @namespace Payment
  */
 export namespace Payment {
     /**
      * @export
      * @enum {string}
      */
     export enum PaidByEnum {
         Sender = <any> 'sender',
         Recipient = <any> 'recipient',
         ThirdParty = <any> 'third_party'
     }
     /**
      * @export
      * @enum {string}
      */
     export enum CurrencyEnum {
         EUR = <any> 'EUR',
         AED = <any> 'AED',
         USD = <any> 'USD',
         XCD = <any> 'XCD',
         AMD = <any> 'AMD',
         ANG = <any> 'ANG',
         AOA = <any> 'AOA',
         ARS = <any> 'ARS',
         AUD = <any> 'AUD',
         AWG = <any> 'AWG',
         AZN = <any> 'AZN',
         BAM = <any> 'BAM',
         BBD = <any> 'BBD',
         BDT = <any> 'BDT',
         XOF = <any> 'XOF',
         BGN = <any> 'BGN',
         BHD = <any> 'BHD',
         BIF = <any> 'BIF',
         BMD = <any> 'BMD',
         BND = <any> 'BND',
         BOB = <any> 'BOB',
         BRL = <any> 'BRL',
         BSD = <any> 'BSD',
         BTN = <any> 'BTN',
         BWP = <any> 'BWP',
         BYN = <any> 'BYN',
         BZD = <any> 'BZD',
         CAD = <any> 'CAD',
         CDF = <any> 'CDF',
         XAF = <any> 'XAF',
         CHF = <any> 'CHF',
         NZD = <any> 'NZD',
         CLP = <any> 'CLP',
         CNY = <any> 'CNY',
         COP = <any> 'COP',
         CRC = <any> 'CRC',
         CUC = <any> 'CUC',
         CVE = <any> 'CVE',
         CZK = <any> 'CZK',
         DJF = <any> 'DJF',
         DKK = <any> 'DKK',
         DOP = <any> 'DOP',
         DZD = <any> 'DZD',
         EGP = <any> 'EGP',
         ERN = <any> 'ERN',
         ETB = <any> 'ETB',
         FJD = <any> 'FJD',
         GBP = <any> 'GBP',
         GEL = <any> 'GEL',
         GHS = <any> 'GHS',
         GMD = <any> 'GMD',
         GNF = <any> 'GNF',
         GTQ = <any> 'GTQ',
         GYD = <any> 'GYD',
         HKD = <any> 'HKD',
         HNL = <any> 'HNL',
         HRK = <any> 'HRK',
         HTG = <any> 'HTG',
         HUF = <any> 'HUF',
         IDR = <any> 'IDR',
         ILS = <any> 'ILS',
         INR = <any> 'INR',
         IRR = <any> 'IRR',
         ISK = <any> 'ISK',
         JMD = <any> 'JMD',
         JOD = <any> 'JOD',
         JPY = <any> 'JPY',
         KES = <any> 'KES',
         KGS = <any> 'KGS',
         KHR = <any> 'KHR',
         KMF = <any> 'KMF',
         KPW = <any> 'KPW',
         KRW = <any> 'KRW',
         KWD = <any> 'KWD',
         KYD = <any> 'KYD',
         KZT = <any> 'KZT',
         LAK = <any> 'LAK',
         LKR = <any> 'LKR',
         LRD = <any> 'LRD',
         LSL = <any> 'LSL',
         LYD = <any> 'LYD',
         MAD = <any> 'MAD',
         MDL = <any> 'MDL',
         MGA = <any> 'MGA',
         MKD = <any> 'MKD',
         MMK = <any> 'MMK',
         MNT = <any> 'MNT',
         MOP = <any> 'MOP',
         MRO = <any> 'MRO',
         MUR = <any> 'MUR',
         MVR = <any> 'MVR',
         MWK = <any> 'MWK',
         MXN = <any> 'MXN',
         MYR = <any> 'MYR',
         MZN = <any> 'MZN',
         NAD = <any> 'NAD',
         XPF = <any> 'XPF',
         NGN = <any> 'NGN',
         NIO = <any> 'NIO',
         NOK = <any> 'NOK',
         NPR = <any> 'NPR',
         OMR = <any> 'OMR',
         PEN = <any> 'PEN',
         PGK = <any> 'PGK',
         PHP = <any> 'PHP',
         PKR = <any> 'PKR',
         PLN = <any> 'PLN',
         PYG = <any> 'PYG',
         QAR = <any> 'QAR',
         RSD = <any> 'RSD',
         RUB = <any> 'RUB',
         RWF = <any> 'RWF',
         SAR = <any> 'SAR',
         SBD = <any> 'SBD',
         SCR = <any> 'SCR',
         SDG = <any> 'SDG',
         SEK = <any> 'SEK',
         SGD = <any> 'SGD',
         SHP = <any> 'SHP',
         SLL = <any> 'SLL',
         SOS = <any> 'SOS',
         SRD = <any> 'SRD',
         SSP = <any> 'SSP',
         STD = <any> 'STD',
         SYP = <any> 'SYP',
         SZL = <any> 'SZL',
         THB = <any> 'THB',
         TJS = <any> 'TJS',
         TND = <any> 'TND',
         TOP = <any> 'TOP',
         TRY = <any> 'TRY',
         TTD = <any> 'TTD',
         TWD = <any> 'TWD',
         TZS = <any> 'TZS',
         UAH = <any> 'UAH',
         UYU = <any> 'UYU',
         UZS = <any> 'UZS',
         VEF = <any> 'VEF',
         VND = <any> 'VND',
         VUV = <any> 'VUV',
         WST = <any> 'WST',
         YER = <any> 'YER',
         ZAR = <any> 'ZAR'
     }
 }
 /**
  * The payment details
  * @export
  * @interface PaymentData
  */
 export interface PaymentData {
     /**
      * The payment payer
      * @type {string}
      * @memberof PaymentData
      */
     paid_by?: PaymentData.PaidByEnum;
     /**
      * The payment amount if known
      * @type {number}
      * @memberof PaymentData
      */
     amount?: number;
     /**
      * The payment amount currency
      * @type {string}
      * @memberof PaymentData
      */
     currency: PaymentData.CurrencyEnum;
     /**
      * The selected rate carrier payer account number
      * @type {string}
      * @memberof PaymentData
      */
     account_number?: string;
     /**
      * 
      * @type {Address}
      * @memberof PaymentData
      */
     contact?: Address;
 }
 
 /**
  * @export
  * @namespace PaymentData
  */
 export namespace PaymentData {
     /**
      * @export
      * @enum {string}
      */
     export enum PaidByEnum {
         Sender = <any> 'sender',
         Recipient = <any> 'recipient',
         ThirdParty = <any> 'third_party'
     }
     /**
      * @export
      * @enum {string}
      */
     export enum CurrencyEnum {
         EUR = <any> 'EUR',
         AED = <any> 'AED',
         USD = <any> 'USD',
         XCD = <any> 'XCD',
         AMD = <any> 'AMD',
         ANG = <any> 'ANG',
         AOA = <any> 'AOA',
         ARS = <any> 'ARS',
         AUD = <any> 'AUD',
         AWG = <any> 'AWG',
         AZN = <any> 'AZN',
         BAM = <any> 'BAM',
         BBD = <any> 'BBD',
         BDT = <any> 'BDT',
         XOF = <any> 'XOF',
         BGN = <any> 'BGN',
         BHD = <any> 'BHD',
         BIF = <any> 'BIF',
         BMD = <any> 'BMD',
         BND = <any> 'BND',
         BOB = <any> 'BOB',
         BRL = <any> 'BRL',
         BSD = <any> 'BSD',
         BTN = <any> 'BTN',
         BWP = <any> 'BWP',
         BYN = <any> 'BYN',
         BZD = <any> 'BZD',
         CAD = <any> 'CAD',
         CDF = <any> 'CDF',
         XAF = <any> 'XAF',
         CHF = <any> 'CHF',
         NZD = <any> 'NZD',
         CLP = <any> 'CLP',
         CNY = <any> 'CNY',
         COP = <any> 'COP',
         CRC = <any> 'CRC',
         CUC = <any> 'CUC',
         CVE = <any> 'CVE',
         CZK = <any> 'CZK',
         DJF = <any> 'DJF',
         DKK = <any> 'DKK',
         DOP = <any> 'DOP',
         DZD = <any> 'DZD',
         EGP = <any> 'EGP',
         ERN = <any> 'ERN',
         ETB = <any> 'ETB',
         FJD = <any> 'FJD',
         GBP = <any> 'GBP',
         GEL = <any> 'GEL',
         GHS = <any> 'GHS',
         GMD = <any> 'GMD',
         GNF = <any> 'GNF',
         GTQ = <any> 'GTQ',
         GYD = <any> 'GYD',
         HKD = <any> 'HKD',
         HNL = <any> 'HNL',
         HRK = <any> 'HRK',
         HTG = <any> 'HTG',
         HUF = <any> 'HUF',
         IDR = <any> 'IDR',
         ILS = <any> 'ILS',
         INR = <any> 'INR',
         IRR = <any> 'IRR',
         ISK = <any> 'ISK',
         JMD = <any> 'JMD',
         JOD = <any> 'JOD',
         JPY = <any> 'JPY',
         KES = <any> 'KES',
         KGS = <any> 'KGS',
         KHR = <any> 'KHR',
         KMF = <any> 'KMF',
         KPW = <any> 'KPW',
         KRW = <any> 'KRW',
         KWD = <any> 'KWD',
         KYD = <any> 'KYD',
         KZT = <any> 'KZT',
         LAK = <any> 'LAK',
         LKR = <any> 'LKR',
         LRD = <any> 'LRD',
         LSL = <any> 'LSL',
         LYD = <any> 'LYD',
         MAD = <any> 'MAD',
         MDL = <any> 'MDL',
         MGA = <any> 'MGA',
         MKD = <any> 'MKD',
         MMK = <any> 'MMK',
         MNT = <any> 'MNT',
         MOP = <any> 'MOP',
         MRO = <any> 'MRO',
         MUR = <any> 'MUR',
         MVR = <any> 'MVR',
         MWK = <any> 'MWK',
         MXN = <any> 'MXN',
         MYR = <any> 'MYR',
         MZN = <any> 'MZN',
         NAD = <any> 'NAD',
         XPF = <any> 'XPF',
         NGN = <any> 'NGN',
         NIO = <any> 'NIO',
         NOK = <any> 'NOK',
         NPR = <any> 'NPR',
         OMR = <any> 'OMR',
         PEN = <any> 'PEN',
         PGK = <any> 'PGK',
         PHP = <any> 'PHP',
         PKR = <any> 'PKR',
         PLN = <any> 'PLN',
         PYG = <any> 'PYG',
         QAR = <any> 'QAR',
         RSD = <any> 'RSD',
         RUB = <any> 'RUB',
         RWF = <any> 'RWF',
         SAR = <any> 'SAR',
         SBD = <any> 'SBD',
         SCR = <any> 'SCR',
         SDG = <any> 'SDG',
         SEK = <any> 'SEK',
         SGD = <any> 'SGD',
         SHP = <any> 'SHP',
         SLL = <any> 'SLL',
         SOS = <any> 'SOS',
         SRD = <any> 'SRD',
         SSP = <any> 'SSP',
         STD = <any> 'STD',
         SYP = <any> 'SYP',
         SZL = <any> 'SZL',
         THB = <any> 'THB',
         TJS = <any> 'TJS',
         TND = <any> 'TND',
         TOP = <any> 'TOP',
         TRY = <any> 'TRY',
         TTD = <any> 'TTD',
         TWD = <any> 'TWD',
         TZS = <any> 'TZS',
         UAH = <any> 'UAH',
         UYU = <any> 'UYU',
         UZS = <any> 'UZS',
         VEF = <any> 'VEF',
         VND = <any> 'VND',
         VUV = <any> 'VUV',
         WST = <any> 'WST',
         YER = <any> 'YER',
         ZAR = <any> 'ZAR'
     }
 }
 /**
  * 
  * @export
  * @interface Pickup
  */
 export interface Pickup {
     /**
      * A unique pickup identifier
      * @type {string}
      * @memberof Pickup
      */
     id?: string;
     /**
      * The pickup carrier
      * @type {string}
      * @memberof Pickup
      */
     carrier_name: string;
     /**
      * The pickup carrier configured name
      * @type {string}
      * @memberof Pickup
      */
     carrier_id: string;
     /**
      * The pickup confirmation identifier
      * @type {string}
      * @memberof Pickup
      */
     confirmation_number: string;
     /**
      * The pickup date
      * @type {string}
      * @memberof Pickup
      */
     pickup_date?: string;
     /**
      * 
      * @type {Charge}
      * @memberof Pickup
      */
     pickup_charge?: Charge;
     /**
      * The pickup expected ready time
      * @type {string}
      * @memberof Pickup
      */
     ready_time?: string;
     /**
      * The pickup expected closing or late time
      * @type {string}
      * @memberof Pickup
      */
     closing_time?: string;
     /**
      * 
      * @type {Address}
      * @memberof Pickup
      */
     address: Address;
     /**
      * The shipment parcels to pickup.
      * @type {Array<Parcel>}
      * @memberof Pickup
      */
     parcels: Array<Parcel>;
     /**
      *  The pickup instruction.  eg: Handle with care. 
      * @type {string}
      * @memberof Pickup
      */
     instruction?: string;
     /**
      *  The package(s) location.  eg: Behind the entrance door. 
      * @type {string}
      * @memberof Pickup
      */
     package_location?: string;
     /**
      * Advanced carrier specific pickup options
      * @type {any}
      * @memberof Pickup
      */
     options?: any;
     /**
      * Specified whether it was created with a carrier in test mode
      * @type {boolean}
      * @memberof Pickup
      */
     test_mode: boolean;
 }
 /**
  * 
  * @export
  * @interface PickupCancelData
  */
 export interface PickupCancelData {
     /**
      * The reason of the pickup cancellation
      * @type {string}
      * @memberof PickupCancelData
      */
     reason?: string;
 }
 /**
  * 
  * @export
  * @interface PickupCancelRequest
  */
 export interface PickupCancelRequest {
     /**
      * The pickup confirmation identifier
      * @type {string}
      * @memberof PickupCancelRequest
      */
     confirmation_number: string;
     /**
      * 
      * @type {AddressData}
      * @memberof PickupCancelRequest
      */
     address?: AddressData;
     /**
      *  The pickup date  Date Format: `YYYY-MM-DD` 
      * @type {string}
      * @memberof PickupCancelRequest
      */
     pickup_date?: string;
     /**
      * The reason of the pickup cancellation
      * @type {string}
      * @memberof PickupCancelRequest
      */
     reason?: string;
 }
 /**
  * 
  * @export
  * @interface PickupData
  */
 export interface PickupData {
     /**
      *  The expected pickup date  Date Format: `YYYY-MM-DD` 
      * @type {string}
      * @memberof PickupData
      */
     pickup_date: string;
     /**
      * 
      * @type {AddressData}
      * @memberof PickupData
      */
     address?: AddressData;
     /**
      *  The ready time for pickup.  Time Format: `HH:MM` 
      * @type {string}
      * @memberof PickupData
      */
     ready_time: string;
     /**
      *  The closing or late time of the pickup  Time Format: `HH:MM` 
      * @type {string}
      * @memberof PickupData
      */
     closing_time: string;
     /**
      *  The pickup instruction.  eg: Handle with care. 
      * @type {string}
      * @memberof PickupData
      */
     instruction?: string;
     /**
      *  The package(s) location.  eg: Behind the entrance door. 
      * @type {string}
      * @memberof PickupData
      */
     package_location?: string;
     /**
      * Advanced carrier specific pickup options
      * @type {any}
      * @memberof PickupData
      */
     options?: any;
     /**
      * The list of shipments to be picked up
      * @type {Array<string>}
      * @memberof PickupData
      */
     tracking_numbers: Array<string>;
 }
 /**
  * 
  * @export
  * @interface PickupList
  */
 export interface PickupList {
     /**
      * 
      * @type {string}
      * @memberof PickupList
      */
     next?: string;
     /**
      * 
      * @type {string}
      * @memberof PickupList
      */
     previous?: string;
     /**
      * 
      * @type {Array<Pickup>}
      * @memberof PickupList
      */
     results: Array<Pickup>;
 }
 /**
  * 
  * @export
  * @interface PickupRequest
  */
 export interface PickupRequest {
     /**
      *  The expected pickup date  Date Format: `YYYY-MM-DD` 
      * @type {string}
      * @memberof PickupRequest
      */
     pickup_date: string;
     /**
      * 
      * @type {AddressData}
      * @memberof PickupRequest
      */
     address: AddressData;
     /**
      * The shipment parcels to pickup.
      * @type {Array<ParcelData>}
      * @memberof PickupRequest
      */
     parcels: Array<ParcelData>;
     /**
      *  The ready time for pickup.  Time Format: `HH:MM` 
      * @type {string}
      * @memberof PickupRequest
      */
     ready_time: string;
     /**
      *  The closing or late time of the pickup  Time Format: `HH:MM` 
      * @type {string}
      * @memberof PickupRequest
      */
     closing_time: string;
     /**
      *  The pickup instruction.  eg: Handle with care. 
      * @type {string}
      * @memberof PickupRequest
      */
     instruction?: string;
     /**
      *  The package(s) location.  eg: Behind the entrance door. 
      * @type {string}
      * @memberof PickupRequest
      */
     package_location?: string;
     /**
      * Advanced carrier specific pickup options
      * @type {any}
      * @memberof PickupRequest
      */
     options?: any;
 }
 /**
  * 
  * @export
  * @interface PickupResponse
  */
 export interface PickupResponse {
     /**
      * The list of note or warning messages
      * @type {Array<Message>}
      * @memberof PickupResponse
      */
     messages?: Array<Message>;
     /**
      * 
      * @type {Pickup}
      * @memberof PickupResponse
      */
     pickup?: Pickup;
 }
 /**
  * 
  * @export
  * @interface PickupUpdateData
  */
 export interface PickupUpdateData {
     /**
      *  The expected pickup date  Date Format: YYYY-MM-DD 
      * @type {string}
      * @memberof PickupUpdateData
      */
     pickup_date?: string;
     /**
      * 
      * @type {AddressData}
      * @memberof PickupUpdateData
      */
     address?: AddressData;
     /**
      * The ready time for pickup.
      * @type {string}
      * @memberof PickupUpdateData
      */
     ready_time?: string;
     /**
      * The closing or late time of the pickup
      * @type {string}
      * @memberof PickupUpdateData
      */
     closing_time?: string;
     /**
      *  The pickup instruction.  eg: Handle with care. 
      * @type {string}
      * @memberof PickupUpdateData
      */
     instruction?: string;
     /**
      *  The package(s) location.  eg: Behind the entrance door. 
      * @type {string}
      * @memberof PickupUpdateData
      */
     package_location?: string;
     /**
      * Advanced carrier specific pickup options
      * @type {any}
      * @memberof PickupUpdateData
      */
     options?: any;
     /**
      * The list of shipments to be picked up
      * @type {Array<string>}
      * @memberof PickupUpdateData
      */
     tracking_numbers?: Array<string>;
     /**
      * pickup identification number
      * @type {string}
      * @memberof PickupUpdateData
      */
     confirmation_number: string;
 }
 /**
  * 
  * @export
  * @interface PickupUpdateRequest
  */
 export interface PickupUpdateRequest {
     /**
      *  The expected pickup date  Date Format: `YYYY-MM-DD` 
      * @type {string}
      * @memberof PickupUpdateRequest
      */
     pickup_date: string;
     /**
      * 
      * @type {Address}
      * @memberof PickupUpdateRequest
      */
     address: Address;
     /**
      * The shipment parcels to pickup.
      * @type {Array<Parcel>}
      * @memberof PickupUpdateRequest
      */
     parcels: Array<Parcel>;
     /**
      * pickup identification number
      * @type {string}
      * @memberof PickupUpdateRequest
      */
     confirmation_number: string;
     /**
      *  The ready time for pickup.  Time Format: `HH:MM` 
      * @type {string}
      * @memberof PickupUpdateRequest
      */
     ready_time: string;
     /**
      *  The closing or late time of the pickup  Time Format: `HH:MM` 
      * @type {string}
      * @memberof PickupUpdateRequest
      */
     closing_time: string;
     /**
      *  The pickup instruction.  eg: Handle with care. 
      * @type {string}
      * @memberof PickupUpdateRequest
      */
     instruction?: string;
     /**
      *  The package(s) location.  eg: Behind the entrance door. 
      * @type {string}
      * @memberof PickupUpdateRequest
      */
     package_location?: string;
     /**
      * Advanced carrier specific pickup options
      * @type {any}
      * @memberof PickupUpdateRequest
      */
     options?: any;
 }
 /**
  * The list of returned rates
  * @export
  * @interface Rate
  */
 export interface Rate {
     /**
      * A unique identifier
      * @type {string}
      * @memberof Rate
      */
     id?: string;
     /**
      * The rate's carrier
      * @type {string}
      * @memberof Rate
      */
     carrier_name: string;
     /**
      * The targeted carrier's name (unique identifier)
      * @type {string}
      * @memberof Rate
      */
     carrier_id: string;
     /**
      * The rate monetary values currency code
      * @type {string}
      * @memberof Rate
      */
     currency: string;
     /**
      * The carrier's rate (quote) service
      * @type {string}
      * @memberof Rate
      */
     service?: string;
     /**
      * The monetary amount of the discount on the rate
      * @type {number}
      * @memberof Rate
      */
     discount?: number;
     /**
      *  The rate's monetary amount of the base charge.<br/> This is the net amount of the rate before additional charges 
      * @type {number}
      * @memberof Rate
      */
     base_charge?: number;
     /**
      *  The rate's monetary amount of the total charge.<br/> This is the gross amount of the rate after adding the additional charges 
      * @type {number}
      * @memberof Rate
      */
     total_charge?: number;
     /**
      * The monetary amount of the duties and taxes if applied
      * @type {number}
      * @memberof Rate
      */
     duties_and_taxes?: number;
     /**
      * The estimated delivery transit days
      * @type {number}
      * @memberof Rate
      */
     transit_days?: number;
     /**
      * list of the rate's additional charges
      * @type {Array<Charge>}
      * @memberof Rate
      */
     extra_charges?: Array<Charge>;
     /**
      * provider specific metadata
      * @type {any}
      * @memberof Rate
      */
     meta?: any;
     /**
      * The system carrier configuration id
      * @type {string}
      * @memberof Rate
      */
     carrier_ref?: string;
     /**
      * Specified whether it was created with a carrier in test mode
      * @type {boolean}
      * @memberof Rate
      */
     test_mode: boolean;
 }
 /**
  * 
  * @export
  * @interface RateRequest
  */
 export interface RateRequest {
     /**
      * 
      * @type {Address}
      * @memberof RateRequest
      */
     shipper: Address;
     /**
      * 
      * @type {Address}
      * @memberof RateRequest
      */
     recipient: Address;
     /**
      * The shipment's parcels
      * @type {Array<Parcel>}
      * @memberof RateRequest
      */
     parcels: Array<Parcel>;
     /**
      *  The requested carrier service for the shipment.<br/> Please consult [the reference](#operation/references) for specific carriers services.  Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
      * @type {Array<string>}
      * @memberof RateRequest
      */
     services?: Array<string>;
     /**
      *  The options available for the shipment.  Please consult [the reference](#operation/references) for additional specific carriers options. 
      * @type {any}
      * @memberof RateRequest
      */
     options?: any;
     /**
      * The shipment reference
      * @type {string}
      * @memberof RateRequest
      */
     reference?: string;
     /**
      *  The list of configured carriers you wish to get rates from. 
      * @type {Array<string>}
      * @memberof RateRequest
      */
     carrier_ids?: Array<string>;
 }
 /**
  * 
  * @export
  * @interface RateResponse
  */
 export interface RateResponse {
     /**
      * The list of note or warning messages
      * @type {Array<Message>}
      * @memberof RateResponse
      */
     messages?: Array<Message>;
     /**
      * The list of returned rates
      * @type {Array<Rate>}
      * @memberof RateResponse
      */
     rates: Array<Rate>;
 }
 /**
  * 
  * @export
  * @interface References
  */
 export interface References {
     /**
      * 
      * @type {string}
      * @memberof References
      */
     APP_NAME: string;
     /**
      * 
      * @type {string}
      * @memberof References
      */
     APP_VERSION: string;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     countries: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     currencies: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     carriers: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     customs_content_type: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     incoterms: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     states: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     services: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     options: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     package_presets: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     packaging_types: any;
     /**
      * 
      * @type {any}
      * @memberof References
      */
     payment_types: any;
 }
 /**
  * 
  * @export
  * @interface Shipment
  */
 export interface Shipment {
     /**
      * A unique identifier
      * @type {string}
      * @memberof Shipment
      */
     id?: string;
     /**
      * The current Shipment status
      * @type {string}
      * @memberof Shipment
      */
     status?: Shipment.StatusEnum;
     /**
      * The shipment carrier
      * @type {string}
      * @memberof Shipment
      */
     carrier_name?: string;
     /**
      * The shipment carrier configured identifier
      * @type {string}
      * @memberof Shipment
      */
     carrier_id?: string;
     /**
      * The shipment label in base64 string
      * @type {string}
      * @memberof Shipment
      */
     label?: string;
     /**
      * The shipment tracking number
      * @type {string}
      * @memberof Shipment
      */
     tracking_number?: string;
     /**
      * The shipment carrier system identifier
      * @type {string}
      * @memberof Shipment
      */
     shipment_identifier?: string;
     /**
      * 
      * @type {Rate}
      * @memberof Shipment
      */
     selected_rate?: Rate;
     /**
      * The shipment selected rate.
      * @type {string}
      * @memberof Shipment
      */
     selected_rate_id?: string;
     /**
      * The list for shipment rates fetched previously
      * @type {Array<Rate>}
      * @memberof Shipment
      */
     rates?: Array<Rate>;
     /**
      * The shipment tracking url
      * @type {string}
      * @memberof Shipment
      */
     tracking_url?: string;
     /**
      * The selected service
      * @type {string}
      * @memberof Shipment
      */
     service?: string;
     /**
      * 
      * @type {Address}
      * @memberof Shipment
      */
     shipper: Address;
     /**
      * 
      * @type {Address}
      * @memberof Shipment
      */
     recipient: Address;
     /**
      * The shipment's parcels
      * @type {Array<Parcel>}
      * @memberof Shipment
      */
     parcels: Array<Parcel>;
     /**
      *  The carriers services requested for the shipment.  Please consult [the reference](#operation/references) for specific carriers services.<br/> Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
      * @type {Array<string>}
      * @memberof Shipment
      */
     services?: Array<string>;
     /**
      *  The options available for the shipment.<br/> Please consult [the reference](#operation/references) for additional specific carriers options. 
      * @type {any}
      * @memberof Shipment
      */
     options?: any;
     /**
      * 
      * @type {Payment}
      * @memberof Shipment
      */
     payment?: Payment;
     /**
      * 
      * @type {Customs}
      * @memberof Shipment
      */
     customs?: Customs;
     /**
      * The shipment reference
      * @type {string}
      * @memberof Shipment
      */
     reference?: string;
     /**
      * The shipment label file type.
      * @type {string}
      * @memberof Shipment
      */
     label_type?: Shipment.LabelTypeEnum;
     /**
      *  The list of configured carriers you wish to get rates from.  *Note that the request will be sent to all carriers in nothing is specified* 
      * @type {Array<string>}
      * @memberof Shipment
      */
     carrier_ids?: Array<string>;
     /**
      * provider specific metadata
      * @type {any}
      * @memberof Shipment
      */
     meta?: any;
     /**
      *  The shipment creation date  Date Format: `YYYY-MM-DD` 
      * @type {string}
      * @memberof Shipment
      */
     created_at: string;
     /**
      * Specified whether it was created with a carrier in test mode
      * @type {boolean}
      * @memberof Shipment
      */
     test_mode: boolean;
     /**
      * The list of note or warning messages
      * @type {Array<Message>}
      * @memberof Shipment
      */
     messages?: Array<Message>;
 }
 
 /**
  * @export
  * @namespace Shipment
  */
 export namespace Shipment {
     /**
      * @export
      * @enum {string}
      */
     export enum StatusEnum {
         Created = <any> 'created',
         Purchased = <any> 'purchased',
         Shipped = <any> 'shipped',
         Transit = <any> 'transit',
         Delivered = <any> 'delivered'
     }
     /**
      * @export
      * @enum {string}
      */
     export enum LabelTypeEnum {
         PDF = <any> 'PDF',
         ZPL = <any> 'ZPL'
     }
 }
 /**
  * 
  * @export
  * @interface ShipmentCancelRequest
  */
 export interface ShipmentCancelRequest {
     /**
      * The shipment identifier returned during creation
      * @type {string}
      * @memberof ShipmentCancelRequest
      */
     shipment_identifier: string;
     /**
      * The selected shipment service
      * @type {string}
      * @memberof ShipmentCancelRequest
      */
     service?: string;
     /**
      * Advanced carrier specific cancellation options
      * @type {any}
      * @memberof ShipmentCancelRequest
      */
     options?: any;
 }
 /**
  * 
  * @export
  * @interface ShipmentData
  */
 export interface ShipmentData {
     /**
      * 
      * @type {AddressData}
      * @memberof ShipmentData
      */
     shipper: AddressData;
     /**
      * 
      * @type {AddressData}
      * @memberof ShipmentData
      */
     recipient: AddressData;
     /**
      * The shipment's parcels
      * @type {Array<ParcelData>}
      * @memberof ShipmentData
      */
     parcels: Array<ParcelData>;
     /**
      *  The options available for the shipment.<br/> Please consult [the reference](#operation/references) for additional specific carriers options. 
      * @type {any}
      * @memberof ShipmentData
      */
     options?: any;
     /**
      * 
      * @type {PaymentData}
      * @memberof ShipmentData
      */
     payment?: PaymentData;
     /**
      * 
      * @type {CustomsData}
      * @memberof ShipmentData
      */
     customs?: CustomsData;
     /**
      * The shipment reference
      * @type {string}
      * @memberof ShipmentData
      */
     reference?: string;
     /**
      * The shipment label file type.
      * @type {string}
      * @memberof ShipmentData
      */
     label_type?: ShipmentData.LabelTypeEnum;
     /**
      *  The requested carrier service for the shipment.  Please consult [the reference](#operation/references) for specific carriers services.<br/> Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
      * @type {Array<string>}
      * @memberof ShipmentData
      */
     services?: Array<string>;
     /**
      *  The list of configured carriers you wish to get rates from.  *Note that the request will be sent to all carriers in nothing is specified* 
      * @type {Array<string>}
      * @memberof ShipmentData
      */
     carrier_ids?: Array<string>;
 }
 
 /**
  * @export
  * @namespace ShipmentData
  */
 export namespace ShipmentData {
     /**
      * @export
      * @enum {string}
      */
     export enum LabelTypeEnum {
         PDF = <any> 'PDF',
         ZPL = <any> 'ZPL'
     }
 }
 /**
  * 
  * @export
  * @interface ShipmentList
  */
 export interface ShipmentList {
     /**
      * 
      * @type {string}
      * @memberof ShipmentList
      */
     next?: string;
     /**
      * 
      * @type {string}
      * @memberof ShipmentList
      */
     previous?: string;
     /**
      * 
      * @type {Array<Shipment>}
      * @memberof ShipmentList
      */
     results: Array<Shipment>;
 }
 /**
  * 
  * @export
  * @interface ShipmentPurchaseData
  */
 export interface ShipmentPurchaseData {
     /**
      * The shipment selected rate.
      * @type {string}
      * @memberof ShipmentPurchaseData
      */
     selected_rate_id: string;
     /**
      * The shipment label file type.
      * @type {string}
      * @memberof ShipmentPurchaseData
      */
     label_type?: ShipmentPurchaseData.LabelTypeEnum;
     /**
      * 
      * @type {Payment}
      * @memberof ShipmentPurchaseData
      */
     payment?: Payment;
 }
 
 /**
  * @export
  * @namespace ShipmentPurchaseData
  */
 export namespace ShipmentPurchaseData {
     /**
      * @export
      * @enum {string}
      */
     export enum LabelTypeEnum {
         PDF = <any> 'PDF',
         ZPL = <any> 'ZPL'
     }
 }
 /**
  * 
  * @export
  * @interface ShippingRequest
  */
 export interface ShippingRequest {
     /**
      * 
      * @type {AddressData}
      * @memberof ShippingRequest
      */
     shipper: AddressData;
     /**
      * 
      * @type {AddressData}
      * @memberof ShippingRequest
      */
     recipient: AddressData;
     /**
      * The shipment's parcels
      * @type {Array<ParcelData>}
      * @memberof ShippingRequest
      */
     parcels: Array<ParcelData>;
     /**
      *  The options available for the shipment.<br/> Please consult [the reference](#operation/references) for additional specific carriers options. 
      * @type {any}
      * @memberof ShippingRequest
      */
     options?: any;
     /**
      * 
      * @type {Payment}
      * @memberof ShippingRequest
      */
     payment: Payment;
     /**
      * 
      * @type {CustomsData}
      * @memberof ShippingRequest
      */
     customs?: CustomsData;
     /**
      * The shipment reference
      * @type {string}
      * @memberof ShippingRequest
      */
     reference?: string;
     /**
      * The shipment label file type.
      * @type {string}
      * @memberof ShippingRequest
      */
     label_type?: ShippingRequest.LabelTypeEnum;
     /**
      * The shipment selected rate.
      * @type {string}
      * @memberof ShippingRequest
      */
     selected_rate_id: string;
     /**
      * The list for shipment rates fetched previously
      * @type {Array<Rate>}
      * @memberof ShippingRequest
      */
     rates: Array<Rate>;
 }
 
 /**
  * @export
  * @namespace ShippingRequest
  */
 export namespace ShippingRequest {
     /**
      * @export
      * @enum {string}
      */
     export enum LabelTypeEnum {
         PDF = <any> 'PDF',
         ZPL = <any> 'ZPL'
     }
 }
 /**
  * 
  * @export
  * @interface TrackerList
  */
 export interface TrackerList {
     /**
      * 
      * @type {string}
      * @memberof TrackerList
      */
     next?: string;
     /**
      * 
      * @type {string}
      * @memberof TrackerList
      */
     previous?: string;
     /**
      * 
      * @type {Array<TrackingStatus>}
      * @memberof TrackerList
      */
     results: Array<TrackingStatus>;
 }
 /**
  * The tracking details events
  * @export
  * @interface TrackingEvent
  */
 export interface TrackingEvent {
     /**
      * The tracking event's date
      * @type {string}
      * @memberof TrackingEvent
      */
     date?: string;
     /**
      * The tracking event's description
      * @type {string}
      * @memberof TrackingEvent
      */
     description?: string;
     /**
      * The tracking event's location
      * @type {string}
      * @memberof TrackingEvent
      */
     location?: string;
     /**
      * The tracking event's code
      * @type {string}
      * @memberof TrackingEvent
      */
     code?: string;
     /**
      * The tracking event's time
      * @type {string}
      * @memberof TrackingEvent
      */
     time?: string;
 }
 /**
  * 
  * @export
  * @interface TrackingResponse
  */
 export interface TrackingResponse {
     /**
      * The list of note or warning messages
      * @type {Array<Message>}
      * @memberof TrackingResponse
      */
     messages?: Array<Message>;
     /**
      * 
      * @type {TrackingStatus}
      * @memberof TrackingResponse
      */
     tracking?: TrackingStatus;
 }
 /**
  * The tracking details retrieved
  * @export
  * @interface TrackingStatus
  */
 export interface TrackingStatus {
     /**
      * A unique identifier
      * @type {string}
      * @memberof TrackingStatus
      */
     id?: string;
     /**
      * The tracking carrier
      * @type {string}
      * @memberof TrackingStatus
      */
     carrier_name: string;
     /**
      * The tracking carrier configured identifier
      * @type {string}
      * @memberof TrackingStatus
      */
     carrier_id: string;
     /**
      * The shipment tracking number
      * @type {string}
      * @memberof TrackingStatus
      */
     tracking_number: string;
     /**
      * The tracking details events
      * @type {Array<TrackingEvent>}
      * @memberof TrackingStatus
      */
     events?: Array<TrackingEvent>;
     /**
      * Specified whether the related shipment was delivered
      * @type {boolean}
      * @memberof TrackingStatus
      */
     delivered?: boolean;
     /**
      * Specified whether the object was created with a carrier in test mode
      * @type {boolean}
      * @memberof TrackingStatus
      */
     test_mode: boolean;
 }
 /**
  * AddressesApi - fetch parameter creator
  * @export
  */
 export const AddressesApiFetchParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Create a new address.
          * @summary Create an address
          * @param {AddressData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: AddressData, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling create.');
             }
             const localVarPath = `/addresses`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"AddressData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve all addresses.
          * @summary List all addresses
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options: any = {}): FetchArgs {
             const localVarPath = `/addresses`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (limit !== undefined) {
                 localVarQueryParameter['limit'] = limit;
             }
 
             if (offset !== undefined) {
                 localVarQueryParameter['offset'] = offset;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve an address.
          * @summary Retrieve an address
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options: any = {}): FetchArgs {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling retrieve.');
             }
             const localVarPath = `/addresses/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * update an address.
          * @summary Update an address
          * @param {AddressData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: AddressData, id: string, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling update.');
             }
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling update.');
             }
             const localVarPath = `/addresses/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"AddressData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * AddressesApi - functional programming interface
  * @export
  */
 export const AddressesApiFp = function(configuration?: Configuration) {
     return {
         /**
          * Create a new address.
          * @summary Create an address
          * @param {AddressData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: AddressData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Address> {
             const localVarFetchArgs = AddressesApiFetchParamCreator(configuration).create(body, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve all addresses.
          * @summary List all addresses
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddressList> {
             const localVarFetchArgs = AddressesApiFetchParamCreator(configuration).list(limit, offset, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve an address.
          * @summary Retrieve an address
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Address> {
             const localVarFetchArgs = AddressesApiFetchParamCreator(configuration).retrieve(id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * update an address.
          * @summary Update an address
          * @param {AddressData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: AddressData, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Address> {
             const localVarFetchArgs = AddressesApiFetchParamCreator(configuration).update(body, id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
     }
 };
 
 /**
  * AddressesApi - factory interface
  * @export
  */
 export const AddressesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
     return {
         /**
          * Create a new address.
          * @summary Create an address
          * @param {AddressData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: AddressData, options?: any) {
             return AddressesApiFp(configuration).create(body, options)(fetch, basePath);
         },
         /**
          * Retrieve all addresses.
          * @summary List all addresses
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any) {
             return AddressesApiFp(configuration).list(limit, offset, options)(fetch, basePath);
         },
         /**
          * Retrieve an address.
          * @summary Retrieve an address
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any) {
             return AddressesApiFp(configuration).retrieve(id, options)(fetch, basePath);
         },
         /**
          * update an address.
          * @summary Update an address
          * @param {AddressData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: AddressData, id: string, options?: any) {
             return AddressesApiFp(configuration).update(body, id, options)(fetch, basePath);
         },
     };
 };
 
 /**
  * AddressesApi - object-oriented interface
  * @export
  * @class AddressesApi
  * @extends {BaseAPI}
  */
 export class AddressesApi extends BaseAPI {
     /**
      * Create a new address.
      * @summary Create an address
      * @param {AddressData} body 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof AddressesApi
      */
     public create(body: AddressData, options?: any) {
         return AddressesApiFp(this.configuration).create(body, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve all addresses.
      * @summary List all addresses
      * @param {number} [limit] Number of results to return per page.
      * @param {number} [offset] The initial index from which to return the results.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof AddressesApi
      */
     public list(limit?: number, offset?: number, options?: any) {
         return AddressesApiFp(this.configuration).list(limit, offset, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve an address.
      * @summary Retrieve an address
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof AddressesApi
      */
     public retrieve(id: string, options?: any) {
         return AddressesApiFp(this.configuration).retrieve(id, options)(this.fetch, this.basePath);
     }
 
     /**
      * update an address.
      * @summary Update an address
      * @param {AddressData} body 
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof AddressesApi
      */
     public update(body: AddressData, id: string, options?: any) {
         return AddressesApiFp(this.configuration).update(body, id, options)(this.fetch, this.basePath);
     }
 
 }
 /**
  * CarriersApi - fetch parameter creator
  * @export
  */
 export const CarriersApiFetchParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Returns the list of configured carriers
          * @summary List all carriers
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {string} [carrier_name] Indicates a carrier (type)
          * @param {boolean} [test] This flag filter out carriers in test or prod mode
          * @param {boolean} [active] This flag indicates whether to return active carriers only
          * @param {boolean} [system_only] This flag indicates that only system carriers should be returned
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, carrier_name?: string, test?: boolean, active?: boolean, system_only?: boolean, options: any = {}): FetchArgs {
             const localVarPath = `/carriers`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (limit !== undefined) {
                 localVarQueryParameter['limit'] = limit;
             }
 
             if (offset !== undefined) {
                 localVarQueryParameter['offset'] = offset;
             }
 
             if (carrier_name !== undefined) {
                 localVarQueryParameter['carrier_name'] = carrier_name;
             }
 
             if (test !== undefined) {
                 localVarQueryParameter['test'] = test;
             }
 
             if (active !== undefined) {
                 localVarQueryParameter['active'] = active;
             }
 
             if (system_only !== undefined) {
                 localVarQueryParameter['system_only'] = system_only;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * CarriersApi - functional programming interface
  * @export
  */
 export const CarriersApiFp = function(configuration?: Configuration) {
     return {
         /**
          * Returns the list of configured carriers
          * @summary List all carriers
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {string} [carrier_name] Indicates a carrier (type)
          * @param {boolean} [test] This flag filter out carriers in test or prod mode
          * @param {boolean} [active] This flag indicates whether to return active carriers only
          * @param {boolean} [system_only] This flag indicates that only system carriers should be returned
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, carrier_name?: string, test?: boolean, active?: boolean, system_only?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CarrierList> {
             const localVarFetchArgs = CarriersApiFetchParamCreator(configuration).list(limit, offset, carrier_name, test, active, system_only, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
     }
 };
 
 /**
  * CarriersApi - factory interface
  * @export
  */
 export const CarriersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
     return {
         /**
          * Returns the list of configured carriers
          * @summary List all carriers
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {string} [carrier_name] Indicates a carrier (type)
          * @param {boolean} [test] This flag filter out carriers in test or prod mode
          * @param {boolean} [active] This flag indicates whether to return active carriers only
          * @param {boolean} [system_only] This flag indicates that only system carriers should be returned
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, carrier_name?: string, test?: boolean, active?: boolean, system_only?: boolean, options?: any) {
             return CarriersApiFp(configuration).list(limit, offset, carrier_name, test, active, system_only, options)(fetch, basePath);
         },
     };
 };
 
 /**
  * CarriersApi - object-oriented interface
  * @export
  * @class CarriersApi
  * @extends {BaseAPI}
  */
 export class CarriersApi extends BaseAPI {
     /**
      * Returns the list of configured carriers
      * @summary List all carriers
      * @param {number} [limit] Number of results to return per page.
      * @param {number} [offset] The initial index from which to return the results.
      * @param {string} [carrier_name] Indicates a carrier (type)
      * @param {boolean} [test] This flag filter out carriers in test or prod mode
      * @param {boolean} [active] This flag indicates whether to return active carriers only
      * @param {boolean} [system_only] This flag indicates that only system carriers should be returned
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof CarriersApi
      */
     public list(limit?: number, offset?: number, carrier_name?: string, test?: boolean, active?: boolean, system_only?: boolean, options?: any) {
         return CarriersApiFp(this.configuration).list(limit, offset, carrier_name, test, active, system_only, options)(this.fetch, this.basePath);
     }
 
 }
 /**
  * CustomsApi - fetch parameter creator
  * @export
  */
 export const CustomsApiFetchParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Create a new customs declaration.
          * @summary Create a customs info
          * @param {CustomsData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: CustomsData, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling create.');
             }
             const localVarPath = `/customs_info`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"CustomsData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Discard a customs declaration.
          * @summary Discard a customs info
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         discard(id: string, options: any = {}): FetchArgs {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling discard.');
             }
             const localVarPath = `/customs_info/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve all stored customs declarations.
          * @summary List all customs info
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options: any = {}): FetchArgs {
             const localVarPath = `/customs_info`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (limit !== undefined) {
                 localVarQueryParameter['limit'] = limit;
             }
 
             if (offset !== undefined) {
                 localVarQueryParameter['offset'] = offset;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve customs declaration.
          * @summary Retrieve a customs info
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options: any = {}): FetchArgs {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling retrieve.');
             }
             const localVarPath = `/customs_info/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * modify an existing customs declaration.
          * @summary Update a customs info
          * @param {CustomsData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: CustomsData, id: string, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling update.');
             }
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling update.');
             }
             const localVarPath = `/customs_info/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"CustomsData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * CustomsApi - functional programming interface
  * @export
  */
 export const CustomsApiFp = function(configuration?: Configuration) {
     return {
         /**
          * Create a new customs declaration.
          * @summary Create a customs info
          * @param {CustomsData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: CustomsData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customs> {
             const localVarFetchArgs = CustomsApiFetchParamCreator(configuration).create(body, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Discard a customs declaration.
          * @summary Discard a customs info
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         discard(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Operation> {
             const localVarFetchArgs = CustomsApiFetchParamCreator(configuration).discard(id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve all stored customs declarations.
          * @summary List all customs info
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomsList> {
             const localVarFetchArgs = CustomsApiFetchParamCreator(configuration).list(limit, offset, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve customs declaration.
          * @summary Retrieve a customs info
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customs> {
             const localVarFetchArgs = CustomsApiFetchParamCreator(configuration).retrieve(id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * modify an existing customs declaration.
          * @summary Update a customs info
          * @param {CustomsData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: CustomsData, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customs> {
             const localVarFetchArgs = CustomsApiFetchParamCreator(configuration).update(body, id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
     }
 };
 
 /**
  * CustomsApi - factory interface
  * @export
  */
 export const CustomsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
     return {
         /**
          * Create a new customs declaration.
          * @summary Create a customs info
          * @param {CustomsData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: CustomsData, options?: any) {
             return CustomsApiFp(configuration).create(body, options)(fetch, basePath);
         },
         /**
          * Discard a customs declaration.
          * @summary Discard a customs info
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         discard(id: string, options?: any) {
             return CustomsApiFp(configuration).discard(id, options)(fetch, basePath);
         },
         /**
          * Retrieve all stored customs declarations.
          * @summary List all customs info
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any) {
             return CustomsApiFp(configuration).list(limit, offset, options)(fetch, basePath);
         },
         /**
          * Retrieve customs declaration.
          * @summary Retrieve a customs info
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any) {
             return CustomsApiFp(configuration).retrieve(id, options)(fetch, basePath);
         },
         /**
          * modify an existing customs declaration.
          * @summary Update a customs info
          * @param {CustomsData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: CustomsData, id: string, options?: any) {
             return CustomsApiFp(configuration).update(body, id, options)(fetch, basePath);
         },
     };
 };
 
 /**
  * CustomsApi - object-oriented interface
  * @export
  * @class CustomsApi
  * @extends {BaseAPI}
  */
 export class CustomsApi extends BaseAPI {
     /**
      * Create a new customs declaration.
      * @summary Create a customs info
      * @param {CustomsData} body 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof CustomsApi
      */
     public create(body: CustomsData, options?: any) {
         return CustomsApiFp(this.configuration).create(body, options)(this.fetch, this.basePath);
     }
 
     /**
      * Discard a customs declaration.
      * @summary Discard a customs info
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof CustomsApi
      */
     public discard(id: string, options?: any) {
         return CustomsApiFp(this.configuration).discard(id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve all stored customs declarations.
      * @summary List all customs info
      * @param {number} [limit] Number of results to return per page.
      * @param {number} [offset] The initial index from which to return the results.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof CustomsApi
      */
     public list(limit?: number, offset?: number, options?: any) {
         return CustomsApiFp(this.configuration).list(limit, offset, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve customs declaration.
      * @summary Retrieve a customs info
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof CustomsApi
      */
     public retrieve(id: string, options?: any) {
         return CustomsApiFp(this.configuration).retrieve(id, options)(this.fetch, this.basePath);
     }
 
     /**
      * modify an existing customs declaration.
      * @summary Update a customs info
      * @param {CustomsData} body 
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof CustomsApi
      */
     public update(body: CustomsData, id: string, options?: any) {
         return CustomsApiFp(this.configuration).update(body, id, options)(this.fetch, this.basePath);
     }
 
 }
 /**
  * ParcelsApi - fetch parameter creator
  * @export
  */
 export const ParcelsApiFetchParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Create a new parcel.
          * @summary Create a parcel
          * @param {ParcelData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: ParcelData, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling create.');
             }
             const localVarPath = `/parcels`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"ParcelData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Remove a parcel.
          * @summary Remove a parcel
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         discard(id: string, options: any = {}): FetchArgs {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling discard.');
             }
             const localVarPath = `/parcels/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve all stored parcels.
          * @summary List all parcels
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options: any = {}): FetchArgs {
             const localVarPath = `/parcels`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (limit !== undefined) {
                 localVarQueryParameter['limit'] = limit;
             }
 
             if (offset !== undefined) {
                 localVarQueryParameter['offset'] = offset;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve a parcel.
          * @summary Retrieve a parcel
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options: any = {}): FetchArgs {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling retrieve.');
             }
             const localVarPath = `/parcels/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * modify an existing parcel's details.
          * @summary Update a parcel
          * @param {ParcelData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: ParcelData, id: string, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling update.');
             }
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling update.');
             }
             const localVarPath = `/parcels/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"ParcelData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * ParcelsApi - functional programming interface
  * @export
  */
 export const ParcelsApiFp = function(configuration?: Configuration) {
     return {
         /**
          * Create a new parcel.
          * @summary Create a parcel
          * @param {ParcelData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: ParcelData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Parcel> {
             const localVarFetchArgs = ParcelsApiFetchParamCreator(configuration).create(body, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Remove a parcel.
          * @summary Remove a parcel
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         discard(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Operation> {
             const localVarFetchArgs = ParcelsApiFetchParamCreator(configuration).discard(id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve all stored parcels.
          * @summary List all parcels
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParcelList> {
             const localVarFetchArgs = ParcelsApiFetchParamCreator(configuration).list(limit, offset, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve a parcel.
          * @summary Retrieve a parcel
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Parcel> {
             const localVarFetchArgs = ParcelsApiFetchParamCreator(configuration).retrieve(id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * modify an existing parcel's details.
          * @summary Update a parcel
          * @param {ParcelData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: ParcelData, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Parcel> {
             const localVarFetchArgs = ParcelsApiFetchParamCreator(configuration).update(body, id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
     }
 };
 
 /**
  * ParcelsApi - factory interface
  * @export
  */
 export const ParcelsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
     return {
         /**
          * Create a new parcel.
          * @summary Create a parcel
          * @param {ParcelData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: ParcelData, options?: any) {
             return ParcelsApiFp(configuration).create(body, options)(fetch, basePath);
         },
         /**
          * Remove a parcel.
          * @summary Remove a parcel
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         discard(id: string, options?: any) {
             return ParcelsApiFp(configuration).discard(id, options)(fetch, basePath);
         },
         /**
          * Retrieve all stored parcels.
          * @summary List all parcels
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any) {
             return ParcelsApiFp(configuration).list(limit, offset, options)(fetch, basePath);
         },
         /**
          * Retrieve a parcel.
          * @summary Retrieve a parcel
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any) {
             return ParcelsApiFp(configuration).retrieve(id, options)(fetch, basePath);
         },
         /**
          * modify an existing parcel's details.
          * @summary Update a parcel
          * @param {ParcelData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: ParcelData, id: string, options?: any) {
             return ParcelsApiFp(configuration).update(body, id, options)(fetch, basePath);
         },
     };
 };
 
 /**
  * ParcelsApi - object-oriented interface
  * @export
  * @class ParcelsApi
  * @extends {BaseAPI}
  */
 export class ParcelsApi extends BaseAPI {
     /**
      * Create a new parcel.
      * @summary Create a parcel
      * @param {ParcelData} body 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ParcelsApi
      */
     public create(body: ParcelData, options?: any) {
         return ParcelsApiFp(this.configuration).create(body, options)(this.fetch, this.basePath);
     }
 
     /**
      * Remove a parcel.
      * @summary Remove a parcel
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ParcelsApi
      */
     public discard(id: string, options?: any) {
         return ParcelsApiFp(this.configuration).discard(id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve all stored parcels.
      * @summary List all parcels
      * @param {number} [limit] Number of results to return per page.
      * @param {number} [offset] The initial index from which to return the results.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ParcelsApi
      */
     public list(limit?: number, offset?: number, options?: any) {
         return ParcelsApiFp(this.configuration).list(limit, offset, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve a parcel.
      * @summary Retrieve a parcel
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ParcelsApi
      */
     public retrieve(id: string, options?: any) {
         return ParcelsApiFp(this.configuration).retrieve(id, options)(this.fetch, this.basePath);
     }
 
     /**
      * modify an existing parcel's details.
      * @summary Update a parcel
      * @param {ParcelData} body 
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ParcelsApi
      */
     public update(body: ParcelData, id: string, options?: any) {
         return ParcelsApiFp(this.configuration).update(body, id, options)(this.fetch, this.basePath);
     }
 
 }
 /**
  * PickupsApi - fetch parameter creator
  * @export
  */
 export const PickupsApiFetchParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Cancel a pickup of one or more shipments.
          * @summary Cancel a pickup
          * @param {PickupCancelData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         cancel(body: PickupCancelData, id: string, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling cancel.');
             }
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling cancel.');
             }
             const localVarPath = `/pickups/{id}/cancel`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"PickupCancelData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve all scheduled pickups.
          * @summary List shipment pickups
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options: any = {}): FetchArgs {
             const localVarPath = `/pickups`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (limit !== undefined) {
                 localVarQueryParameter['limit'] = limit;
             }
 
             if (offset !== undefined) {
                 localVarQueryParameter['offset'] = offset;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve a scheduled pickup.
          * @summary Retrieve a pickup
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options: any = {}): FetchArgs {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling retrieve.');
             }
             const localVarPath = `/pickups/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Schedule a pickup for one or many shipments with labels already purchased.
          * @summary Schedule a pickup
          * @param {PickupData} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         schedule(body: PickupData, carrier_name: string, test?: boolean, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling schedule.');
             }
             // verify required parameter 'carrier_name' is not null or undefined
             if (carrier_name === null || carrier_name === undefined) {
                 throw new RequiredError('carrier_name','Required parameter carrier_name was null or undefined when calling schedule.');
             }
             const localVarPath = `/pickups/{carrier_name}/schedule`
                 .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrier_name)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (test !== undefined) {
                 localVarQueryParameter['test'] = test;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"PickupData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Modify a pickup for one or many shipments with labels already purchased.
          * @summary Update a pickup
          * @param {PickupUpdateData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: PickupUpdateData, id: string, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling update.');
             }
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling update.');
             }
             const localVarPath = `/pickups/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"PickupUpdateData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * PickupsApi - functional programming interface
  * @export
  */
 export const PickupsApiFp = function(configuration?: Configuration) {
     return {
         /**
          * Cancel a pickup of one or more shipments.
          * @summary Cancel a pickup
          * @param {PickupCancelData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         cancel(body: PickupCancelData, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationConfirmation> {
             const localVarFetchArgs = PickupsApiFetchParamCreator(configuration).cancel(body, id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve all scheduled pickups.
          * @summary List shipment pickups
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PickupList> {
             const localVarFetchArgs = PickupsApiFetchParamCreator(configuration).list(limit, offset, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve a scheduled pickup.
          * @summary Retrieve a pickup
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pickup> {
             const localVarFetchArgs = PickupsApiFetchParamCreator(configuration).retrieve(id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Schedule a pickup for one or many shipments with labels already purchased.
          * @summary Schedule a pickup
          * @param {PickupData} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         schedule(body: PickupData, carrier_name: string, test?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pickup> {
             const localVarFetchArgs = PickupsApiFetchParamCreator(configuration).schedule(body, carrier_name, test, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Modify a pickup for one or many shipments with labels already purchased.
          * @summary Update a pickup
          * @param {PickupUpdateData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: PickupUpdateData, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationConfirmation> {
             const localVarFetchArgs = PickupsApiFetchParamCreator(configuration).update(body, id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
     }
 };
 
 /**
  * PickupsApi - factory interface
  * @export
  */
 export const PickupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
     return {
         /**
          * Cancel a pickup of one or more shipments.
          * @summary Cancel a pickup
          * @param {PickupCancelData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         cancel(body: PickupCancelData, id: string, options?: any) {
             return PickupsApiFp(configuration).cancel(body, id, options)(fetch, basePath);
         },
         /**
          * Retrieve all scheduled pickups.
          * @summary List shipment pickups
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any) {
             return PickupsApiFp(configuration).list(limit, offset, options)(fetch, basePath);
         },
         /**
          * Retrieve a scheduled pickup.
          * @summary Retrieve a pickup
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any) {
             return PickupsApiFp(configuration).retrieve(id, options)(fetch, basePath);
         },
         /**
          * Schedule a pickup for one or many shipments with labels already purchased.
          * @summary Schedule a pickup
          * @param {PickupData} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         schedule(body: PickupData, carrier_name: string, test?: boolean, options?: any) {
             return PickupsApiFp(configuration).schedule(body, carrier_name, test, options)(fetch, basePath);
         },
         /**
          * Modify a pickup for one or many shipments with labels already purchased.
          * @summary Update a pickup
          * @param {PickupUpdateData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         update(body: PickupUpdateData, id: string, options?: any) {
             return PickupsApiFp(configuration).update(body, id, options)(fetch, basePath);
         },
     };
 };
 
 /**
  * PickupsApi - object-oriented interface
  * @export
  * @class PickupsApi
  * @extends {BaseAPI}
  */
 export class PickupsApi extends BaseAPI {
     /**
      * Cancel a pickup of one or more shipments.
      * @summary Cancel a pickup
      * @param {PickupCancelData} body 
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof PickupsApi
      */
     public cancel(body: PickupCancelData, id: string, options?: any) {
         return PickupsApiFp(this.configuration).cancel(body, id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve all scheduled pickups.
      * @summary List shipment pickups
      * @param {number} [limit] Number of results to return per page.
      * @param {number} [offset] The initial index from which to return the results.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof PickupsApi
      */
     public list(limit?: number, offset?: number, options?: any) {
         return PickupsApiFp(this.configuration).list(limit, offset, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve a scheduled pickup.
      * @summary Retrieve a pickup
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof PickupsApi
      */
     public retrieve(id: string, options?: any) {
         return PickupsApiFp(this.configuration).retrieve(id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Schedule a pickup for one or many shipments with labels already purchased.
      * @summary Schedule a pickup
      * @param {PickupData} body 
      * @param {string} carrier_name 
      * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof PickupsApi
      */
     public schedule(body: PickupData, carrier_name: string, test?: boolean, options?: any) {
         return PickupsApiFp(this.configuration).schedule(body, carrier_name, test, options)(this.fetch, this.basePath);
     }
 
     /**
      * Modify a pickup for one or many shipments with labels already purchased.
      * @summary Update a pickup
      * @param {PickupUpdateData} body 
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof PickupsApi
      */
     public update(body: PickupUpdateData, id: string, options?: any) {
         return PickupsApiFp(this.configuration).update(body, id, options)(this.fetch, this.basePath);
     }
 
 }
 /**
  * ProxyApi - fetch parameter creator
  * @export
  */
 export const ProxyApiFetchParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
          * @summary Buy a shipment label
          * @param {ShippingRequest} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         buyLabel(body: ShippingRequest, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling buyLabel.');
             }
             const localVarPath = `/proxy/shipping`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"ShippingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Cancel a pickup previously scheduled
          * @summary Cancel a pickup
          * @param {PickupCancelRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         cancelPickup(body: PickupCancelRequest, carrier_name: string, test?: boolean, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling cancelPickup.');
             }
             // verify required parameter 'carrier_name' is not null or undefined
             if (carrier_name === null || carrier_name === undefined) {
                 throw new RequiredError('carrier_name','Required parameter carrier_name was null or undefined when calling cancelPickup.');
             }
             const localVarPath = `/proxy/pickups/{carrier_name}/cancel`
                 .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrier_name)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (test !== undefined) {
                 localVarQueryParameter['test'] = test;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"PickupCancelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
          * @summary Fetch shipment rates
          * @param {RateRequest} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         fetchRates(body: RateRequest, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling fetchRates.');
             }
             const localVarPath = `/proxy/rates`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"RateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Schedule one or many parcels pickup
          * @summary Schedule a pickup
          * @param {PickupRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         schedulePickup(body: PickupRequest, carrier_name: string, test?: boolean, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling schedulePickup.');
             }
             // verify required parameter 'carrier_name' is not null or undefined
             if (carrier_name === null || carrier_name === undefined) {
                 throw new RequiredError('carrier_name','Required parameter carrier_name was null or undefined when calling schedulePickup.');
             }
             const localVarPath = `/proxy/pickups/{carrier_name}`
                 .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrier_name)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (test !== undefined) {
                 localVarQueryParameter['test'] = test;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"PickupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * You can track a shipment by specifying the carrier and the shipment tracking number.
          * @summary Track a shipment
          * @param {string} carrier_name 
          * @param {string} tracking_number 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         trackShipment(carrier_name: string, tracking_number: string, test?: boolean, options: any = {}): FetchArgs {
             // verify required parameter 'carrier_name' is not null or undefined
             if (carrier_name === null || carrier_name === undefined) {
                 throw new RequiredError('carrier_name','Required parameter carrier_name was null or undefined when calling trackShipment.');
             }
             // verify required parameter 'tracking_number' is not null or undefined
             if (tracking_number === null || tracking_number === undefined) {
                 throw new RequiredError('tracking_number','Required parameter tracking_number was null or undefined when calling trackShipment.');
             }
             const localVarPath = `/proxy/tracking/{carrier_name}/{tracking_number}`
                 .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrier_name)))
                 .replace(`{${"tracking_number"}}`, encodeURIComponent(String(tracking_number)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (test !== undefined) {
                 localVarQueryParameter['test'] = test;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Modify a scheduled pickup
          * @summary Update a pickup
          * @param {PickupUpdateRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updatePickup(body: PickupUpdateRequest, carrier_name: string, test?: boolean, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling updatePickup.');
             }
             // verify required parameter 'carrier_name' is not null or undefined
             if (carrier_name === null || carrier_name === undefined) {
                 throw new RequiredError('carrier_name','Required parameter carrier_name was null or undefined when calling updatePickup.');
             }
             const localVarPath = `/proxy/pickups/{carrier_name}`
                 .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrier_name)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (test !== undefined) {
                 localVarQueryParameter['test'] = test;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"PickupUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Cancel a shipment and the label previously created
          * @summary Void a shipment label
          * @param {ShipmentCancelRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         voidLabel(body: ShipmentCancelRequest, carrier_name: string, test?: boolean, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling voidLabel.');
             }
             // verify required parameter 'carrier_name' is not null or undefined
             if (carrier_name === null || carrier_name === undefined) {
                 throw new RequiredError('carrier_name','Required parameter carrier_name was null or undefined when calling voidLabel.');
             }
             const localVarPath = `/proxy/shipping/{carrier_name}/cancel`
                 .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrier_name)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (test !== undefined) {
                 localVarQueryParameter['test'] = test;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"ShipmentCancelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * ProxyApi - functional programming interface
  * @export
  */
 export const ProxyApiFp = function(configuration?: Configuration) {
     return {
         /**
          * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
          * @summary Buy a shipment label
          * @param {ShippingRequest} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         buyLabel(body: ShippingRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Shipment> {
             const localVarFetchArgs = ProxyApiFetchParamCreator(configuration).buyLabel(body, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Cancel a pickup previously scheduled
          * @summary Cancel a pickup
          * @param {PickupCancelRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         cancelPickup(body: PickupCancelRequest, carrier_name: string, test?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResponse> {
             const localVarFetchArgs = ProxyApiFetchParamCreator(configuration).cancelPickup(body, carrier_name, test, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
          * @summary Fetch shipment rates
          * @param {RateRequest} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         fetchRates(body: RateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RateResponse> {
             const localVarFetchArgs = ProxyApiFetchParamCreator(configuration).fetchRates(body, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Schedule one or many parcels pickup
          * @summary Schedule a pickup
          * @param {PickupRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         schedulePickup(body: PickupRequest, carrier_name: string, test?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PickupResponse> {
             const localVarFetchArgs = ProxyApiFetchParamCreator(configuration).schedulePickup(body, carrier_name, test, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * You can track a shipment by specifying the carrier and the shipment tracking number.
          * @summary Track a shipment
          * @param {string} carrier_name 
          * @param {string} tracking_number 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         trackShipment(carrier_name: string, tracking_number: string, test?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TrackingResponse> {
             const localVarFetchArgs = ProxyApiFetchParamCreator(configuration).trackShipment(carrier_name, tracking_number, test, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Modify a scheduled pickup
          * @summary Update a pickup
          * @param {PickupUpdateRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updatePickup(body: PickupUpdateRequest, carrier_name: string, test?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PickupResponse> {
             const localVarFetchArgs = ProxyApiFetchParamCreator(configuration).updatePickup(body, carrier_name, test, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Cancel a shipment and the label previously created
          * @summary Void a shipment label
          * @param {ShipmentCancelRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         voidLabel(body: ShipmentCancelRequest, carrier_name: string, test?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResponse> {
             const localVarFetchArgs = ProxyApiFetchParamCreator(configuration).voidLabel(body, carrier_name, test, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
     }
 };
 
 /**
  * ProxyApi - factory interface
  * @export
  */
 export const ProxyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
     return {
         /**
          * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
          * @summary Buy a shipment label
          * @param {ShippingRequest} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         buyLabel(body: ShippingRequest, options?: any) {
             return ProxyApiFp(configuration).buyLabel(body, options)(fetch, basePath);
         },
         /**
          * Cancel a pickup previously scheduled
          * @summary Cancel a pickup
          * @param {PickupCancelRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         cancelPickup(body: PickupCancelRequest, carrier_name: string, test?: boolean, options?: any) {
             return ProxyApiFp(configuration).cancelPickup(body, carrier_name, test, options)(fetch, basePath);
         },
         /**
          *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
          * @summary Fetch shipment rates
          * @param {RateRequest} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         fetchRates(body: RateRequest, options?: any) {
             return ProxyApiFp(configuration).fetchRates(body, options)(fetch, basePath);
         },
         /**
          * Schedule one or many parcels pickup
          * @summary Schedule a pickup
          * @param {PickupRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         schedulePickup(body: PickupRequest, carrier_name: string, test?: boolean, options?: any) {
             return ProxyApiFp(configuration).schedulePickup(body, carrier_name, test, options)(fetch, basePath);
         },
         /**
          * You can track a shipment by specifying the carrier and the shipment tracking number.
          * @summary Track a shipment
          * @param {string} carrier_name 
          * @param {string} tracking_number 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         trackShipment(carrier_name: string, tracking_number: string, test?: boolean, options?: any) {
             return ProxyApiFp(configuration).trackShipment(carrier_name, tracking_number, test, options)(fetch, basePath);
         },
         /**
          * Modify a scheduled pickup
          * @summary Update a pickup
          * @param {PickupUpdateRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         updatePickup(body: PickupUpdateRequest, carrier_name: string, test?: boolean, options?: any) {
             return ProxyApiFp(configuration).updatePickup(body, carrier_name, test, options)(fetch, basePath);
         },
         /**
          * Cancel a shipment and the label previously created
          * @summary Void a shipment label
          * @param {ShipmentCancelRequest} body 
          * @param {string} carrier_name 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         voidLabel(body: ShipmentCancelRequest, carrier_name: string, test?: boolean, options?: any) {
             return ProxyApiFp(configuration).voidLabel(body, carrier_name, test, options)(fetch, basePath);
         },
     };
 };
 
 /**
  * ProxyApi - object-oriented interface
  * @export
  * @class ProxyApi
  * @extends {BaseAPI}
  */
 export class ProxyApi extends BaseAPI {
     /**
      * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
      * @summary Buy a shipment label
      * @param {ShippingRequest} body 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ProxyApi
      */
     public buyLabel(body: ShippingRequest, options?: any) {
         return ProxyApiFp(this.configuration).buyLabel(body, options)(this.fetch, this.basePath);
     }
 
     /**
      * Cancel a pickup previously scheduled
      * @summary Cancel a pickup
      * @param {PickupCancelRequest} body 
      * @param {string} carrier_name 
      * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ProxyApi
      */
     public cancelPickup(body: PickupCancelRequest, carrier_name: string, test?: boolean, options?: any) {
         return ProxyApiFp(this.configuration).cancelPickup(body, carrier_name, test, options)(this.fetch, this.basePath);
     }
 
     /**
      *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
      * @summary Fetch shipment rates
      * @param {RateRequest} body 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ProxyApi
      */
     public fetchRates(body: RateRequest, options?: any) {
         return ProxyApiFp(this.configuration).fetchRates(body, options)(this.fetch, this.basePath);
     }
 
     /**
      * Schedule one or many parcels pickup
      * @summary Schedule a pickup
      * @param {PickupRequest} body 
      * @param {string} carrier_name 
      * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ProxyApi
      */
     public schedulePickup(body: PickupRequest, carrier_name: string, test?: boolean, options?: any) {
         return ProxyApiFp(this.configuration).schedulePickup(body, carrier_name, test, options)(this.fetch, this.basePath);
     }
 
     /**
      * You can track a shipment by specifying the carrier and the shipment tracking number.
      * @summary Track a shipment
      * @param {string} carrier_name 
      * @param {string} tracking_number 
      * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ProxyApi
      */
     public trackShipment(carrier_name: string, tracking_number: string, test?: boolean, options?: any) {
         return ProxyApiFp(this.configuration).trackShipment(carrier_name, tracking_number, test, options)(this.fetch, this.basePath);
     }
 
     /**
      * Modify a scheduled pickup
      * @summary Update a pickup
      * @param {PickupUpdateRequest} body 
      * @param {string} carrier_name 
      * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ProxyApi
      */
     public updatePickup(body: PickupUpdateRequest, carrier_name: string, test?: boolean, options?: any) {
         return ProxyApiFp(this.configuration).updatePickup(body, carrier_name, test, options)(this.fetch, this.basePath);
     }
 
     /**
      * Cancel a shipment and the label previously created
      * @summary Void a shipment label
      * @param {ShipmentCancelRequest} body 
      * @param {string} carrier_name 
      * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ProxyApi
      */
     public voidLabel(body: ShipmentCancelRequest, carrier_name: string, test?: boolean, options?: any) {
         return ProxyApiFp(this.configuration).voidLabel(body, carrier_name, test, options)(this.fetch, this.basePath);
     }
 
 }
 /**
  * ShipmentsApi - fetch parameter creator
  * @export
  */
 export const ShipmentsApiFetchParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Add the customs declaration for the shipment if non existent.
          * @summary Add a customs declaration
          * @param {CustomsData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         addCustoms(body: CustomsData, id: string, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling addCustoms.');
             }
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling addCustoms.');
             }
             const localVarPath = `/shipments/{id}/customs`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"CustomsData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Add a parcel to an existing shipment for a multi-parcel shipment.
          * @summary Add a shipment parcel
          * @param {ParcelData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         addParcel(body: ParcelData, id: string, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling addParcel.');
             }
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling addParcel.');
             }
             const localVarPath = `/shipments/{id}/parcels`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"ParcelData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Void a shipment with the associated label.
          * @summary Cancel a shipment
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         cancel(id: string, options: any = {}): FetchArgs {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling cancel.');
             }
             const localVarPath = `/shipments/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Create a new shipment instance.
          * @summary Create a shipment
          * @param {ShipmentData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: ShipmentData, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling create.');
             }
             const localVarPath = `/shipments`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"ShipmentData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve all shipments.
          * @summary List all shipments
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options: any = {}): FetchArgs {
             const localVarPath = `/shipments`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (limit !== undefined) {
                 localVarQueryParameter['limit'] = limit;
             }
 
             if (offset !== undefined) {
                 localVarQueryParameter['offset'] = offset;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Select your preferred rates to buy a shipment label.
          * @summary Buy a shipment label
          * @param {ShipmentPurchaseData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         purchase(body: ShipmentPurchaseData, id: string, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling purchase.');
             }
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling purchase.');
             }
             const localVarPath = `/shipments/{id}/purchase`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"ShipmentPurchaseData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Refresh the list of the shipment rates
          * @summary Fetch new shipment rates
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         rates(id: string, options: any = {}): FetchArgs {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling rates.');
             }
             const localVarPath = `/shipments/{id}/rates`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Retrieve a shipment.
          * @summary Retrieve a shipment
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options: any = {}): FetchArgs {
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling retrieve.');
             }
             const localVarPath = `/shipments/{id}`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * Add one or many options to your shipment.<br/> **eg:**<br/> - add shipment **insurance** - specify the preferred transaction **currency** - setup a **cash collected on delivery** option  ```json {     \"insurance\": 120,     \"currency\": \"USD\" } ```  And many more, check additional options available in the [reference](#operation/all_references).
          * @summary Add shipment options
          * @param {any} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         setOptions(body: any, id: string, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling setOptions.');
             }
             // verify required parameter 'id' is not null or undefined
             if (id === null || id === undefined) {
                 throw new RequiredError('id','Required parameter id was null or undefined when calling setOptions.');
             }
             const localVarPath = `/shipments/{id}/options`
                 .replace(`{${"id"}}`, encodeURIComponent(String(id)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * ShipmentsApi - functional programming interface
  * @export
  */
 export const ShipmentsApiFp = function(configuration?: Configuration) {
     return {
         /**
          * Add the customs declaration for the shipment if non existent.
          * @summary Add a customs declaration
          * @param {CustomsData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         addCustoms(body: CustomsData, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Shipment> {
             const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).addCustoms(body, id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Add a parcel to an existing shipment for a multi-parcel shipment.
          * @summary Add a shipment parcel
          * @param {ParcelData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         addParcel(body: ParcelData, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Shipment> {
             const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).addParcel(body, id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Void a shipment with the associated label.
          * @summary Cancel a shipment
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         cancel(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResponse> {
             const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).cancel(id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Create a new shipment instance.
          * @summary Create a shipment
          * @param {ShipmentData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: ShipmentData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Shipment> {
             const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).create(body, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve all shipments.
          * @summary List all shipments
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShipmentList> {
             const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).list(limit, offset, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Select your preferred rates to buy a shipment label.
          * @summary Buy a shipment label
          * @param {ShipmentPurchaseData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         purchase(body: ShipmentPurchaseData, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Shipment> {
             const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).purchase(body, id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Refresh the list of the shipment rates
          * @summary Fetch new shipment rates
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         rates(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Shipment> {
             const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).rates(id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Retrieve a shipment.
          * @summary Retrieve a shipment
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Shipment> {
             const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).retrieve(id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * Add one or many options to your shipment.<br/> **eg:**<br/> - add shipment **insurance** - specify the preferred transaction **currency** - setup a **cash collected on delivery** option  ```json {     \"insurance\": 120,     \"currency\": \"USD\" } ```  And many more, check additional options available in the [reference](#operation/all_references).
          * @summary Add shipment options
          * @param {any} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         setOptions(body: any, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Shipment> {
             const localVarFetchArgs = ShipmentsApiFetchParamCreator(configuration).setOptions(body, id, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
     }
 };
 
 /**
  * ShipmentsApi - factory interface
  * @export
  */
 export const ShipmentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
     return {
         /**
          * Add the customs declaration for the shipment if non existent.
          * @summary Add a customs declaration
          * @param {CustomsData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         addCustoms(body: CustomsData, id: string, options?: any) {
             return ShipmentsApiFp(configuration).addCustoms(body, id, options)(fetch, basePath);
         },
         /**
          * Add a parcel to an existing shipment for a multi-parcel shipment.
          * @summary Add a shipment parcel
          * @param {ParcelData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         addParcel(body: ParcelData, id: string, options?: any) {
             return ShipmentsApiFp(configuration).addParcel(body, id, options)(fetch, basePath);
         },
         /**
          * Void a shipment with the associated label.
          * @summary Cancel a shipment
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         cancel(id: string, options?: any) {
             return ShipmentsApiFp(configuration).cancel(id, options)(fetch, basePath);
         },
         /**
          * Create a new shipment instance.
          * @summary Create a shipment
          * @param {ShipmentData} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         create(body: ShipmentData, options?: any) {
             return ShipmentsApiFp(configuration).create(body, options)(fetch, basePath);
         },
         /**
          * Retrieve all shipments.
          * @summary List all shipments
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any) {
             return ShipmentsApiFp(configuration).list(limit, offset, options)(fetch, basePath);
         },
         /**
          * Select your preferred rates to buy a shipment label.
          * @summary Buy a shipment label
          * @param {ShipmentPurchaseData} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         purchase(body: ShipmentPurchaseData, id: string, options?: any) {
             return ShipmentsApiFp(configuration).purchase(body, id, options)(fetch, basePath);
         },
         /**
          * Refresh the list of the shipment rates
          * @summary Fetch new shipment rates
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         rates(id: string, options?: any) {
             return ShipmentsApiFp(configuration).rates(id, options)(fetch, basePath);
         },
         /**
          * Retrieve a shipment.
          * @summary Retrieve a shipment
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(id: string, options?: any) {
             return ShipmentsApiFp(configuration).retrieve(id, options)(fetch, basePath);
         },
         /**
          * Add one or many options to your shipment.<br/> **eg:**<br/> - add shipment **insurance** - specify the preferred transaction **currency** - setup a **cash collected on delivery** option  ```json {     \"insurance\": 120,     \"currency\": \"USD\" } ```  And many more, check additional options available in the [reference](#operation/all_references).
          * @summary Add shipment options
          * @param {any} body 
          * @param {string} id 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         setOptions(body: any, id: string, options?: any) {
             return ShipmentsApiFp(configuration).setOptions(body, id, options)(fetch, basePath);
         },
     };
 };
 
 /**
  * ShipmentsApi - object-oriented interface
  * @export
  * @class ShipmentsApi
  * @extends {BaseAPI}
  */
 export class ShipmentsApi extends BaseAPI {
     /**
      * Add the customs declaration for the shipment if non existent.
      * @summary Add a customs declaration
      * @param {CustomsData} body 
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ShipmentsApi
      */
     public addCustoms(body: CustomsData, id: string, options?: any) {
         return ShipmentsApiFp(this.configuration).addCustoms(body, id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Add a parcel to an existing shipment for a multi-parcel shipment.
      * @summary Add a shipment parcel
      * @param {ParcelData} body 
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ShipmentsApi
      */
     public addParcel(body: ParcelData, id: string, options?: any) {
         return ShipmentsApiFp(this.configuration).addParcel(body, id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Void a shipment with the associated label.
      * @summary Cancel a shipment
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ShipmentsApi
      */
     public cancel(id: string, options?: any) {
         return ShipmentsApiFp(this.configuration).cancel(id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Create a new shipment instance.
      * @summary Create a shipment
      * @param {ShipmentData} body 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ShipmentsApi
      */
     public create(body: ShipmentData, options?: any) {
         return ShipmentsApiFp(this.configuration).create(body, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve all shipments.
      * @summary List all shipments
      * @param {number} [limit] Number of results to return per page.
      * @param {number} [offset] The initial index from which to return the results.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ShipmentsApi
      */
     public list(limit?: number, offset?: number, options?: any) {
         return ShipmentsApiFp(this.configuration).list(limit, offset, options)(this.fetch, this.basePath);
     }
 
     /**
      * Select your preferred rates to buy a shipment label.
      * @summary Buy a shipment label
      * @param {ShipmentPurchaseData} body 
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ShipmentsApi
      */
     public purchase(body: ShipmentPurchaseData, id: string, options?: any) {
         return ShipmentsApiFp(this.configuration).purchase(body, id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Refresh the list of the shipment rates
      * @summary Fetch new shipment rates
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ShipmentsApi
      */
     public rates(id: string, options?: any) {
         return ShipmentsApiFp(this.configuration).rates(id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Retrieve a shipment.
      * @summary Retrieve a shipment
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ShipmentsApi
      */
     public retrieve(id: string, options?: any) {
         return ShipmentsApiFp(this.configuration).retrieve(id, options)(this.fetch, this.basePath);
     }
 
     /**
      * Add one or many options to your shipment.<br/> **eg:**<br/> - add shipment **insurance** - specify the preferred transaction **currency** - setup a **cash collected on delivery** option  ```json {     \"insurance\": 120,     \"currency\": \"USD\" } ```  And many more, check additional options available in the [reference](#operation/all_references).
      * @summary Add shipment options
      * @param {any} body 
      * @param {string} id 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof ShipmentsApi
      */
     public setOptions(body: any, id: string, options?: any) {
         return ShipmentsApiFp(this.configuration).setOptions(body, id, options)(this.fetch, this.basePath);
     }
 
 }
 /**
  * TrackersApi - fetch parameter creator
  * @export
  */
 export const TrackersApiFetchParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Retrieve all shipment trackers.
          * @summary List all shipment trackers
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options: any = {}): FetchArgs {
             const localVarPath = `/trackers`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (limit !== undefined) {
                 localVarQueryParameter['limit'] = limit;
             }
 
             if (offset !== undefined) {
                 localVarQueryParameter['offset'] = offset;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * This API retrieves or creates (if non existent) a tracking status object containing the details and events of a shipping in progress.
          * @summary Retrieves or creates a shipment trackers
          * @param {string} carrier_name 
          * @param {string} tracking_number 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(carrier_name: string, tracking_number: string, test?: boolean, options: any = {}): FetchArgs {
             // verify required parameter 'carrier_name' is not null or undefined
             if (carrier_name === null || carrier_name === undefined) {
                 throw new RequiredError('carrier_name','Required parameter carrier_name was null or undefined when calling retrieve.');
             }
             // verify required parameter 'tracking_number' is not null or undefined
             if (tracking_number === null || tracking_number === undefined) {
                 throw new RequiredError('tracking_number','Required parameter tracking_number was null or undefined when calling retrieve.');
             }
             const localVarPath = `/trackers/{carrier_name}/{tracking_number}`
                 .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrier_name)))
                 .replace(`{${"tracking_number"}}`, encodeURIComponent(String(tracking_number)));
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             if (test !== undefined) {
                 localVarQueryParameter['test'] = test;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * TrackersApi - functional programming interface
  * @export
  */
 export const TrackersApiFp = function(configuration?: Configuration) {
     return {
         /**
          * Retrieve all shipment trackers.
          * @summary List all shipment trackers
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TrackerList> {
             const localVarFetchArgs = TrackersApiFetchParamCreator(configuration).list(limit, offset, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * This API retrieves or creates (if non existent) a tracking status object containing the details and events of a shipping in progress.
          * @summary Retrieves or creates a shipment trackers
          * @param {string} carrier_name 
          * @param {string} tracking_number 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(carrier_name: string, tracking_number: string, test?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TrackingStatus> {
             const localVarFetchArgs = TrackersApiFetchParamCreator(configuration).retrieve(carrier_name, tracking_number, test, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
     }
 };
 
 /**
  * TrackersApi - factory interface
  * @export
  */
 export const TrackersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
     return {
         /**
          * Retrieve all shipment trackers.
          * @summary List all shipment trackers
          * @param {number} [limit] Number of results to return per page.
          * @param {number} [offset] The initial index from which to return the results.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         list(limit?: number, offset?: number, options?: any) {
             return TrackersApiFp(configuration).list(limit, offset, options)(fetch, basePath);
         },
         /**
          * This API retrieves or creates (if non existent) a tracking status object containing the details and events of a shipping in progress.
          * @summary Retrieves or creates a shipment trackers
          * @param {string} carrier_name 
          * @param {string} tracking_number 
          * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         retrieve(carrier_name: string, tracking_number: string, test?: boolean, options?: any) {
             return TrackersApiFp(configuration).retrieve(carrier_name, tracking_number, test, options)(fetch, basePath);
         },
     };
 };
 
 /**
  * TrackersApi - object-oriented interface
  * @export
  * @class TrackersApi
  * @extends {BaseAPI}
  */
 export class TrackersApi extends BaseAPI {
     /**
      * Retrieve all shipment trackers.
      * @summary List all shipment trackers
      * @param {number} [limit] Number of results to return per page.
      * @param {number} [offset] The initial index from which to return the results.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof TrackersApi
      */
     public list(limit?: number, offset?: number, options?: any) {
         return TrackersApiFp(this.configuration).list(limit, offset, options)(this.fetch, this.basePath);
     }
 
     /**
      * This API retrieves or creates (if non existent) a tracking status object containing the details and events of a shipping in progress.
      * @summary Retrieves or creates a shipment trackers
      * @param {string} carrier_name 
      * @param {string} tracking_number 
      * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof TrackersApi
      */
     public retrieve(carrier_name: string, tracking_number: string, test?: boolean, options?: any) {
         return TrackersApiFp(this.configuration).retrieve(carrier_name, tracking_number, test, options)(this.fetch, this.basePath);
     }
 
 }
 /**
  * UtilsApi - fetch parameter creator
  * @export
  */
 export const UtilsApiFetchParamCreator = function (configuration?: Configuration) {
     return {
         /**
          * Returns a label PDF file.
          * @summary Print a Label
          * @param {LabelPrintingRequest} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         printLabel(body: LabelPrintingRequest, options: any = {}): FetchArgs {
             // verify required parameter 'body' is not null or undefined
             if (body === null || body === undefined) {
                 throw new RequiredError('body','Required parameter body was null or undefined when calling printLabel.');
             }
             const localVarPath = `/labels`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarHeaderParameter['Content-Type'] = 'application/json';
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
             const needsSerialization = (<any>"LabelPrintingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
             localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
         /**
          * 
          * @summary Data References
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         references(options: any = {}): FetchArgs {
             const localVarPath = `/references`;
             const localVarUrlObj = url.parse(localVarPath, true);
             const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
             const localVarHeaderParameter = {} as any;
             const localVarQueryParameter = {} as any;
 
             // authentication Token required
             if (configuration && configuration.apiKey) {
                 const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                     ? configuration.apiKey("Authorization")
                     : configuration.apiKey;
                 localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
             }
 
             localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
             // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
             delete localVarUrlObj.search;
             localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
 
             return {
                 url: url.format(localVarUrlObj),
                 options: localVarRequestOptions,
             };
         },
     }
 };
 
 /**
  * UtilsApi - functional programming interface
  * @export
  */
 export const UtilsApiFp = function(configuration?: Configuration) {
     return {
         /**
          * Returns a label PDF file.
          * @summary Print a Label
          * @param {LabelPrintingRequest} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         printLabel(body: LabelPrintingRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
             const localVarFetchArgs = UtilsApiFetchParamCreator(configuration).printLabel(body, options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response;
                     } else {
                         throw response;
                     }
                 });
             };
         },
         /**
          * 
          * @summary Data References
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         references(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<References> {
             const localVarFetchArgs = UtilsApiFetchParamCreator(configuration).references(options);
             return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                 return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                     if (response.status >= 200 && response.status < 300) {
                         return response.json();
                     } else {
                         throw response;
                     }
                 });
             };
         },
     }
 };
 
 /**
  * UtilsApi - factory interface
  * @export
  */
 export const UtilsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
     return {
         /**
          * Returns a label PDF file.
          * @summary Print a Label
          * @param {LabelPrintingRequest} body 
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         printLabel(body: LabelPrintingRequest, options?: any) {
             return UtilsApiFp(configuration).printLabel(body, options)(fetch, basePath);
         },
         /**
          * 
          * @summary Data References
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
         references(options?: any) {
             return UtilsApiFp(configuration).references(options)(fetch, basePath);
         },
     };
 };
 
 /**
  * UtilsApi - object-oriented interface
  * @export
  * @class UtilsApi
  * @extends {BaseAPI}
  */
 export class UtilsApi extends BaseAPI {
     /**
      * Returns a label PDF file.
      * @summary Print a Label
      * @param {LabelPrintingRequest} body 
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof UtilsApi
      */
     public printLabel(body: LabelPrintingRequest, options?: any) {
         return UtilsApiFp(this.configuration).printLabel(body, options)(this.fetch, this.basePath);
     }
 
     /**
      * 
      * @summary Data References
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof UtilsApi
      */
     public references(options?: any) {
         return UtilsApiFp(this.configuration).references(options)(this.fetch, this.basePath);
     }
 
 }
 