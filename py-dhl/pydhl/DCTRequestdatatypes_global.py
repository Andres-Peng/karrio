#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Apr  3 22:04:04 2018 by generateDS.py version 2.29.5.
# Python 3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28)  [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('-o', './lib/DCTRequestdatatypes_global.py')
#
# Command line arguments:
#   ./xsd/DCTRequestdatatypes_global.xsd
#
# Current working directory (os.getcwd()):
#   dhl
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class DCTRequestDataTypes(GeneratedsSuper):
    """Comment describing your root element"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DCTRequestDataTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DCTRequestDataTypes.subclass:
            return DCTRequestDataTypes.subclass(*args_, **kwargs_)
        else:
            return DCTRequestDataTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DCTRequestDataTypes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DCTRequestDataTypes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCTRequestDataTypes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DCTRequestDataTypes', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCTRequestDataTypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DCTRequestDataTypes', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DCTRequestDataTypes


class DCTFrom(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CountryCode=None, Postalcode=None, City=None, Suburb=None):
        self.original_tagname_ = None
        self.CountryCode = CountryCode
        self.validate_CountryCodeType(self.CountryCode)
        self.Postalcode = Postalcode
        self.validate_PostalcodeType(self.Postalcode)
        self.City = City
        self.validate_CityType(self.City)
        self.Suburb = Suburb
        self.validate_SuburbType(self.Suburb)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DCTFrom)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DCTFrom.subclass:
            return DCTFrom.subclass(*args_, **kwargs_)
        else:
            return DCTFrom(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_Postalcode(self): return self.Postalcode
    def set_Postalcode(self, Postalcode): self.Postalcode = Postalcode
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_Suburb(self): return self.Suburb
    def set_Suburb(self, Suburb): self.Suburb = Suburb
    def validate_CountryCodeType(self, value):
        # Validate type CountryCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CountryCodeType' % {"value" : value.encode("utf-8")} )
    def validate_PostalcodeType(self, value):
        # Validate type PostalcodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PostalcodeType' % {"value" : value.encode("utf-8")} )
    def validate_CityType(self, value):
        # Validate type CityType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CityType' % {"value" : value.encode("utf-8")} )
    def validate_SuburbType(self, value):
        # Validate type SuburbType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SuburbType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CountryCode is not None or
            self.Postalcode is not None or
            self.City is not None or
            self.Suburb is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DCTFrom', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DCTFrom')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCTFrom')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DCTFrom', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCTFrom'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DCTFrom', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CountryCode>%s</CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.Postalcode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Postalcode>%s</Postalcode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Postalcode), input_name='Postalcode')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<City>%s</City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.Suburb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Suburb>%s</Suburb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Suburb), input_name='Suburb')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
            # validate type CountryCodeType
            self.validate_CountryCodeType(self.CountryCode)
        elif nodeName_ == 'Postalcode':
            Postalcode_ = child_.text
            Postalcode_ = self.gds_validate_string(Postalcode_, node, 'Postalcode')
            self.Postalcode = Postalcode_
            # validate type PostalcodeType
            self.validate_PostalcodeType(self.Postalcode)
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
            # validate type CityType
            self.validate_CityType(self.City)
        elif nodeName_ == 'Suburb':
            Suburb_ = child_.text
            Suburb_ = self.gds_validate_string(Suburb_, node, 'Suburb')
            self.Suburb = Suburb_
            # validate type SuburbType
            self.validate_SuburbType(self.Suburb)
# end class DCTFrom


class BkgDetailsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PaymentCountryCode=None, Date=None, ReadyTime=None, ReadyTimeGMTOffset=None, DimensionUnit=None, WeightUnit=None, NumberOfPieces=None, ShipmentWeight=None, Volume=None, MaxPieceWeight=None, MaxPieceHeight=None, MaxPieceDepth=None, MaxPieceWidth=None, Pieces=None, PaymentAccountNumber=None, IsDutiable=None, NetworkTypeCode=None, QtdShp=None, InsuredValue=None, InsuredCurrency=None, PaymentType=None, AcctPickupCloseTime=None):
        self.original_tagname_ = None
        self.PaymentCountryCode = PaymentCountryCode
        self.validate_PaymentCountryCodeType(self.PaymentCountryCode)
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.ReadyTime = ReadyTime
        self.validate_ReadyTimeType(self.ReadyTime)
        self.ReadyTimeGMTOffset = ReadyTimeGMTOffset
        self.validate_ReadyTimeGMTOffsetType(self.ReadyTimeGMTOffset)
        self.DimensionUnit = DimensionUnit
        self.validate_DimensionUnitType(self.DimensionUnit)
        self.WeightUnit = WeightUnit
        self.validate_WeightUnitType(self.WeightUnit)
        if NumberOfPieces is None:
            self.NumberOfPieces = []
        else:
            self.NumberOfPieces = NumberOfPieces
        self.ShipmentWeight = ShipmentWeight
        self.validate_ShipmentWeightType(self.ShipmentWeight)
        self.Volume = Volume
        self.validate_VolumeType(self.Volume)
        self.MaxPieceWeight = MaxPieceWeight
        self.validate_MaxPieceWeightType(self.MaxPieceWeight)
        self.MaxPieceHeight = MaxPieceHeight
        self.validate_MaxPieceHeightType(self.MaxPieceHeight)
        self.MaxPieceDepth = MaxPieceDepth
        self.validate_MaxPieceDepthType(self.MaxPieceDepth)
        self.MaxPieceWidth = MaxPieceWidth
        self.validate_MaxPieceWidthType(self.MaxPieceWidth)
        self.Pieces = Pieces
        self.PaymentAccountNumber = PaymentAccountNumber
        self.validate_PaymentAccountNumberType(self.PaymentAccountNumber)
        self.IsDutiable = IsDutiable
        self.validate_IsDutiableType(self.IsDutiable)
        self.NetworkTypeCode = NetworkTypeCode
        self.validate_NetworkTypeCodeType(self.NetworkTypeCode)
        if QtdShp is None:
            self.QtdShp = []
        else:
            self.QtdShp = QtdShp
        self.InsuredValue = InsuredValue
        self.validate_InsuredValueType(self.InsuredValue)
        self.InsuredCurrency = InsuredCurrency
        self.validate_InsuredCurrencyType(self.InsuredCurrency)
        self.PaymentType = PaymentType
        self.validate_PaymentTypeType(self.PaymentType)
        if isinstance(AcctPickupCloseTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AcctPickupCloseTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = AcctPickupCloseTime
        self.AcctPickupCloseTime = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BkgDetailsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BkgDetailsType.subclass:
            return BkgDetailsType.subclass(*args_, **kwargs_)
        else:
            return BkgDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PaymentCountryCode(self): return self.PaymentCountryCode
    def set_PaymentCountryCode(self, PaymentCountryCode): self.PaymentCountryCode = PaymentCountryCode
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_ReadyTime(self): return self.ReadyTime
    def set_ReadyTime(self, ReadyTime): self.ReadyTime = ReadyTime
    def get_ReadyTimeGMTOffset(self): return self.ReadyTimeGMTOffset
    def set_ReadyTimeGMTOffset(self, ReadyTimeGMTOffset): self.ReadyTimeGMTOffset = ReadyTimeGMTOffset
    def get_DimensionUnit(self): return self.DimensionUnit
    def set_DimensionUnit(self, DimensionUnit): self.DimensionUnit = DimensionUnit
    def get_WeightUnit(self): return self.WeightUnit
    def set_WeightUnit(self, WeightUnit): self.WeightUnit = WeightUnit
    def get_NumberOfPieces(self): return self.NumberOfPieces
    def set_NumberOfPieces(self, NumberOfPieces): self.NumberOfPieces = NumberOfPieces
    def add_NumberOfPieces(self, value): self.NumberOfPieces.append(value)
    def insert_NumberOfPieces_at(self, index, value): self.NumberOfPieces.insert(index, value)
    def replace_NumberOfPieces_at(self, index, value): self.NumberOfPieces[index] = value
    def get_ShipmentWeight(self): return self.ShipmentWeight
    def set_ShipmentWeight(self, ShipmentWeight): self.ShipmentWeight = ShipmentWeight
    def get_Volume(self): return self.Volume
    def set_Volume(self, Volume): self.Volume = Volume
    def get_MaxPieceWeight(self): return self.MaxPieceWeight
    def set_MaxPieceWeight(self, MaxPieceWeight): self.MaxPieceWeight = MaxPieceWeight
    def get_MaxPieceHeight(self): return self.MaxPieceHeight
    def set_MaxPieceHeight(self, MaxPieceHeight): self.MaxPieceHeight = MaxPieceHeight
    def get_MaxPieceDepth(self): return self.MaxPieceDepth
    def set_MaxPieceDepth(self, MaxPieceDepth): self.MaxPieceDepth = MaxPieceDepth
    def get_MaxPieceWidth(self): return self.MaxPieceWidth
    def set_MaxPieceWidth(self, MaxPieceWidth): self.MaxPieceWidth = MaxPieceWidth
    def get_Pieces(self): return self.Pieces
    def set_Pieces(self, Pieces): self.Pieces = Pieces
    def get_PaymentAccountNumber(self): return self.PaymentAccountNumber
    def set_PaymentAccountNumber(self, PaymentAccountNumber): self.PaymentAccountNumber = PaymentAccountNumber
    def get_IsDutiable(self): return self.IsDutiable
    def set_IsDutiable(self, IsDutiable): self.IsDutiable = IsDutiable
    def get_NetworkTypeCode(self): return self.NetworkTypeCode
    def set_NetworkTypeCode(self, NetworkTypeCode): self.NetworkTypeCode = NetworkTypeCode
    def get_QtdShp(self): return self.QtdShp
    def set_QtdShp(self, QtdShp): self.QtdShp = QtdShp
    def add_QtdShp(self, value): self.QtdShp.append(value)
    def insert_QtdShp_at(self, index, value): self.QtdShp.insert(index, value)
    def replace_QtdShp_at(self, index, value): self.QtdShp[index] = value
    def get_InsuredValue(self): return self.InsuredValue
    def set_InsuredValue(self, InsuredValue): self.InsuredValue = InsuredValue
    def get_InsuredCurrency(self): return self.InsuredCurrency
    def set_InsuredCurrency(self, InsuredCurrency): self.InsuredCurrency = InsuredCurrency
    def get_PaymentType(self): return self.PaymentType
    def set_PaymentType(self, PaymentType): self.PaymentType = PaymentType
    def get_AcctPickupCloseTime(self): return self.AcctPickupCloseTime
    def set_AcctPickupCloseTime(self, AcctPickupCloseTime): self.AcctPickupCloseTime = AcctPickupCloseTime
    def validate_PaymentCountryCodeType(self, value):
        # Validate type PaymentCountryCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PaymentCountryCodeType' % {"value" : value.encode("utf-8")} )
    def validate_DateType(self, value):
        # Validate type DateType, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ReadyTimeType(self, value):
        # Validate type ReadyTimeType, a restriction on xsd:duration.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ReadyTimeGMTOffsetType(self, value):
        # Validate type ReadyTimeGMTOffsetType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ReadyTimeGMTOffsetType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ReadyTimeGMTOffsetType' % {"value" : value.encode("utf-8")} )
    def validate_DimensionUnitType(self, value):
        # Validate type DimensionUnitType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['IN', 'CM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DimensionUnitType' % {"value" : value.encode("utf-8")} )
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DimensionUnitType' % {"value" : value.encode("utf-8")} )
    def validate_WeightUnitType(self, value):
        # Validate type WeightUnitType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['KG', 'LB']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeightUnitType' % {"value" : value.encode("utf-8")} )
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on WeightUnitType' % {"value" : value.encode("utf-8")} )
    def validate_NumberOfPiecesType(self, value):
        # Validate type NumberOfPiecesType, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ShipmentWeightType(self, value):
        # Validate type ShipmentWeightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ShipmentWeightType' % {"value" : value} )
    def validate_VolumeType(self, value):
        # Validate type VolumeType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on VolumeType' % {"value" : value} )
    def validate_MaxPieceWeightType(self, value):
        # Validate type MaxPieceWeightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MaxPieceWeightType' % {"value" : value} )
    def validate_MaxPieceHeightType(self, value):
        # Validate type MaxPieceHeightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MaxPieceHeightType' % {"value" : value} )
    def validate_MaxPieceDepthType(self, value):
        # Validate type MaxPieceDepthType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MaxPieceDepthType' % {"value" : value} )
    def validate_MaxPieceWidthType(self, value):
        # Validate type MaxPieceWidthType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MaxPieceWidthType' % {"value" : value} )
    def validate_PaymentAccountNumberType(self, value):
        # Validate type PaymentAccountNumberType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PaymentAccountNumberType' % {"value" : value.encode("utf-8")} )
    def validate_IsDutiableType(self, value):
        # Validate type IsDutiableType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IsDutiableType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on IsDutiableType' % {"value" : value.encode("utf-8")} )
    def validate_NetworkTypeCodeType(self, value):
        # Validate type NetworkTypeCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DD', 'TD', 'AL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NetworkTypeCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on NetworkTypeCodeType' % {"value" : value.encode("utf-8")} )
    def validate_InsuredValueType(self, value):
        # Validate type InsuredValueType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on InsuredValueType' % {"value" : value} )
    def validate_InsuredCurrencyType(self, value):
        # Validate type InsuredCurrencyType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on InsuredCurrencyType' % {"value" : value.encode("utf-8")} )
    def validate_PaymentTypeType(self, value):
        # Validate type PaymentTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['D']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PaymentTypeType' % {"value" : value.encode("utf-8")} )
    def validate_AcctPickupCloseTimeType(self, value):
        # Validate type AcctPickupCloseTimeType, a restriction on xsd:dateTime.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.PaymentCountryCode is not None or
            self.Date is not None or
            self.ReadyTime is not None or
            self.ReadyTimeGMTOffset is not None or
            self.DimensionUnit is not None or
            self.WeightUnit is not None or
            self.NumberOfPieces or
            self.ShipmentWeight is not None or
            self.Volume is not None or
            self.MaxPieceWeight is not None or
            self.MaxPieceHeight is not None or
            self.MaxPieceDepth is not None or
            self.MaxPieceWidth is not None or
            self.Pieces is not None or
            self.PaymentAccountNumber is not None or
            self.IsDutiable is not None or
            self.NetworkTypeCode is not None or
            self.QtdShp or
            self.InsuredValue is not None or
            self.InsuredCurrency is not None or
            self.PaymentType is not None or
            self.AcctPickupCloseTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BkgDetailsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BkgDetailsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BkgDetailsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BkgDetailsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BkgDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BkgDetailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PaymentCountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PaymentCountryCode>%s</PaymentCountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PaymentCountryCode), input_name='PaymentCountryCode')), eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Date>%s</Date>%s' % (self.gds_format_date(self.Date, input_name='Date'), eol_))
        if self.ReadyTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ReadyTime>%s</ReadyTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReadyTime), input_name='ReadyTime')), eol_))
        if self.ReadyTimeGMTOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ReadyTimeGMTOffset>%s</ReadyTimeGMTOffset>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReadyTimeGMTOffset), input_name='ReadyTimeGMTOffset')), eol_))
        if self.DimensionUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DimensionUnit>%s</DimensionUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DimensionUnit), input_name='DimensionUnit')), eol_))
        if self.WeightUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightUnit>%s</WeightUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeightUnit), input_name='WeightUnit')), eol_))
        for NumberOfPieces_ in self.NumberOfPieces:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NumberOfPieces>%s</NumberOfPieces>%s' % (self.gds_format_integer(NumberOfPieces_, input_name='NumberOfPieces'), eol_))
        if self.ShipmentWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipmentWeight>%s</ShipmentWeight>%s' % (self.gds_format_float(self.ShipmentWeight, input_name='ShipmentWeight'), eol_))
        if self.Volume is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Volume>%s</Volume>%s' % (self.gds_format_float(self.Volume, input_name='Volume'), eol_))
        if self.MaxPieceWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MaxPieceWeight>%s</MaxPieceWeight>%s' % (self.gds_format_float(self.MaxPieceWeight, input_name='MaxPieceWeight'), eol_))
        if self.MaxPieceHeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MaxPieceHeight>%s</MaxPieceHeight>%s' % (self.gds_format_float(self.MaxPieceHeight, input_name='MaxPieceHeight'), eol_))
        if self.MaxPieceDepth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MaxPieceDepth>%s</MaxPieceDepth>%s' % (self.gds_format_float(self.MaxPieceDepth, input_name='MaxPieceDepth'), eol_))
        if self.MaxPieceWidth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MaxPieceWidth>%s</MaxPieceWidth>%s' % (self.gds_format_float(self.MaxPieceWidth, input_name='MaxPieceWidth'), eol_))
        if self.Pieces is not None:
            self.Pieces.export(outfile, level, namespace_, name_='Pieces', pretty_print=pretty_print)
        if self.PaymentAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PaymentAccountNumber>%s</PaymentAccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PaymentAccountNumber), input_name='PaymentAccountNumber')), eol_))
        if self.IsDutiable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IsDutiable>%s</IsDutiable>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IsDutiable), input_name='IsDutiable')), eol_))
        if self.NetworkTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NetworkTypeCode>%s</NetworkTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NetworkTypeCode), input_name='NetworkTypeCode')), eol_))
        for QtdShp_ in self.QtdShp:
            QtdShp_.export(outfile, level, namespace_, name_='QtdShp', pretty_print=pretty_print)
        if self.InsuredValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<InsuredValue>%s</InsuredValue>%s' % (self.gds_format_float(self.InsuredValue, input_name='InsuredValue'), eol_))
        if self.InsuredCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<InsuredCurrency>%s</InsuredCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.InsuredCurrency), input_name='InsuredCurrency')), eol_))
        if self.PaymentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PaymentType>%s</PaymentType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PaymentType), input_name='PaymentType')), eol_))
        if self.AcctPickupCloseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AcctPickupCloseTime>%s</AcctPickupCloseTime>%s' % (self.gds_format_datetime(self.AcctPickupCloseTime, input_name='AcctPickupCloseTime'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PaymentCountryCode':
            PaymentCountryCode_ = child_.text
            PaymentCountryCode_ = self.gds_validate_string(PaymentCountryCode_, node, 'PaymentCountryCode')
            self.PaymentCountryCode = PaymentCountryCode_
            # validate type PaymentCountryCodeType
            self.validate_PaymentCountryCodeType(self.PaymentCountryCode)
        elif nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
            # validate type DateType
            self.validate_DateType(self.Date)
        elif nodeName_ == 'ReadyTime':
            ReadyTime_ = child_.text
            ReadyTime_ = self.gds_validate_string(ReadyTime_, node, 'ReadyTime')
            self.ReadyTime = ReadyTime_
            # validate type ReadyTimeType
            self.validate_ReadyTimeType(self.ReadyTime)
        elif nodeName_ == 'ReadyTimeGMTOffset':
            ReadyTimeGMTOffset_ = child_.text
            ReadyTimeGMTOffset_ = self.gds_validate_string(ReadyTimeGMTOffset_, node, 'ReadyTimeGMTOffset')
            self.ReadyTimeGMTOffset = ReadyTimeGMTOffset_
            # validate type ReadyTimeGMTOffsetType
            self.validate_ReadyTimeGMTOffsetType(self.ReadyTimeGMTOffset)
        elif nodeName_ == 'DimensionUnit':
            DimensionUnit_ = child_.text
            DimensionUnit_ = self.gds_validate_string(DimensionUnit_, node, 'DimensionUnit')
            self.DimensionUnit = DimensionUnit_
            # validate type DimensionUnitType
            self.validate_DimensionUnitType(self.DimensionUnit)
        elif nodeName_ == 'WeightUnit':
            WeightUnit_ = child_.text
            WeightUnit_ = self.gds_validate_string(WeightUnit_, node, 'WeightUnit')
            self.WeightUnit = WeightUnit_
            # validate type WeightUnitType
            self.validate_WeightUnitType(self.WeightUnit)
        elif nodeName_ == 'NumberOfPieces':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfPieces')
            self.NumberOfPieces.append(ival_)
            # validate type NumberOfPiecesType
            self.validate_NumberOfPiecesType(self.NumberOfPieces[-1])
        elif nodeName_ == 'ShipmentWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ShipmentWeight')
            self.ShipmentWeight = fval_
            # validate type ShipmentWeightType
            self.validate_ShipmentWeightType(self.ShipmentWeight)
        elif nodeName_ == 'Volume':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Volume')
            self.Volume = fval_
            # validate type VolumeType
            self.validate_VolumeType(self.Volume)
        elif nodeName_ == 'MaxPieceWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaxPieceWeight')
            self.MaxPieceWeight = fval_
            # validate type MaxPieceWeightType
            self.validate_MaxPieceWeightType(self.MaxPieceWeight)
        elif nodeName_ == 'MaxPieceHeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaxPieceHeight')
            self.MaxPieceHeight = fval_
            # validate type MaxPieceHeightType
            self.validate_MaxPieceHeightType(self.MaxPieceHeight)
        elif nodeName_ == 'MaxPieceDepth':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaxPieceDepth')
            self.MaxPieceDepth = fval_
            # validate type MaxPieceDepthType
            self.validate_MaxPieceDepthType(self.MaxPieceDepth)
        elif nodeName_ == 'MaxPieceWidth':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaxPieceWidth')
            self.MaxPieceWidth = fval_
            # validate type MaxPieceWidthType
            self.validate_MaxPieceWidthType(self.MaxPieceWidth)
        elif nodeName_ == 'Pieces':
            obj_ = PiecesType.factory()
            obj_.build(child_)
            self.Pieces = obj_
            obj_.original_tagname_ = 'Pieces'
        elif nodeName_ == 'PaymentAccountNumber':
            PaymentAccountNumber_ = child_.text
            PaymentAccountNumber_ = self.gds_validate_string(PaymentAccountNumber_, node, 'PaymentAccountNumber')
            self.PaymentAccountNumber = PaymentAccountNumber_
            # validate type PaymentAccountNumberType
            self.validate_PaymentAccountNumberType(self.PaymentAccountNumber)
        elif nodeName_ == 'IsDutiable':
            IsDutiable_ = child_.text
            IsDutiable_ = self.gds_validate_string(IsDutiable_, node, 'IsDutiable')
            self.IsDutiable = IsDutiable_
            # validate type IsDutiableType
            self.validate_IsDutiableType(self.IsDutiable)
        elif nodeName_ == 'NetworkTypeCode':
            NetworkTypeCode_ = child_.text
            NetworkTypeCode_ = self.gds_validate_string(NetworkTypeCode_, node, 'NetworkTypeCode')
            self.NetworkTypeCode = NetworkTypeCode_
            # validate type NetworkTypeCodeType
            self.validate_NetworkTypeCodeType(self.NetworkTypeCode)
        elif nodeName_ == 'QtdShp':
            obj_ = QtdShpType.factory()
            obj_.build(child_)
            self.QtdShp.append(obj_)
            obj_.original_tagname_ = 'QtdShp'
        elif nodeName_ == 'InsuredValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'InsuredValue')
            self.InsuredValue = fval_
            # validate type InsuredValueType
            self.validate_InsuredValueType(self.InsuredValue)
        elif nodeName_ == 'InsuredCurrency':
            InsuredCurrency_ = child_.text
            InsuredCurrency_ = self.gds_validate_string(InsuredCurrency_, node, 'InsuredCurrency')
            self.InsuredCurrency = InsuredCurrency_
            # validate type InsuredCurrencyType
            self.validate_InsuredCurrencyType(self.InsuredCurrency)
        elif nodeName_ == 'PaymentType':
            PaymentType_ = child_.text
            PaymentType_ = self.gds_validate_string(PaymentType_, node, 'PaymentType')
            self.PaymentType = PaymentType_
            # validate type PaymentTypeType
            self.validate_PaymentTypeType(self.PaymentType)
        elif nodeName_ == 'AcctPickupCloseTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.AcctPickupCloseTime = dval_
            # validate type AcctPickupCloseTimeType
            self.validate_AcctPickupCloseTimeType(self.AcctPickupCloseTime)
# end class BkgDetailsType


class DCTTo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CountryCode=None, Postalcode=None, City=None, Suburb=None):
        self.original_tagname_ = None
        self.CountryCode = CountryCode
        self.validate_CountryCodeType1(self.CountryCode)
        self.Postalcode = Postalcode
        self.validate_PostalcodeType2(self.Postalcode)
        self.City = City
        self.validate_CityType3(self.City)
        self.Suburb = Suburb
        self.validate_SuburbType4(self.Suburb)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DCTTo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DCTTo.subclass:
            return DCTTo.subclass(*args_, **kwargs_)
        else:
            return DCTTo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_Postalcode(self): return self.Postalcode
    def set_Postalcode(self, Postalcode): self.Postalcode = Postalcode
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_Suburb(self): return self.Suburb
    def set_Suburb(self, Suburb): self.Suburb = Suburb
    def validate_CountryCodeType1(self, value):
        # Validate type CountryCodeType1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CountryCodeType1' % {"value" : value.encode("utf-8")} )
    def validate_PostalcodeType2(self, value):
        # Validate type PostalcodeType2, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PostalcodeType2' % {"value" : value.encode("utf-8")} )
    def validate_CityType3(self, value):
        # Validate type CityType3, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CityType3' % {"value" : value.encode("utf-8")} )
    def validate_SuburbType4(self, value):
        # Validate type SuburbType4, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 45:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SuburbType4' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CountryCode is not None or
            self.Postalcode is not None or
            self.City is not None or
            self.Suburb is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DCTTo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DCTTo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCTTo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DCTTo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCTTo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DCTTo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CountryCode>%s</CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.Postalcode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Postalcode>%s</Postalcode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Postalcode), input_name='Postalcode')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<City>%s</City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.Suburb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Suburb>%s</Suburb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Suburb), input_name='Suburb')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
            # validate type CountryCodeType1
            self.validate_CountryCodeType1(self.CountryCode)
        elif nodeName_ == 'Postalcode':
            Postalcode_ = child_.text
            Postalcode_ = self.gds_validate_string(Postalcode_, node, 'Postalcode')
            self.Postalcode = Postalcode_
            # validate type PostalcodeType2
            self.validate_PostalcodeType2(self.Postalcode)
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
            # validate type CityType3
            self.validate_CityType3(self.City)
        elif nodeName_ == 'Suburb':
            Suburb_ = child_.text
            Suburb_ = self.gds_validate_string(Suburb_, node, 'Suburb')
            self.Suburb = Suburb_
            # validate type SuburbType4
            self.validate_SuburbType4(self.Suburb)
# end class DCTTo


class DCTDutiable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeclaredCurrency=None, DeclaredValue=None):
        self.original_tagname_ = None
        self.DeclaredCurrency = DeclaredCurrency
        self.validate_DeclaredCurrencyType(self.DeclaredCurrency)
        self.DeclaredValue = DeclaredValue
        self.validate_DeclaredValueType(self.DeclaredValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DCTDutiable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DCTDutiable.subclass:
            return DCTDutiable.subclass(*args_, **kwargs_)
        else:
            return DCTDutiable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeclaredCurrency(self): return self.DeclaredCurrency
    def set_DeclaredCurrency(self, DeclaredCurrency): self.DeclaredCurrency = DeclaredCurrency
    def get_DeclaredValue(self): return self.DeclaredValue
    def set_DeclaredValue(self, DeclaredValue): self.DeclaredValue = DeclaredValue
    def validate_DeclaredCurrencyType(self, value):
        # Validate type DeclaredCurrencyType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DeclaredCurrencyType' % {"value" : value.encode("utf-8")} )
    def validate_DeclaredValueType(self, value):
        # Validate type DeclaredValueType, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on DeclaredValueType' % {"value" : value} )
            if value > 999999999999999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DeclaredValueType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DeclaredCurrency is not None or
            self.DeclaredValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DCTDutiable', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DCTDutiable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCTDutiable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DCTDutiable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCTDutiable'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DCTDutiable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DeclaredCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeclaredCurrency>%s</DeclaredCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeclaredCurrency), input_name='DeclaredCurrency')), eol_))
        if self.DeclaredValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeclaredValue>%s</DeclaredValue>%s' % (self.gds_format_float(self.DeclaredValue, input_name='DeclaredValue'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DeclaredCurrency':
            DeclaredCurrency_ = child_.text
            DeclaredCurrency_ = self.gds_validate_string(DeclaredCurrency_, node, 'DeclaredCurrency')
            self.DeclaredCurrency = DeclaredCurrency_
            # validate type DeclaredCurrencyType
            self.validate_DeclaredCurrencyType(self.DeclaredCurrency)
        elif nodeName_ == 'DeclaredValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DeclaredValue')
            self.DeclaredValue = fval_
            # validate type DeclaredValueType
            self.validate_DeclaredValueType(self.DeclaredValue)
# end class DCTDutiable


class PieceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PieceID=None, PackageTypeCode='BOX', Height=None, Depth=None, Width=None, Weight=None):
        self.original_tagname_ = None
        self.PieceID = PieceID
        self.validate_PieceIDType(self.PieceID)
        self.PackageTypeCode = PackageTypeCode
        self.validate_PackageTypeCodeType(self.PackageTypeCode)
        self.Height = Height
        self.validate_HeightType(self.Height)
        self.Depth = Depth
        self.validate_DepthType(self.Depth)
        self.Width = Width
        self.validate_WidthType(self.Width)
        self.Weight = Weight
        self.validate_WeightType(self.Weight)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PieceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PieceType.subclass:
            return PieceType.subclass(*args_, **kwargs_)
        else:
            return PieceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PieceID(self): return self.PieceID
    def set_PieceID(self, PieceID): self.PieceID = PieceID
    def get_PackageTypeCode(self): return self.PackageTypeCode
    def set_PackageTypeCode(self, PackageTypeCode): self.PackageTypeCode = PackageTypeCode
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Depth(self): return self.Depth
    def set_Depth(self, Depth): self.Depth = Depth
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def validate_PieceIDType(self, value):
        # Validate type PieceIDType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PieceIDType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PieceIDType_patterns_, ))
    validate_PieceIDType_patterns_ = [['^[0-9]+$']]
    def validate_PackageTypeCodeType(self, value):
        # Validate type PackageTypeCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FLY', 'COY', 'NCY', 'PAL', 'DBL', 'BOX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PackageTypeCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PackageTypeCodeType' % {"value" : value.encode("utf-8")} )
    def validate_HeightType(self, value):
        # Validate type HeightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on HeightType' % {"value" : value} )
    def validate_DepthType(self, value):
        # Validate type DepthType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DepthType' % {"value" : value} )
    def validate_WidthType(self, value):
        # Validate type WidthType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WidthType' % {"value" : value} )
    def validate_WeightType(self, value):
        # Validate type WeightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.PieceID is not None or
            self.PackageTypeCode != "BOX" or
            self.Height is not None or
            self.Depth is not None or
            self.Width is not None or
            self.Weight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PieceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PieceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PieceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PieceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PieceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PieceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PieceID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PieceID>%s</PieceID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PieceID), input_name='PieceID')), eol_))
        if self.PackageTypeCode != "BOX":
            showIndent(outfile, level, pretty_print)
            outfile.write('<PackageTypeCode>%s</PackageTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackageTypeCode), input_name='PackageTypeCode')), eol_))
        if self.Height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Height>%s</Height>%s' % (self.gds_format_float(self.Height, input_name='Height'), eol_))
        if self.Depth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Depth>%s</Depth>%s' % (self.gds_format_float(self.Depth, input_name='Depth'), eol_))
        if self.Width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Width>%s</Width>%s' % (self.gds_format_float(self.Width, input_name='Width'), eol_))
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Weight>%s</Weight>%s' % (self.gds_format_float(self.Weight, input_name='Weight'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PieceID':
            PieceID_ = child_.text
            PieceID_ = self.gds_validate_string(PieceID_, node, 'PieceID')
            self.PieceID = PieceID_
            # validate type PieceIDType
            self.validate_PieceIDType(self.PieceID)
        elif nodeName_ == 'PackageTypeCode':
            PackageTypeCode_ = child_.text
            PackageTypeCode_ = self.gds_validate_string(PackageTypeCode_, node, 'PackageTypeCode')
            self.PackageTypeCode = PackageTypeCode_
            # validate type PackageTypeCodeType
            self.validate_PackageTypeCodeType(self.PackageTypeCode)
        elif nodeName_ == 'Height':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Height')
            self.Height = fval_
            # validate type HeightType
            self.validate_HeightType(self.Height)
        elif nodeName_ == 'Depth':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Depth')
            self.Depth = fval_
            # validate type DepthType
            self.validate_DepthType(self.Depth)
        elif nodeName_ == 'Width':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Width')
            self.Width = fval_
            # validate type WidthType
            self.validate_WidthType(self.Width)
        elif nodeName_ == 'Weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Weight')
            self.Weight = fval_
            # validate type WeightType
            self.validate_WeightType(self.Weight)
# end class PieceType


class QtdShpType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GlobalProductCode=None, LocalProductCode=None, QtdShpExChrg=None):
        self.original_tagname_ = None
        self.GlobalProductCode = GlobalProductCode
        self.validate_GlobalProductCodeType(self.GlobalProductCode)
        self.LocalProductCode = LocalProductCode
        self.validate_LocalProductCodeType(self.LocalProductCode)
        if QtdShpExChrg is None:
            self.QtdShpExChrg = []
        else:
            self.QtdShpExChrg = QtdShpExChrg
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdShpType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdShpType.subclass:
            return QtdShpType.subclass(*args_, **kwargs_)
        else:
            return QtdShpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GlobalProductCode(self): return self.GlobalProductCode
    def set_GlobalProductCode(self, GlobalProductCode): self.GlobalProductCode = GlobalProductCode
    def get_LocalProductCode(self): return self.LocalProductCode
    def set_LocalProductCode(self, LocalProductCode): self.LocalProductCode = LocalProductCode
    def get_QtdShpExChrg(self): return self.QtdShpExChrg
    def set_QtdShpExChrg(self, QtdShpExChrg): self.QtdShpExChrg = QtdShpExChrg
    def add_QtdShpExChrg(self, value): self.QtdShpExChrg.append(value)
    def insert_QtdShpExChrg_at(self, index, value): self.QtdShpExChrg.insert(index, value)
    def replace_QtdShpExChrg_at(self, index, value): self.QtdShpExChrg[index] = value
    def validate_GlobalProductCodeType(self, value):
        # Validate type GlobalProductCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on GlobalProductCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on GlobalProductCodeType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_GlobalProductCodeType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_GlobalProductCodeType_patterns_, ))
    validate_GlobalProductCodeType_patterns_ = [['^[A-Z0-9]+$']]
    def validate_LocalProductCodeType(self, value):
        # Validate type LocalProductCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LocalProductCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on LocalProductCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.GlobalProductCode is not None or
            self.LocalProductCode is not None or
            self.QtdShpExChrg
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdShpType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdShpType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdShpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdShpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdShpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdShpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GlobalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalProductCode>%s</GlobalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalProductCode), input_name='GlobalProductCode')), eol_))
        if self.LocalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductCode>%s</LocalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductCode), input_name='LocalProductCode')), eol_))
        for QtdShpExChrg_ in self.QtdShpExChrg:
            QtdShpExChrg_.export(outfile, level, namespace_, name_='QtdShpExChrg', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GlobalProductCode':
            GlobalProductCode_ = child_.text
            GlobalProductCode_ = self.gds_validate_string(GlobalProductCode_, node, 'GlobalProductCode')
            self.GlobalProductCode = GlobalProductCode_
            # validate type GlobalProductCodeType
            self.validate_GlobalProductCodeType(self.GlobalProductCode)
        elif nodeName_ == 'LocalProductCode':
            LocalProductCode_ = child_.text
            LocalProductCode_ = self.gds_validate_string(LocalProductCode_, node, 'LocalProductCode')
            self.LocalProductCode = LocalProductCode_
            # validate type LocalProductCodeType
            self.validate_LocalProductCodeType(self.LocalProductCode)
        elif nodeName_ == 'QtdShpExChrg':
            obj_ = QtdShpExChrgType.factory()
            obj_.build(child_)
            self.QtdShpExChrg.append(obj_)
            obj_.original_tagname_ = 'QtdShpExChrg'
# end class QtdShpType


class QtdShpExChrgType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SpecialServiceType=None, LocalSpecialServiceType=None):
        self.original_tagname_ = None
        self.SpecialServiceType = SpecialServiceType
        self.validate_SpecialServiceTypeType(self.SpecialServiceType)
        self.LocalSpecialServiceType = LocalSpecialServiceType
        self.validate_LocalSpecialServiceTypeType(self.LocalSpecialServiceType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdShpExChrgType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdShpExChrgType.subclass:
            return QtdShpExChrgType.subclass(*args_, **kwargs_)
        else:
            return QtdShpExChrgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialServiceType(self): return self.SpecialServiceType
    def set_SpecialServiceType(self, SpecialServiceType): self.SpecialServiceType = SpecialServiceType
    def get_LocalSpecialServiceType(self): return self.LocalSpecialServiceType
    def set_LocalSpecialServiceType(self, LocalSpecialServiceType): self.LocalSpecialServiceType = LocalSpecialServiceType
    def validate_SpecialServiceTypeType(self, value):
        # Validate type SpecialServiceTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SpecialServiceTypeType' % {"value" : value.encode("utf-8")} )
    def validate_LocalSpecialServiceTypeType(self, value):
        # Validate type LocalSpecialServiceTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LocalSpecialServiceTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SpecialServiceType is not None or
            self.LocalSpecialServiceType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdShpExChrgType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdShpExChrgType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdShpExChrgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdShpExChrgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdShpExChrgType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdShpExChrgType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecialServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SpecialServiceType>%s</SpecialServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialServiceType), input_name='SpecialServiceType')), eol_))
        if self.LocalSpecialServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalSpecialServiceType>%s</LocalSpecialServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalSpecialServiceType), input_name='LocalSpecialServiceType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialServiceType':
            SpecialServiceType_ = child_.text
            SpecialServiceType_ = self.gds_validate_string(SpecialServiceType_, node, 'SpecialServiceType')
            self.SpecialServiceType = SpecialServiceType_
            # validate type SpecialServiceTypeType
            self.validate_SpecialServiceTypeType(self.SpecialServiceType)
        elif nodeName_ == 'LocalSpecialServiceType':
            LocalSpecialServiceType_ = child_.text
            LocalSpecialServiceType_ = self.gds_validate_string(LocalSpecialServiceType_, node, 'LocalSpecialServiceType')
            self.LocalSpecialServiceType = LocalSpecialServiceType_
            # validate type LocalSpecialServiceTypeType
            self.validate_LocalSpecialServiceTypeType(self.LocalSpecialServiceType)
# end class QtdShpExChrgType


class GenReq(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OSINFO=None, NXTPU=None, FCNTWTYCD=None, CUSTAGRIND=None, VLDTRT_DD=None):
        self.original_tagname_ = None
        self.OSINFO = OSINFO
        self.validate_OSINFOType(self.OSINFO)
        self.NXTPU = NXTPU
        self.validate_NXTPUType(self.NXTPU)
        self.FCNTWTYCD = FCNTWTYCD
        self.validate_FCNTWTYCDType(self.FCNTWTYCD)
        self.CUSTAGRIND = CUSTAGRIND
        self.validate_CUSTAGRINDType(self.CUSTAGRIND)
        self.VLDTRT_DD = VLDTRT_DD
        self.validate_VLDTRT_DDType(self.VLDTRT_DD)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenReq)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenReq.subclass:
            return GenReq.subclass(*args_, **kwargs_)
        else:
            return GenReq(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OSINFO(self): return self.OSINFO
    def set_OSINFO(self, OSINFO): self.OSINFO = OSINFO
    def get_NXTPU(self): return self.NXTPU
    def set_NXTPU(self, NXTPU): self.NXTPU = NXTPU
    def get_FCNTWTYCD(self): return self.FCNTWTYCD
    def set_FCNTWTYCD(self, FCNTWTYCD): self.FCNTWTYCD = FCNTWTYCD
    def get_CUSTAGRIND(self): return self.CUSTAGRIND
    def set_CUSTAGRIND(self, CUSTAGRIND): self.CUSTAGRIND = CUSTAGRIND
    def get_VLDTRT_DD(self): return self.VLDTRT_DD
    def set_VLDTRT_DD(self, VLDTRT_DD): self.VLDTRT_DD = VLDTRT_DD
    def validate_OSINFOType(self, value):
        # Validate type OSINFOType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OSINFOType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on OSINFOType' % {"value" : value.encode("utf-8")} )
    def validate_NXTPUType(self, value):
        # Validate type NXTPUType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on NXTPUType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on NXTPUType' % {"value" : value.encode("utf-8")} )
    def validate_FCNTWTYCDType(self, value):
        # Validate type FCNTWTYCDType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DD', 'TD', 'AL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FCNTWTYCDType' % {"value" : value.encode("utf-8")} )
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on FCNTWTYCDType' % {"value" : value.encode("utf-8")} )
    def validate_CUSTAGRINDType(self, value):
        # Validate type CUSTAGRINDType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CUSTAGRINDType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CUSTAGRINDType' % {"value" : value.encode("utf-8")} )
    def validate_VLDTRT_DDType(self, value):
        # Validate type VLDTRT_DDType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VLDTRT_DDType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on VLDTRT_DDType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OSINFO is not None or
            self.NXTPU is not None or
            self.FCNTWTYCD is not None or
            self.CUSTAGRIND is not None or
            self.VLDTRT_DD is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GenReq', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenReq')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenReq')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GenReq', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GenReq'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GenReq', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OSINFO is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OSINFO>%s</OSINFO>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OSINFO), input_name='OSINFO')), eol_))
        if self.NXTPU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NXTPU>%s</NXTPU>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NXTPU), input_name='NXTPU')), eol_))
        if self.FCNTWTYCD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FCNTWTYCD>%s</FCNTWTYCD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FCNTWTYCD), input_name='FCNTWTYCD')), eol_))
        if self.CUSTAGRIND is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CUSTAGRIND>%s</CUSTAGRIND>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CUSTAGRIND), input_name='CUSTAGRIND')), eol_))
        if self.VLDTRT_DD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VLDTRT_DD>%s</VLDTRT_DD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VLDTRT_DD), input_name='VLDTRT_DD')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OSINFO':
            OSINFO_ = child_.text
            OSINFO_ = self.gds_validate_string(OSINFO_, node, 'OSINFO')
            self.OSINFO = OSINFO_
            # validate type OSINFOType
            self.validate_OSINFOType(self.OSINFO)
        elif nodeName_ == 'NXTPU':
            NXTPU_ = child_.text
            NXTPU_ = self.gds_validate_string(NXTPU_, node, 'NXTPU')
            self.NXTPU = NXTPU_
            # validate type NXTPUType
            self.validate_NXTPUType(self.NXTPU)
        elif nodeName_ == 'FCNTWTYCD':
            FCNTWTYCD_ = child_.text
            FCNTWTYCD_ = self.gds_validate_string(FCNTWTYCD_, node, 'FCNTWTYCD')
            self.FCNTWTYCD = FCNTWTYCD_
            # validate type FCNTWTYCDType
            self.validate_FCNTWTYCDType(self.FCNTWTYCD)
        elif nodeName_ == 'CUSTAGRIND':
            CUSTAGRIND_ = child_.text
            CUSTAGRIND_ = self.gds_validate_string(CUSTAGRIND_, node, 'CUSTAGRIND')
            self.CUSTAGRIND = CUSTAGRIND_
            # validate type CUSTAGRINDType
            self.validate_CUSTAGRINDType(self.CUSTAGRIND)
        elif nodeName_ == 'VLDTRT_DD':
            VLDTRT_DD_ = child_.text
            VLDTRT_DD_ = self.gds_validate_string(VLDTRT_DD_, node, 'VLDTRT_DD')
            self.VLDTRT_DD = VLDTRT_DD_
            # validate type VLDTRT_DDType
            self.validate_VLDTRT_DDType(self.VLDTRT_DD)
# end class GenReq


class PiecesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Piece=None):
        self.original_tagname_ = None
        if Piece is None:
            self.Piece = []
        else:
            self.Piece = Piece
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PiecesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PiecesType.subclass:
            return PiecesType.subclass(*args_, **kwargs_)
        else:
            return PiecesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Piece(self): return self.Piece
    def set_Piece(self, Piece): self.Piece = Piece
    def add_Piece(self, value): self.Piece.append(value)
    def insert_Piece_at(self, index, value): self.Piece.insert(index, value)
    def replace_Piece_at(self, index, value): self.Piece[index] = value
    def hasContent_(self):
        if (
            self.Piece
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PiecesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PiecesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PiecesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PiecesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PiecesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PiecesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Piece_ in self.Piece:
            Piece_.export(outfile, level, namespace_, name_='Piece', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Piece':
            obj_ = PieceType.factory()
            obj_.build(child_)
            self.Piece.append(obj_)
            obj_.original_tagname_ = 'Piece'
# end class PiecesType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTRequestDataTypes'
        rootClass = DCTRequestDataTypes
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTRequestDataTypes'
        rootClass = DCTRequestDataTypes
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTRequestDataTypes'
        rootClass = DCTRequestDataTypes
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTRequestDataTypes'
        rootClass = DCTRequestDataTypes
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from DCTRequestdatatypes_global import *\n\n')
        sys.stdout.write('import DCTRequestdatatypes_global as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "BkgDetailsType",
    "DCTDutiable",
    "DCTFrom",
    "DCTRequestDataTypes",
    "DCTTo",
    "GenReq",
    "PieceType",
    "PiecesType",
    "QtdShpExChrgType",
    "QtdShpType"
]
