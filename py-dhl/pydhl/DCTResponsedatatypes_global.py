#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Apr  3 22:04:05 2018 by generateDS.py version 2.29.5.
# Python 3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28)  [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('-o', './lib/DCTResponsedatatypes_global.py')
#
# Command line arguments:
#   ./xsd/DCTResponsedatatypes_global.xsd
#
# Current working directory (os.getcwd()):
#   dhl
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class DCTResponseDataTypes(GeneratedsSuper):
    """Comment describing your root element"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DCTResponseDataTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DCTResponseDataTypes.subclass:
            return DCTResponseDataTypes.subclass(*args_, **kwargs_)
        else:
            return DCTResponseDataTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DCTResponseDataTypes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DCTResponseDataTypes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCTResponseDataTypes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DCTResponseDataTypes', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCTResponseDataTypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DCTResponseDataTypes', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DCTResponseDataTypes


class OrgnSvcAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FacilityCode=None, ServiceAreaCode=None):
        self.original_tagname_ = None
        self.FacilityCode = FacilityCode
        self.validate_FacilityCodeType(self.FacilityCode)
        self.ServiceAreaCode = ServiceAreaCode
        self.validate_ServiceAreaCodeType(self.ServiceAreaCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrgnSvcAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrgnSvcAreaType.subclass:
            return OrgnSvcAreaType.subclass(*args_, **kwargs_)
        else:
            return OrgnSvcAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FacilityCode(self): return self.FacilityCode
    def set_FacilityCode(self, FacilityCode): self.FacilityCode = FacilityCode
    def get_ServiceAreaCode(self): return self.ServiceAreaCode
    def set_ServiceAreaCode(self, ServiceAreaCode): self.ServiceAreaCode = ServiceAreaCode
    def validate_FacilityCodeType(self, value):
        # Validate type FacilityCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on FacilityCodeType' % {"value" : value.encode("utf-8")} )
    def validate_ServiceAreaCodeType(self, value):
        # Validate type ServiceAreaCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ServiceAreaCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FacilityCode is not None or
            self.ServiceAreaCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrgnSvcAreaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrgnSvcAreaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrgnSvcAreaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrgnSvcAreaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrgnSvcAreaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OrgnSvcAreaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FacilityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FacilityCode>%s</FacilityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FacilityCode), input_name='FacilityCode')), eol_))
        if self.ServiceAreaCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ServiceAreaCode>%s</ServiceAreaCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceAreaCode), input_name='ServiceAreaCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FacilityCode':
            FacilityCode_ = child_.text
            FacilityCode_ = self.gds_validate_string(FacilityCode_, node, 'FacilityCode')
            self.FacilityCode = FacilityCode_
            # validate type FacilityCodeType
            self.validate_FacilityCodeType(self.FacilityCode)
        elif nodeName_ == 'ServiceAreaCode':
            ServiceAreaCode_ = child_.text
            ServiceAreaCode_ = self.gds_validate_string(ServiceAreaCode_, node, 'ServiceAreaCode')
            self.ServiceAreaCode = ServiceAreaCode_
            # validate type ServiceAreaCodeType
            self.validate_ServiceAreaCodeType(self.ServiceAreaCode)
# end class OrgnSvcAreaType


class DestSvcAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FacilityCode=None, ServiceAreaCode=None):
        self.original_tagname_ = None
        self.FacilityCode = FacilityCode
        self.validate_FacilityCodeType1(self.FacilityCode)
        self.ServiceAreaCode = ServiceAreaCode
        self.validate_ServiceAreaCodeType2(self.ServiceAreaCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DestSvcAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DestSvcAreaType.subclass:
            return DestSvcAreaType.subclass(*args_, **kwargs_)
        else:
            return DestSvcAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FacilityCode(self): return self.FacilityCode
    def set_FacilityCode(self, FacilityCode): self.FacilityCode = FacilityCode
    def get_ServiceAreaCode(self): return self.ServiceAreaCode
    def set_ServiceAreaCode(self, ServiceAreaCode): self.ServiceAreaCode = ServiceAreaCode
    def validate_FacilityCodeType1(self, value):
        # Validate type FacilityCodeType1, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on FacilityCodeType1' % {"value" : value.encode("utf-8")} )
    def validate_ServiceAreaCodeType2(self, value):
        # Validate type ServiceAreaCodeType2, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ServiceAreaCodeType2' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FacilityCode is not None or
            self.ServiceAreaCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DestSvcAreaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DestSvcAreaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestSvcAreaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DestSvcAreaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DestSvcAreaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DestSvcAreaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FacilityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FacilityCode>%s</FacilityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FacilityCode), input_name='FacilityCode')), eol_))
        if self.ServiceAreaCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ServiceAreaCode>%s</ServiceAreaCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceAreaCode), input_name='ServiceAreaCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FacilityCode':
            FacilityCode_ = child_.text
            FacilityCode_ = self.gds_validate_string(FacilityCode_, node, 'FacilityCode')
            self.FacilityCode = FacilityCode_
            # validate type FacilityCodeType1
            self.validate_FacilityCodeType1(self.FacilityCode)
        elif nodeName_ == 'ServiceAreaCode':
            ServiceAreaCode_ = child_.text
            ServiceAreaCode_ = self.gds_validate_string(ServiceAreaCode_, node, 'ServiceAreaCode')
            self.ServiceAreaCode = ServiceAreaCode_
            # validate type ServiceAreaCodeType2
            self.validate_ServiceAreaCodeType2(self.ServiceAreaCode)
# end class DestSvcAreaType


class BkgDetailsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, QtdShp=None):
        self.original_tagname_ = None
        if QtdShp is None:
            self.QtdShp = []
        else:
            self.QtdShp = QtdShp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BkgDetailsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BkgDetailsType.subclass:
            return BkgDetailsType.subclass(*args_, **kwargs_)
        else:
            return BkgDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QtdShp(self): return self.QtdShp
    def set_QtdShp(self, QtdShp): self.QtdShp = QtdShp
    def add_QtdShp(self, value): self.QtdShp.append(value)
    def insert_QtdShp_at(self, index, value): self.QtdShp.insert(index, value)
    def replace_QtdShp_at(self, index, value): self.QtdShp[index] = value
    def hasContent_(self):
        if (
            self.QtdShp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BkgDetailsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BkgDetailsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BkgDetailsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BkgDetailsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BkgDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BkgDetailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for QtdShp_ in self.QtdShp:
            QtdShp_.export(outfile, level, namespace_, name_='QtdShp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QtdShp':
            obj_ = QtdShpType.factory()
            obj_.build(child_)
            self.QtdShp.append(obj_)
            obj_.original_tagname_ = 'QtdShp'
# end class BkgDetailsType


class SrvCombType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GlobalServiceName=None, GlobalServiceCode=None, LocalServiceCode=None, LocalServiceTypeName=None, ChargeCodeType=None, SOfferedCustAgreement=None, SrvComb=None):
        self.original_tagname_ = None
        self.GlobalServiceName = GlobalServiceName
        self.validate_GlobalServiceNameType(self.GlobalServiceName)
        self.GlobalServiceCode = GlobalServiceCode
        self.validate_GlobalServiceCodeType(self.GlobalServiceCode)
        self.LocalServiceCode = LocalServiceCode
        self.validate_LocalServiceCodeType(self.LocalServiceCode)
        self.LocalServiceTypeName = LocalServiceTypeName
        self.validate_LocalServiceTypeNameType(self.LocalServiceTypeName)
        self.ChargeCodeType = ChargeCodeType
        self.validate_ChargeCodeTypeType(self.ChargeCodeType)
        self.SOfferedCustAgreement = SOfferedCustAgreement
        self.validate_SOfferedCustAgreementType(self.SOfferedCustAgreement)
        self.SrvComb = SrvComb
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SrvCombType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SrvCombType.subclass:
            return SrvCombType.subclass(*args_, **kwargs_)
        else:
            return SrvCombType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GlobalServiceName(self): return self.GlobalServiceName
    def set_GlobalServiceName(self, GlobalServiceName): self.GlobalServiceName = GlobalServiceName
    def get_GlobalServiceCode(self): return self.GlobalServiceCode
    def set_GlobalServiceCode(self, GlobalServiceCode): self.GlobalServiceCode = GlobalServiceCode
    def get_LocalServiceCode(self): return self.LocalServiceCode
    def set_LocalServiceCode(self, LocalServiceCode): self.LocalServiceCode = LocalServiceCode
    def get_LocalServiceTypeName(self): return self.LocalServiceTypeName
    def set_LocalServiceTypeName(self, LocalServiceTypeName): self.LocalServiceTypeName = LocalServiceTypeName
    def get_ChargeCodeType(self): return self.ChargeCodeType
    def set_ChargeCodeType(self, ChargeCodeType): self.ChargeCodeType = ChargeCodeType
    def get_SOfferedCustAgreement(self): return self.SOfferedCustAgreement
    def set_SOfferedCustAgreement(self, SOfferedCustAgreement): self.SOfferedCustAgreement = SOfferedCustAgreement
    def get_SrvComb(self): return self.SrvComb
    def set_SrvComb(self, SrvComb): self.SrvComb = SrvComb
    def validate_GlobalServiceNameType(self, value):
        # Validate type GlobalServiceNameType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 45:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on GlobalServiceNameType' % {"value" : value.encode("utf-8")} )
    def validate_GlobalServiceCodeType(self, value):
        # Validate type GlobalServiceCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 6:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on GlobalServiceCodeType' % {"value" : value.encode("utf-8")} )
    def validate_LocalServiceCodeType(self, value):
        # Validate type LocalServiceCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on LocalServiceCodeType' % {"value" : value.encode("utf-8")} )
    def validate_LocalServiceTypeNameType(self, value):
        # Validate type LocalServiceTypeNameType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 45:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on LocalServiceTypeNameType' % {"value" : value.encode("utf-8")} )
    def validate_ChargeCodeTypeType(self, value):
        # Validate type ChargeCodeTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEE', 'SCH', 'XCH', 'NRI']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChargeCodeTypeType' % {"value" : value.encode("utf-8")} )
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ChargeCodeTypeType' % {"value" : value.encode("utf-8")} )
    def validate_SOfferedCustAgreementType(self, value):
        # Validate type SOfferedCustAgreementType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on SOfferedCustAgreementType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.GlobalServiceName is not None or
            self.GlobalServiceCode is not None or
            self.LocalServiceCode is not None or
            self.LocalServiceTypeName is not None or
            self.ChargeCodeType is not None or
            self.SOfferedCustAgreement is not None or
            self.SrvComb is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SrvCombType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SrvCombType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SrvCombType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SrvCombType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SrvCombType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SrvCombType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GlobalServiceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceName>%s</GlobalServiceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceName), input_name='GlobalServiceName')), eol_))
        if self.GlobalServiceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceCode>%s</GlobalServiceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceCode), input_name='GlobalServiceCode')), eol_))
        if self.LocalServiceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceCode>%s</LocalServiceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceCode), input_name='LocalServiceCode')), eol_))
        if self.LocalServiceTypeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceTypeName>%s</LocalServiceTypeName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceTypeName), input_name='LocalServiceTypeName')), eol_))
        if self.ChargeCodeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeCodeType>%s</ChargeCodeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeCodeType), input_name='ChargeCodeType')), eol_))
        if self.SOfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SOfferedCustAgreement>%s</SOfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SOfferedCustAgreement), input_name='SOfferedCustAgreement')), eol_))
        if self.SrvComb is not None:
            self.SrvComb.export(outfile, level, namespace_, name_='SrvComb', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GlobalServiceName':
            GlobalServiceName_ = child_.text
            GlobalServiceName_ = self.gds_validate_string(GlobalServiceName_, node, 'GlobalServiceName')
            self.GlobalServiceName = GlobalServiceName_
            # validate type GlobalServiceNameType
            self.validate_GlobalServiceNameType(self.GlobalServiceName)
        elif nodeName_ == 'GlobalServiceCode':
            GlobalServiceCode_ = child_.text
            GlobalServiceCode_ = self.gds_validate_string(GlobalServiceCode_, node, 'GlobalServiceCode')
            self.GlobalServiceCode = GlobalServiceCode_
            # validate type GlobalServiceCodeType
            self.validate_GlobalServiceCodeType(self.GlobalServiceCode)
        elif nodeName_ == 'LocalServiceCode':
            LocalServiceCode_ = child_.text
            LocalServiceCode_ = self.gds_validate_string(LocalServiceCode_, node, 'LocalServiceCode')
            self.LocalServiceCode = LocalServiceCode_
            # validate type LocalServiceCodeType
            self.validate_LocalServiceCodeType(self.LocalServiceCode)
        elif nodeName_ == 'LocalServiceTypeName':
            LocalServiceTypeName_ = child_.text
            LocalServiceTypeName_ = self.gds_validate_string(LocalServiceTypeName_, node, 'LocalServiceTypeName')
            self.LocalServiceTypeName = LocalServiceTypeName_
            # validate type LocalServiceTypeNameType
            self.validate_LocalServiceTypeNameType(self.LocalServiceTypeName)
        elif nodeName_ == 'ChargeCodeType':
            ChargeCodeType_ = child_.text
            ChargeCodeType_ = self.gds_validate_string(ChargeCodeType_, node, 'ChargeCodeType')
            self.ChargeCodeType = ChargeCodeType_
            # validate type ChargeCodeTypeType
            self.validate_ChargeCodeTypeType(self.ChargeCodeType)
        elif nodeName_ == 'SOfferedCustAgreement':
            SOfferedCustAgreement_ = child_.text
            SOfferedCustAgreement_ = self.gds_validate_string(SOfferedCustAgreement_, node, 'SOfferedCustAgreement')
            self.SOfferedCustAgreement = SOfferedCustAgreement_
            # validate type SOfferedCustAgreementType
            self.validate_SOfferedCustAgreementType(self.SOfferedCustAgreement)
        elif nodeName_ == 'SrvComb':
            obj_ = SrvCombType3.factory()
            obj_.build(child_)
            self.SrvComb = obj_
            obj_.original_tagname_ = 'SrvComb'
# end class SrvCombType


class ProdType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VldSrvComb=None, TotalDiscount=None):
        self.original_tagname_ = None
        if VldSrvComb is None:
            self.VldSrvComb = []
        else:
            self.VldSrvComb = VldSrvComb
        self.TotalDiscount = TotalDiscount
        self.validate_TotalDiscountType(self.TotalDiscount)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProdType.subclass:
            return ProdType.subclass(*args_, **kwargs_)
        else:
            return ProdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VldSrvComb(self): return self.VldSrvComb
    def set_VldSrvComb(self, VldSrvComb): self.VldSrvComb = VldSrvComb
    def add_VldSrvComb(self, value): self.VldSrvComb.append(value)
    def insert_VldSrvComb_at(self, index, value): self.VldSrvComb.insert(index, value)
    def replace_VldSrvComb_at(self, index, value): self.VldSrvComb[index] = value
    def get_TotalDiscount(self): return self.TotalDiscount
    def set_TotalDiscount(self, TotalDiscount): self.TotalDiscount = TotalDiscount
    def validate_TotalDiscountType(self, value):
        # Validate type TotalDiscountType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on TotalDiscountType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.VldSrvComb or
            self.TotalDiscount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProdType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProdType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProdType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProdType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProdType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProdType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VldSrvComb_ in self.VldSrvComb:
            VldSrvComb_.export(outfile, level, namespace_, name_='VldSrvComb', pretty_print=pretty_print)
        if self.TotalDiscount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalDiscount>%s</TotalDiscount>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TotalDiscount), input_name='TotalDiscount')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VldSrvComb':
            obj_ = VldSrvCombType.factory()
            obj_.build(child_)
            self.VldSrvComb.append(obj_)
            obj_.original_tagname_ = 'VldSrvComb'
        elif nodeName_ == 'TotalDiscount':
            TotalDiscount_ = child_.text
            TotalDiscount_ = self.gds_validate_string(TotalDiscount_, node, 'TotalDiscount')
            self.TotalDiscount = TotalDiscount_
            # validate type TotalDiscountType
            self.validate_TotalDiscountType(self.TotalDiscount)
# end class ProdType


class NoteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ActionStatus=None, Condition=None):
        self.original_tagname_ = None
        self.ActionStatus = ActionStatus
        if Condition is None:
            self.Condition = []
        else:
            self.Condition = Condition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoteType.subclass:
            return NoteType.subclass(*args_, **kwargs_)
        else:
            return NoteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionStatus(self): return self.ActionStatus
    def set_ActionStatus(self, ActionStatus): self.ActionStatus = ActionStatus
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def add_Condition(self, value): self.Condition.append(value)
    def insert_Condition_at(self, index, value): self.Condition.insert(index, value)
    def replace_Condition_at(self, index, value): self.Condition[index] = value
    def hasContent_(self):
        if (
            self.ActionStatus is not None or
            self.Condition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NoteType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NoteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NoteType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NoteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActionStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ActionStatus>%s</ActionStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ActionStatus), input_name='ActionStatus')), eol_))
        for Condition_ in self.Condition:
            Condition_.export(outfile, level, namespace_, name_='Condition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionStatus':
            ActionStatus_ = child_.text
            ActionStatus_ = self.gds_validate_string(ActionStatus_, node, 'ActionStatus')
            self.ActionStatus = ActionStatus_
        elif nodeName_ == 'Condition':
            obj_ = ConditionType.factory()
            obj_.build(child_)
            self.Condition.append(obj_)
            obj_.original_tagname_ = 'Condition'
# end class NoteType


class QtdShpExChrgType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SpecialServiceType=None, LocalServiceType=None, GlobalServiceName=None, LocalServiceTypeName=None, SOfferedCustAgreement=None, ChargeCodeType=None, InsPrmRateInPercentage=None, CurrencyCode=None, ChargeValue=None, ChargeTaxAmount=None, ChargeTaxRate=None, ChargeTaxAmountDet=None, QtdSExtrChrgInAdCur=None):
        self.original_tagname_ = None
        self.SpecialServiceType = SpecialServiceType
        self.validate_SpecialServiceTypeType(self.SpecialServiceType)
        self.LocalServiceType = LocalServiceType
        self.validate_LocalServiceTypeType(self.LocalServiceType)
        self.GlobalServiceName = GlobalServiceName
        self.LocalServiceTypeName = LocalServiceTypeName
        self.SOfferedCustAgreement = SOfferedCustAgreement
        self.ChargeCodeType = ChargeCodeType
        self.InsPrmRateInPercentage = InsPrmRateInPercentage
        self.validate_InsPrmRateInPercentageType(self.InsPrmRateInPercentage)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType(self.CurrencyCode)
        self.ChargeValue = ChargeValue
        self.validate_ChargeValueType(self.ChargeValue)
        self.ChargeTaxAmount = ChargeTaxAmount
        self.validate_ChargeTaxAmountType(self.ChargeTaxAmount)
        if ChargeTaxRate is None:
            self.ChargeTaxRate = []
        else:
            self.ChargeTaxRate = ChargeTaxRate
        if ChargeTaxAmountDet is None:
            self.ChargeTaxAmountDet = []
        else:
            self.ChargeTaxAmountDet = ChargeTaxAmountDet
        if QtdSExtrChrgInAdCur is None:
            self.QtdSExtrChrgInAdCur = []
        else:
            self.QtdSExtrChrgInAdCur = QtdSExtrChrgInAdCur
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdShpExChrgType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdShpExChrgType.subclass:
            return QtdShpExChrgType.subclass(*args_, **kwargs_)
        else:
            return QtdShpExChrgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialServiceType(self): return self.SpecialServiceType
    def set_SpecialServiceType(self, SpecialServiceType): self.SpecialServiceType = SpecialServiceType
    def get_LocalServiceType(self): return self.LocalServiceType
    def set_LocalServiceType(self, LocalServiceType): self.LocalServiceType = LocalServiceType
    def get_GlobalServiceName(self): return self.GlobalServiceName
    def set_GlobalServiceName(self, GlobalServiceName): self.GlobalServiceName = GlobalServiceName
    def get_LocalServiceTypeName(self): return self.LocalServiceTypeName
    def set_LocalServiceTypeName(self, LocalServiceTypeName): self.LocalServiceTypeName = LocalServiceTypeName
    def get_SOfferedCustAgreement(self): return self.SOfferedCustAgreement
    def set_SOfferedCustAgreement(self, SOfferedCustAgreement): self.SOfferedCustAgreement = SOfferedCustAgreement
    def get_ChargeCodeType(self): return self.ChargeCodeType
    def set_ChargeCodeType(self, ChargeCodeType): self.ChargeCodeType = ChargeCodeType
    def get_InsPrmRateInPercentage(self): return self.InsPrmRateInPercentage
    def set_InsPrmRateInPercentage(self, InsPrmRateInPercentage): self.InsPrmRateInPercentage = InsPrmRateInPercentage
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_ChargeValue(self): return self.ChargeValue
    def set_ChargeValue(self, ChargeValue): self.ChargeValue = ChargeValue
    def get_ChargeTaxAmount(self): return self.ChargeTaxAmount
    def set_ChargeTaxAmount(self, ChargeTaxAmount): self.ChargeTaxAmount = ChargeTaxAmount
    def get_ChargeTaxRate(self): return self.ChargeTaxRate
    def set_ChargeTaxRate(self, ChargeTaxRate): self.ChargeTaxRate = ChargeTaxRate
    def add_ChargeTaxRate(self, value): self.ChargeTaxRate.append(value)
    def insert_ChargeTaxRate_at(self, index, value): self.ChargeTaxRate.insert(index, value)
    def replace_ChargeTaxRate_at(self, index, value): self.ChargeTaxRate[index] = value
    def get_ChargeTaxAmountDet(self): return self.ChargeTaxAmountDet
    def set_ChargeTaxAmountDet(self, ChargeTaxAmountDet): self.ChargeTaxAmountDet = ChargeTaxAmountDet
    def add_ChargeTaxAmountDet(self, value): self.ChargeTaxAmountDet.append(value)
    def insert_ChargeTaxAmountDet_at(self, index, value): self.ChargeTaxAmountDet.insert(index, value)
    def replace_ChargeTaxAmountDet_at(self, index, value): self.ChargeTaxAmountDet[index] = value
    def get_QtdSExtrChrgInAdCur(self): return self.QtdSExtrChrgInAdCur
    def set_QtdSExtrChrgInAdCur(self, QtdSExtrChrgInAdCur): self.QtdSExtrChrgInAdCur = QtdSExtrChrgInAdCur
    def add_QtdSExtrChrgInAdCur(self, value): self.QtdSExtrChrgInAdCur.append(value)
    def insert_QtdSExtrChrgInAdCur_at(self, index, value): self.QtdSExtrChrgInAdCur.insert(index, value)
    def replace_QtdSExtrChrgInAdCur_at(self, index, value): self.QtdSExtrChrgInAdCur[index] = value
    def validate_SpecialServiceTypeType(self, value):
        # Validate type SpecialServiceTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SpecialServiceTypeType' % {"value" : value.encode("utf-8")} )
    def validate_LocalServiceTypeType(self, value):
        # Validate type LocalServiceTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LocalServiceTypeType' % {"value" : value.encode("utf-8")} )
    def validate_InsPrmRateInPercentageType(self, value):
        # Validate type InsPrmRateInPercentageType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 8:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on InsPrmRateInPercentageType' % {"value" : value} )
    def validate_CurrencyCodeType(self, value):
        # Validate type CurrencyCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType' % {"value" : value.encode("utf-8")} )
    def validate_ChargeValueType(self, value):
        # Validate type ChargeValueType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeValueType' % {"value" : value} )
    def validate_ChargeTaxAmountType(self, value):
        # Validate type ChargeTaxAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeTaxAmountType' % {"value" : value} )
    def validate_ChargeTaxRateType(self, value):
        # Validate type ChargeTaxRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeTaxRateType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.SpecialServiceType is not None or
            self.LocalServiceType is not None or
            self.GlobalServiceName is not None or
            self.LocalServiceTypeName is not None or
            self.SOfferedCustAgreement is not None or
            self.ChargeCodeType is not None or
            self.InsPrmRateInPercentage is not None or
            self.CurrencyCode is not None or
            self.ChargeValue is not None or
            self.ChargeTaxAmount is not None or
            self.ChargeTaxRate or
            self.ChargeTaxAmountDet or
            self.QtdSExtrChrgInAdCur
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdShpExChrgType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdShpExChrgType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdShpExChrgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdShpExChrgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdShpExChrgType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdShpExChrgType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecialServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SpecialServiceType>%s</SpecialServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialServiceType), input_name='SpecialServiceType')), eol_))
        if self.LocalServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceType>%s</LocalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceType), input_name='LocalServiceType')), eol_))
        if self.GlobalServiceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceName>%s</GlobalServiceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceName), input_name='GlobalServiceName')), eol_))
        if self.LocalServiceTypeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceTypeName>%s</LocalServiceTypeName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceTypeName), input_name='LocalServiceTypeName')), eol_))
        if self.SOfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SOfferedCustAgreement>%s</SOfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SOfferedCustAgreement), input_name='SOfferedCustAgreement')), eol_))
        if self.ChargeCodeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeCodeType>%s</ChargeCodeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeCodeType), input_name='ChargeCodeType')), eol_))
        if self.InsPrmRateInPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<InsPrmRateInPercentage>%s</InsPrmRateInPercentage>%s' % (self.gds_format_float(self.InsPrmRateInPercentage, input_name='InsPrmRateInPercentage'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.ChargeValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeValue>%s</ChargeValue>%s' % (self.gds_format_float(self.ChargeValue, input_name='ChargeValue'), eol_))
        if self.ChargeTaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeTaxAmount>%s</ChargeTaxAmount>%s' % (self.gds_format_float(self.ChargeTaxAmount, input_name='ChargeTaxAmount'), eol_))
        for ChargeTaxRate_ in self.ChargeTaxRate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeTaxRate>%s</ChargeTaxRate>%s' % (self.gds_format_float(ChargeTaxRate_, input_name='ChargeTaxRate'), eol_))
        for ChargeTaxAmountDet_ in self.ChargeTaxAmountDet:
            ChargeTaxAmountDet_.export(outfile, level, namespace_, name_='ChargeTaxAmountDet', pretty_print=pretty_print)
        for QtdSExtrChrgInAdCur_ in self.QtdSExtrChrgInAdCur:
            QtdSExtrChrgInAdCur_.export(outfile, level, namespace_, name_='QtdSExtrChrgInAdCur', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialServiceType':
            SpecialServiceType_ = child_.text
            SpecialServiceType_ = self.gds_validate_string(SpecialServiceType_, node, 'SpecialServiceType')
            self.SpecialServiceType = SpecialServiceType_
            # validate type SpecialServiceTypeType
            self.validate_SpecialServiceTypeType(self.SpecialServiceType)
        elif nodeName_ == 'LocalServiceType':
            LocalServiceType_ = child_.text
            LocalServiceType_ = self.gds_validate_string(LocalServiceType_, node, 'LocalServiceType')
            self.LocalServiceType = LocalServiceType_
            # validate type LocalServiceTypeType
            self.validate_LocalServiceTypeType(self.LocalServiceType)
        elif nodeName_ == 'GlobalServiceName':
            GlobalServiceName_ = child_.text
            GlobalServiceName_ = self.gds_validate_string(GlobalServiceName_, node, 'GlobalServiceName')
            self.GlobalServiceName = GlobalServiceName_
        elif nodeName_ == 'LocalServiceTypeName':
            LocalServiceTypeName_ = child_.text
            LocalServiceTypeName_ = self.gds_validate_string(LocalServiceTypeName_, node, 'LocalServiceTypeName')
            self.LocalServiceTypeName = LocalServiceTypeName_
        elif nodeName_ == 'SOfferedCustAgreement':
            SOfferedCustAgreement_ = child_.text
            SOfferedCustAgreement_ = self.gds_validate_string(SOfferedCustAgreement_, node, 'SOfferedCustAgreement')
            self.SOfferedCustAgreement = SOfferedCustAgreement_
        elif nodeName_ == 'ChargeCodeType':
            ChargeCodeType_ = child_.text
            ChargeCodeType_ = self.gds_validate_string(ChargeCodeType_, node, 'ChargeCodeType')
            self.ChargeCodeType = ChargeCodeType_
        elif nodeName_ == 'InsPrmRateInPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'InsPrmRateInPercentage')
            self.InsPrmRateInPercentage = fval_
            # validate type InsPrmRateInPercentageType
            self.validate_InsPrmRateInPercentageType(self.InsPrmRateInPercentage)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType
            self.validate_CurrencyCodeType(self.CurrencyCode)
        elif nodeName_ == 'ChargeValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeValue')
            self.ChargeValue = fval_
            # validate type ChargeValueType
            self.validate_ChargeValueType(self.ChargeValue)
        elif nodeName_ == 'ChargeTaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeTaxAmount')
            self.ChargeTaxAmount = fval_
            # validate type ChargeTaxAmountType
            self.validate_ChargeTaxAmountType(self.ChargeTaxAmount)
        elif nodeName_ == 'ChargeTaxRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeTaxRate')
            self.ChargeTaxRate.append(fval_)
            # validate type ChargeTaxRateType
            self.validate_ChargeTaxRateType(self.ChargeTaxRate[-1])
        elif nodeName_ == 'ChargeTaxAmountDet':
            obj_ = ChargeTaxAmountDetType.factory()
            obj_.build(child_)
            self.ChargeTaxAmountDet.append(obj_)
            obj_.original_tagname_ = 'ChargeTaxAmountDet'
        elif nodeName_ == 'QtdSExtrChrgInAdCur':
            obj_ = QtdSExtrChrgInAdCurType.factory()
            obj_.build(child_)
            self.QtdSExtrChrgInAdCur.append(obj_)
            obj_.original_tagname_ = 'QtdSExtrChrgInAdCur'
# end class QtdShpExChrgType


class WeightChargeTaxDetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxTypeRate=None, TaxTypeCode=None, WeightChargeTax=None, BaseAmt=None):
        self.original_tagname_ = None
        self.TaxTypeRate = TaxTypeRate
        self.validate_TaxTypeRateType(self.TaxTypeRate)
        self.TaxTypeCode = TaxTypeCode
        self.validate_TaxTypeCodeType(self.TaxTypeCode)
        self.WeightChargeTax = WeightChargeTax
        self.validate_WeightChargeTaxType(self.WeightChargeTax)
        self.BaseAmt = BaseAmt
        self.validate_BaseAmtType(self.BaseAmt)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightChargeTaxDetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightChargeTaxDetType.subclass:
            return WeightChargeTaxDetType.subclass(*args_, **kwargs_)
        else:
            return WeightChargeTaxDetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxTypeRate(self): return self.TaxTypeRate
    def set_TaxTypeRate(self, TaxTypeRate): self.TaxTypeRate = TaxTypeRate
    def get_TaxTypeCode(self): return self.TaxTypeCode
    def set_TaxTypeCode(self, TaxTypeCode): self.TaxTypeCode = TaxTypeCode
    def get_WeightChargeTax(self): return self.WeightChargeTax
    def set_WeightChargeTax(self, WeightChargeTax): self.WeightChargeTax = WeightChargeTax
    def get_BaseAmt(self): return self.BaseAmt
    def set_BaseAmt(self, BaseAmt): self.BaseAmt = BaseAmt
    def validate_TaxTypeRateType(self, value):
        # Validate type TaxTypeRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 8:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TaxTypeRateType' % {"value" : value} )
    def validate_TaxTypeCodeType(self, value):
        # Validate type TaxTypeCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TaxTypeCodeType' % {"value" : value.encode("utf-8")} )
    def validate_WeightChargeTaxType(self, value):
        # Validate type WeightChargeTaxType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeTaxType' % {"value" : value} )
    def validate_BaseAmtType(self, value):
        # Validate type BaseAmtType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseAmtType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TaxTypeRate is not None or
            self.TaxTypeCode is not None or
            self.WeightChargeTax is not None or
            self.BaseAmt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeightChargeTaxDetType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightChargeTaxDetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightChargeTaxDetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeightChargeTaxDetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeightChargeTaxDetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeightChargeTaxDetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxTypeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxTypeRate>%s</TaxTypeRate>%s' % (self.gds_format_float(self.TaxTypeRate, input_name='TaxTypeRate'), eol_))
        if self.TaxTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxTypeCode>%s</TaxTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxTypeCode), input_name='TaxTypeCode')), eol_))
        if self.WeightChargeTax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightChargeTax>%s</WeightChargeTax>%s' % (self.gds_format_float(self.WeightChargeTax, input_name='WeightChargeTax'), eol_))
        if self.BaseAmt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BaseAmt>%s</BaseAmt>%s' % (self.gds_format_float(self.BaseAmt, input_name='BaseAmt'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxTypeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TaxTypeRate')
            self.TaxTypeRate = fval_
            # validate type TaxTypeRateType
            self.validate_TaxTypeRateType(self.TaxTypeRate)
        elif nodeName_ == 'TaxTypeCode':
            TaxTypeCode_ = child_.text
            TaxTypeCode_ = self.gds_validate_string(TaxTypeCode_, node, 'TaxTypeCode')
            self.TaxTypeCode = TaxTypeCode_
            # validate type TaxTypeCodeType
            self.validate_TaxTypeCodeType(self.TaxTypeCode)
        elif nodeName_ == 'WeightChargeTax':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightChargeTax')
            self.WeightChargeTax = fval_
            # validate type WeightChargeTaxType
            self.validate_WeightChargeTaxType(self.WeightChargeTax)
        elif nodeName_ == 'BaseAmt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BaseAmt')
            self.BaseAmt = fval_
            # validate type BaseAmtType
            self.validate_BaseAmtType(self.BaseAmt)
# end class WeightChargeTaxDetType


class ChargeTaxAmountDetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxTypeRate=None, TaxTypeCode=None, TaxAmount=None, BaseAmount=None):
        self.original_tagname_ = None
        self.TaxTypeRate = TaxTypeRate
        self.validate_TaxTypeRateType4(self.TaxTypeRate)
        self.TaxTypeCode = TaxTypeCode
        self.validate_TaxTypeCodeType5(self.TaxTypeCode)
        self.TaxAmount = TaxAmount
        self.validate_TaxAmountType(self.TaxAmount)
        self.BaseAmount = BaseAmount
        self.validate_BaseAmountType(self.BaseAmount)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChargeTaxAmountDetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChargeTaxAmountDetType.subclass:
            return ChargeTaxAmountDetType.subclass(*args_, **kwargs_)
        else:
            return ChargeTaxAmountDetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxTypeRate(self): return self.TaxTypeRate
    def set_TaxTypeRate(self, TaxTypeRate): self.TaxTypeRate = TaxTypeRate
    def get_TaxTypeCode(self): return self.TaxTypeCode
    def set_TaxTypeCode(self, TaxTypeCode): self.TaxTypeCode = TaxTypeCode
    def get_TaxAmount(self): return self.TaxAmount
    def set_TaxAmount(self, TaxAmount): self.TaxAmount = TaxAmount
    def get_BaseAmount(self): return self.BaseAmount
    def set_BaseAmount(self, BaseAmount): self.BaseAmount = BaseAmount
    def validate_TaxTypeRateType4(self, value):
        # Validate type TaxTypeRateType4, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 8:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TaxTypeRateType4' % {"value" : value} )
    def validate_TaxTypeCodeType5(self, value):
        # Validate type TaxTypeCodeType5, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TaxTypeCodeType5' % {"value" : value.encode("utf-8")} )
    def validate_TaxAmountType(self, value):
        # Validate type TaxAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TaxAmountType' % {"value" : value} )
    def validate_BaseAmountType(self, value):
        # Validate type BaseAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseAmountType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TaxTypeRate is not None or
            self.TaxTypeCode is not None or
            self.TaxAmount is not None or
            self.BaseAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChargeTaxAmountDetType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChargeTaxAmountDetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChargeTaxAmountDetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChargeTaxAmountDetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChargeTaxAmountDetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChargeTaxAmountDetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxTypeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxTypeRate>%s</TaxTypeRate>%s' % (self.gds_format_float(self.TaxTypeRate, input_name='TaxTypeRate'), eol_))
        if self.TaxTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxTypeCode>%s</TaxTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxTypeCode), input_name='TaxTypeCode')), eol_))
        if self.TaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxAmount>%s</TaxAmount>%s' % (self.gds_format_float(self.TaxAmount, input_name='TaxAmount'), eol_))
        if self.BaseAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BaseAmount>%s</BaseAmount>%s' % (self.gds_format_float(self.BaseAmount, input_name='BaseAmount'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxTypeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TaxTypeRate')
            self.TaxTypeRate = fval_
            # validate type TaxTypeRateType4
            self.validate_TaxTypeRateType4(self.TaxTypeRate)
        elif nodeName_ == 'TaxTypeCode':
            TaxTypeCode_ = child_.text
            TaxTypeCode_ = self.gds_validate_string(TaxTypeCode_, node, 'TaxTypeCode')
            self.TaxTypeCode = TaxTypeCode_
            # validate type TaxTypeCodeType5
            self.validate_TaxTypeCodeType5(self.TaxTypeCode)
        elif nodeName_ == 'TaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TaxAmount')
            self.TaxAmount = fval_
            # validate type TaxAmountType
            self.validate_TaxAmountType(self.TaxAmount)
        elif nodeName_ == 'BaseAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BaseAmount')
            self.BaseAmount = fval_
            # validate type BaseAmountType
            self.validate_BaseAmountType(self.BaseAmount)
# end class ChargeTaxAmountDetType


class QtdSInAdCurType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomsValue=None, ExchangeRate=None, CurrencyCode=None, CurrencyRoleTypeCode=None, WeightCharge=None, TotalAmount=None, TotalTaxAmount=None, WeightChargeTax=None, WeightChargeTaxDet=None):
        self.original_tagname_ = None
        self.CustomsValue = CustomsValue
        self.validate_CustomsValueType(self.CustomsValue)
        self.ExchangeRate = ExchangeRate
        self.validate_ExchangeRateType(self.ExchangeRate)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType6(self.CurrencyCode)
        self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
        self.validate_CurrencyRoleTypeCodeType(self.CurrencyRoleTypeCode)
        self.WeightCharge = WeightCharge
        self.validate_WeightChargeType(self.WeightCharge)
        self.TotalAmount = TotalAmount
        self.validate_TotalAmountType(self.TotalAmount)
        self.TotalTaxAmount = TotalTaxAmount
        self.validate_TotalTaxAmountType(self.TotalTaxAmount)
        self.WeightChargeTax = WeightChargeTax
        self.validate_WeightChargeTaxType7(self.WeightChargeTax)
        if WeightChargeTaxDet is None:
            self.WeightChargeTaxDet = []
        else:
            self.WeightChargeTaxDet = WeightChargeTaxDet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdSInAdCurType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdSInAdCurType.subclass:
            return QtdSInAdCurType.subclass(*args_, **kwargs_)
        else:
            return QtdSInAdCurType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomsValue(self): return self.CustomsValue
    def set_CustomsValue(self, CustomsValue): self.CustomsValue = CustomsValue
    def get_ExchangeRate(self): return self.ExchangeRate
    def set_ExchangeRate(self, ExchangeRate): self.ExchangeRate = ExchangeRate
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_CurrencyRoleTypeCode(self): return self.CurrencyRoleTypeCode
    def set_CurrencyRoleTypeCode(self, CurrencyRoleTypeCode): self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
    def get_WeightCharge(self): return self.WeightCharge
    def set_WeightCharge(self, WeightCharge): self.WeightCharge = WeightCharge
    def get_TotalAmount(self): return self.TotalAmount
    def set_TotalAmount(self, TotalAmount): self.TotalAmount = TotalAmount
    def get_TotalTaxAmount(self): return self.TotalTaxAmount
    def set_TotalTaxAmount(self, TotalTaxAmount): self.TotalTaxAmount = TotalTaxAmount
    def get_WeightChargeTax(self): return self.WeightChargeTax
    def set_WeightChargeTax(self, WeightChargeTax): self.WeightChargeTax = WeightChargeTax
    def get_WeightChargeTaxDet(self): return self.WeightChargeTaxDet
    def set_WeightChargeTaxDet(self, WeightChargeTaxDet): self.WeightChargeTaxDet = WeightChargeTaxDet
    def add_WeightChargeTaxDet(self, value): self.WeightChargeTaxDet.append(value)
    def insert_WeightChargeTaxDet_at(self, index, value): self.WeightChargeTaxDet.insert(index, value)
    def replace_WeightChargeTaxDet_at(self, index, value): self.WeightChargeTaxDet[index] = value
    def validate_CustomsValueType(self, value):
        # Validate type CustomsValueType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on CustomsValueType' % {"value" : value} )
    def validate_ExchangeRateType(self, value):
        # Validate type ExchangeRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ExchangeRateType' % {"value" : value} )
    def validate_CurrencyCodeType6(self, value):
        # Validate type CurrencyCodeType6, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType6' % {"value" : value.encode("utf-8")} )
    def validate_CurrencyRoleTypeCodeType(self, value):
        # Validate type CurrencyRoleTypeCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 5:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyRoleTypeCodeType' % {"value" : value.encode("utf-8")} )
    def validate_WeightChargeType(self, value):
        # Validate type WeightChargeType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeType' % {"value" : value} )
    def validate_TotalAmountType(self, value):
        # Validate type TotalAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TotalAmountType' % {"value" : value} )
    def validate_TotalTaxAmountType(self, value):
        # Validate type TotalTaxAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TotalTaxAmountType' % {"value" : value} )
    def validate_WeightChargeTaxType7(self, value):
        # Validate type WeightChargeTaxType7, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeTaxType7' % {"value" : value} )
    def hasContent_(self):
        if (
            self.CustomsValue is not None or
            self.ExchangeRate is not None or
            self.CurrencyCode is not None or
            self.CurrencyRoleTypeCode is not None or
            self.WeightCharge is not None or
            self.TotalAmount is not None or
            self.TotalTaxAmount is not None or
            self.WeightChargeTax is not None or
            self.WeightChargeTaxDet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdSInAdCurType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdSInAdCurType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdSInAdCurType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdSInAdCurType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdSInAdCurType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdSInAdCurType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomsValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CustomsValue>%s</CustomsValue>%s' % (self.gds_format_float(self.CustomsValue, input_name='CustomsValue'), eol_))
        if self.ExchangeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ExchangeRate>%s</ExchangeRate>%s' % (self.gds_format_float(self.ExchangeRate, input_name='ExchangeRate'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.CurrencyRoleTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyRoleTypeCode>%s</CurrencyRoleTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyRoleTypeCode), input_name='CurrencyRoleTypeCode')), eol_))
        if self.WeightCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightCharge>%s</WeightCharge>%s' % (self.gds_format_float(self.WeightCharge, input_name='WeightCharge'), eol_))
        if self.TotalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalAmount>%s</TotalAmount>%s' % (self.gds_format_float(self.TotalAmount, input_name='TotalAmount'), eol_))
        if self.TotalTaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalTaxAmount>%s</TotalTaxAmount>%s' % (self.gds_format_float(self.TotalTaxAmount, input_name='TotalTaxAmount'), eol_))
        if self.WeightChargeTax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightChargeTax>%s</WeightChargeTax>%s' % (self.gds_format_float(self.WeightChargeTax, input_name='WeightChargeTax'), eol_))
        for WeightChargeTaxDet_ in self.WeightChargeTaxDet:
            WeightChargeTaxDet_.export(outfile, level, namespace_, name_='WeightChargeTaxDet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomsValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CustomsValue')
            self.CustomsValue = fval_
            # validate type CustomsValueType
            self.validate_CustomsValueType(self.CustomsValue)
        elif nodeName_ == 'ExchangeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ExchangeRate')
            self.ExchangeRate = fval_
            # validate type ExchangeRateType
            self.validate_ExchangeRateType(self.ExchangeRate)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType6
            self.validate_CurrencyCodeType6(self.CurrencyCode)
        elif nodeName_ == 'CurrencyRoleTypeCode':
            CurrencyRoleTypeCode_ = child_.text
            CurrencyRoleTypeCode_ = self.gds_validate_string(CurrencyRoleTypeCode_, node, 'CurrencyRoleTypeCode')
            self.CurrencyRoleTypeCode = CurrencyRoleTypeCode_
            # validate type CurrencyRoleTypeCodeType
            self.validate_CurrencyRoleTypeCodeType(self.CurrencyRoleTypeCode)
        elif nodeName_ == 'WeightCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightCharge')
            self.WeightCharge = fval_
            # validate type WeightChargeType
            self.validate_WeightChargeType(self.WeightCharge)
        elif nodeName_ == 'TotalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TotalAmount')
            self.TotalAmount = fval_
            # validate type TotalAmountType
            self.validate_TotalAmountType(self.TotalAmount)
        elif nodeName_ == 'TotalTaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TotalTaxAmount')
            self.TotalTaxAmount = fval_
            # validate type TotalTaxAmountType
            self.validate_TotalTaxAmountType(self.TotalTaxAmount)
        elif nodeName_ == 'WeightChargeTax':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightChargeTax')
            self.WeightChargeTax = fval_
            # validate type WeightChargeTaxType7
            self.validate_WeightChargeTaxType7(self.WeightChargeTax)
        elif nodeName_ == 'WeightChargeTaxDet':
            obj_ = WeightChargeTaxDetType.factory()
            obj_.build(child_)
            self.WeightChargeTaxDet.append(obj_)
            obj_.original_tagname_ = 'WeightChargeTaxDet'
# end class QtdSInAdCurType


class QtdSExtrChrgInAdCurType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChargeValue=None, ChargeExchangeRate=None, ChargeTaxAmount=None, CurrencyCode=None, CurrencyRoleTypeCode=None, ChargeTaxAmountDet=None):
        self.original_tagname_ = None
        self.ChargeValue = ChargeValue
        self.validate_ChargeValueType8(self.ChargeValue)
        self.ChargeExchangeRate = ChargeExchangeRate
        self.validate_ChargeExchangeRateType(self.ChargeExchangeRate)
        self.ChargeTaxAmount = ChargeTaxAmount
        self.validate_ChargeTaxAmountType9(self.ChargeTaxAmount)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType10(self.CurrencyCode)
        self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
        self.validate_CurrencyRoleTypeCodeType11(self.CurrencyRoleTypeCode)
        if ChargeTaxAmountDet is None:
            self.ChargeTaxAmountDet = []
        else:
            self.ChargeTaxAmountDet = ChargeTaxAmountDet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdSExtrChrgInAdCurType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdSExtrChrgInAdCurType.subclass:
            return QtdSExtrChrgInAdCurType.subclass(*args_, **kwargs_)
        else:
            return QtdSExtrChrgInAdCurType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChargeValue(self): return self.ChargeValue
    def set_ChargeValue(self, ChargeValue): self.ChargeValue = ChargeValue
    def get_ChargeExchangeRate(self): return self.ChargeExchangeRate
    def set_ChargeExchangeRate(self, ChargeExchangeRate): self.ChargeExchangeRate = ChargeExchangeRate
    def get_ChargeTaxAmount(self): return self.ChargeTaxAmount
    def set_ChargeTaxAmount(self, ChargeTaxAmount): self.ChargeTaxAmount = ChargeTaxAmount
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_CurrencyRoleTypeCode(self): return self.CurrencyRoleTypeCode
    def set_CurrencyRoleTypeCode(self, CurrencyRoleTypeCode): self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
    def get_ChargeTaxAmountDet(self): return self.ChargeTaxAmountDet
    def set_ChargeTaxAmountDet(self, ChargeTaxAmountDet): self.ChargeTaxAmountDet = ChargeTaxAmountDet
    def add_ChargeTaxAmountDet(self, value): self.ChargeTaxAmountDet.append(value)
    def insert_ChargeTaxAmountDet_at(self, index, value): self.ChargeTaxAmountDet.insert(index, value)
    def replace_ChargeTaxAmountDet_at(self, index, value): self.ChargeTaxAmountDet[index] = value
    def validate_ChargeValueType8(self, value):
        # Validate type ChargeValueType8, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeValueType8' % {"value" : value} )
    def validate_ChargeExchangeRateType(self, value):
        # Validate type ChargeExchangeRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeExchangeRateType' % {"value" : value} )
    def validate_ChargeTaxAmountType9(self, value):
        # Validate type ChargeTaxAmountType9, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeTaxAmountType9' % {"value" : value} )
    def validate_CurrencyCodeType10(self, value):
        # Validate type CurrencyCodeType10, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType10' % {"value" : value.encode("utf-8")} )
    def validate_CurrencyRoleTypeCodeType11(self, value):
        # Validate type CurrencyRoleTypeCodeType11, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 5:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyRoleTypeCodeType11' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ChargeValue is not None or
            self.ChargeExchangeRate is not None or
            self.ChargeTaxAmount is not None or
            self.CurrencyCode is not None or
            self.CurrencyRoleTypeCode is not None or
            self.ChargeTaxAmountDet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdSExtrChrgInAdCurType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdSExtrChrgInAdCurType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdSExtrChrgInAdCurType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdSExtrChrgInAdCurType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdSExtrChrgInAdCurType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdSExtrChrgInAdCurType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChargeValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeValue>%s</ChargeValue>%s' % (self.gds_format_float(self.ChargeValue, input_name='ChargeValue'), eol_))
        if self.ChargeExchangeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeExchangeRate>%s</ChargeExchangeRate>%s' % (self.gds_format_float(self.ChargeExchangeRate, input_name='ChargeExchangeRate'), eol_))
        if self.ChargeTaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeTaxAmount>%s</ChargeTaxAmount>%s' % (self.gds_format_float(self.ChargeTaxAmount, input_name='ChargeTaxAmount'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.CurrencyRoleTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyRoleTypeCode>%s</CurrencyRoleTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyRoleTypeCode), input_name='CurrencyRoleTypeCode')), eol_))
        for ChargeTaxAmountDet_ in self.ChargeTaxAmountDet:
            ChargeTaxAmountDet_.export(outfile, level, namespace_, name_='ChargeTaxAmountDet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChargeValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeValue')
            self.ChargeValue = fval_
            # validate type ChargeValueType8
            self.validate_ChargeValueType8(self.ChargeValue)
        elif nodeName_ == 'ChargeExchangeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeExchangeRate')
            self.ChargeExchangeRate = fval_
            # validate type ChargeExchangeRateType
            self.validate_ChargeExchangeRateType(self.ChargeExchangeRate)
        elif nodeName_ == 'ChargeTaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeTaxAmount')
            self.ChargeTaxAmount = fval_
            # validate type ChargeTaxAmountType9
            self.validate_ChargeTaxAmountType9(self.ChargeTaxAmount)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType10
            self.validate_CurrencyCodeType10(self.CurrencyCode)
        elif nodeName_ == 'CurrencyRoleTypeCode':
            CurrencyRoleTypeCode_ = child_.text
            CurrencyRoleTypeCode_ = self.gds_validate_string(CurrencyRoleTypeCode_, node, 'CurrencyRoleTypeCode')
            self.CurrencyRoleTypeCode = CurrencyRoleTypeCode_
            # validate type CurrencyRoleTypeCodeType11
            self.validate_CurrencyRoleTypeCodeType11(self.CurrencyRoleTypeCode)
        elif nodeName_ == 'ChargeTaxAmountDet':
            obj_ = ChargeTaxAmountDetType.factory()
            obj_.build(child_)
            self.ChargeTaxAmountDet.append(obj_)
            obj_.original_tagname_ = 'ChargeTaxAmountDet'
# end class QtdSExtrChrgInAdCurType


class QtdShpType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OriginServiceArea=None, DestinationServiceArea=None, GlobalProductCode=None, LocalProductCode=None, ProductShortName=None, LocalProductName=None, NetworkTypeCode=None, POfferedCustAgreement=None, TransInd=None, PickupDate=None, PickupCutoffTime=None, BookingTime=None, CurrencyCode=None, ExchangeRate=None, WeightCharge=None, WeightChargeTax=None, weightChargeTaxRate=None, TotalTransitDays=None, PickupPostalLocAddDays=None, DeliveryPostalLocAddDays=None, DeliveryTime=None, DeliveryTimeGMTOffset=None, DimensionalWeight=None, WeightUnit=None, PickupDayOfWeekNum=None, DestinationDayOfWeekNum=None, QuotedWeight=None, QuotedWeightUOM=None, QtdShpExChrg=None, PricingDate=None, ShippingCharge=None, TotalTaxAmount=None, TotalDiscount=None, WeightChargeTaxDet=None, PickupWindowEarliestTime=None, PickupWindowLatestTime=None, BookingCutoffOffset=None, DeliveryDate=None, PickupLeadTime=None, PickupCloseTime=None, WeightChargeDisc=None, QtdShpExChrgDisc=None):
        self.original_tagname_ = None
        self.OriginServiceArea = OriginServiceArea
        self.DestinationServiceArea = DestinationServiceArea
        self.GlobalProductCode = GlobalProductCode
        self.validate_GlobalProductCodeType(self.GlobalProductCode)
        self.LocalProductCode = LocalProductCode
        self.validate_LocalProductCodeType(self.LocalProductCode)
        self.ProductShortName = ProductShortName
        self.LocalProductName = LocalProductName
        self.NetworkTypeCode = NetworkTypeCode
        self.POfferedCustAgreement = POfferedCustAgreement
        self.TransInd = TransInd
        if isinstance(PickupDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PickupDate, '%Y-%m-%d').date()
        else:
            initvalue_ = PickupDate
        self.PickupDate = initvalue_
        self.PickupCutoffTime = PickupCutoffTime
        self.BookingTime = BookingTime
        self.validate_BookingTimeType(self.BookingTime)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType12(self.CurrencyCode)
        self.ExchangeRate = ExchangeRate
        self.validate_ExchangeRateType13(self.ExchangeRate)
        self.WeightCharge = WeightCharge
        self.validate_WeightChargeType14(self.WeightCharge)
        self.WeightChargeTax = WeightChargeTax
        self.validate_WeightChargeTaxType15(self.WeightChargeTax)
        self.weightChargeTaxRate = weightChargeTaxRate
        self.validate_weightChargeTaxRateType(self.weightChargeTaxRate)
        self.TotalTransitDays = TotalTransitDays
        self.validate_TotalTransitDaysType(self.TotalTransitDays)
        self.PickupPostalLocAddDays = PickupPostalLocAddDays
        self.validate_PickupPostalLocAddDaysType(self.PickupPostalLocAddDays)
        self.DeliveryPostalLocAddDays = DeliveryPostalLocAddDays
        self.validate_DeliveryPostalLocAddDaysType(self.DeliveryPostalLocAddDays)
        self.DeliveryTime = DeliveryTime
        self.validate_DeliveryTimeType(self.DeliveryTime)
        self.DeliveryTimeGMTOffset = DeliveryTimeGMTOffset
        self.validate_DeliveryTimeGMTOffsetType(self.DeliveryTimeGMTOffset)
        self.DimensionalWeight = DimensionalWeight
        self.validate_DimensionalWeightType(self.DimensionalWeight)
        self.WeightUnit = WeightUnit
        self.validate_WeightUnitType(self.WeightUnit)
        self.PickupDayOfWeekNum = PickupDayOfWeekNum
        self.validate_PickupDayOfWeekNumType(self.PickupDayOfWeekNum)
        self.DestinationDayOfWeekNum = DestinationDayOfWeekNum
        self.validate_DestinationDayOfWeekNumType(self.DestinationDayOfWeekNum)
        self.QuotedWeight = QuotedWeight
        self.validate_QuotedWeight(self.QuotedWeight)
        self.QuotedWeightUOM = QuotedWeightUOM
        self.validate_QuotedWeightUOM(self.QuotedWeightUOM)
        if QtdShpExChrg is None:
            self.QtdShpExChrg = []
        else:
            self.QtdShpExChrg = QtdShpExChrg
        if isinstance(PricingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PricingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = PricingDate
        self.PricingDate = initvalue_
        self.ShippingCharge = ShippingCharge
        self.validate_ShippingChargeType(self.ShippingCharge)
        self.TotalTaxAmount = TotalTaxAmount
        self.validate_TotalTaxAmountType16(self.TotalTaxAmount)
        self.TotalDiscount = TotalDiscount
        self.validate_TotalDiscountType17(self.TotalDiscount)
        if WeightChargeTaxDet is None:
            self.WeightChargeTaxDet = []
        else:
            self.WeightChargeTaxDet = WeightChargeTaxDet
        self.PickupWindowEarliestTime = PickupWindowEarliestTime
        self.validate_PickupWindowEarliestTimeType(self.PickupWindowEarliestTime)
        self.PickupWindowLatestTime = PickupWindowLatestTime
        self.validate_PickupWindowLatestTimeType(self.PickupWindowLatestTime)
        self.BookingCutoffOffset = BookingCutoffOffset
        self.validate_BookingCutoffOffsetType(self.BookingCutoffOffset)
        if DeliveryDate is None:
            self.DeliveryDate = []
        else:
            self.DeliveryDate = DeliveryDate
        self.PickupLeadTime = PickupLeadTime
        self.validate_PickupLeadTimeType(self.PickupLeadTime)
        self.PickupCloseTime = PickupCloseTime
        self.validate_PickupCloseTimeType(self.PickupCloseTime)
        if WeightChargeDisc is None:
            self.WeightChargeDisc = []
        else:
            self.WeightChargeDisc = WeightChargeDisc
        if QtdShpExChrgDisc is None:
            self.QtdShpExChrgDisc = []
        else:
            self.QtdShpExChrgDisc = QtdShpExChrgDisc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdShpType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdShpType.subclass:
            return QtdShpType.subclass(*args_, **kwargs_)
        else:
            return QtdShpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OriginServiceArea(self): return self.OriginServiceArea
    def set_OriginServiceArea(self, OriginServiceArea): self.OriginServiceArea = OriginServiceArea
    def get_DestinationServiceArea(self): return self.DestinationServiceArea
    def set_DestinationServiceArea(self, DestinationServiceArea): self.DestinationServiceArea = DestinationServiceArea
    def get_GlobalProductCode(self): return self.GlobalProductCode
    def set_GlobalProductCode(self, GlobalProductCode): self.GlobalProductCode = GlobalProductCode
    def get_LocalProductCode(self): return self.LocalProductCode
    def set_LocalProductCode(self, LocalProductCode): self.LocalProductCode = LocalProductCode
    def get_ProductShortName(self): return self.ProductShortName
    def set_ProductShortName(self, ProductShortName): self.ProductShortName = ProductShortName
    def get_LocalProductName(self): return self.LocalProductName
    def set_LocalProductName(self, LocalProductName): self.LocalProductName = LocalProductName
    def get_NetworkTypeCode(self): return self.NetworkTypeCode
    def set_NetworkTypeCode(self, NetworkTypeCode): self.NetworkTypeCode = NetworkTypeCode
    def get_POfferedCustAgreement(self): return self.POfferedCustAgreement
    def set_POfferedCustAgreement(self, POfferedCustAgreement): self.POfferedCustAgreement = POfferedCustAgreement
    def get_TransInd(self): return self.TransInd
    def set_TransInd(self, TransInd): self.TransInd = TransInd
    def get_PickupDate(self): return self.PickupDate
    def set_PickupDate(self, PickupDate): self.PickupDate = PickupDate
    def get_PickupCutoffTime(self): return self.PickupCutoffTime
    def set_PickupCutoffTime(self, PickupCutoffTime): self.PickupCutoffTime = PickupCutoffTime
    def get_BookingTime(self): return self.BookingTime
    def set_BookingTime(self, BookingTime): self.BookingTime = BookingTime
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_ExchangeRate(self): return self.ExchangeRate
    def set_ExchangeRate(self, ExchangeRate): self.ExchangeRate = ExchangeRate
    def get_WeightCharge(self): return self.WeightCharge
    def set_WeightCharge(self, WeightCharge): self.WeightCharge = WeightCharge
    def get_WeightChargeTax(self): return self.WeightChargeTax
    def set_WeightChargeTax(self, WeightChargeTax): self.WeightChargeTax = WeightChargeTax
    def get_weightChargeTaxRate(self): return self.weightChargeTaxRate
    def set_weightChargeTaxRate(self, weightChargeTaxRate): self.weightChargeTaxRate = weightChargeTaxRate
    def get_TotalTransitDays(self): return self.TotalTransitDays
    def set_TotalTransitDays(self, TotalTransitDays): self.TotalTransitDays = TotalTransitDays
    def get_PickupPostalLocAddDays(self): return self.PickupPostalLocAddDays
    def set_PickupPostalLocAddDays(self, PickupPostalLocAddDays): self.PickupPostalLocAddDays = PickupPostalLocAddDays
    def get_DeliveryPostalLocAddDays(self): return self.DeliveryPostalLocAddDays
    def set_DeliveryPostalLocAddDays(self, DeliveryPostalLocAddDays): self.DeliveryPostalLocAddDays = DeliveryPostalLocAddDays
    def get_DeliveryTime(self): return self.DeliveryTime
    def set_DeliveryTime(self, DeliveryTime): self.DeliveryTime = DeliveryTime
    def get_DeliveryTimeGMTOffset(self): return self.DeliveryTimeGMTOffset
    def set_DeliveryTimeGMTOffset(self, DeliveryTimeGMTOffset): self.DeliveryTimeGMTOffset = DeliveryTimeGMTOffset
    def get_DimensionalWeight(self): return self.DimensionalWeight
    def set_DimensionalWeight(self, DimensionalWeight): self.DimensionalWeight = DimensionalWeight
    def get_WeightUnit(self): return self.WeightUnit
    def set_WeightUnit(self, WeightUnit): self.WeightUnit = WeightUnit
    def get_PickupDayOfWeekNum(self): return self.PickupDayOfWeekNum
    def set_PickupDayOfWeekNum(self, PickupDayOfWeekNum): self.PickupDayOfWeekNum = PickupDayOfWeekNum
    def get_DestinationDayOfWeekNum(self): return self.DestinationDayOfWeekNum
    def set_DestinationDayOfWeekNum(self, DestinationDayOfWeekNum): self.DestinationDayOfWeekNum = DestinationDayOfWeekNum
    def get_QuotedWeight(self): return self.QuotedWeight
    def set_QuotedWeight(self, QuotedWeight): self.QuotedWeight = QuotedWeight
    def get_QuotedWeightUOM(self): return self.QuotedWeightUOM
    def set_QuotedWeightUOM(self, QuotedWeightUOM): self.QuotedWeightUOM = QuotedWeightUOM
    def get_QtdShpExChrg(self): return self.QtdShpExChrg
    def set_QtdShpExChrg(self, QtdShpExChrg): self.QtdShpExChrg = QtdShpExChrg
    def add_QtdShpExChrg(self, value): self.QtdShpExChrg.append(value)
    def insert_QtdShpExChrg_at(self, index, value): self.QtdShpExChrg.insert(index, value)
    def replace_QtdShpExChrg_at(self, index, value): self.QtdShpExChrg[index] = value
    def get_PricingDate(self): return self.PricingDate
    def set_PricingDate(self, PricingDate): self.PricingDate = PricingDate
    def get_ShippingCharge(self): return self.ShippingCharge
    def set_ShippingCharge(self, ShippingCharge): self.ShippingCharge = ShippingCharge
    def get_TotalTaxAmount(self): return self.TotalTaxAmount
    def set_TotalTaxAmount(self, TotalTaxAmount): self.TotalTaxAmount = TotalTaxAmount
    def get_TotalDiscount(self): return self.TotalDiscount
    def set_TotalDiscount(self, TotalDiscount): self.TotalDiscount = TotalDiscount
    def get_WeightChargeTaxDet(self): return self.WeightChargeTaxDet
    def set_WeightChargeTaxDet(self, WeightChargeTaxDet): self.WeightChargeTaxDet = WeightChargeTaxDet
    def add_WeightChargeTaxDet(self, value): self.WeightChargeTaxDet.append(value)
    def insert_WeightChargeTaxDet_at(self, index, value): self.WeightChargeTaxDet.insert(index, value)
    def replace_WeightChargeTaxDet_at(self, index, value): self.WeightChargeTaxDet[index] = value
    def get_PickupWindowEarliestTime(self): return self.PickupWindowEarliestTime
    def set_PickupWindowEarliestTime(self, PickupWindowEarliestTime): self.PickupWindowEarliestTime = PickupWindowEarliestTime
    def get_PickupWindowLatestTime(self): return self.PickupWindowLatestTime
    def set_PickupWindowLatestTime(self, PickupWindowLatestTime): self.PickupWindowLatestTime = PickupWindowLatestTime
    def get_BookingCutoffOffset(self): return self.BookingCutoffOffset
    def set_BookingCutoffOffset(self, BookingCutoffOffset): self.BookingCutoffOffset = BookingCutoffOffset
    def get_DeliveryDate(self): return self.DeliveryDate
    def set_DeliveryDate(self, DeliveryDate): self.DeliveryDate = DeliveryDate
    def add_DeliveryDate(self, value): self.DeliveryDate.append(value)
    def insert_DeliveryDate_at(self, index, value): self.DeliveryDate.insert(index, value)
    def replace_DeliveryDate_at(self, index, value): self.DeliveryDate[index] = value
    def get_PickupLeadTime(self): return self.PickupLeadTime
    def set_PickupLeadTime(self, PickupLeadTime): self.PickupLeadTime = PickupLeadTime
    def get_PickupCloseTime(self): return self.PickupCloseTime
    def set_PickupCloseTime(self, PickupCloseTime): self.PickupCloseTime = PickupCloseTime
    def get_WeightChargeDisc(self): return self.WeightChargeDisc
    def set_WeightChargeDisc(self, WeightChargeDisc): self.WeightChargeDisc = WeightChargeDisc
    def add_WeightChargeDisc(self, value): self.WeightChargeDisc.append(value)
    def insert_WeightChargeDisc_at(self, index, value): self.WeightChargeDisc.insert(index, value)
    def replace_WeightChargeDisc_at(self, index, value): self.WeightChargeDisc[index] = value
    def get_QtdShpExChrgDisc(self): return self.QtdShpExChrgDisc
    def set_QtdShpExChrgDisc(self, QtdShpExChrgDisc): self.QtdShpExChrgDisc = QtdShpExChrgDisc
    def add_QtdShpExChrgDisc(self, value): self.QtdShpExChrgDisc.append(value)
    def insert_QtdShpExChrgDisc_at(self, index, value): self.QtdShpExChrgDisc.insert(index, value)
    def replace_QtdShpExChrgDisc_at(self, index, value): self.QtdShpExChrgDisc[index] = value
    def validate_GlobalProductCodeType(self, value):
        # Validate type GlobalProductCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on GlobalProductCodeType' % {"value" : value.encode("utf-8")} )
    def validate_LocalProductCodeType(self, value):
        # Validate type LocalProductCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LocalProductCodeType' % {"value" : value.encode("utf-8")} )
    def validate_PickupDateType(self, value):
        # Validate type PickupDateType, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_BookingTimeType(self, value):
        # Validate type BookingTimeType, a restriction on xsd:duration.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_CurrencyCodeType12(self, value):
        # Validate type CurrencyCodeType12, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType12' % {"value" : value.encode("utf-8")} )
    def validate_ExchangeRateType13(self, value):
        # Validate type ExchangeRateType13, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ExchangeRateType13' % {"value" : value} )
    def validate_WeightChargeType14(self, value):
        # Validate type WeightChargeType14, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeType14' % {"value" : value} )
    def validate_WeightChargeTaxType15(self, value):
        # Validate type WeightChargeTaxType15, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeTaxType15' % {"value" : value} )
    def validate_weightChargeTaxRateType(self, value):
        # Validate type weightChargeTaxRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on weightChargeTaxRateType' % {"value" : value} )
    def validate_TotalTransitDaysType(self, value):
        # Validate type TotalTransitDaysType, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PickupPostalLocAddDaysType(self, value):
        # Validate type PickupPostalLocAddDaysType, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DeliveryPostalLocAddDaysType(self, value):
        # Validate type DeliveryPostalLocAddDaysType, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DeliveryTimeType(self, value):
        # Validate type DeliveryTimeType, a restriction on xsd:duration.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DeliveryTimeGMTOffsetType(self, value):
        # Validate type DeliveryTimeGMTOffsetType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DeliveryTimeGMTOffsetType' % {"value" : value.encode("utf-8")} )
    def validate_DimensionalWeightType(self, value):
        # Validate type DimensionalWeightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DimensionalWeightType' % {"value" : value} )
    def validate_WeightUnitType(self, value):
        # Validate type WeightUnitType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on WeightUnitType' % {"value" : value.encode("utf-8")} )
    def validate_PickupDayOfWeekNumType(self, value):
        # Validate type PickupDayOfWeekNumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PickupDayOfWeekNumType' % {"value" : value.encode("utf-8")} )
    def validate_DestinationDayOfWeekNumType(self, value):
        # Validate type DestinationDayOfWeekNumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DestinationDayOfWeekNumType' % {"value" : value.encode("utf-8")} )
    def validate_QuotedWeight(self, value):
        # Validate type QuotedWeight, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on QuotedWeight' % {"value" : value} )
            if value > 999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on QuotedWeight' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on QuotedWeight' % {"value" : value} )
    def validate_QuotedWeightUOM(self, value):
        # Validate type QuotedWeightUOM, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['KG', 'Lbs']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuotedWeightUOM' % {"value" : value.encode("utf-8")} )
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on QuotedWeightUOM' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuotedWeightUOM' % {"value" : value.encode("utf-8")} )
    def validate_PricingDateType(self, value):
        # Validate type PricingDateType, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ShippingChargeType(self, value):
        # Validate type ShippingChargeType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ShippingChargeType' % {"value" : value} )
    def validate_TotalTaxAmountType16(self, value):
        # Validate type TotalTaxAmountType16, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TotalTaxAmountType16' % {"value" : value} )
    def validate_TotalDiscountType17(self, value):
        # Validate type TotalDiscountType17, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TotalDiscountType17' % {"value" : value} )
    def validate_PickupWindowEarliestTimeType(self, value):
        # Validate type PickupWindowEarliestTimeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PickupWindowLatestTimeType(self, value):
        # Validate type PickupWindowLatestTimeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_BookingCutoffOffsetType(self, value):
        # Validate type BookingCutoffOffsetType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PickupLeadTimeType(self, value):
        # Validate type PickupLeadTimeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PickupLeadTimeType' % {"value" : value.encode("utf-8")} )
    def validate_PickupCloseTimeType(self, value):
        # Validate type PickupCloseTimeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PickupCloseTimeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OriginServiceArea is not None or
            self.DestinationServiceArea is not None or
            self.GlobalProductCode is not None or
            self.LocalProductCode is not None or
            self.ProductShortName is not None or
            self.LocalProductName is not None or
            self.NetworkTypeCode is not None or
            self.POfferedCustAgreement is not None or
            self.TransInd is not None or
            self.PickupDate is not None or
            self.PickupCutoffTime is not None or
            self.BookingTime is not None or
            self.CurrencyCode is not None or
            self.ExchangeRate is not None or
            self.WeightCharge is not None or
            self.WeightChargeTax is not None or
            self.weightChargeTaxRate is not None or
            self.TotalTransitDays is not None or
            self.PickupPostalLocAddDays is not None or
            self.DeliveryPostalLocAddDays is not None or
            self.DeliveryTime is not None or
            self.DeliveryTimeGMTOffset is not None or
            self.DimensionalWeight is not None or
            self.WeightUnit is not None or
            self.PickupDayOfWeekNum is not None or
            self.DestinationDayOfWeekNum is not None or
            self.QuotedWeight is not None or
            self.QuotedWeightUOM is not None or
            self.QtdShpExChrg or
            self.PricingDate is not None or
            self.ShippingCharge is not None or
            self.TotalTaxAmount is not None or
            self.TotalDiscount is not None or
            self.WeightChargeTaxDet or
            self.PickupWindowEarliestTime is not None or
            self.PickupWindowLatestTime is not None or
            self.BookingCutoffOffset is not None or
            self.DeliveryDate or
            self.PickupLeadTime is not None or
            self.PickupCloseTime is not None or
            self.WeightChargeDisc or
            self.QtdShpExChrgDisc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdShpType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdShpType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdShpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdShpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdShpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdShpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OriginServiceArea is not None:
            self.OriginServiceArea.export(outfile, level, namespace_, name_='OriginServiceArea', pretty_print=pretty_print)
        if self.DestinationServiceArea is not None:
            self.DestinationServiceArea.export(outfile, level, namespace_, name_='DestinationServiceArea', pretty_print=pretty_print)
        if self.GlobalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalProductCode>%s</GlobalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalProductCode), input_name='GlobalProductCode')), eol_))
        if self.LocalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductCode>%s</LocalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductCode), input_name='LocalProductCode')), eol_))
        if self.ProductShortName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ProductShortName>%s</ProductShortName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProductShortName), input_name='ProductShortName')), eol_))
        if self.LocalProductName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductName>%s</LocalProductName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductName), input_name='LocalProductName')), eol_))
        if self.NetworkTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NetworkTypeCode>%s</NetworkTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NetworkTypeCode), input_name='NetworkTypeCode')), eol_))
        if self.POfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<POfferedCustAgreement>%s</POfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.POfferedCustAgreement), input_name='POfferedCustAgreement')), eol_))
        if self.TransInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TransInd>%s</TransInd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransInd), input_name='TransInd')), eol_))
        if self.PickupDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupDate>%s</PickupDate>%s' % (self.gds_format_date(self.PickupDate, input_name='PickupDate'), eol_))
        if self.PickupCutoffTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupCutoffTime>%s</PickupCutoffTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupCutoffTime), input_name='PickupCutoffTime')), eol_))
        if self.BookingTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BookingTime>%s</BookingTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BookingTime), input_name='BookingTime')), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.ExchangeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ExchangeRate>%s</ExchangeRate>%s' % (self.gds_format_float(self.ExchangeRate, input_name='ExchangeRate'), eol_))
        if self.WeightCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightCharge>%s</WeightCharge>%s' % (self.gds_format_float(self.WeightCharge, input_name='WeightCharge'), eol_))
        if self.WeightChargeTax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightChargeTax>%s</WeightChargeTax>%s' % (self.gds_format_float(self.WeightChargeTax, input_name='WeightChargeTax'), eol_))
        if self.weightChargeTaxRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<weightChargeTaxRate>%s</weightChargeTaxRate>%s' % (self.gds_format_float(self.weightChargeTaxRate, input_name='weightChargeTaxRate'), eol_))
        if self.TotalTransitDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalTransitDays>%s</TotalTransitDays>%s' % (self.gds_format_integer(self.TotalTransitDays, input_name='TotalTransitDays'), eol_))
        if self.PickupPostalLocAddDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupPostalLocAddDays>%s</PickupPostalLocAddDays>%s' % (self.gds_format_integer(self.PickupPostalLocAddDays, input_name='PickupPostalLocAddDays'), eol_))
        if self.DeliveryPostalLocAddDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryPostalLocAddDays>%s</DeliveryPostalLocAddDays>%s' % (self.gds_format_integer(self.DeliveryPostalLocAddDays, input_name='DeliveryPostalLocAddDays'), eol_))
        if self.DeliveryTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryTime>%s</DeliveryTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryTime), input_name='DeliveryTime')), eol_))
        if self.DeliveryTimeGMTOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryTimeGMTOffset>%s</DeliveryTimeGMTOffset>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryTimeGMTOffset), input_name='DeliveryTimeGMTOffset')), eol_))
        if self.DimensionalWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DimensionalWeight>%s</DimensionalWeight>%s' % (self.gds_format_float(self.DimensionalWeight, input_name='DimensionalWeight'), eol_))
        if self.WeightUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightUnit>%s</WeightUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeightUnit), input_name='WeightUnit')), eol_))
        if self.PickupDayOfWeekNum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupDayOfWeekNum>%s</PickupDayOfWeekNum>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupDayOfWeekNum), input_name='PickupDayOfWeekNum')), eol_))
        if self.DestinationDayOfWeekNum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DestinationDayOfWeekNum>%s</DestinationDayOfWeekNum>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationDayOfWeekNum), input_name='DestinationDayOfWeekNum')), eol_))
        if self.QuotedWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<QuotedWeight>%s</QuotedWeight>%s' % (self.gds_format_float(self.QuotedWeight, input_name='QuotedWeight'), eol_))
        if self.QuotedWeightUOM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<QuotedWeightUOM>%s</QuotedWeightUOM>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.QuotedWeightUOM), input_name='QuotedWeightUOM')), eol_))
        for QtdShpExChrg_ in self.QtdShpExChrg:
            QtdShpExChrg_.export(outfile, level, namespace_, name_='QtdShpExChrg', pretty_print=pretty_print)
        if self.PricingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PricingDate>%s</PricingDate>%s' % (self.gds_format_date(self.PricingDate, input_name='PricingDate'), eol_))
        if self.ShippingCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShippingCharge>%s</ShippingCharge>%s' % (self.gds_format_float(self.ShippingCharge, input_name='ShippingCharge'), eol_))
        if self.TotalTaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalTaxAmount>%s</TotalTaxAmount>%s' % (self.gds_format_float(self.TotalTaxAmount, input_name='TotalTaxAmount'), eol_))
        if self.TotalDiscount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalDiscount>%s</TotalDiscount>%s' % (self.gds_format_float(self.TotalDiscount, input_name='TotalDiscount'), eol_))
        for WeightChargeTaxDet_ in self.WeightChargeTaxDet:
            WeightChargeTaxDet_.export(outfile, level, namespace_, name_='WeightChargeTaxDet', pretty_print=pretty_print)
        if self.PickupWindowEarliestTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupWindowEarliestTime>%s</PickupWindowEarliestTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupWindowEarliestTime), input_name='PickupWindowEarliestTime')), eol_))
        if self.PickupWindowLatestTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupWindowLatestTime>%s</PickupWindowLatestTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupWindowLatestTime), input_name='PickupWindowLatestTime')), eol_))
        if self.BookingCutoffOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BookingCutoffOffset>%s</BookingCutoffOffset>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BookingCutoffOffset), input_name='BookingCutoffOffset')), eol_))
        for DeliveryDate_ in self.DeliveryDate:
            DeliveryDate_.export(outfile, level, namespace_, name_='DeliveryDate', pretty_print=pretty_print)
        if self.PickupLeadTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupLeadTime>%s</PickupLeadTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupLeadTime), input_name='PickupLeadTime')), eol_))
        if self.PickupCloseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupCloseTime>%s</PickupCloseTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupCloseTime), input_name='PickupCloseTime')), eol_))
        for WeightChargeDisc_ in self.WeightChargeDisc:
            WeightChargeDisc_.export(outfile, level, namespace_, name_='WeightChargeDisc', pretty_print=pretty_print)
        for QtdShpExChrgDisc_ in self.QtdShpExChrgDisc:
            QtdShpExChrgDisc_.export(outfile, level, namespace_, name_='QtdShpExChrgDisc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OriginServiceArea':
            obj_ = OrgnSvcAreaType.factory()
            obj_.build(child_)
            self.OriginServiceArea = obj_
            obj_.original_tagname_ = 'OriginServiceArea'
        elif nodeName_ == 'DestinationServiceArea':
            obj_ = DestSvcAreaType.factory()
            obj_.build(child_)
            self.DestinationServiceArea = obj_
            obj_.original_tagname_ = 'DestinationServiceArea'
        elif nodeName_ == 'GlobalProductCode':
            GlobalProductCode_ = child_.text
            GlobalProductCode_ = self.gds_validate_string(GlobalProductCode_, node, 'GlobalProductCode')
            self.GlobalProductCode = GlobalProductCode_
            # validate type GlobalProductCodeType
            self.validate_GlobalProductCodeType(self.GlobalProductCode)
        elif nodeName_ == 'LocalProductCode':
            LocalProductCode_ = child_.text
            LocalProductCode_ = self.gds_validate_string(LocalProductCode_, node, 'LocalProductCode')
            self.LocalProductCode = LocalProductCode_
            # validate type LocalProductCodeType
            self.validate_LocalProductCodeType(self.LocalProductCode)
        elif nodeName_ == 'ProductShortName':
            ProductShortName_ = child_.text
            ProductShortName_ = self.gds_validate_string(ProductShortName_, node, 'ProductShortName')
            self.ProductShortName = ProductShortName_
        elif nodeName_ == 'LocalProductName':
            LocalProductName_ = child_.text
            LocalProductName_ = self.gds_validate_string(LocalProductName_, node, 'LocalProductName')
            self.LocalProductName = LocalProductName_
        elif nodeName_ == 'NetworkTypeCode':
            NetworkTypeCode_ = child_.text
            NetworkTypeCode_ = self.gds_validate_string(NetworkTypeCode_, node, 'NetworkTypeCode')
            self.NetworkTypeCode = NetworkTypeCode_
        elif nodeName_ == 'POfferedCustAgreement':
            POfferedCustAgreement_ = child_.text
            POfferedCustAgreement_ = self.gds_validate_string(POfferedCustAgreement_, node, 'POfferedCustAgreement')
            self.POfferedCustAgreement = POfferedCustAgreement_
        elif nodeName_ == 'TransInd':
            TransInd_ = child_.text
            TransInd_ = self.gds_validate_string(TransInd_, node, 'TransInd')
            self.TransInd = TransInd_
        elif nodeName_ == 'PickupDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PickupDate = dval_
            # validate type PickupDateType
            self.validate_PickupDateType(self.PickupDate)
        elif nodeName_ == 'PickupCutoffTime':
            PickupCutoffTime_ = child_.text
            PickupCutoffTime_ = self.gds_validate_string(PickupCutoffTime_, node, 'PickupCutoffTime')
            self.PickupCutoffTime = PickupCutoffTime_
        elif nodeName_ == 'BookingTime':
            BookingTime_ = child_.text
            BookingTime_ = self.gds_validate_string(BookingTime_, node, 'BookingTime')
            self.BookingTime = BookingTime_
            # validate type BookingTimeType
            self.validate_BookingTimeType(self.BookingTime)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType12
            self.validate_CurrencyCodeType12(self.CurrencyCode)
        elif nodeName_ == 'ExchangeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ExchangeRate')
            self.ExchangeRate = fval_
            # validate type ExchangeRateType13
            self.validate_ExchangeRateType13(self.ExchangeRate)
        elif nodeName_ == 'WeightCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightCharge')
            self.WeightCharge = fval_
            # validate type WeightChargeType14
            self.validate_WeightChargeType14(self.WeightCharge)
        elif nodeName_ == 'WeightChargeTax':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightChargeTax')
            self.WeightChargeTax = fval_
            # validate type WeightChargeTaxType15
            self.validate_WeightChargeTaxType15(self.WeightChargeTax)
        elif nodeName_ == 'weightChargeTaxRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'weightChargeTaxRate')
            self.weightChargeTaxRate = fval_
            # validate type weightChargeTaxRateType
            self.validate_weightChargeTaxRateType(self.weightChargeTaxRate)
        elif nodeName_ == 'TotalTransitDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TotalTransitDays')
            self.TotalTransitDays = ival_
            # validate type TotalTransitDaysType
            self.validate_TotalTransitDaysType(self.TotalTransitDays)
        elif nodeName_ == 'PickupPostalLocAddDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PickupPostalLocAddDays')
            self.PickupPostalLocAddDays = ival_
            # validate type PickupPostalLocAddDaysType
            self.validate_PickupPostalLocAddDaysType(self.PickupPostalLocAddDays)
        elif nodeName_ == 'DeliveryPostalLocAddDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DeliveryPostalLocAddDays')
            self.DeliveryPostalLocAddDays = ival_
            # validate type DeliveryPostalLocAddDaysType
            self.validate_DeliveryPostalLocAddDaysType(self.DeliveryPostalLocAddDays)
        elif nodeName_ == 'DeliveryTime':
            DeliveryTime_ = child_.text
            DeliveryTime_ = self.gds_validate_string(DeliveryTime_, node, 'DeliveryTime')
            self.DeliveryTime = DeliveryTime_
            # validate type DeliveryTimeType
            self.validate_DeliveryTimeType(self.DeliveryTime)
        elif nodeName_ == 'DeliveryTimeGMTOffset':
            DeliveryTimeGMTOffset_ = child_.text
            DeliveryTimeGMTOffset_ = self.gds_validate_string(DeliveryTimeGMTOffset_, node, 'DeliveryTimeGMTOffset')
            self.DeliveryTimeGMTOffset = DeliveryTimeGMTOffset_
            # validate type DeliveryTimeGMTOffsetType
            self.validate_DeliveryTimeGMTOffsetType(self.DeliveryTimeGMTOffset)
        elif nodeName_ == 'DimensionalWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DimensionalWeight')
            self.DimensionalWeight = fval_
            # validate type DimensionalWeightType
            self.validate_DimensionalWeightType(self.DimensionalWeight)
        elif nodeName_ == 'WeightUnit':
            WeightUnit_ = child_.text
            WeightUnit_ = self.gds_validate_string(WeightUnit_, node, 'WeightUnit')
            self.WeightUnit = WeightUnit_
            # validate type WeightUnitType
            self.validate_WeightUnitType(self.WeightUnit)
        elif nodeName_ == 'PickupDayOfWeekNum':
            PickupDayOfWeekNum_ = child_.text
            PickupDayOfWeekNum_ = self.gds_validate_string(PickupDayOfWeekNum_, node, 'PickupDayOfWeekNum')
            self.PickupDayOfWeekNum = PickupDayOfWeekNum_
            # validate type PickupDayOfWeekNumType
            self.validate_PickupDayOfWeekNumType(self.PickupDayOfWeekNum)
        elif nodeName_ == 'DestinationDayOfWeekNum':
            DestinationDayOfWeekNum_ = child_.text
            DestinationDayOfWeekNum_ = self.gds_validate_string(DestinationDayOfWeekNum_, node, 'DestinationDayOfWeekNum')
            self.DestinationDayOfWeekNum = DestinationDayOfWeekNum_
            # validate type DestinationDayOfWeekNumType
            self.validate_DestinationDayOfWeekNumType(self.DestinationDayOfWeekNum)
        elif nodeName_ == 'QuotedWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QuotedWeight')
            self.QuotedWeight = fval_
            # validate type QuotedWeight
            self.validate_QuotedWeight(self.QuotedWeight)
        elif nodeName_ == 'QuotedWeightUOM':
            QuotedWeightUOM_ = child_.text
            QuotedWeightUOM_ = self.gds_validate_string(QuotedWeightUOM_, node, 'QuotedWeightUOM')
            self.QuotedWeightUOM = QuotedWeightUOM_
            # validate type QuotedWeightUOM
            self.validate_QuotedWeightUOM(self.QuotedWeightUOM)
        elif nodeName_ == 'QtdShpExChrg':
            obj_ = QtdShpExChrgType.factory()
            obj_.build(child_)
            self.QtdShpExChrg.append(obj_)
            obj_.original_tagname_ = 'QtdShpExChrg'
        elif nodeName_ == 'PricingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PricingDate = dval_
            # validate type PricingDateType
            self.validate_PricingDateType(self.PricingDate)
        elif nodeName_ == 'ShippingCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ShippingCharge')
            self.ShippingCharge = fval_
            # validate type ShippingChargeType
            self.validate_ShippingChargeType(self.ShippingCharge)
        elif nodeName_ == 'TotalTaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TotalTaxAmount')
            self.TotalTaxAmount = fval_
            # validate type TotalTaxAmountType16
            self.validate_TotalTaxAmountType16(self.TotalTaxAmount)
        elif nodeName_ == 'TotalDiscount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TotalDiscount')
            self.TotalDiscount = fval_
            # validate type TotalDiscountType17
            self.validate_TotalDiscountType17(self.TotalDiscount)
        elif nodeName_ == 'WeightChargeTaxDet':
            obj_ = WeightChargeTaxDetType.factory()
            obj_.build(child_)
            self.WeightChargeTaxDet.append(obj_)
            obj_.original_tagname_ = 'WeightChargeTaxDet'
        elif nodeName_ == 'PickupWindowEarliestTime':
            PickupWindowEarliestTime_ = child_.text
            PickupWindowEarliestTime_ = self.gds_validate_string(PickupWindowEarliestTime_, node, 'PickupWindowEarliestTime')
            self.PickupWindowEarliestTime = PickupWindowEarliestTime_
            # validate type PickupWindowEarliestTimeType
            self.validate_PickupWindowEarliestTimeType(self.PickupWindowEarliestTime)
        elif nodeName_ == 'PickupWindowLatestTime':
            PickupWindowLatestTime_ = child_.text
            PickupWindowLatestTime_ = self.gds_validate_string(PickupWindowLatestTime_, node, 'PickupWindowLatestTime')
            self.PickupWindowLatestTime = PickupWindowLatestTime_
            # validate type PickupWindowLatestTimeType
            self.validate_PickupWindowLatestTimeType(self.PickupWindowLatestTime)
        elif nodeName_ == 'BookingCutoffOffset':
            BookingCutoffOffset_ = child_.text
            BookingCutoffOffset_ = self.gds_validate_string(BookingCutoffOffset_, node, 'BookingCutoffOffset')
            self.BookingCutoffOffset = BookingCutoffOffset_
            # validate type BookingCutoffOffsetType
            self.validate_BookingCutoffOffsetType(self.BookingCutoffOffset)
        elif nodeName_ == 'DeliveryDate':
            obj_ = DeliveryDate.factory()
            obj_.build(child_)
            self.DeliveryDate.append(obj_)
            obj_.original_tagname_ = 'DeliveryDate'
        elif nodeName_ == 'PickupLeadTime':
            PickupLeadTime_ = child_.text
            PickupLeadTime_ = self.gds_validate_string(PickupLeadTime_, node, 'PickupLeadTime')
            self.PickupLeadTime = PickupLeadTime_
            # validate type PickupLeadTimeType
            self.validate_PickupLeadTimeType(self.PickupLeadTime)
        elif nodeName_ == 'PickupCloseTime':
            PickupCloseTime_ = child_.text
            PickupCloseTime_ = self.gds_validate_string(PickupCloseTime_, node, 'PickupCloseTime')
            self.PickupCloseTime = PickupCloseTime_
            # validate type PickupCloseTimeType
            self.validate_PickupCloseTimeType(self.PickupCloseTime)
        elif nodeName_ == 'WeightChargeDisc':
            obj_ = WeightChargeDisc.factory()
            obj_.build(child_)
            self.WeightChargeDisc.append(obj_)
            obj_.original_tagname_ = 'WeightChargeDisc'
        elif nodeName_ == 'QtdShpExChrgDisc':
            obj_ = QtdShpExChrgDisc.factory()
            obj_.build(child_)
            self.QtdShpExChrgDisc.append(obj_)
            obj_.original_tagname_ = 'QtdShpExChrgDisc'
# end class QtdShpType


class MrkSrvType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LocalProductCode=None, LocalServiceType=None, ProductShortName=None, GlobalServiceName=None, LocalProductName=None, LocalServiceTypeName=None, ProductDesc=None, ServiceDesc=None, NetworkTypeCode=None, POfferedCustAgreement=None, SOfferedCustAgreement=None, TransInd=None, ChargeCodeType=None, MrkSrvInd=None, LocalProductCtryCd=None, LocalProductDesc=None, GlobalProductDesc=None, GlobalServiceType=None, BillingServiceIndicator=None, LocalServiceName=None):
        self.original_tagname_ = None
        self.LocalProductCode = LocalProductCode
        self.LocalServiceType = LocalServiceType
        self.ProductShortName = ProductShortName
        self.GlobalServiceName = GlobalServiceName
        self.LocalProductName = LocalProductName
        self.LocalServiceTypeName = LocalServiceTypeName
        self.ProductDesc = ProductDesc
        self.ServiceDesc = ServiceDesc
        self.NetworkTypeCode = NetworkTypeCode
        self.POfferedCustAgreement = POfferedCustAgreement
        self.SOfferedCustAgreement = SOfferedCustAgreement
        self.TransInd = TransInd
        if ChargeCodeType is None:
            self.ChargeCodeType = []
        else:
            self.ChargeCodeType = ChargeCodeType
        self.MrkSrvInd = MrkSrvInd
        self.validate_MrkSrvIndType(self.MrkSrvInd)
        self.LocalProductCtryCd = LocalProductCtryCd
        self.validate_LocalProductCtryCdType(self.LocalProductCtryCd)
        self.LocalProductDesc = LocalProductDesc
        self.GlobalProductDesc = GlobalProductDesc
        self.GlobalServiceType = GlobalServiceType
        self.BillingServiceIndicator = BillingServiceIndicator
        self.LocalServiceName = LocalServiceName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MrkSrvType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MrkSrvType.subclass:
            return MrkSrvType.subclass(*args_, **kwargs_)
        else:
            return MrkSrvType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocalProductCode(self): return self.LocalProductCode
    def set_LocalProductCode(self, LocalProductCode): self.LocalProductCode = LocalProductCode
    def get_LocalServiceType(self): return self.LocalServiceType
    def set_LocalServiceType(self, LocalServiceType): self.LocalServiceType = LocalServiceType
    def get_ProductShortName(self): return self.ProductShortName
    def set_ProductShortName(self, ProductShortName): self.ProductShortName = ProductShortName
    def get_GlobalServiceName(self): return self.GlobalServiceName
    def set_GlobalServiceName(self, GlobalServiceName): self.GlobalServiceName = GlobalServiceName
    def get_LocalProductName(self): return self.LocalProductName
    def set_LocalProductName(self, LocalProductName): self.LocalProductName = LocalProductName
    def get_LocalServiceTypeName(self): return self.LocalServiceTypeName
    def set_LocalServiceTypeName(self, LocalServiceTypeName): self.LocalServiceTypeName = LocalServiceTypeName
    def get_ProductDesc(self): return self.ProductDesc
    def set_ProductDesc(self, ProductDesc): self.ProductDesc = ProductDesc
    def get_ServiceDesc(self): return self.ServiceDesc
    def set_ServiceDesc(self, ServiceDesc): self.ServiceDesc = ServiceDesc
    def get_NetworkTypeCode(self): return self.NetworkTypeCode
    def set_NetworkTypeCode(self, NetworkTypeCode): self.NetworkTypeCode = NetworkTypeCode
    def get_POfferedCustAgreement(self): return self.POfferedCustAgreement
    def set_POfferedCustAgreement(self, POfferedCustAgreement): self.POfferedCustAgreement = POfferedCustAgreement
    def get_SOfferedCustAgreement(self): return self.SOfferedCustAgreement
    def set_SOfferedCustAgreement(self, SOfferedCustAgreement): self.SOfferedCustAgreement = SOfferedCustAgreement
    def get_TransInd(self): return self.TransInd
    def set_TransInd(self, TransInd): self.TransInd = TransInd
    def get_ChargeCodeType(self): return self.ChargeCodeType
    def set_ChargeCodeType(self, ChargeCodeType): self.ChargeCodeType = ChargeCodeType
    def add_ChargeCodeType(self, value): self.ChargeCodeType.append(value)
    def insert_ChargeCodeType_at(self, index, value): self.ChargeCodeType.insert(index, value)
    def replace_ChargeCodeType_at(self, index, value): self.ChargeCodeType[index] = value
    def get_MrkSrvInd(self): return self.MrkSrvInd
    def set_MrkSrvInd(self, MrkSrvInd): self.MrkSrvInd = MrkSrvInd
    def get_LocalProductCtryCd(self): return self.LocalProductCtryCd
    def set_LocalProductCtryCd(self, LocalProductCtryCd): self.LocalProductCtryCd = LocalProductCtryCd
    def get_LocalProductDesc(self): return self.LocalProductDesc
    def set_LocalProductDesc(self, LocalProductDesc): self.LocalProductDesc = LocalProductDesc
    def get_GlobalProductDesc(self): return self.GlobalProductDesc
    def set_GlobalProductDesc(self, GlobalProductDesc): self.GlobalProductDesc = GlobalProductDesc
    def get_GlobalServiceType(self): return self.GlobalServiceType
    def set_GlobalServiceType(self, GlobalServiceType): self.GlobalServiceType = GlobalServiceType
    def get_BillingServiceIndicator(self): return self.BillingServiceIndicator
    def set_BillingServiceIndicator(self, BillingServiceIndicator): self.BillingServiceIndicator = BillingServiceIndicator
    def get_LocalServiceName(self): return self.LocalServiceName
    def set_LocalServiceName(self, LocalServiceName): self.LocalServiceName = LocalServiceName
    def validate_MrkSrvIndType(self, value):
        # Validate type MrkSrvIndType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on MrkSrvIndType' % {"value" : value.encode("utf-8")} )
    def validate_LocalProductCtryCdType(self, value):
        # Validate type LocalProductCtryCdType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on LocalProductCtryCdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LocalProductCode is not None or
            self.LocalServiceType is not None or
            self.ProductShortName is not None or
            self.GlobalServiceName is not None or
            self.LocalProductName is not None or
            self.LocalServiceTypeName is not None or
            self.ProductDesc is not None or
            self.ServiceDesc is not None or
            self.NetworkTypeCode is not None or
            self.POfferedCustAgreement is not None or
            self.SOfferedCustAgreement is not None or
            self.TransInd is not None or
            self.ChargeCodeType or
            self.MrkSrvInd is not None or
            self.LocalProductCtryCd is not None or
            self.LocalProductDesc is not None or
            self.GlobalProductDesc is not None or
            self.GlobalServiceType is not None or
            self.BillingServiceIndicator is not None or
            self.LocalServiceName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MrkSrvType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MrkSrvType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MrkSrvType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MrkSrvType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MrkSrvType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MrkSrvType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductCode>%s</LocalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductCode), input_name='LocalProductCode')), eol_))
        if self.LocalServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceType>%s</LocalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceType), input_name='LocalServiceType')), eol_))
        if self.ProductShortName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ProductShortName>%s</ProductShortName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProductShortName), input_name='ProductShortName')), eol_))
        if self.GlobalServiceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceName>%s</GlobalServiceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceName), input_name='GlobalServiceName')), eol_))
        if self.LocalProductName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductName>%s</LocalProductName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductName), input_name='LocalProductName')), eol_))
        if self.LocalServiceTypeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceTypeName>%s</LocalServiceTypeName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceTypeName), input_name='LocalServiceTypeName')), eol_))
        if self.ProductDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ProductDesc>%s</ProductDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProductDesc), input_name='ProductDesc')), eol_))
        if self.ServiceDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ServiceDesc>%s</ServiceDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceDesc), input_name='ServiceDesc')), eol_))
        if self.NetworkTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NetworkTypeCode>%s</NetworkTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NetworkTypeCode), input_name='NetworkTypeCode')), eol_))
        if self.POfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<POfferedCustAgreement>%s</POfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.POfferedCustAgreement), input_name='POfferedCustAgreement')), eol_))
        if self.SOfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SOfferedCustAgreement>%s</SOfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SOfferedCustAgreement), input_name='SOfferedCustAgreement')), eol_))
        if self.TransInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TransInd>%s</TransInd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransInd), input_name='TransInd')), eol_))
        for ChargeCodeType_ in self.ChargeCodeType:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeCodeType>%s</ChargeCodeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(ChargeCodeType_), input_name='ChargeCodeType')), eol_))
        if self.MrkSrvInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MrkSrvInd>%s</MrkSrvInd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MrkSrvInd), input_name='MrkSrvInd')), eol_))
        if self.LocalProductCtryCd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductCtryCd>%s</LocalProductCtryCd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductCtryCd), input_name='LocalProductCtryCd')), eol_))
        if self.LocalProductDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductDesc>%s</LocalProductDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductDesc), input_name='LocalProductDesc')), eol_))
        if self.GlobalProductDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalProductDesc>%s</GlobalProductDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalProductDesc), input_name='GlobalProductDesc')), eol_))
        if self.GlobalServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceType>%s</GlobalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceType), input_name='GlobalServiceType')), eol_))
        if self.BillingServiceIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BillingServiceIndicator>%s</BillingServiceIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BillingServiceIndicator), input_name='BillingServiceIndicator')), eol_))
        if self.LocalServiceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceName>%s</LocalServiceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceName), input_name='LocalServiceName')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocalProductCode':
            LocalProductCode_ = child_.text
            LocalProductCode_ = self.gds_validate_string(LocalProductCode_, node, 'LocalProductCode')
            self.LocalProductCode = LocalProductCode_
        elif nodeName_ == 'LocalServiceType':
            LocalServiceType_ = child_.text
            LocalServiceType_ = self.gds_validate_string(LocalServiceType_, node, 'LocalServiceType')
            self.LocalServiceType = LocalServiceType_
        elif nodeName_ == 'ProductShortName':
            ProductShortName_ = child_.text
            ProductShortName_ = self.gds_validate_string(ProductShortName_, node, 'ProductShortName')
            self.ProductShortName = ProductShortName_
        elif nodeName_ == 'GlobalServiceName':
            GlobalServiceName_ = child_.text
            GlobalServiceName_ = self.gds_validate_string(GlobalServiceName_, node, 'GlobalServiceName')
            self.GlobalServiceName = GlobalServiceName_
        elif nodeName_ == 'LocalProductName':
            LocalProductName_ = child_.text
            LocalProductName_ = self.gds_validate_string(LocalProductName_, node, 'LocalProductName')
            self.LocalProductName = LocalProductName_
        elif nodeName_ == 'LocalServiceTypeName':
            LocalServiceTypeName_ = child_.text
            LocalServiceTypeName_ = self.gds_validate_string(LocalServiceTypeName_, node, 'LocalServiceTypeName')
            self.LocalServiceTypeName = LocalServiceTypeName_
        elif nodeName_ == 'ProductDesc':
            ProductDesc_ = child_.text
            ProductDesc_ = self.gds_validate_string(ProductDesc_, node, 'ProductDesc')
            self.ProductDesc = ProductDesc_
        elif nodeName_ == 'ServiceDesc':
            ServiceDesc_ = child_.text
            ServiceDesc_ = self.gds_validate_string(ServiceDesc_, node, 'ServiceDesc')
            self.ServiceDesc = ServiceDesc_
        elif nodeName_ == 'NetworkTypeCode':
            NetworkTypeCode_ = child_.text
            NetworkTypeCode_ = self.gds_validate_string(NetworkTypeCode_, node, 'NetworkTypeCode')
            self.NetworkTypeCode = NetworkTypeCode_
        elif nodeName_ == 'POfferedCustAgreement':
            POfferedCustAgreement_ = child_.text
            POfferedCustAgreement_ = self.gds_validate_string(POfferedCustAgreement_, node, 'POfferedCustAgreement')
            self.POfferedCustAgreement = POfferedCustAgreement_
        elif nodeName_ == 'SOfferedCustAgreement':
            SOfferedCustAgreement_ = child_.text
            SOfferedCustAgreement_ = self.gds_validate_string(SOfferedCustAgreement_, node, 'SOfferedCustAgreement')
            self.SOfferedCustAgreement = SOfferedCustAgreement_
        elif nodeName_ == 'TransInd':
            TransInd_ = child_.text
            TransInd_ = self.gds_validate_string(TransInd_, node, 'TransInd')
            self.TransInd = TransInd_
        elif nodeName_ == 'ChargeCodeType':
            ChargeCodeType_ = child_.text
            ChargeCodeType_ = self.gds_validate_string(ChargeCodeType_, node, 'ChargeCodeType')
            self.ChargeCodeType.append(ChargeCodeType_)
        elif nodeName_ == 'MrkSrvInd':
            MrkSrvInd_ = child_.text
            MrkSrvInd_ = self.gds_validate_string(MrkSrvInd_, node, 'MrkSrvInd')
            self.MrkSrvInd = MrkSrvInd_
            # validate type MrkSrvIndType
            self.validate_MrkSrvIndType(self.MrkSrvInd)
        elif nodeName_ == 'LocalProductCtryCd':
            LocalProductCtryCd_ = child_.text
            LocalProductCtryCd_ = self.gds_validate_string(LocalProductCtryCd_, node, 'LocalProductCtryCd')
            self.LocalProductCtryCd = LocalProductCtryCd_
            # validate type LocalProductCtryCdType
            self.validate_LocalProductCtryCdType(self.LocalProductCtryCd)
        elif nodeName_ == 'LocalProductDesc':
            LocalProductDesc_ = child_.text
            LocalProductDesc_ = self.gds_validate_string(LocalProductDesc_, node, 'LocalProductDesc')
            self.LocalProductDesc = LocalProductDesc_
        elif nodeName_ == 'GlobalProductDesc':
            GlobalProductDesc_ = child_.text
            GlobalProductDesc_ = self.gds_validate_string(GlobalProductDesc_, node, 'GlobalProductDesc')
            self.GlobalProductDesc = GlobalProductDesc_
        elif nodeName_ == 'GlobalServiceType':
            GlobalServiceType_ = child_.text
            GlobalServiceType_ = self.gds_validate_string(GlobalServiceType_, node, 'GlobalServiceType')
            self.GlobalServiceType = GlobalServiceType_
        elif nodeName_ == 'BillingServiceIndicator':
            BillingServiceIndicator_ = child_.text
            BillingServiceIndicator_ = self.gds_validate_string(BillingServiceIndicator_, node, 'BillingServiceIndicator')
            self.BillingServiceIndicator = BillingServiceIndicator_
        elif nodeName_ == 'LocalServiceName':
            LocalServiceName_ = child_.text
            LocalServiceName_ = self.gds_validate_string(LocalServiceName_, node, 'LocalServiceName')
            self.LocalServiceName = LocalServiceName_
# end class MrkSrvType


class ProdNtwrkType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NetworkTypeCode=None):
        self.original_tagname_ = None
        self.NetworkTypeCode = NetworkTypeCode
        self.validate_NetworkTypeCodeType(self.NetworkTypeCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProdNtwrkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProdNtwrkType.subclass:
            return ProdNtwrkType.subclass(*args_, **kwargs_)
        else:
            return ProdNtwrkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkTypeCode(self): return self.NetworkTypeCode
    def set_NetworkTypeCode(self, NetworkTypeCode): self.NetworkTypeCode = NetworkTypeCode
    def validate_NetworkTypeCodeType(self, value):
        # Validate type NetworkTypeCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on NetworkTypeCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NetworkTypeCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProdNtwrkType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProdNtwrkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProdNtwrkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProdNtwrkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProdNtwrkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProdNtwrkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetworkTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NetworkTypeCode>%s</NetworkTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NetworkTypeCode), input_name='NetworkTypeCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkTypeCode':
            NetworkTypeCode_ = child_.text
            NetworkTypeCode_ = self.gds_validate_string(NetworkTypeCode_, node, 'NetworkTypeCode')
            self.NetworkTypeCode = NetworkTypeCode_
            # validate type NetworkTypeCodeType
            self.validate_NetworkTypeCodeType(self.NetworkTypeCode)
# end class ProdNtwrkType


class SrvType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GlobalProductCode=None, MrkSrv=None, SBTP=None):
        self.original_tagname_ = None
        self.GlobalProductCode = GlobalProductCode
        if MrkSrv is None:
            self.MrkSrv = []
        else:
            self.MrkSrv = MrkSrv
        self.SBTP = SBTP
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SrvType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SrvType.subclass:
            return SrvType.subclass(*args_, **kwargs_)
        else:
            return SrvType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GlobalProductCode(self): return self.GlobalProductCode
    def set_GlobalProductCode(self, GlobalProductCode): self.GlobalProductCode = GlobalProductCode
    def get_MrkSrv(self): return self.MrkSrv
    def set_MrkSrv(self, MrkSrv): self.MrkSrv = MrkSrv
    def add_MrkSrv(self, value): self.MrkSrv.append(value)
    def insert_MrkSrv_at(self, index, value): self.MrkSrv.insert(index, value)
    def replace_MrkSrv_at(self, index, value): self.MrkSrv[index] = value
    def get_SBTP(self): return self.SBTP
    def set_SBTP(self, SBTP): self.SBTP = SBTP
    def hasContent_(self):
        if (
            self.GlobalProductCode is not None or
            self.MrkSrv or
            self.SBTP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SrvType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SrvType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SrvType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SrvType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SrvType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SrvType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GlobalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalProductCode>%s</GlobalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalProductCode), input_name='GlobalProductCode')), eol_))
        for MrkSrv_ in self.MrkSrv:
            MrkSrv_.export(outfile, level, namespace_, name_='MrkSrv', pretty_print=pretty_print)
        if self.SBTP is not None:
            self.SBTP.export(outfile, level, namespace_, name_='SBTP', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GlobalProductCode':
            GlobalProductCode_ = child_.text
            GlobalProductCode_ = self.gds_validate_string(GlobalProductCode_, node, 'GlobalProductCode')
            self.GlobalProductCode = GlobalProductCode_
        elif nodeName_ == 'MrkSrv':
            obj_ = MrkSrvType.factory()
            obj_.build(child_)
            self.MrkSrv.append(obj_)
            obj_.original_tagname_ = 'MrkSrv'
        elif nodeName_ == 'SBTP':
            obj_ = SBTPType.factory()
            obj_.build(child_)
            self.SBTP = obj_
            obj_.original_tagname_ = 'SBTP'
# end class SrvType


class SBTPType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Prod=None):
        self.original_tagname_ = None
        self.Prod = Prod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SBTPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SBTPType.subclass:
            return SBTPType.subclass(*args_, **kwargs_)
        else:
            return SBTPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Prod(self): return self.Prod
    def set_Prod(self, Prod): self.Prod = Prod
    def hasContent_(self):
        if (
            self.Prod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SBTPType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SBTPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SBTPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SBTPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SBTPType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SBTPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Prod is not None:
            self.Prod.export(outfile, level, namespace_, name_='Prod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Prod':
            obj_ = ProdType.factory()
            obj_.build(child_)
            self.Prod = obj_
            obj_.original_tagname_ = 'Prod'
# end class SBTPType


class DeliveryDate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeliveryType=None, DlvyDateTime=None, DeliveryDateTimeOffset=None):
        self.original_tagname_ = None
        self.DeliveryType = DeliveryType
        self.DlvyDateTime = DlvyDateTime
        self.DeliveryDateTimeOffset = DeliveryDateTimeOffset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryDate.subclass:
            return DeliveryDate.subclass(*args_, **kwargs_)
        else:
            return DeliveryDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeliveryType(self): return self.DeliveryType
    def set_DeliveryType(self, DeliveryType): self.DeliveryType = DeliveryType
    def get_DlvyDateTime(self): return self.DlvyDateTime
    def set_DlvyDateTime(self, DlvyDateTime): self.DlvyDateTime = DlvyDateTime
    def get_DeliveryDateTimeOffset(self): return self.DeliveryDateTimeOffset
    def set_DeliveryDateTimeOffset(self, DeliveryDateTimeOffset): self.DeliveryDateTimeOffset = DeliveryDateTimeOffset
    def hasContent_(self):
        if (
            self.DeliveryType is not None or
            self.DlvyDateTime is not None or
            self.DeliveryDateTimeOffset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeliveryDate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeliveryDate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeliveryDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeliveryDate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeliveryDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DeliveryType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryType>%s</DeliveryType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryType), input_name='DeliveryType')), eol_))
        if self.DlvyDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DlvyDateTime>%s</DlvyDateTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DlvyDateTime), input_name='DlvyDateTime')), eol_))
        if self.DeliveryDateTimeOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryDateTimeOffset>%s</DeliveryDateTimeOffset>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryDateTimeOffset), input_name='DeliveryDateTimeOffset')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DeliveryType':
            DeliveryType_ = child_.text
            DeliveryType_ = self.gds_validate_string(DeliveryType_, node, 'DeliveryType')
            self.DeliveryType = DeliveryType_
        elif nodeName_ == 'DlvyDateTime':
            DlvyDateTime_ = child_.text
            DlvyDateTime_ = self.gds_validate_string(DlvyDateTime_, node, 'DlvyDateTime')
            self.DlvyDateTime = DlvyDateTime_
        elif nodeName_ == 'DeliveryDateTimeOffset':
            DeliveryDateTimeOffset_ = child_.text
            DeliveryDateTimeOffset_ = self.gds_validate_string(DeliveryDateTimeOffset_, node, 'DeliveryDateTimeOffset')
            self.DeliveryDateTimeOffset = DeliveryDateTimeOffset_
# end class DeliveryDate


class WeightChargeDisc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DiscAmt=None, BaseAmount=None, CurrencyCode=None, DiscType=None, DiscPercentage=None):
        self.original_tagname_ = None
        self.DiscAmt = DiscAmt
        self.validate_DiscAmtType(self.DiscAmt)
        self.BaseAmount = BaseAmount
        self.validate_BaseAmountType18(self.BaseAmount)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType19(self.CurrencyCode)
        self.DiscType = DiscType
        self.validate_DiscTypeType(self.DiscType)
        self.DiscPercentage = DiscPercentage
        self.validate_DiscPercentageType(self.DiscPercentage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightChargeDisc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightChargeDisc.subclass:
            return WeightChargeDisc.subclass(*args_, **kwargs_)
        else:
            return WeightChargeDisc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DiscAmt(self): return self.DiscAmt
    def set_DiscAmt(self, DiscAmt): self.DiscAmt = DiscAmt
    def get_BaseAmount(self): return self.BaseAmount
    def set_BaseAmount(self, BaseAmount): self.BaseAmount = BaseAmount
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_DiscType(self): return self.DiscType
    def set_DiscType(self, DiscType): self.DiscType = DiscType
    def get_DiscPercentage(self): return self.DiscPercentage
    def set_DiscPercentage(self, DiscPercentage): self.DiscPercentage = DiscPercentage
    def validate_DiscAmtType(self, value):
        # Validate type DiscAmtType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DiscAmtType' % {"value" : value} )
    def validate_BaseAmountType18(self, value):
        # Validate type BaseAmountType18, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseAmountType18' % {"value" : value} )
    def validate_CurrencyCodeType19(self, value):
        # Validate type CurrencyCodeType19, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType19' % {"value" : value.encode("utf-8")} )
    def validate_DiscTypeType(self, value):
        # Validate type DiscTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DiscTypeType' % {"value" : value.encode("utf-8")} )
    def validate_DiscPercentageType(self, value):
        # Validate type DiscPercentageType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DiscPercentageType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DiscAmt is not None or
            self.BaseAmount is not None or
            self.CurrencyCode is not None or
            self.DiscType is not None or
            self.DiscPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeightChargeDisc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightChargeDisc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightChargeDisc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeightChargeDisc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeightChargeDisc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeightChargeDisc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DiscAmt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscAmt>%s</DiscAmt>%s' % (self.gds_format_float(self.DiscAmt, input_name='DiscAmt'), eol_))
        if self.BaseAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BaseAmount>%s</BaseAmount>%s' % (self.gds_format_float(self.BaseAmount, input_name='BaseAmount'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.DiscType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscType>%s</DiscType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DiscType), input_name='DiscType')), eol_))
        if self.DiscPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscPercentage>%s</DiscPercentage>%s' % (self.gds_format_float(self.DiscPercentage, input_name='DiscPercentage'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DiscAmt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DiscAmt')
            self.DiscAmt = fval_
            # validate type DiscAmtType
            self.validate_DiscAmtType(self.DiscAmt)
        elif nodeName_ == 'BaseAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BaseAmount')
            self.BaseAmount = fval_
            # validate type BaseAmountType18
            self.validate_BaseAmountType18(self.BaseAmount)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType19
            self.validate_CurrencyCodeType19(self.CurrencyCode)
        elif nodeName_ == 'DiscType':
            DiscType_ = child_.text
            DiscType_ = self.gds_validate_string(DiscType_, node, 'DiscType')
            self.DiscType = DiscType_
            # validate type DiscTypeType
            self.validate_DiscTypeType(self.DiscType)
        elif nodeName_ == 'DiscPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DiscPercentage')
            self.DiscPercentage = fval_
            # validate type DiscPercentageType
            self.validate_DiscPercentageType(self.DiscPercentage)
# end class WeightChargeDisc


class QtdShpExChrgDisc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DiscAmt=None, BaseAmt=None, CurrencyCode=None, CurrencyRoleTypeCode=None, DiscPercentage=None):
        self.original_tagname_ = None
        self.DiscAmt = DiscAmt
        self.validate_DiscAmtType20(self.DiscAmt)
        self.BaseAmt = BaseAmt
        self.validate_BaseAmtType21(self.BaseAmt)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType22(self.CurrencyCode)
        self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
        self.validate_CurrencyRoleTypeCodeType23(self.CurrencyRoleTypeCode)
        self.DiscPercentage = DiscPercentage
        self.validate_DiscPercentageType24(self.DiscPercentage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdShpExChrgDisc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdShpExChrgDisc.subclass:
            return QtdShpExChrgDisc.subclass(*args_, **kwargs_)
        else:
            return QtdShpExChrgDisc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DiscAmt(self): return self.DiscAmt
    def set_DiscAmt(self, DiscAmt): self.DiscAmt = DiscAmt
    def get_BaseAmt(self): return self.BaseAmt
    def set_BaseAmt(self, BaseAmt): self.BaseAmt = BaseAmt
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_CurrencyRoleTypeCode(self): return self.CurrencyRoleTypeCode
    def set_CurrencyRoleTypeCode(self, CurrencyRoleTypeCode): self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
    def get_DiscPercentage(self): return self.DiscPercentage
    def set_DiscPercentage(self, DiscPercentage): self.DiscPercentage = DiscPercentage
    def validate_DiscAmtType20(self, value):
        # Validate type DiscAmtType20, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 5:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DiscAmtType20' % {"value" : value.encode("utf-8")} )
    def validate_BaseAmtType21(self, value):
        # Validate type BaseAmtType21, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseAmtType21' % {"value" : value} )
    def validate_CurrencyCodeType22(self, value):
        # Validate type CurrencyCodeType22, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType22' % {"value" : value.encode("utf-8")} )
    def validate_CurrencyRoleTypeCodeType23(self, value):
        # Validate type CurrencyRoleTypeCodeType23, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 5:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyRoleTypeCodeType23' % {"value" : value.encode("utf-8")} )
    def validate_DiscPercentageType24(self, value):
        # Validate type DiscPercentageType24, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DiscPercentageType24' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DiscAmt is not None or
            self.BaseAmt is not None or
            self.CurrencyCode is not None or
            self.CurrencyRoleTypeCode is not None or
            self.DiscPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdShpExChrgDisc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdShpExChrgDisc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdShpExChrgDisc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdShpExChrgDisc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdShpExChrgDisc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdShpExChrgDisc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DiscAmt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscAmt>%s</DiscAmt>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DiscAmt), input_name='DiscAmt')), eol_))
        if self.BaseAmt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BaseAmt>%s</BaseAmt>%s' % (self.gds_format_float(self.BaseAmt, input_name='BaseAmt'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.CurrencyRoleTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyRoleTypeCode>%s</CurrencyRoleTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyRoleTypeCode), input_name='CurrencyRoleTypeCode')), eol_))
        if self.DiscPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscPercentage>%s</DiscPercentage>%s' % (self.gds_format_float(self.DiscPercentage, input_name='DiscPercentage'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DiscAmt':
            DiscAmt_ = child_.text
            DiscAmt_ = self.gds_validate_string(DiscAmt_, node, 'DiscAmt')
            self.DiscAmt = DiscAmt_
            # validate type DiscAmtType20
            self.validate_DiscAmtType20(self.DiscAmt)
        elif nodeName_ == 'BaseAmt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BaseAmt')
            self.BaseAmt = fval_
            # validate type BaseAmtType21
            self.validate_BaseAmtType21(self.BaseAmt)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType22
            self.validate_CurrencyCodeType22(self.CurrencyCode)
        elif nodeName_ == 'CurrencyRoleTypeCode':
            CurrencyRoleTypeCode_ = child_.text
            CurrencyRoleTypeCode_ = self.gds_validate_string(CurrencyRoleTypeCode_, node, 'CurrencyRoleTypeCode')
            self.CurrencyRoleTypeCode = CurrencyRoleTypeCode_
            # validate type CurrencyRoleTypeCodeType23
            self.validate_CurrencyRoleTypeCodeType23(self.CurrencyRoleTypeCode)
        elif nodeName_ == 'DiscPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DiscPercentage')
            self.DiscPercentage = fval_
            # validate type DiscPercentageType24
            self.validate_DiscPercentageType24(self.DiscPercentage)
# end class QtdShpExChrgDisc


class SrvCombType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Prod=None):
        self.original_tagname_ = None
        self.Prod = Prod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SrvCombType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SrvCombType3.subclass:
            return SrvCombType3.subclass(*args_, **kwargs_)
        else:
            return SrvCombType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Prod(self): return self.Prod
    def set_Prod(self, Prod): self.Prod = Prod
    def hasContent_(self):
        if (
            self.Prod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SrvCombType3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SrvCombType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SrvCombType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SrvCombType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SrvCombType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SrvCombType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Prod is not None:
            self.Prod.export(outfile, level, namespace_, name_='Prod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Prod':
            obj_ = ProdType.factory()
            obj_.build(child_)
            self.Prod = obj_
            obj_.original_tagname_ = 'Prod'
# end class SrvCombType3


class VldSrvCombType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SpecialServiceType=None, LocalServiceType=None, CombRSrv=None):
        self.original_tagname_ = None
        self.SpecialServiceType = SpecialServiceType
        if LocalServiceType is None:
            self.LocalServiceType = []
        else:
            self.LocalServiceType = LocalServiceType
        if CombRSrv is None:
            self.CombRSrv = []
        else:
            self.CombRSrv = CombRSrv
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VldSrvCombType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VldSrvCombType.subclass:
            return VldSrvCombType.subclass(*args_, **kwargs_)
        else:
            return VldSrvCombType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialServiceType(self): return self.SpecialServiceType
    def set_SpecialServiceType(self, SpecialServiceType): self.SpecialServiceType = SpecialServiceType
    def get_LocalServiceType(self): return self.LocalServiceType
    def set_LocalServiceType(self, LocalServiceType): self.LocalServiceType = LocalServiceType
    def add_LocalServiceType(self, value): self.LocalServiceType.append(value)
    def insert_LocalServiceType_at(self, index, value): self.LocalServiceType.insert(index, value)
    def replace_LocalServiceType_at(self, index, value): self.LocalServiceType[index] = value
    def get_CombRSrv(self): return self.CombRSrv
    def set_CombRSrv(self, CombRSrv): self.CombRSrv = CombRSrv
    def add_CombRSrv(self, value): self.CombRSrv.append(value)
    def insert_CombRSrv_at(self, index, value): self.CombRSrv.insert(index, value)
    def replace_CombRSrv_at(self, index, value): self.CombRSrv[index] = value
    def hasContent_(self):
        if (
            self.SpecialServiceType is not None or
            self.LocalServiceType or
            self.CombRSrv
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VldSrvCombType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VldSrvCombType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VldSrvCombType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VldSrvCombType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VldSrvCombType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VldSrvCombType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecialServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SpecialServiceType>%s</SpecialServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialServiceType), input_name='SpecialServiceType')), eol_))
        for LocalServiceType_ in self.LocalServiceType:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceType>%s</LocalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(LocalServiceType_), input_name='LocalServiceType')), eol_))
        for CombRSrv_ in self.CombRSrv:
            CombRSrv_.export(outfile, level, namespace_, name_='CombRSrv', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialServiceType':
            SpecialServiceType_ = child_.text
            SpecialServiceType_ = self.gds_validate_string(SpecialServiceType_, node, 'SpecialServiceType')
            self.SpecialServiceType = SpecialServiceType_
        elif nodeName_ == 'LocalServiceType':
            LocalServiceType_ = child_.text
            LocalServiceType_ = self.gds_validate_string(LocalServiceType_, node, 'LocalServiceType')
            self.LocalServiceType.append(LocalServiceType_)
        elif nodeName_ == 'CombRSrv':
            obj_ = CombRSrvType.factory()
            obj_.build(child_)
            self.CombRSrv.append(obj_)
            obj_.original_tagname_ = 'CombRSrv'
# end class VldSrvCombType


class CombRSrvType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RestrictedSpecialServiceType=None, RestrictedLocalServiceType=None):
        self.original_tagname_ = None
        self.RestrictedSpecialServiceType = RestrictedSpecialServiceType
        if RestrictedLocalServiceType is None:
            self.RestrictedLocalServiceType = []
        else:
            self.RestrictedLocalServiceType = RestrictedLocalServiceType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CombRSrvType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CombRSrvType.subclass:
            return CombRSrvType.subclass(*args_, **kwargs_)
        else:
            return CombRSrvType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RestrictedSpecialServiceType(self): return self.RestrictedSpecialServiceType
    def set_RestrictedSpecialServiceType(self, RestrictedSpecialServiceType): self.RestrictedSpecialServiceType = RestrictedSpecialServiceType
    def get_RestrictedLocalServiceType(self): return self.RestrictedLocalServiceType
    def set_RestrictedLocalServiceType(self, RestrictedLocalServiceType): self.RestrictedLocalServiceType = RestrictedLocalServiceType
    def add_RestrictedLocalServiceType(self, value): self.RestrictedLocalServiceType.append(value)
    def insert_RestrictedLocalServiceType_at(self, index, value): self.RestrictedLocalServiceType.insert(index, value)
    def replace_RestrictedLocalServiceType_at(self, index, value): self.RestrictedLocalServiceType[index] = value
    def hasContent_(self):
        if (
            self.RestrictedSpecialServiceType is not None or
            self.RestrictedLocalServiceType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CombRSrvType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CombRSrvType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CombRSrvType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CombRSrvType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CombRSrvType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CombRSrvType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RestrictedSpecialServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RestrictedSpecialServiceType>%s</RestrictedSpecialServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RestrictedSpecialServiceType), input_name='RestrictedSpecialServiceType')), eol_))
        for RestrictedLocalServiceType_ in self.RestrictedLocalServiceType:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RestrictedLocalServiceType>%s</RestrictedLocalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(RestrictedLocalServiceType_), input_name='RestrictedLocalServiceType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RestrictedSpecialServiceType':
            RestrictedSpecialServiceType_ = child_.text
            RestrictedSpecialServiceType_ = self.gds_validate_string(RestrictedSpecialServiceType_, node, 'RestrictedSpecialServiceType')
            self.RestrictedSpecialServiceType = RestrictedSpecialServiceType_
        elif nodeName_ == 'RestrictedLocalServiceType':
            RestrictedLocalServiceType_ = child_.text
            RestrictedLocalServiceType_ = self.gds_validate_string(RestrictedLocalServiceType_, node, 'RestrictedLocalServiceType')
            self.RestrictedLocalServiceType.append(RestrictedLocalServiceType_)
# end class CombRSrvType


class ConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ConditionCode=None, ConditionData=None):
        self.original_tagname_ = None
        self.ConditionCode = ConditionCode
        self.validate_ConditionCodeType(self.ConditionCode)
        self.ConditionData = ConditionData
        self.validate_ConditionDataType(self.ConditionData)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConditionType.subclass:
            return ConditionType.subclass(*args_, **kwargs_)
        else:
            return ConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConditionCode(self): return self.ConditionCode
    def set_ConditionCode(self, ConditionCode): self.ConditionCode = ConditionCode
    def get_ConditionData(self): return self.ConditionData
    def set_ConditionData(self, ConditionData): self.ConditionData = ConditionData
    def validate_ConditionCodeType(self, value):
        # Validate type ConditionCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ConditionCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ConditionCodeType' % {"value" : value.encode("utf-8")} )
    def validate_ConditionDataType(self, value):
        # Validate type ConditionDataType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.ConditionCode is not None or
            self.ConditionData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConditionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConditionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConditionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConditionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConditionCode>%s</ConditionCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConditionCode), input_name='ConditionCode')), eol_))
        if self.ConditionData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConditionData>%s</ConditionData>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConditionData), input_name='ConditionData')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConditionCode':
            ConditionCode_ = child_.text
            ConditionCode_ = self.gds_validate_string(ConditionCode_, node, 'ConditionCode')
            self.ConditionCode = ConditionCode_
            # validate type ConditionCodeType
            self.validate_ConditionCodeType(self.ConditionCode)
        elif nodeName_ == 'ConditionData':
            ConditionData_ = child_.text
            ConditionData_ = self.gds_validate_string(ConditionData_, node, 'ConditionData')
            self.ConditionData = ConditionData_
            # validate type ConditionDataType
            self.validate_ConditionDataType(self.ConditionData)
# end class ConditionType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTResponseDataTypes'
        rootClass = DCTResponseDataTypes
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTResponseDataTypes'
        rootClass = DCTResponseDataTypes
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTResponseDataTypes'
        rootClass = DCTResponseDataTypes
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTResponseDataTypes'
        rootClass = DCTResponseDataTypes
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from DCTResponsedatatypes_global import *\n\n')
        sys.stdout.write('import DCTResponsedatatypes_global as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "BkgDetailsType",
    "ChargeTaxAmountDetType",
    "CombRSrvType",
    "ConditionType",
    "DCTResponseDataTypes",
    "DeliveryDate",
    "DestSvcAreaType",
    "MrkSrvType",
    "NoteType",
    "OrgnSvcAreaType",
    "ProdNtwrkType",
    "ProdType",
    "QtdSExtrChrgInAdCurType",
    "QtdSInAdCurType",
    "QtdShpExChrgDisc",
    "QtdShpExChrgType",
    "QtdShpType",
    "SBTPType",
    "SrvCombType",
    "SrvCombType3",
    "SrvType",
    "VldSrvCombType",
    "WeightChargeDisc",
    "WeightChargeTaxDetType"
]
