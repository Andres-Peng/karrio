#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Apr  3 22:04:06 2018 by generateDS.py version 2.29.5.
# Python 3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28)  [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('-o', './lib/DCT_Response_global.py')
#
# Command line arguments:
#   ./xsd/DCT-Response_global.xsd
#
# Current working directory (os.getcwd()):
#   dhl
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class DCTResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GetQuoteResponse=None, GetCapabilityResponse=None):
        self.original_tagname_ = None
        self.GetQuoteResponse = GetQuoteResponse
        self.GetCapabilityResponse = GetCapabilityResponse
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DCTResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DCTResponse.subclass:
            return DCTResponse.subclass(*args_, **kwargs_)
        else:
            return DCTResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GetQuoteResponse(self): return self.GetQuoteResponse
    def set_GetQuoteResponse(self, GetQuoteResponse): self.GetQuoteResponse = GetQuoteResponse
    def get_GetCapabilityResponse(self): return self.GetCapabilityResponse
    def set_GetCapabilityResponse(self, GetCapabilityResponse): self.GetCapabilityResponse = GetCapabilityResponse
    def hasContent_(self):
        if (
            self.GetQuoteResponse is not None or
            self.GetCapabilityResponse is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DCTResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DCTResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCTResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DCTResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCTResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DCTResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GetQuoteResponse is not None:
            self.GetQuoteResponse.export(outfile, level, namespace_, name_='GetQuoteResponse', pretty_print=pretty_print)
        if self.GetCapabilityResponse is not None:
            self.GetCapabilityResponse.export(outfile, level, namespace_, name_='GetCapabilityResponse', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GetQuoteResponse':
            obj_ = GetQuoteResponseType.factory()
            obj_.build(child_)
            self.GetQuoteResponse = obj_
            obj_.original_tagname_ = 'GetQuoteResponse'
        elif nodeName_ == 'GetCapabilityResponse':
            obj_ = GetCapabilityResponseType.factory()
            obj_.build(child_)
            self.GetCapabilityResponse = obj_
            obj_.original_tagname_ = 'GetCapabilityResponse'
# end class DCTResponse


class ServiceHeader(GeneratedsSuper):
    """Standard routing header"""
    subclass = None
    superclass = None
    def __init__(self, MessageTime=None, MessageReference=None, SiteID=None):
        self.original_tagname_ = None
        if isinstance(MessageTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(MessageTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = MessageTime
        self.MessageTime = initvalue_
        self.MessageReference = MessageReference
        self.SiteID = SiteID
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceHeader.subclass:
            return ServiceHeader.subclass(*args_, **kwargs_)
        else:
            return ServiceHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MessageTime(self): return self.MessageTime
    def set_MessageTime(self, MessageTime): self.MessageTime = MessageTime
    def get_MessageReference(self): return self.MessageReference
    def set_MessageReference(self, MessageReference): self.MessageReference = MessageReference
    def get_SiteID(self): return self.SiteID
    def set_SiteID(self, SiteID): self.SiteID = SiteID
    def hasContent_(self):
        if (
            self.MessageTime is not None or
            self.MessageReference is not None or
            self.SiteID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceHeader', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceHeader')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceHeader'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceHeader', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MessageTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MessageTime>%s</MessageTime>%s' % (self.gds_format_datetime(self.MessageTime, input_name='MessageTime'), eol_))
        if self.MessageReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MessageReference>%s</MessageReference>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MessageReference), input_name='MessageReference')), eol_))
        if self.SiteID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiteID>%s</SiteID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SiteID), input_name='SiteID')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MessageTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.MessageTime = dval_
        elif nodeName_ == 'MessageReference':
            MessageReference_ = child_.text
            MessageReference_ = self.gds_validate_string(MessageReference_, node, 'MessageReference')
            self.MessageReference = MessageReference_
        elif nodeName_ == 'SiteID':
            SiteID_ = child_.text
            SiteID_ = self.gds_validate_string(SiteID_, node, 'SiteID')
            self.SiteID = SiteID_
# end class ServiceHeader


class DataTypes(GeneratedsSuper):
    """Comment describing your root element"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataTypes.subclass:
            return DataTypes.subclass(*args_, **kwargs_)
        else:
            return DataTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataTypes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataTypes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataTypes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DataTypes', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataTypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataTypes', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataTypes


class Billing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ShipperAccountNumber=None, ShippingPaymentType=None, BillingAccountNumber=None, DutyPaymentType=None, DutyAccountNumber=None):
        self.original_tagname_ = None
        self.ShipperAccountNumber = ShipperAccountNumber
        self.validate_AccountNumber(self.ShipperAccountNumber)
        self.ShippingPaymentType = ShippingPaymentType
        self.validate_ShipmentPaymentType(self.ShippingPaymentType)
        self.BillingAccountNumber = BillingAccountNumber
        self.validate_AccountNumber(self.BillingAccountNumber)
        self.DutyPaymentType = DutyPaymentType
        self.validate_DutyTaxPaymentType(self.DutyPaymentType)
        self.DutyAccountNumber = DutyAccountNumber
        self.validate_AccountNumber(self.DutyAccountNumber)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Billing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Billing.subclass:
            return Billing.subclass(*args_, **kwargs_)
        else:
            return Billing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShipperAccountNumber(self): return self.ShipperAccountNumber
    def set_ShipperAccountNumber(self, ShipperAccountNumber): self.ShipperAccountNumber = ShipperAccountNumber
    def get_ShippingPaymentType(self): return self.ShippingPaymentType
    def set_ShippingPaymentType(self, ShippingPaymentType): self.ShippingPaymentType = ShippingPaymentType
    def get_BillingAccountNumber(self): return self.BillingAccountNumber
    def set_BillingAccountNumber(self, BillingAccountNumber): self.BillingAccountNumber = BillingAccountNumber
    def get_DutyPaymentType(self): return self.DutyPaymentType
    def set_DutyPaymentType(self, DutyPaymentType): self.DutyPaymentType = DutyPaymentType
    def get_DutyAccountNumber(self): return self.DutyAccountNumber
    def set_DutyAccountNumber(self, DutyAccountNumber): self.DutyAccountNumber = DutyAccountNumber
    def validate_AccountNumber(self, value):
        # Validate type AccountNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on AccountNumber' % {"value" : value.encode("utf-8")} )
    def validate_ShipmentPaymentType(self, value):
        # Validate type ShipmentPaymentType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'R', 'T']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShipmentPaymentType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ShipmentPaymentType' % {"value" : value.encode("utf-8")} )
    def validate_DutyTaxPaymentType(self, value):
        # Validate type DutyTaxPaymentType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'R', 'T']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DutyTaxPaymentType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DutyTaxPaymentType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ShipperAccountNumber is not None or
            self.ShippingPaymentType is not None or
            self.BillingAccountNumber is not None or
            self.DutyPaymentType is not None or
            self.DutyAccountNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Billing', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Billing')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Billing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Billing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Billing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Billing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ShipperAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipperAccountNumber>%s</ShipperAccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShipperAccountNumber), input_name='ShipperAccountNumber')), eol_))
        if self.ShippingPaymentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShippingPaymentType>%s</ShippingPaymentType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShippingPaymentType), input_name='ShippingPaymentType')), eol_))
        if self.BillingAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BillingAccountNumber>%s</BillingAccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BillingAccountNumber), input_name='BillingAccountNumber')), eol_))
        if self.DutyPaymentType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DutyPaymentType>%s</DutyPaymentType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DutyPaymentType), input_name='DutyPaymentType')), eol_))
        if self.DutyAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DutyAccountNumber>%s</DutyAccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DutyAccountNumber), input_name='DutyAccountNumber')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ShipperAccountNumber':
            ShipperAccountNumber_ = child_.text
            ShipperAccountNumber_ = self.gds_validate_string(ShipperAccountNumber_, node, 'ShipperAccountNumber')
            self.ShipperAccountNumber = ShipperAccountNumber_
            # validate type AccountNumber
            self.validate_AccountNumber(self.ShipperAccountNumber)
        elif nodeName_ == 'ShippingPaymentType':
            ShippingPaymentType_ = child_.text
            ShippingPaymentType_ = self.gds_validate_string(ShippingPaymentType_, node, 'ShippingPaymentType')
            self.ShippingPaymentType = ShippingPaymentType_
            # validate type ShipmentPaymentType
            self.validate_ShipmentPaymentType(self.ShippingPaymentType)
        elif nodeName_ == 'BillingAccountNumber':
            BillingAccountNumber_ = child_.text
            BillingAccountNumber_ = self.gds_validate_string(BillingAccountNumber_, node, 'BillingAccountNumber')
            self.BillingAccountNumber = BillingAccountNumber_
            # validate type AccountNumber
            self.validate_AccountNumber(self.BillingAccountNumber)
        elif nodeName_ == 'DutyPaymentType':
            DutyPaymentType_ = child_.text
            DutyPaymentType_ = self.gds_validate_string(DutyPaymentType_, node, 'DutyPaymentType')
            self.DutyPaymentType = DutyPaymentType_
            # validate type DutyTaxPaymentType
            self.validate_DutyTaxPaymentType(self.DutyPaymentType)
        elif nodeName_ == 'DutyAccountNumber':
            DutyAccountNumber_ = child_.text
            DutyAccountNumber_ = self.gds_validate_string(DutyAccountNumber_, node, 'DutyAccountNumber')
            self.DutyAccountNumber = DutyAccountNumber_
            # validate type AccountNumber
            self.validate_AccountNumber(self.DutyAccountNumber)
# end class Billing


class Commodity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommodityCode=None, CommodityName=None):
        self.original_tagname_ = None
        self.CommodityCode = CommodityCode
        self.validate_CommodityCode(self.CommodityCode)
        self.CommodityName = CommodityName
        self.validate_CommodityName(self.CommodityName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Commodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Commodity.subclass:
            return Commodity.subclass(*args_, **kwargs_)
        else:
            return Commodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommodityCode(self): return self.CommodityCode
    def set_CommodityCode(self, CommodityCode): self.CommodityCode = CommodityCode
    def get_CommodityName(self): return self.CommodityName
    def set_CommodityName(self, CommodityName): self.CommodityName = CommodityName
    def validate_CommodityCode(self, value):
        # Validate type CommodityCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CommodityCode' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityCode' % {"value" : value.encode("utf-8")} )
    def validate_CommodityName(self, value):
        # Validate type CommodityName, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CommodityName' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CommodityCode is not None or
            self.CommodityName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Commodity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Commodity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Commodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Commodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Commodity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Commodity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommodityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CommodityCode>%s</CommodityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CommodityCode), input_name='CommodityCode')), eol_))
        if self.CommodityName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CommodityName>%s</CommodityName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CommodityName), input_name='CommodityName')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommodityCode':
            CommodityCode_ = child_.text
            CommodityCode_ = self.gds_validate_string(CommodityCode_, node, 'CommodityCode')
            self.CommodityCode = CommodityCode_
            # validate type CommodityCode
            self.validate_CommodityCode(self.CommodityCode)
        elif nodeName_ == 'CommodityName':
            CommodityName_ = child_.text
            CommodityName_ = self.gds_validate_string(CommodityName_, node, 'CommodityName')
            self.CommodityName = CommodityName_
            # validate type CommodityName
            self.validate_CommodityName(self.CommodityName)
# end class Commodity


class Consignee(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CompanyName=None, SuiteDepartmentName=None, AddressLine=None, City=None, Division=None, DivisionCode=None, PostalCode=None, CountryCode=None, CountryName=None, FederalTaxId=None, StateTaxId=None, Contact=None, Suburb=None):
        self.original_tagname_ = None
        self.CompanyName = CompanyName
        self.validate_CompanyNameValidator(self.CompanyName)
        self.SuiteDepartmentName = SuiteDepartmentName
        self.validate_SuiteDepartmentName(self.SuiteDepartmentName)
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.City = City
        self.validate_City(self.City)
        self.Division = Division
        self.validate_Division(self.Division)
        self.DivisionCode = DivisionCode
        self.validate_DivisionCode(self.DivisionCode)
        self.PostalCode = PostalCode
        self.validate_PostalCode(self.PostalCode)
        self.CountryCode = CountryCode
        self.validate_CountryCode(self.CountryCode)
        self.CountryName = CountryName
        self.validate_CountryName(self.CountryName)
        self.FederalTaxId = FederalTaxId
        self.validate_FederalTaxIdType(self.FederalTaxId)
        self.StateTaxId = StateTaxId
        self.validate_StateTaxIdType(self.StateTaxId)
        self.Contact = Contact
        self.Suburb = Suburb
        self.validate_Suburb(self.Suburb)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Consignee)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Consignee.subclass:
            return Consignee.subclass(*args_, **kwargs_)
        else:
            return Consignee(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompanyName(self): return self.CompanyName
    def set_CompanyName(self, CompanyName): self.CompanyName = CompanyName
    def get_SuiteDepartmentName(self): return self.SuiteDepartmentName
    def set_SuiteDepartmentName(self, SuiteDepartmentName): self.SuiteDepartmentName = SuiteDepartmentName
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine_at(self, index, value): self.AddressLine.insert(index, value)
    def replace_AddressLine_at(self, index, value): self.AddressLine[index] = value
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_Division(self): return self.Division
    def set_Division(self, Division): self.Division = Division
    def get_DivisionCode(self): return self.DivisionCode
    def set_DivisionCode(self, DivisionCode): self.DivisionCode = DivisionCode
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_FederalTaxId(self): return self.FederalTaxId
    def set_FederalTaxId(self, FederalTaxId): self.FederalTaxId = FederalTaxId
    def get_StateTaxId(self): return self.StateTaxId
    def set_StateTaxId(self, StateTaxId): self.StateTaxId = StateTaxId
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def get_Suburb(self): return self.Suburb
    def set_Suburb(self, Suburb): self.Suburb = Suburb
    def validate_CompanyNameValidator(self, value):
        # Validate type CompanyNameValidator, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CompanyNameValidator' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CompanyNameValidator' % {"value" : value.encode("utf-8")} )
    def validate_SuiteDepartmentName(self, value):
        # Validate type SuiteDepartmentName, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SuiteDepartmentName' % {"value" : value.encode("utf-8")} )
    def validate_AddressLine(self, value):
        # Validate type AddressLine, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on AddressLine' % {"value" : value.encode("utf-8")} )
    def validate_City(self, value):
        # Validate type City, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on City' % {"value" : value.encode("utf-8")} )
    def validate_Division(self, value):
        # Validate type Division, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Division' % {"value" : value.encode("utf-8")} )
    def validate_DivisionCode(self, value):
        # Validate type DivisionCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DivisionCode' % {"value" : value.encode("utf-8")} )
    def validate_PostalCode(self, value):
        # Validate type PostalCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PostalCode' % {"value" : value.encode("utf-8")} )
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CountryCode' % {"value" : value.encode("utf-8")} )
    def validate_CountryName(self, value):
        # Validate type CountryName, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CountryName' % {"value" : value.encode("utf-8")} )
    def validate_FederalTaxIdType(self, value):
        # Validate type FederalTaxIdType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on FederalTaxIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on FederalTaxIdType' % {"value" : value.encode("utf-8")} )
    def validate_StateTaxIdType(self, value):
        # Validate type StateTaxIdType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on StateTaxIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on StateTaxIdType' % {"value" : value.encode("utf-8")} )
    def validate_Suburb(self, value):
        # Validate type Suburb, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Suburb' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CompanyName is not None or
            self.SuiteDepartmentName is not None or
            self.AddressLine or
            self.City is not None or
            self.Division is not None or
            self.DivisionCode is not None or
            self.PostalCode is not None or
            self.CountryCode is not None or
            self.CountryName is not None or
            self.FederalTaxId is not None or
            self.StateTaxId is not None or
            self.Contact is not None or
            self.Suburb is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Consignee', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Consignee')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Consignee')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Consignee', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Consignee'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Consignee', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompanyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CompanyName>%s</CompanyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompanyName), input_name='CompanyName')), eol_))
        if self.SuiteDepartmentName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SuiteDepartmentName>%s</SuiteDepartmentName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SuiteDepartmentName), input_name='SuiteDepartmentName')), eol_))
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AddressLine>%s</AddressLine>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressLine_), input_name='AddressLine')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<City>%s</City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.Division is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Division>%s</Division>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Division), input_name='Division')), eol_))
        if self.DivisionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DivisionCode>%s</DivisionCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DivisionCode), input_name='DivisionCode')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PostalCode>%s</PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CountryCode>%s</CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CountryName>%s</CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.FederalTaxId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FederalTaxId>%s</FederalTaxId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FederalTaxId), input_name='FederalTaxId')), eol_))
        if self.StateTaxId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StateTaxId>%s</StateTaxId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateTaxId), input_name='StateTaxId')), eol_))
        if self.Contact is not None:
            self.Contact.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
        if self.Suburb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Suburb>%s</Suburb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Suburb), input_name='Suburb')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompanyName':
            CompanyName_ = child_.text
            CompanyName_ = self.gds_validate_string(CompanyName_, node, 'CompanyName')
            self.CompanyName = CompanyName_
            # validate type CompanyNameValidator
            self.validate_CompanyNameValidator(self.CompanyName)
        elif nodeName_ == 'SuiteDepartmentName':
            SuiteDepartmentName_ = child_.text
            SuiteDepartmentName_ = self.gds_validate_string(SuiteDepartmentName_, node, 'SuiteDepartmentName')
            self.SuiteDepartmentName = SuiteDepartmentName_
            # validate type SuiteDepartmentName
            self.validate_SuiteDepartmentName(self.SuiteDepartmentName)
        elif nodeName_ == 'AddressLine':
            AddressLine_ = child_.text
            AddressLine_ = self.gds_validate_string(AddressLine_, node, 'AddressLine')
            self.AddressLine.append(AddressLine_)
            # validate type AddressLine
            self.validate_AddressLine(self.AddressLine[-1])
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
            # validate type City
            self.validate_City(self.City)
        elif nodeName_ == 'Division':
            Division_ = child_.text
            Division_ = self.gds_validate_string(Division_, node, 'Division')
            self.Division = Division_
            # validate type Division
            self.validate_Division(self.Division)
        elif nodeName_ == 'DivisionCode':
            DivisionCode_ = child_.text
            DivisionCode_ = self.gds_validate_string(DivisionCode_, node, 'DivisionCode')
            self.DivisionCode = DivisionCode_
            # validate type DivisionCode
            self.validate_DivisionCode(self.DivisionCode)
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
            # validate type PostalCode
            self.validate_PostalCode(self.PostalCode)
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
            # validate type CountryCode
            self.validate_CountryCode(self.CountryCode)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName
            self.validate_CountryName(self.CountryName)
        elif nodeName_ == 'FederalTaxId':
            FederalTaxId_ = child_.text
            FederalTaxId_ = self.gds_validate_string(FederalTaxId_, node, 'FederalTaxId')
            self.FederalTaxId = FederalTaxId_
            # validate type FederalTaxIdType
            self.validate_FederalTaxIdType(self.FederalTaxId)
        elif nodeName_ == 'StateTaxId':
            StateTaxId_ = child_.text
            StateTaxId_ = self.gds_validate_string(StateTaxId_, node, 'StateTaxId')
            self.StateTaxId = StateTaxId_
            # validate type StateTaxIdType
            self.validate_StateTaxIdType(self.StateTaxId)
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.Contact = obj_
            obj_.original_tagname_ = 'Contact'
        elif nodeName_ == 'Suburb':
            Suburb_ = child_.text
            Suburb_ = self.gds_validate_string(Suburb_, node, 'Suburb')
            self.Suburb = Suburb_
            # validate type Suburb
            self.validate_Suburb(self.Suburb)
# end class Consignee


class Contact(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PersonName=None, PhoneNumber=None, PhoneExtension=None, FaxNumber=None, Telex=None, Email=None, MobilePhoneNumber=None):
        self.original_tagname_ = None
        self.PersonName = PersonName
        self.validate_PersonName(self.PersonName)
        self.PhoneNumber = PhoneNumber
        self.validate_PhoneNumber(self.PhoneNumber)
        self.PhoneExtension = PhoneExtension
        self.validate_PhoneExtension(self.PhoneExtension)
        self.FaxNumber = FaxNumber
        self.validate_PhoneNumber(self.FaxNumber)
        self.Telex = Telex
        self.validate_Telex(self.Telex)
        self.Email = Email
        self.validate_EmailAddress(self.Email)
        self.MobilePhoneNumber = MobilePhoneNumber
        self.validate_MobilePhoneNumber(self.MobilePhoneNumber)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Contact)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Contact.subclass:
            return Contact.subclass(*args_, **kwargs_)
        else:
            return Contact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PersonName(self): return self.PersonName
    def set_PersonName(self, PersonName): self.PersonName = PersonName
    def get_PhoneNumber(self): return self.PhoneNumber
    def set_PhoneNumber(self, PhoneNumber): self.PhoneNumber = PhoneNumber
    def get_PhoneExtension(self): return self.PhoneExtension
    def set_PhoneExtension(self, PhoneExtension): self.PhoneExtension = PhoneExtension
    def get_FaxNumber(self): return self.FaxNumber
    def set_FaxNumber(self, FaxNumber): self.FaxNumber = FaxNumber
    def get_Telex(self): return self.Telex
    def set_Telex(self, Telex): self.Telex = Telex
    def get_Email(self): return self.Email
    def set_Email(self, Email): self.Email = Email
    def get_MobilePhoneNumber(self): return self.MobilePhoneNumber
    def set_MobilePhoneNumber(self, MobilePhoneNumber): self.MobilePhoneNumber = MobilePhoneNumber
    def validate_PersonName(self, value):
        # Validate type PersonName, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PersonName' % {"value" : value.encode("utf-8")} )
    def validate_PhoneNumber(self, value):
        # Validate type PhoneNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PhoneNumber' % {"value" : value.encode("utf-8")} )
    def validate_PhoneExtension(self, value):
        # Validate type PhoneExtension, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PhoneExtension' % {"value" : value.encode("utf-8")} )
    def validate_Telex(self, value):
        # Validate type Telex, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Telex' % {"value" : value.encode("utf-8")} )
    def validate_EmailAddress(self, value):
        # Validate type EmailAddress, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on EmailAddress' % {"value" : value.encode("utf-8")} )
    def validate_MobilePhoneNumber(self, value):
        # Validate type MobilePhoneNumber, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value > 9999999999999999999999999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on MobilePhoneNumber' % {"value" : value} )
    def hasContent_(self):
        if (
            self.PersonName is not None or
            self.PhoneNumber is not None or
            self.PhoneExtension is not None or
            self.FaxNumber is not None or
            self.Telex is not None or
            self.Email is not None or
            self.MobilePhoneNumber is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Contact', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Contact')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Contact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Contact', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Contact'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Contact', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PersonName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PersonName>%s</PersonName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PersonName), input_name='PersonName')), eol_))
        if self.PhoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PhoneNumber>%s</PhoneNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PhoneNumber), input_name='PhoneNumber')), eol_))
        if self.PhoneExtension is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PhoneExtension>%s</PhoneExtension>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PhoneExtension), input_name='PhoneExtension')), eol_))
        if self.FaxNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FaxNumber>%s</FaxNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FaxNumber), input_name='FaxNumber')), eol_))
        if self.Telex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Telex>%s</Telex>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Telex), input_name='Telex')), eol_))
        if self.Email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Email>%s</Email>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Email), input_name='Email')), eol_))
        if self.MobilePhoneNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MobilePhoneNumber>%s</MobilePhoneNumber>%s' % (self.gds_format_integer(self.MobilePhoneNumber, input_name='MobilePhoneNumber'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PersonName':
            PersonName_ = child_.text
            PersonName_ = self.gds_validate_string(PersonName_, node, 'PersonName')
            self.PersonName = PersonName_
            # validate type PersonName
            self.validate_PersonName(self.PersonName)
        elif nodeName_ == 'PhoneNumber':
            PhoneNumber_ = child_.text
            PhoneNumber_ = self.gds_validate_string(PhoneNumber_, node, 'PhoneNumber')
            self.PhoneNumber = PhoneNumber_
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.PhoneNumber)
        elif nodeName_ == 'PhoneExtension':
            PhoneExtension_ = child_.text
            PhoneExtension_ = self.gds_validate_string(PhoneExtension_, node, 'PhoneExtension')
            self.PhoneExtension = PhoneExtension_
            # validate type PhoneExtension
            self.validate_PhoneExtension(self.PhoneExtension)
        elif nodeName_ == 'FaxNumber':
            FaxNumber_ = child_.text
            FaxNumber_ = self.gds_validate_string(FaxNumber_, node, 'FaxNumber')
            self.FaxNumber = FaxNumber_
            # validate type PhoneNumber
            self.validate_PhoneNumber(self.FaxNumber)
        elif nodeName_ == 'Telex':
            Telex_ = child_.text
            Telex_ = self.gds_validate_string(Telex_, node, 'Telex')
            self.Telex = Telex_
            # validate type Telex
            self.validate_Telex(self.Telex)
        elif nodeName_ == 'Email':
            Email_ = child_.text
            Email_ = self.gds_validate_string(Email_, node, 'Email')
            self.Email = Email_
            # validate type EmailAddress
            self.validate_EmailAddress(self.Email)
        elif nodeName_ == 'MobilePhoneNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MobilePhoneNumber')
            self.MobilePhoneNumber = ival_
            # validate type MobilePhoneNumber
            self.validate_MobilePhoneNumber(self.MobilePhoneNumber)
# end class Contact


class Dutiable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeclaredValue=None, DeclaredCurrency=None, ScheduleB=None, ExportLicense=None, ShipperEIN=None, ShipperIDType=None, ConsigneeIDType=None, ImportLicense=None, ConsigneeEIN=None, TermsOfTrade=None, CommerceLicensed=None, Filing=None):
        self.original_tagname_ = None
        self.DeclaredValue = DeclaredValue
        self.validate_DeclaredValue(self.DeclaredValue)
        self.DeclaredCurrency = DeclaredCurrency
        self.validate_CurrencyCode(self.DeclaredCurrency)
        self.ScheduleB = ScheduleB
        self.validate_ScheduleB(self.ScheduleB)
        self.ExportLicense = ExportLicense
        self.validate_ExportLicense(self.ExportLicense)
        self.ShipperEIN = ShipperEIN
        self.validate_ShipperEINType(self.ShipperEIN)
        self.ShipperIDType = ShipperIDType
        self.validate_ShipperIDTypeType(self.ShipperIDType)
        self.ConsigneeIDType = ConsigneeIDType
        self.validate_ConsigneeIDTypeType(self.ConsigneeIDType)
        self.ImportLicense = ImportLicense
        self.validate_ImportLicense(self.ImportLicense)
        self.ConsigneeEIN = ConsigneeEIN
        self.validate_ConsigneeEINType(self.ConsigneeEIN)
        self.TermsOfTrade = TermsOfTrade
        self.validate_TermsOfTrade(self.TermsOfTrade)
        self.CommerceLicensed = CommerceLicensed
        self.validate_YesNo(self.CommerceLicensed)
        self.Filing = Filing
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Dutiable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Dutiable.subclass:
            return Dutiable.subclass(*args_, **kwargs_)
        else:
            return Dutiable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeclaredValue(self): return self.DeclaredValue
    def set_DeclaredValue(self, DeclaredValue): self.DeclaredValue = DeclaredValue
    def get_DeclaredCurrency(self): return self.DeclaredCurrency
    def set_DeclaredCurrency(self, DeclaredCurrency): self.DeclaredCurrency = DeclaredCurrency
    def get_ScheduleB(self): return self.ScheduleB
    def set_ScheduleB(self, ScheduleB): self.ScheduleB = ScheduleB
    def get_ExportLicense(self): return self.ExportLicense
    def set_ExportLicense(self, ExportLicense): self.ExportLicense = ExportLicense
    def get_ShipperEIN(self): return self.ShipperEIN
    def set_ShipperEIN(self, ShipperEIN): self.ShipperEIN = ShipperEIN
    def get_ShipperIDType(self): return self.ShipperIDType
    def set_ShipperIDType(self, ShipperIDType): self.ShipperIDType = ShipperIDType
    def get_ConsigneeIDType(self): return self.ConsigneeIDType
    def set_ConsigneeIDType(self, ConsigneeIDType): self.ConsigneeIDType = ConsigneeIDType
    def get_ImportLicense(self): return self.ImportLicense
    def set_ImportLicense(self, ImportLicense): self.ImportLicense = ImportLicense
    def get_ConsigneeEIN(self): return self.ConsigneeEIN
    def set_ConsigneeEIN(self, ConsigneeEIN): self.ConsigneeEIN = ConsigneeEIN
    def get_TermsOfTrade(self): return self.TermsOfTrade
    def set_TermsOfTrade(self, TermsOfTrade): self.TermsOfTrade = TermsOfTrade
    def get_CommerceLicensed(self): return self.CommerceLicensed
    def set_CommerceLicensed(self, CommerceLicensed): self.CommerceLicensed = CommerceLicensed
    def get_Filing(self): return self.Filing
    def set_Filing(self, Filing): self.Filing = Filing
    def validate_DeclaredValue(self, value):
        # Validate type DeclaredValue, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.00:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on DeclaredValue' % {"value" : value} )
            if value > 9999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DeclaredValue' % {"value" : value} )
    def validate_CurrencyCode(self, value):
        # Validate type CurrencyCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCode' % {"value" : value.encode("utf-8")} )
    def validate_ScheduleB(self, value):
        # Validate type ScheduleB, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ScheduleB' % {"value" : value.encode("utf-8")} )
    def validate_ExportLicense(self, value):
        # Validate type ExportLicense, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 16:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ExportLicense' % {"value" : value.encode("utf-8")} )
    def validate_ShipperEINType(self, value):
        # Validate type ShipperEINType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ShipperEINType' % {"value" : value.encode("utf-8")} )
    def validate_ShipperIDTypeType(self, value):
        # Validate type ShipperIDTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'E', 'D']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ShipperIDTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ConsigneeIDTypeType(self, value):
        # Validate type ConsigneeIDTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'E', 'D']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ConsigneeIDTypeType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ConsigneeIDTypeType' % {"value" : value.encode("utf-8")} )
    def validate_ImportLicense(self, value):
        # Validate type ImportLicense, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 16:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ImportLicense' % {"value" : value.encode("utf-8")} )
    def validate_ConsigneeEINType(self, value):
        # Validate type ConsigneeEINType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ConsigneeEINType' % {"value" : value.encode("utf-8")} )
    def validate_TermsOfTrade(self, value):
        # Validate type TermsOfTrade, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TermsOfTrade' % {"value" : value.encode("utf-8")} )
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on YesNo' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on YesNo' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DeclaredValue is not None or
            self.DeclaredCurrency is not None or
            self.ScheduleB is not None or
            self.ExportLicense is not None or
            self.ShipperEIN is not None or
            self.ShipperIDType is not None or
            self.ConsigneeIDType is not None or
            self.ImportLicense is not None or
            self.ConsigneeEIN is not None or
            self.TermsOfTrade is not None or
            self.CommerceLicensed is not None or
            self.Filing is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Dutiable', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Dutiable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Dutiable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Dutiable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Dutiable'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Dutiable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DeclaredValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeclaredValue>%s</DeclaredValue>%s' % (self.gds_format_float(self.DeclaredValue, input_name='DeclaredValue'), eol_))
        if self.DeclaredCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeclaredCurrency>%s</DeclaredCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeclaredCurrency), input_name='DeclaredCurrency')), eol_))
        if self.ScheduleB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ScheduleB>%s</ScheduleB>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ScheduleB), input_name='ScheduleB')), eol_))
        if self.ExportLicense is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ExportLicense>%s</ExportLicense>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ExportLicense), input_name='ExportLicense')), eol_))
        if self.ShipperEIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipperEIN>%s</ShipperEIN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShipperEIN), input_name='ShipperEIN')), eol_))
        if self.ShipperIDType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipperIDType>%s</ShipperIDType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShipperIDType), input_name='ShipperIDType')), eol_))
        if self.ConsigneeIDType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConsigneeIDType>%s</ConsigneeIDType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConsigneeIDType), input_name='ConsigneeIDType')), eol_))
        if self.ImportLicense is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ImportLicense>%s</ImportLicense>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ImportLicense), input_name='ImportLicense')), eol_))
        if self.ConsigneeEIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConsigneeEIN>%s</ConsigneeEIN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConsigneeEIN), input_name='ConsigneeEIN')), eol_))
        if self.TermsOfTrade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TermsOfTrade>%s</TermsOfTrade>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TermsOfTrade), input_name='TermsOfTrade')), eol_))
        if self.CommerceLicensed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CommerceLicensed>%s</CommerceLicensed>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CommerceLicensed), input_name='CommerceLicensed')), eol_))
        if self.Filing is not None:
            self.Filing.export(outfile, level, namespace_, name_='Filing', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DeclaredValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DeclaredValue')
            self.DeclaredValue = fval_
            # validate type DeclaredValue
            self.validate_DeclaredValue(self.DeclaredValue)
        elif nodeName_ == 'DeclaredCurrency':
            DeclaredCurrency_ = child_.text
            DeclaredCurrency_ = self.gds_validate_string(DeclaredCurrency_, node, 'DeclaredCurrency')
            self.DeclaredCurrency = DeclaredCurrency_
            # validate type CurrencyCode
            self.validate_CurrencyCode(self.DeclaredCurrency)
        elif nodeName_ == 'ScheduleB':
            ScheduleB_ = child_.text
            ScheduleB_ = self.gds_validate_string(ScheduleB_, node, 'ScheduleB')
            self.ScheduleB = ScheduleB_
            # validate type ScheduleB
            self.validate_ScheduleB(self.ScheduleB)
        elif nodeName_ == 'ExportLicense':
            ExportLicense_ = child_.text
            ExportLicense_ = self.gds_validate_string(ExportLicense_, node, 'ExportLicense')
            self.ExportLicense = ExportLicense_
            # validate type ExportLicense
            self.validate_ExportLicense(self.ExportLicense)
        elif nodeName_ == 'ShipperEIN':
            ShipperEIN_ = child_.text
            ShipperEIN_ = self.gds_validate_string(ShipperEIN_, node, 'ShipperEIN')
            self.ShipperEIN = ShipperEIN_
            # validate type ShipperEINType
            self.validate_ShipperEINType(self.ShipperEIN)
        elif nodeName_ == 'ShipperIDType':
            ShipperIDType_ = child_.text
            ShipperIDType_ = self.gds_validate_string(ShipperIDType_, node, 'ShipperIDType')
            self.ShipperIDType = ShipperIDType_
            # validate type ShipperIDTypeType
            self.validate_ShipperIDTypeType(self.ShipperIDType)
        elif nodeName_ == 'ConsigneeIDType':
            ConsigneeIDType_ = child_.text
            ConsigneeIDType_ = self.gds_validate_string(ConsigneeIDType_, node, 'ConsigneeIDType')
            self.ConsigneeIDType = ConsigneeIDType_
            # validate type ConsigneeIDTypeType
            self.validate_ConsigneeIDTypeType(self.ConsigneeIDType)
        elif nodeName_ == 'ImportLicense':
            ImportLicense_ = child_.text
            ImportLicense_ = self.gds_validate_string(ImportLicense_, node, 'ImportLicense')
            self.ImportLicense = ImportLicense_
            # validate type ImportLicense
            self.validate_ImportLicense(self.ImportLicense)
        elif nodeName_ == 'ConsigneeEIN':
            ConsigneeEIN_ = child_.text
            ConsigneeEIN_ = self.gds_validate_string(ConsigneeEIN_, node, 'ConsigneeEIN')
            self.ConsigneeEIN = ConsigneeEIN_
            # validate type ConsigneeEINType
            self.validate_ConsigneeEINType(self.ConsigneeEIN)
        elif nodeName_ == 'TermsOfTrade':
            TermsOfTrade_ = child_.text
            TermsOfTrade_ = self.gds_validate_string(TermsOfTrade_, node, 'TermsOfTrade')
            self.TermsOfTrade = TermsOfTrade_
            # validate type TermsOfTrade
            self.validate_TermsOfTrade(self.TermsOfTrade)
        elif nodeName_ == 'CommerceLicensed':
            CommerceLicensed_ = child_.text
            CommerceLicensed_ = self.gds_validate_string(CommerceLicensed_, node, 'CommerceLicensed')
            self.CommerceLicensed = CommerceLicensed_
            # validate type YesNo
            self.validate_YesNo(self.CommerceLicensed)
        elif nodeName_ == 'Filing':
            obj_ = Filing.factory()
            obj_.build(child_)
            self.Filing = obj_
            obj_.original_tagname_ = 'Filing'
# end class Dutiable


class Filing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FilingType=None, FTSR=None, ITN=None, AES4EIN=None):
        self.original_tagname_ = None
        self.FilingType = FilingType
        self.validate_FilingType(self.FilingType)
        self.FTSR = FTSR
        self.validate_FTSR(self.FTSR)
        self.ITN = ITN
        self.validate_ITN(self.ITN)
        self.AES4EIN = AES4EIN
        self.validate_AES4EIN(self.AES4EIN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Filing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Filing.subclass:
            return Filing.subclass(*args_, **kwargs_)
        else:
            return Filing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FilingType(self): return self.FilingType
    def set_FilingType(self, FilingType): self.FilingType = FilingType
    def get_FTSR(self): return self.FTSR
    def set_FTSR(self, FTSR): self.FTSR = FTSR
    def get_ITN(self): return self.ITN
    def set_ITN(self, ITN): self.ITN = ITN
    def get_AES4EIN(self): return self.AES4EIN
    def set_AES4EIN(self, AES4EIN): self.AES4EIN = AES4EIN
    def validate_FilingType(self, value):
        # Validate type FilingType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FTR', 'ITN', 'AES4']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FilingType' % {"value" : value.encode("utf-8")} )
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on FilingType' % {"value" : value.encode("utf-8")} )
            if len(value) < 3:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on FilingType' % {"value" : value.encode("utf-8")} )
    def validate_FTSR(self, value):
        # Validate type FTSR, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['30.2(d)(2)', '30.36', '30.37(a)', '30.37(b)', '30.37(e)', '30.37(f)', '30.37(g)', '30.37(h)', '30.37(j)', '30.37(k)', '30.39', '30.40(a)', '30.40(b)', '30.40(c)', '30.40(d)']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FTSR' % {"value" : value.encode("utf-8")} )
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on FTSR' % {"value" : value.encode("utf-8")} )
            if len(value) < 5:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on FTSR' % {"value" : value.encode("utf-8")} )
    def validate_ITN(self, value):
        # Validate type ITN, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 15:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ITN' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_ITN_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ITN_patterns_, ))
    validate_ITN_patterns_ = [['^X[0-9]{14}$']]
    def validate_AES4EIN(self, value):
        # Validate type AES4EIN, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on AES4EIN' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on AES4EIN' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FilingType is not None or
            self.FTSR is not None or
            self.ITN is not None or
            self.AES4EIN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Filing', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Filing')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Filing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Filing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Filing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Filing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FilingType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FilingType>%s</FilingType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FilingType), input_name='FilingType')), eol_))
        if self.FTSR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FTSR>%s</FTSR>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FTSR), input_name='FTSR')), eol_))
        if self.ITN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ITN>%s</ITN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ITN), input_name='ITN')), eol_))
        if self.AES4EIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AES4EIN>%s</AES4EIN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AES4EIN), input_name='AES4EIN')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FilingType':
            FilingType_ = child_.text
            FilingType_ = self.gds_validate_string(FilingType_, node, 'FilingType')
            self.FilingType = FilingType_
            # validate type FilingType
            self.validate_FilingType(self.FilingType)
        elif nodeName_ == 'FTSR':
            FTSR_ = child_.text
            FTSR_ = self.gds_validate_string(FTSR_, node, 'FTSR')
            self.FTSR = FTSR_
            # validate type FTSR
            self.validate_FTSR(self.FTSR)
        elif nodeName_ == 'ITN':
            ITN_ = child_.text
            ITN_ = self.gds_validate_string(ITN_, node, 'ITN')
            self.ITN = ITN_
            # validate type ITN
            self.validate_ITN(self.ITN)
        elif nodeName_ == 'AES4EIN':
            AES4EIN_ = child_.text
            AES4EIN_ = self.gds_validate_string(AES4EIN_, node, 'AES4EIN')
            self.AES4EIN = AES4EIN_
            # validate type AES4EIN
            self.validate_AES4EIN(self.AES4EIN)
# end class Filing


class ExportDeclaration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InterConsignee=None, IsPartiesRelation=None, ECCN=None, SignatureName=None, SignatureTitle=None, ExportReason=None, ExportReasonCode=None, SedNumber=None, SedNumberType=None, MxStateCode=None, ExportLineItem=None):
        self.original_tagname_ = None
        self.InterConsignee = InterConsignee
        self.validate_InterConsigneeType(self.InterConsignee)
        self.IsPartiesRelation = IsPartiesRelation
        self.validate_YesNo(self.IsPartiesRelation)
        self.ECCN = ECCN
        self.validate_ECCNType(self.ECCN)
        self.SignatureName = SignatureName
        self.validate_SignatureName(self.SignatureName)
        self.SignatureTitle = SignatureTitle
        self.validate_SignatureTitle(self.SignatureTitle)
        self.ExportReason = ExportReason
        self.validate_ExportReason(self.ExportReason)
        self.ExportReasonCode = ExportReasonCode
        self.validate_ExportReasonCode(self.ExportReasonCode)
        self.SedNumber = SedNumber
        self.validate_SEDNumber(self.SedNumber)
        self.SedNumberType = SedNumberType
        self.validate_SEDNumberType(self.SedNumberType)
        self.MxStateCode = MxStateCode
        self.validate_MxStateCodeType(self.MxStateCode)
        if ExportLineItem is None:
            self.ExportLineItem = []
        else:
            self.ExportLineItem = ExportLineItem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExportDeclaration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExportDeclaration.subclass:
            return ExportDeclaration.subclass(*args_, **kwargs_)
        else:
            return ExportDeclaration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InterConsignee(self): return self.InterConsignee
    def set_InterConsignee(self, InterConsignee): self.InterConsignee = InterConsignee
    def get_IsPartiesRelation(self): return self.IsPartiesRelation
    def set_IsPartiesRelation(self, IsPartiesRelation): self.IsPartiesRelation = IsPartiesRelation
    def get_ECCN(self): return self.ECCN
    def set_ECCN(self, ECCN): self.ECCN = ECCN
    def get_SignatureName(self): return self.SignatureName
    def set_SignatureName(self, SignatureName): self.SignatureName = SignatureName
    def get_SignatureTitle(self): return self.SignatureTitle
    def set_SignatureTitle(self, SignatureTitle): self.SignatureTitle = SignatureTitle
    def get_ExportReason(self): return self.ExportReason
    def set_ExportReason(self, ExportReason): self.ExportReason = ExportReason
    def get_ExportReasonCode(self): return self.ExportReasonCode
    def set_ExportReasonCode(self, ExportReasonCode): self.ExportReasonCode = ExportReasonCode
    def get_SedNumber(self): return self.SedNumber
    def set_SedNumber(self, SedNumber): self.SedNumber = SedNumber
    def get_SedNumberType(self): return self.SedNumberType
    def set_SedNumberType(self, SedNumberType): self.SedNumberType = SedNumberType
    def get_MxStateCode(self): return self.MxStateCode
    def set_MxStateCode(self, MxStateCode): self.MxStateCode = MxStateCode
    def get_ExportLineItem(self): return self.ExportLineItem
    def set_ExportLineItem(self, ExportLineItem): self.ExportLineItem = ExportLineItem
    def add_ExportLineItem(self, value): self.ExportLineItem.append(value)
    def insert_ExportLineItem_at(self, index, value): self.ExportLineItem.insert(index, value)
    def replace_ExportLineItem_at(self, index, value): self.ExportLineItem[index] = value
    def validate_InterConsigneeType(self, value):
        # Validate type InterConsigneeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 70:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on InterConsigneeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on InterConsigneeType' % {"value" : value.encode("utf-8")} )
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on YesNo' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on YesNo' % {"value" : value.encode("utf-8")} )
    def validate_ECCNType(self, value):
        # Validate type ECCNType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ECCNType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ECCNType' % {"value" : value.encode("utf-8")} )
    def validate_SignatureName(self, value):
        # Validate type SignatureName, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SignatureName' % {"value" : value.encode("utf-8")} )
    def validate_SignatureTitle(self, value):
        # Validate type SignatureTitle, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SignatureTitle' % {"value" : value.encode("utf-8")} )
    def validate_ExportReason(self, value):
        # Validate type ExportReason, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ExportReason' % {"value" : value.encode("utf-8")} )
    def validate_ExportReasonCode(self, value):
        # Validate type ExportReasonCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['P', 'T', 'R']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ExportReasonCode' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ExportReasonCode' % {"value" : value.encode("utf-8")} )
    def validate_SEDNumber(self, value):
        # Validate type SEDNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FTSR', 'XTN', 'SAS', 'ITN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SEDNumber' % {"value" : value.encode("utf-8")} )
    def validate_SEDNumberType(self, value):
        # Validate type SEDNumberType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['F', 'X', 'S', 'I']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SEDNumberType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on SEDNumberType' % {"value" : value.encode("utf-8")} )
    def validate_MxStateCodeType(self, value):
        # Validate type MxStateCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on MxStateCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on MxStateCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InterConsignee is not None or
            self.IsPartiesRelation is not None or
            self.ECCN is not None or
            self.SignatureName is not None or
            self.SignatureTitle is not None or
            self.ExportReason is not None or
            self.ExportReasonCode is not None or
            self.SedNumber is not None or
            self.SedNumberType is not None or
            self.MxStateCode is not None or
            self.ExportLineItem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExportDeclaration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExportDeclaration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExportDeclaration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExportDeclaration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExportDeclaration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExportDeclaration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InterConsignee is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<InterConsignee>%s</InterConsignee>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.InterConsignee), input_name='InterConsignee')), eol_))
        if self.IsPartiesRelation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IsPartiesRelation>%s</IsPartiesRelation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IsPartiesRelation), input_name='IsPartiesRelation')), eol_))
        if self.ECCN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ECCN>%s</ECCN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ECCN), input_name='ECCN')), eol_))
        if self.SignatureName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SignatureName>%s</SignatureName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SignatureName), input_name='SignatureName')), eol_))
        if self.SignatureTitle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SignatureTitle>%s</SignatureTitle>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SignatureTitle), input_name='SignatureTitle')), eol_))
        if self.ExportReason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ExportReason>%s</ExportReason>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ExportReason), input_name='ExportReason')), eol_))
        if self.ExportReasonCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ExportReasonCode>%s</ExportReasonCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ExportReasonCode), input_name='ExportReasonCode')), eol_))
        if self.SedNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SedNumber>%s</SedNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SedNumber), input_name='SedNumber')), eol_))
        if self.SedNumberType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SedNumberType>%s</SedNumberType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SedNumberType), input_name='SedNumberType')), eol_))
        if self.MxStateCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MxStateCode>%s</MxStateCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MxStateCode), input_name='MxStateCode')), eol_))
        for ExportLineItem_ in self.ExportLineItem:
            ExportLineItem_.export(outfile, level, namespace_, name_='ExportLineItem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InterConsignee':
            InterConsignee_ = child_.text
            InterConsignee_ = self.gds_validate_string(InterConsignee_, node, 'InterConsignee')
            self.InterConsignee = InterConsignee_
            # validate type InterConsigneeType
            self.validate_InterConsigneeType(self.InterConsignee)
        elif nodeName_ == 'IsPartiesRelation':
            IsPartiesRelation_ = child_.text
            IsPartiesRelation_ = self.gds_validate_string(IsPartiesRelation_, node, 'IsPartiesRelation')
            self.IsPartiesRelation = IsPartiesRelation_
            # validate type YesNo
            self.validate_YesNo(self.IsPartiesRelation)
        elif nodeName_ == 'ECCN':
            ECCN_ = child_.text
            ECCN_ = self.gds_validate_string(ECCN_, node, 'ECCN')
            self.ECCN = ECCN_
            # validate type ECCNType
            self.validate_ECCNType(self.ECCN)
        elif nodeName_ == 'SignatureName':
            SignatureName_ = child_.text
            SignatureName_ = self.gds_validate_string(SignatureName_, node, 'SignatureName')
            self.SignatureName = SignatureName_
            # validate type SignatureName
            self.validate_SignatureName(self.SignatureName)
        elif nodeName_ == 'SignatureTitle':
            SignatureTitle_ = child_.text
            SignatureTitle_ = self.gds_validate_string(SignatureTitle_, node, 'SignatureTitle')
            self.SignatureTitle = SignatureTitle_
            # validate type SignatureTitle
            self.validate_SignatureTitle(self.SignatureTitle)
        elif nodeName_ == 'ExportReason':
            ExportReason_ = child_.text
            ExportReason_ = self.gds_validate_string(ExportReason_, node, 'ExportReason')
            self.ExportReason = ExportReason_
            # validate type ExportReason
            self.validate_ExportReason(self.ExportReason)
        elif nodeName_ == 'ExportReasonCode':
            ExportReasonCode_ = child_.text
            ExportReasonCode_ = self.gds_validate_string(ExportReasonCode_, node, 'ExportReasonCode')
            self.ExportReasonCode = ExportReasonCode_
            # validate type ExportReasonCode
            self.validate_ExportReasonCode(self.ExportReasonCode)
        elif nodeName_ == 'SedNumber':
            SedNumber_ = child_.text
            SedNumber_ = self.gds_validate_string(SedNumber_, node, 'SedNumber')
            self.SedNumber = SedNumber_
            # validate type SEDNumber
            self.validate_SEDNumber(self.SedNumber)
        elif nodeName_ == 'SedNumberType':
            SedNumberType_ = child_.text
            SedNumberType_ = self.gds_validate_string(SedNumberType_, node, 'SedNumberType')
            self.SedNumberType = SedNumberType_
            # validate type SEDNumberType
            self.validate_SEDNumberType(self.SedNumberType)
        elif nodeName_ == 'MxStateCode':
            MxStateCode_ = child_.text
            MxStateCode_ = self.gds_validate_string(MxStateCode_, node, 'MxStateCode')
            self.MxStateCode = MxStateCode_
            # validate type MxStateCodeType
            self.validate_MxStateCodeType(self.MxStateCode)
        elif nodeName_ == 'ExportLineItem':
            obj_ = ExportLineItem.factory()
            obj_.build(child_)
            self.ExportLineItem.append(obj_)
            obj_.original_tagname_ = 'ExportLineItem'
# end class ExportDeclaration


class ExportLineItem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LineNumber=None, Quantity=None, QuantityUnit=None, Description=None, Value=None, IsDomestic=None, CommodityCode=None, ScheduleB=None, ECCN=None, Weight=None, License=None, LicenseSymbol=None, ManufactureCountryCode=None):
        self.original_tagname_ = None
        self.LineNumber = LineNumber
        self.validate_LineNumber(self.LineNumber)
        self.Quantity = Quantity
        self.validate_Quantity(self.Quantity)
        self.QuantityUnit = QuantityUnit
        self.validate_QuantityUnit(self.QuantityUnit)
        self.Description = Description
        self.validate_DescriptionType(self.Description)
        self.Value = Value
        self.validate_ValueType(self.Value)
        self.IsDomestic = IsDomestic
        self.validate_YesNo(self.IsDomestic)
        self.CommodityCode = CommodityCode
        self.validate_CommodityCode(self.CommodityCode)
        self.ScheduleB = ScheduleB
        self.validate_ScheduleB(self.ScheduleB)
        self.ECCN = ECCN
        self.validate_ECCNType3(self.ECCN)
        self.Weight = Weight
        self.License = License
        self.LicenseSymbol = LicenseSymbol
        self.validate_LicenseNumber(self.LicenseSymbol)
        self.ManufactureCountryCode = ManufactureCountryCode
        self.validate_CountryCode(self.ManufactureCountryCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExportLineItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExportLineItem.subclass:
            return ExportLineItem.subclass(*args_, **kwargs_)
        else:
            return ExportLineItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LineNumber(self): return self.LineNumber
    def set_LineNumber(self, LineNumber): self.LineNumber = LineNumber
    def get_Quantity(self): return self.Quantity
    def set_Quantity(self, Quantity): self.Quantity = Quantity
    def get_QuantityUnit(self): return self.QuantityUnit
    def set_QuantityUnit(self, QuantityUnit): self.QuantityUnit = QuantityUnit
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_IsDomestic(self): return self.IsDomestic
    def set_IsDomestic(self, IsDomestic): self.IsDomestic = IsDomestic
    def get_CommodityCode(self): return self.CommodityCode
    def set_CommodityCode(self, CommodityCode): self.CommodityCode = CommodityCode
    def get_ScheduleB(self): return self.ScheduleB
    def set_ScheduleB(self, ScheduleB): self.ScheduleB = ScheduleB
    def get_ECCN(self): return self.ECCN
    def set_ECCN(self, ECCN): self.ECCN = ECCN
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_License(self): return self.License
    def set_License(self, License): self.License = License
    def get_LicenseSymbol(self): return self.LicenseSymbol
    def set_LicenseSymbol(self, LicenseSymbol): self.LicenseSymbol = LicenseSymbol
    def get_ManufactureCountryCode(self): return self.ManufactureCountryCode
    def set_ManufactureCountryCode(self, ManufactureCountryCode): self.ManufactureCountryCode = ManufactureCountryCode
    def validate_LineNumber(self, value):
        # Validate type LineNumber, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on LineNumber' % {"value" : value} )
            if value > 200:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on LineNumber' % {"value" : value} )
    def validate_Quantity(self, value):
        # Validate type Quantity, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_QuantityUnit(self, value):
        # Validate type QuantityUnit, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 8:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on QuantityUnit' % {"value" : value.encode("utf-8")} )
    def validate_DescriptionType(self, value):
        # Validate type DescriptionType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 75:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DescriptionType' % {"value" : value.encode("utf-8")} )
    def validate_ValueType(self, value):
        # Validate type ValueType, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.00:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on ValueType' % {"value" : value} )
            if value > 9999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ValueType' % {"value" : value} )
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on YesNo' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on YesNo' % {"value" : value.encode("utf-8")} )
    def validate_CommodityCode(self, value):
        # Validate type CommodityCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CommodityCode' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CommodityCode' % {"value" : value.encode("utf-8")} )
    def validate_ScheduleB(self, value):
        # Validate type ScheduleB, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ScheduleB' % {"value" : value.encode("utf-8")} )
    def validate_ECCNType3(self, value):
        # Validate type ECCNType3, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ECCNType3' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ECCNType3' % {"value" : value.encode("utf-8")} )
    def validate_LicenseNumber(self, value):
        # Validate type LicenseNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 16:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LicenseNumber' % {"value" : value.encode("utf-8")} )
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CountryCode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LineNumber is not None or
            self.Quantity is not None or
            self.QuantityUnit is not None or
            self.Description is not None or
            self.Value is not None or
            self.IsDomestic is not None or
            self.CommodityCode is not None or
            self.ScheduleB is not None or
            self.ECCN is not None or
            self.Weight is not None or
            self.License is not None or
            self.LicenseSymbol is not None or
            self.ManufactureCountryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExportLineItem', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExportLineItem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExportLineItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExportLineItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExportLineItem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExportLineItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LineNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LineNumber>%s</LineNumber>%s' % (self.gds_format_integer(self.LineNumber, input_name='LineNumber'), eol_))
        if self.Quantity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Quantity>%s</Quantity>%s' % (self.gds_format_integer(self.Quantity, input_name='Quantity'), eol_))
        if self.QuantityUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<QuantityUnit>%s</QuantityUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.QuantityUnit), input_name='QuantityUnit')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Description>%s</Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Value>%s</Value>%s' % (self.gds_format_float(self.Value, input_name='Value'), eol_))
        if self.IsDomestic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IsDomestic>%s</IsDomestic>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IsDomestic), input_name='IsDomestic')), eol_))
        if self.CommodityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CommodityCode>%s</CommodityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CommodityCode), input_name='CommodityCode')), eol_))
        if self.ScheduleB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ScheduleB>%s</ScheduleB>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ScheduleB), input_name='ScheduleB')), eol_))
        if self.ECCN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ECCN>%s</ECCN>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ECCN), input_name='ECCN')), eol_))
        if self.Weight is not None:
            self.Weight.export(outfile, level, namespace_, name_='Weight', pretty_print=pretty_print)
        if self.License is not None:
            self.License.export(outfile, level, namespace_, name_='License', pretty_print=pretty_print)
        if self.LicenseSymbol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LicenseSymbol>%s</LicenseSymbol>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LicenseSymbol), input_name='LicenseSymbol')), eol_))
        if self.ManufactureCountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ManufactureCountryCode>%s</ManufactureCountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ManufactureCountryCode), input_name='ManufactureCountryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LineNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'LineNumber')
            self.LineNumber = ival_
            # validate type LineNumber
            self.validate_LineNumber(self.LineNumber)
        elif nodeName_ == 'Quantity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Quantity')
            self.Quantity = ival_
            # validate type Quantity
            self.validate_Quantity(self.Quantity)
        elif nodeName_ == 'QuantityUnit':
            QuantityUnit_ = child_.text
            QuantityUnit_ = self.gds_validate_string(QuantityUnit_, node, 'QuantityUnit')
            self.QuantityUnit = QuantityUnit_
            # validate type QuantityUnit
            self.validate_QuantityUnit(self.QuantityUnit)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
            # validate type DescriptionType
            self.validate_DescriptionType(self.Description)
        elif nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
            # validate type ValueType
            self.validate_ValueType(self.Value)
        elif nodeName_ == 'IsDomestic':
            IsDomestic_ = child_.text
            IsDomestic_ = self.gds_validate_string(IsDomestic_, node, 'IsDomestic')
            self.IsDomestic = IsDomestic_
            # validate type YesNo
            self.validate_YesNo(self.IsDomestic)
        elif nodeName_ == 'CommodityCode':
            CommodityCode_ = child_.text
            CommodityCode_ = self.gds_validate_string(CommodityCode_, node, 'CommodityCode')
            self.CommodityCode = CommodityCode_
            # validate type CommodityCode
            self.validate_CommodityCode(self.CommodityCode)
        elif nodeName_ == 'ScheduleB':
            ScheduleB_ = child_.text
            ScheduleB_ = self.gds_validate_string(ScheduleB_, node, 'ScheduleB')
            self.ScheduleB = ScheduleB_
            # validate type ScheduleB
            self.validate_ScheduleB(self.ScheduleB)
        elif nodeName_ == 'ECCN':
            ECCN_ = child_.text
            ECCN_ = self.gds_validate_string(ECCN_, node, 'ECCN')
            self.ECCN = ECCN_
            # validate type ECCNType3
            self.validate_ECCNType3(self.ECCN)
        elif nodeName_ == 'Weight':
            obj_ = WeightType.factory()
            obj_.build(child_)
            self.Weight = obj_
            obj_.original_tagname_ = 'Weight'
        elif nodeName_ == 'License':
            obj_ = LicenseType.factory()
            obj_.build(child_)
            self.License = obj_
            obj_.original_tagname_ = 'License'
        elif nodeName_ == 'LicenseSymbol':
            LicenseSymbol_ = child_.text
            LicenseSymbol_ = self.gds_validate_string(LicenseSymbol_, node, 'LicenseSymbol')
            self.LicenseSymbol = LicenseSymbol_
            # validate type LicenseNumber
            self.validate_LicenseNumber(self.LicenseSymbol)
        elif nodeName_ == 'ManufactureCountryCode':
            ManufactureCountryCode_ = child_.text
            ManufactureCountryCode_ = self.gds_validate_string(ManufactureCountryCode_, node, 'ManufactureCountryCode')
            self.ManufactureCountryCode = ManufactureCountryCode_
            # validate type CountryCode
            self.validate_CountryCode(self.ManufactureCountryCode)
# end class ExportLineItem


class Piece(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PieceID=None, PackageType=None, Weight=None, DimWeight=None, Width=None, Height=None, Depth=None, PieceContents=None, PieceReference=None):
        self.original_tagname_ = None
        self.PieceID = PieceID
        self.validate_PieceID(self.PieceID)
        self.PackageType = PackageType
        self.validate_PackageType(self.PackageType)
        self.Weight = Weight
        self.validate_Weight(self.Weight)
        self.DimWeight = DimWeight
        self.validate_Weight(self.DimWeight)
        self.Width = Width
        self.Height = Height
        self.Depth = Depth
        self.PieceContents = PieceContents
        self.validate_PieceContents(self.PieceContents)
        if PieceReference is None:
            self.PieceReference = []
        else:
            self.PieceReference = PieceReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Piece)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Piece.subclass:
            return Piece.subclass(*args_, **kwargs_)
        else:
            return Piece(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PieceID(self): return self.PieceID
    def set_PieceID(self, PieceID): self.PieceID = PieceID
    def get_PackageType(self): return self.PackageType
    def set_PackageType(self, PackageType): self.PackageType = PackageType
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_DimWeight(self): return self.DimWeight
    def set_DimWeight(self, DimWeight): self.DimWeight = DimWeight
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Depth(self): return self.Depth
    def set_Depth(self, Depth): self.Depth = Depth
    def get_PieceContents(self): return self.PieceContents
    def set_PieceContents(self, PieceContents): self.PieceContents = PieceContents
    def get_PieceReference(self): return self.PieceReference
    def set_PieceReference(self, PieceReference): self.PieceReference = PieceReference
    def add_PieceReference(self, value): self.PieceReference.append(value)
    def insert_PieceReference_at(self, index, value): self.PieceReference.insert(index, value)
    def replace_PieceReference_at(self, index, value): self.PieceReference[index] = value
    def validate_PieceID(self, value):
        # Validate type PieceID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PieceID' % {"value" : value.encode("utf-8")} )
    def validate_PackageType(self, value):
        # Validate type PackageType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BD', 'BP', 'CP', 'DC', 'DF', 'DM', 'ED', 'EE', 'FR', 'JB', 'JD', 'JJ', 'JP', 'OD', 'PA', 'YP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PackageType' % {"value" : value.encode("utf-8")} )
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PackageType' % {"value" : value.encode("utf-8")} )
    def validate_Weight(self, value):
        # Validate type Weight, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Weight' % {"value" : value} )
            if value > 999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
    def validate_PieceContents(self, value):
        # Validate type PieceContents, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PieceContents' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PieceID is not None or
            self.PackageType is not None or
            self.Weight is not None or
            self.DimWeight is not None or
            self.Width is not None or
            self.Height is not None or
            self.Depth is not None or
            self.PieceContents is not None or
            self.PieceReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Piece', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Piece')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Piece')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Piece', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Piece'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Piece', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PieceID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PieceID>%s</PieceID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PieceID), input_name='PieceID')), eol_))
        if self.PackageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PackageType>%s</PackageType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackageType), input_name='PackageType')), eol_))
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Weight>%s</Weight>%s' % (self.gds_format_float(self.Weight, input_name='Weight'), eol_))
        if self.DimWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DimWeight>%s</DimWeight>%s' % (self.gds_format_float(self.DimWeight, input_name='DimWeight'), eol_))
        if self.Width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Width>%s</Width>%s' % (self.gds_format_integer(self.Width, input_name='Width'), eol_))
        if self.Height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Height>%s</Height>%s' % (self.gds_format_integer(self.Height, input_name='Height'), eol_))
        if self.Depth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Depth>%s</Depth>%s' % (self.gds_format_integer(self.Depth, input_name='Depth'), eol_))
        if self.PieceContents is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PieceContents>%s</PieceContents>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PieceContents), input_name='PieceContents')), eol_))
        for PieceReference_ in self.PieceReference:
            PieceReference_.export(outfile, level, namespace_, name_='PieceReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PieceID':
            PieceID_ = child_.text
            PieceID_ = self.gds_validate_string(PieceID_, node, 'PieceID')
            self.PieceID = PieceID_
            # validate type PieceID
            self.validate_PieceID(self.PieceID)
        elif nodeName_ == 'PackageType':
            PackageType_ = child_.text
            PackageType_ = self.gds_validate_string(PackageType_, node, 'PackageType')
            self.PackageType = PackageType_
            # validate type PackageType
            self.validate_PackageType(self.PackageType)
        elif nodeName_ == 'Weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Weight')
            self.Weight = fval_
            # validate type Weight
            self.validate_Weight(self.Weight)
        elif nodeName_ == 'DimWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DimWeight')
            self.DimWeight = fval_
            # validate type Weight
            self.validate_Weight(self.DimWeight)
        elif nodeName_ == 'Width':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Width')
            self.Width = ival_
        elif nodeName_ == 'Height':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Height')
            self.Height = ival_
        elif nodeName_ == 'Depth':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Depth')
            self.Depth = ival_
        elif nodeName_ == 'PieceContents':
            PieceContents_ = child_.text
            PieceContents_ = self.gds_validate_string(PieceContents_, node, 'PieceContents')
            self.PieceContents = PieceContents_
            # validate type PieceContents
            self.validate_PieceContents(self.PieceContents)
        elif nodeName_ == 'PieceReference':
            obj_ = Reference.factory()
            obj_.build(child_)
            self.PieceReference.append(obj_)
            obj_.original_tagname_ = 'PieceReference'
# end class Piece


class Pieces(GeneratedsSuper):
    """Element encapsulating peices information"""
    subclass = None
    superclass = None
    def __init__(self, Piece=None):
        self.original_tagname_ = None
        if Piece is None:
            self.Piece = []
        else:
            self.Piece = Piece
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Pieces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Pieces.subclass:
            return Pieces.subclass(*args_, **kwargs_)
        else:
            return Pieces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Piece(self): return self.Piece
    def set_Piece(self, Piece): self.Piece = Piece
    def add_Piece(self, value): self.Piece.append(value)
    def insert_Piece_at(self, index, value): self.Piece.insert(index, value)
    def replace_Piece_at(self, index, value): self.Piece[index] = value
    def hasContent_(self):
        if (
            self.Piece
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Pieces', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Pieces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Pieces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Pieces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Pieces'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Pieces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Piece_ in self.Piece:
            Piece_.export(outfile, level, namespace_, name_='Piece', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Piece':
            obj_ = Piece.factory()
            obj_.build(child_)
            self.Piece.append(obj_)
            obj_.original_tagname_ = 'Piece'
# end class Pieces


class ShipValResponsePiece(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PieceNumber=None, Depth=None, Width=None, Height=None, Weight=None, PackageType=None, DimWeight=None, PieceContents=None, PieceReference=None, DataIdentifier=None, LicensePlate=None, LicensePlateBarCode=None):
        self.original_tagname_ = None
        self.PieceNumber = PieceNumber
        self.validate_PieceNumber(self.PieceNumber)
        self.Depth = Depth
        self.Width = Width
        self.Height = Height
        self.Weight = Weight
        self.validate_Weight(self.Weight)
        self.PackageType = PackageType
        self.validate_PackageType(self.PackageType)
        self.DimWeight = DimWeight
        self.validate_Weight(self.DimWeight)
        self.PieceContents = PieceContents
        self.validate_PieceContents(self.PieceContents)
        if PieceReference is None:
            self.PieceReference = []
        else:
            self.PieceReference = PieceReference
        self.DataIdentifier = DataIdentifier
        self.LicensePlate = LicensePlate
        self.validate_PieceID(self.LicensePlate)
        self.LicensePlateBarCode = LicensePlateBarCode
        self.validate_BarCode(self.LicensePlateBarCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipValResponsePiece)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipValResponsePiece.subclass:
            return ShipValResponsePiece.subclass(*args_, **kwargs_)
        else:
            return ShipValResponsePiece(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PieceNumber(self): return self.PieceNumber
    def set_PieceNumber(self, PieceNumber): self.PieceNumber = PieceNumber
    def get_Depth(self): return self.Depth
    def set_Depth(self, Depth): self.Depth = Depth
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_PackageType(self): return self.PackageType
    def set_PackageType(self, PackageType): self.PackageType = PackageType
    def get_DimWeight(self): return self.DimWeight
    def set_DimWeight(self, DimWeight): self.DimWeight = DimWeight
    def get_PieceContents(self): return self.PieceContents
    def set_PieceContents(self, PieceContents): self.PieceContents = PieceContents
    def get_PieceReference(self): return self.PieceReference
    def set_PieceReference(self, PieceReference): self.PieceReference = PieceReference
    def add_PieceReference(self, value): self.PieceReference.append(value)
    def insert_PieceReference_at(self, index, value): self.PieceReference.insert(index, value)
    def replace_PieceReference_at(self, index, value): self.PieceReference[index] = value
    def get_DataIdentifier(self): return self.DataIdentifier
    def set_DataIdentifier(self, DataIdentifier): self.DataIdentifier = DataIdentifier
    def get_LicensePlate(self): return self.LicensePlate
    def set_LicensePlate(self, LicensePlate): self.LicensePlate = LicensePlate
    def get_LicensePlateBarCode(self): return self.LicensePlateBarCode
    def set_LicensePlateBarCode(self, LicensePlateBarCode): self.LicensePlateBarCode = LicensePlateBarCode
    def validate_PieceNumber(self, value):
        # Validate type PieceNumber, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Weight(self, value):
        # Validate type Weight, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Weight' % {"value" : value} )
            if value > 999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
    def validate_PackageType(self, value):
        # Validate type PackageType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BD', 'BP', 'CP', 'DC', 'DF', 'DM', 'ED', 'EE', 'FR', 'JB', 'JD', 'JJ', 'JP', 'OD', 'PA', 'YP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PackageType' % {"value" : value.encode("utf-8")} )
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PackageType' % {"value" : value.encode("utf-8")} )
    def validate_PieceContents(self, value):
        # Validate type PieceContents, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PieceContents' % {"value" : value.encode("utf-8")} )
    def validate_PieceID(self, value):
        # Validate type PieceID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PieceID' % {"value" : value.encode("utf-8")} )
    def validate_BarCode(self, value):
        # Validate type BarCode, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.PieceNumber is not None or
            self.Depth is not None or
            self.Width is not None or
            self.Height is not None or
            self.Weight is not None or
            self.PackageType is not None or
            self.DimWeight is not None or
            self.PieceContents is not None or
            self.PieceReference or
            self.DataIdentifier is not None or
            self.LicensePlate is not None or
            self.LicensePlateBarCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShipValResponsePiece', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipValResponsePiece')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipValResponsePiece')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ShipValResponsePiece', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShipValResponsePiece'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ShipValResponsePiece', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PieceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PieceNumber>%s</PieceNumber>%s' % (self.gds_format_integer(self.PieceNumber, input_name='PieceNumber'), eol_))
        if self.Depth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Depth>%s</Depth>%s' % (self.gds_format_integer(self.Depth, input_name='Depth'), eol_))
        if self.Width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Width>%s</Width>%s' % (self.gds_format_integer(self.Width, input_name='Width'), eol_))
        if self.Height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Height>%s</Height>%s' % (self.gds_format_integer(self.Height, input_name='Height'), eol_))
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Weight>%s</Weight>%s' % (self.gds_format_float(self.Weight, input_name='Weight'), eol_))
        if self.PackageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PackageType>%s</PackageType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackageType), input_name='PackageType')), eol_))
        if self.DimWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DimWeight>%s</DimWeight>%s' % (self.gds_format_float(self.DimWeight, input_name='DimWeight'), eol_))
        if self.PieceContents is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PieceContents>%s</PieceContents>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PieceContents), input_name='PieceContents')), eol_))
        for PieceReference_ in self.PieceReference:
            PieceReference_.export(outfile, level, namespace_, name_='PieceReference', pretty_print=pretty_print)
        if self.DataIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DataIdentifier>%s</DataIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataIdentifier), input_name='DataIdentifier')), eol_))
        if self.LicensePlate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LicensePlate>%s</LicensePlate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LicensePlate), input_name='LicensePlate')), eol_))
        if self.LicensePlateBarCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LicensePlateBarCode>%s</LicensePlateBarCode>%s' % (self.gds_format_base64(self.LicensePlateBarCode, input_name='LicensePlateBarCode'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PieceNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'PieceNumber')
            self.PieceNumber = ival_
            # validate type PieceNumber
            self.validate_PieceNumber(self.PieceNumber)
        elif nodeName_ == 'Depth':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Depth')
            self.Depth = ival_
        elif nodeName_ == 'Width':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Width')
            self.Width = ival_
        elif nodeName_ == 'Height':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Height')
            self.Height = ival_
        elif nodeName_ == 'Weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Weight')
            self.Weight = fval_
            # validate type Weight
            self.validate_Weight(self.Weight)
        elif nodeName_ == 'PackageType':
            PackageType_ = child_.text
            PackageType_ = self.gds_validate_string(PackageType_, node, 'PackageType')
            self.PackageType = PackageType_
            # validate type PackageType
            self.validate_PackageType(self.PackageType)
        elif nodeName_ == 'DimWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DimWeight')
            self.DimWeight = fval_
            # validate type Weight
            self.validate_Weight(self.DimWeight)
        elif nodeName_ == 'PieceContents':
            PieceContents_ = child_.text
            PieceContents_ = self.gds_validate_string(PieceContents_, node, 'PieceContents')
            self.PieceContents = PieceContents_
            # validate type PieceContents
            self.validate_PieceContents(self.PieceContents)
        elif nodeName_ == 'PieceReference':
            obj_ = Reference.factory()
            obj_.build(child_)
            self.PieceReference.append(obj_)
            obj_.original_tagname_ = 'PieceReference'
        elif nodeName_ == 'DataIdentifier':
            DataIdentifier_ = child_.text
            DataIdentifier_ = self.gds_validate_string(DataIdentifier_, node, 'DataIdentifier')
            self.DataIdentifier = DataIdentifier_
        elif nodeName_ == 'LicensePlate':
            LicensePlate_ = child_.text
            LicensePlate_ = self.gds_validate_string(LicensePlate_, node, 'LicensePlate')
            self.LicensePlate = LicensePlate_
            # validate type PieceID
            self.validate_PieceID(self.LicensePlate)
        elif nodeName_ == 'LicensePlateBarCode':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'LicensePlateBarCode')
            else:
                bval_ = None
            self.LicensePlateBarCode = bval_
            # validate type BarCode
            self.validate_BarCode(self.LicensePlateBarCode)
# end class ShipValResponsePiece


class ShipValResponsePieces(GeneratedsSuper):
    """Element encapsulating pieces information"""
    subclass = None
    superclass = None
    def __init__(self, Piece=None):
        self.original_tagname_ = None
        if Piece is None:
            self.Piece = []
        else:
            self.Piece = Piece
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipValResponsePieces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipValResponsePieces.subclass:
            return ShipValResponsePieces.subclass(*args_, **kwargs_)
        else:
            return ShipValResponsePieces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Piece(self): return self.Piece
    def set_Piece(self, Piece): self.Piece = Piece
    def add_Piece(self, value): self.Piece.append(value)
    def insert_Piece_at(self, index, value): self.Piece.insert(index, value)
    def replace_Piece_at(self, index, value): self.Piece[index] = value
    def hasContent_(self):
        if (
            self.Piece
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShipValResponsePieces', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipValResponsePieces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipValResponsePieces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ShipValResponsePieces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShipValResponsePieces'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ShipValResponsePieces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Piece_ in self.Piece:
            Piece_.export(outfile, level, namespace_, name_='Piece', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Piece':
            obj_ = ShipValResponsePiece.factory()
            obj_.build(child_)
            self.Piece.append(obj_)
            obj_.original_tagname_ = 'Piece'
# end class ShipValResponsePieces


class Place(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ResidenceOrBusiness=None, CompanyName=None, AddressLine=None, City=None, CountryCode=None, DivisionCode=None, Division=None, PostalCode=None, PackageLocation=None, Suburb=None):
        self.original_tagname_ = None
        self.ResidenceOrBusiness = ResidenceOrBusiness
        self.validate_ResidenceOrBusiness(self.ResidenceOrBusiness)
        self.CompanyName = CompanyName
        self.validate_CompanyNameValidator(self.CompanyName)
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.City = City
        self.validate_City(self.City)
        self.CountryCode = CountryCode
        self.validate_CountryCode(self.CountryCode)
        self.DivisionCode = DivisionCode
        self.validate_StateCode(self.DivisionCode)
        self.Division = Division
        self.validate_State(self.Division)
        self.PostalCode = PostalCode
        self.validate_PostalCode(self.PostalCode)
        self.PackageLocation = PackageLocation
        self.validate_PackageLocation(self.PackageLocation)
        self.Suburb = Suburb
        self.validate_Suburb(self.Suburb)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Place)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Place.subclass:
            return Place.subclass(*args_, **kwargs_)
        else:
            return Place(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResidenceOrBusiness(self): return self.ResidenceOrBusiness
    def set_ResidenceOrBusiness(self, ResidenceOrBusiness): self.ResidenceOrBusiness = ResidenceOrBusiness
    def get_CompanyName(self): return self.CompanyName
    def set_CompanyName(self, CompanyName): self.CompanyName = CompanyName
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine_at(self, index, value): self.AddressLine.insert(index, value)
    def replace_AddressLine_at(self, index, value): self.AddressLine[index] = value
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_DivisionCode(self): return self.DivisionCode
    def set_DivisionCode(self, DivisionCode): self.DivisionCode = DivisionCode
    def get_Division(self): return self.Division
    def set_Division(self, Division): self.Division = Division
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_PackageLocation(self): return self.PackageLocation
    def set_PackageLocation(self, PackageLocation): self.PackageLocation = PackageLocation
    def get_Suburb(self): return self.Suburb
    def set_Suburb(self, Suburb): self.Suburb = Suburb
    def validate_ResidenceOrBusiness(self, value):
        # Validate type ResidenceOrBusiness, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['B', 'R', 'C']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ResidenceOrBusiness' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ResidenceOrBusiness' % {"value" : value.encode("utf-8")} )
    def validate_CompanyNameValidator(self, value):
        # Validate type CompanyNameValidator, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CompanyNameValidator' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CompanyNameValidator' % {"value" : value.encode("utf-8")} )
    def validate_AddressLine(self, value):
        # Validate type AddressLine, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on AddressLine' % {"value" : value.encode("utf-8")} )
    def validate_City(self, value):
        # Validate type City, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on City' % {"value" : value.encode("utf-8")} )
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CountryCode' % {"value" : value.encode("utf-8")} )
    def validate_StateCode(self, value):
        # Validate type StateCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on StateCode' % {"value" : value.encode("utf-8")} )
    def validate_State(self, value):
        # Validate type State, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on State' % {"value" : value.encode("utf-8")} )
    def validate_PostalCode(self, value):
        # Validate type PostalCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PostalCode' % {"value" : value.encode("utf-8")} )
    def validate_PackageLocation(self, value):
        # Validate type PackageLocation, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PackageLocation' % {"value" : value.encode("utf-8")} )
    def validate_Suburb(self, value):
        # Validate type Suburb, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Suburb' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ResidenceOrBusiness is not None or
            self.CompanyName is not None or
            self.AddressLine or
            self.City is not None or
            self.CountryCode is not None or
            self.DivisionCode is not None or
            self.Division is not None or
            self.PostalCode is not None or
            self.PackageLocation is not None or
            self.Suburb is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Place', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Place')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Place')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Place', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Place'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Place', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ResidenceOrBusiness is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ResidenceOrBusiness>%s</ResidenceOrBusiness>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ResidenceOrBusiness), input_name='ResidenceOrBusiness')), eol_))
        if self.CompanyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CompanyName>%s</CompanyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompanyName), input_name='CompanyName')), eol_))
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AddressLine>%s</AddressLine>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressLine_), input_name='AddressLine')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<City>%s</City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CountryCode>%s</CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.DivisionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DivisionCode>%s</DivisionCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DivisionCode), input_name='DivisionCode')), eol_))
        if self.Division is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Division>%s</Division>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Division), input_name='Division')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PostalCode>%s</PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.PackageLocation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PackageLocation>%s</PackageLocation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackageLocation), input_name='PackageLocation')), eol_))
        if self.Suburb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Suburb>%s</Suburb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Suburb), input_name='Suburb')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResidenceOrBusiness':
            ResidenceOrBusiness_ = child_.text
            ResidenceOrBusiness_ = self.gds_validate_string(ResidenceOrBusiness_, node, 'ResidenceOrBusiness')
            self.ResidenceOrBusiness = ResidenceOrBusiness_
            # validate type ResidenceOrBusiness
            self.validate_ResidenceOrBusiness(self.ResidenceOrBusiness)
        elif nodeName_ == 'CompanyName':
            CompanyName_ = child_.text
            CompanyName_ = self.gds_validate_string(CompanyName_, node, 'CompanyName')
            self.CompanyName = CompanyName_
            # validate type CompanyNameValidator
            self.validate_CompanyNameValidator(self.CompanyName)
        elif nodeName_ == 'AddressLine':
            AddressLine_ = child_.text
            AddressLine_ = self.gds_validate_string(AddressLine_, node, 'AddressLine')
            self.AddressLine.append(AddressLine_)
            # validate type AddressLine
            self.validate_AddressLine(self.AddressLine[-1])
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
            # validate type City
            self.validate_City(self.City)
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
            # validate type CountryCode
            self.validate_CountryCode(self.CountryCode)
        elif nodeName_ == 'DivisionCode':
            DivisionCode_ = child_.text
            DivisionCode_ = self.gds_validate_string(DivisionCode_, node, 'DivisionCode')
            self.DivisionCode = DivisionCode_
            # validate type StateCode
            self.validate_StateCode(self.DivisionCode)
        elif nodeName_ == 'Division':
            Division_ = child_.text
            Division_ = self.gds_validate_string(Division_, node, 'Division')
            self.Division = Division_
            # validate type State
            self.validate_State(self.Division)
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
            # validate type PostalCode
            self.validate_PostalCode(self.PostalCode)
        elif nodeName_ == 'PackageLocation':
            PackageLocation_ = child_.text
            PackageLocation_ = self.gds_validate_string(PackageLocation_, node, 'PackageLocation')
            self.PackageLocation = PackageLocation_
            # validate type PackageLocation
            self.validate_PackageLocation(self.PackageLocation)
        elif nodeName_ == 'Suburb':
            Suburb_ = child_.text
            Suburb_ = self.gds_validate_string(Suburb_, node, 'Suburb')
            self.Suburb = Suburb_
            # validate type Suburb
            self.validate_Suburb(self.Suburb)
# end class Place


class Reference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReferenceID=None, ReferenceType=None):
        self.original_tagname_ = None
        self.ReferenceID = ReferenceID
        self.validate_ReferenceID(self.ReferenceID)
        self.ReferenceType = ReferenceType
        self.validate_ReferenceType(self.ReferenceType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Reference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Reference.subclass:
            return Reference.subclass(*args_, **kwargs_)
        else:
            return Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReferenceID(self): return self.ReferenceID
    def set_ReferenceID(self, ReferenceID): self.ReferenceID = ReferenceID
    def get_ReferenceType(self): return self.ReferenceType
    def set_ReferenceType(self, ReferenceType): self.ReferenceType = ReferenceType
    def validate_ReferenceID(self, value):
        # Validate type ReferenceID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ReferenceID' % {"value" : value.encode("utf-8")} )
    def validate_ReferenceType(self, value):
        # Validate type ReferenceType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ReferenceType' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ReferenceType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ReferenceID is not None or
            self.ReferenceType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Reference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Reference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Reference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Reference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Reference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReferenceID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ReferenceID>%s</ReferenceID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceID), input_name='ReferenceID')), eol_))
        if self.ReferenceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ReferenceType>%s</ReferenceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReferenceType), input_name='ReferenceType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReferenceID':
            ReferenceID_ = child_.text
            ReferenceID_ = self.gds_validate_string(ReferenceID_, node, 'ReferenceID')
            self.ReferenceID = ReferenceID_
            # validate type ReferenceID
            self.validate_ReferenceID(self.ReferenceID)
        elif nodeName_ == 'ReferenceType':
            ReferenceType_ = child_.text
            ReferenceType_ = self.gds_validate_string(ReferenceType_, node, 'ReferenceType')
            self.ReferenceType = ReferenceType_
            # validate type ReferenceType
            self.validate_ReferenceType(self.ReferenceType)
# end class Reference


class ShipmentDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumberOfPieces=None, Pieces=None, Weight=None, WeightUnit=None, GlobalProductCode=None, LocalProductCode=None, Date=None, Contents=None, DoorTo=None, DimensionUnit=None, InsuredAmount=None, PackageType=None, IsDutiable=None, CurrencyCode=None, AdditionalProtection=None, DOSFlag=None, CustData=None, ShipmentCharges=None):
        self.original_tagname_ = None
        self.NumberOfPieces = NumberOfPieces
        self.validate_NumberOfPiecesType(self.NumberOfPieces)
        self.Pieces = Pieces
        self.Weight = Weight
        self.validate_Weight(self.Weight)
        self.WeightUnit = WeightUnit
        self.validate_WeightUnit(self.WeightUnit)
        self.GlobalProductCode = GlobalProductCode
        self.validate_GlobalProductCode(self.GlobalProductCode)
        self.LocalProductCode = LocalProductCode
        self.validate_LocalProductCode(self.LocalProductCode)
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.Contents = Contents
        self.validate_ShipmentContents(self.Contents)
        self.DoorTo = DoorTo
        self.validate_DoorTo(self.DoorTo)
        self.DimensionUnit = DimensionUnit
        self.validate_DimensionUnit(self.DimensionUnit)
        self.InsuredAmount = InsuredAmount
        self.validate_Money(self.InsuredAmount)
        self.PackageType = PackageType
        self.validate_PackageType(self.PackageType)
        self.IsDutiable = IsDutiable
        self.validate_YesNo(self.IsDutiable)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCode(self.CurrencyCode)
        self.AdditionalProtection = AdditionalProtection
        self.DOSFlag = DOSFlag
        self.validate_YesNo(self.DOSFlag)
        self.CustData = CustData
        self.validate_CustData(self.CustData)
        self.ShipmentCharges = ShipmentCharges
        self.validate_ShipmentCharges(self.ShipmentCharges)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentDetails.subclass:
            return ShipmentDetails.subclass(*args_, **kwargs_)
        else:
            return ShipmentDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberOfPieces(self): return self.NumberOfPieces
    def set_NumberOfPieces(self, NumberOfPieces): self.NumberOfPieces = NumberOfPieces
    def get_Pieces(self): return self.Pieces
    def set_Pieces(self, Pieces): self.Pieces = Pieces
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_WeightUnit(self): return self.WeightUnit
    def set_WeightUnit(self, WeightUnit): self.WeightUnit = WeightUnit
    def get_GlobalProductCode(self): return self.GlobalProductCode
    def set_GlobalProductCode(self, GlobalProductCode): self.GlobalProductCode = GlobalProductCode
    def get_LocalProductCode(self): return self.LocalProductCode
    def set_LocalProductCode(self, LocalProductCode): self.LocalProductCode = LocalProductCode
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Contents(self): return self.Contents
    def set_Contents(self, Contents): self.Contents = Contents
    def get_DoorTo(self): return self.DoorTo
    def set_DoorTo(self, DoorTo): self.DoorTo = DoorTo
    def get_DimensionUnit(self): return self.DimensionUnit
    def set_DimensionUnit(self, DimensionUnit): self.DimensionUnit = DimensionUnit
    def get_InsuredAmount(self): return self.InsuredAmount
    def set_InsuredAmount(self, InsuredAmount): self.InsuredAmount = InsuredAmount
    def get_PackageType(self): return self.PackageType
    def set_PackageType(self, PackageType): self.PackageType = PackageType
    def get_IsDutiable(self): return self.IsDutiable
    def set_IsDutiable(self, IsDutiable): self.IsDutiable = IsDutiable
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_AdditionalProtection(self): return self.AdditionalProtection
    def set_AdditionalProtection(self, AdditionalProtection): self.AdditionalProtection = AdditionalProtection
    def get_DOSFlag(self): return self.DOSFlag
    def set_DOSFlag(self, DOSFlag): self.DOSFlag = DOSFlag
    def get_CustData(self): return self.CustData
    def set_CustData(self, CustData): self.CustData = CustData
    def get_ShipmentCharges(self): return self.ShipmentCharges
    def set_ShipmentCharges(self, ShipmentCharges): self.ShipmentCharges = ShipmentCharges
    def validate_NumberOfPiecesType(self, value):
        # Validate type NumberOfPiecesType, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on NumberOfPiecesType' % {"value" : value} )
            if value > 99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on NumberOfPiecesType' % {"value" : value} )
    def validate_Weight(self, value):
        # Validate type Weight, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Weight' % {"value" : value} )
            if value > 999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
    def validate_WeightUnit(self, value):
        # Validate type WeightUnit, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['K', 'L']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
    def validate_GlobalProductCode(self, value):
        # Validate type GlobalProductCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on GlobalProductCode' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on GlobalProductCode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_GlobalProductCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_GlobalProductCode_patterns_, ))
    validate_GlobalProductCode_patterns_ = [['^([A-Z0-9])*$']]
    def validate_LocalProductCode(self, value):
        # Validate type LocalProductCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LocalProductCode' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on LocalProductCode' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_LocalProductCode_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocalProductCode_patterns_, ))
    validate_LocalProductCode_patterns_ = [['^([A-Z0-9])*$']]
    def validate_Date(self, value):
        # Validate type Date, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_Date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Date_patterns_, ))
    validate_Date_patterns_ = [['^[0-9][0-9][0-9][0-9](-)[0-9][0-9](-)[0-9][0-9]$']]
    def validate_ShipmentContents(self, value):
        # Validate type ShipmentContents, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 90:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ShipmentContents' % {"value" : value.encode("utf-8")} )
    def validate_DoorTo(self, value):
        # Validate type DoorTo, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DD', 'DA', 'AA', 'DC']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DoorTo' % {"value" : value.encode("utf-8")} )
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DoorTo' % {"value" : value.encode("utf-8")} )
    def validate_DimensionUnit(self, value):
        # Validate type DimensionUnit, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['C', 'I']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DimensionUnit' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DimensionUnit' % {"value" : value.encode("utf-8")} )
    def validate_Money(self, value):
        # Validate type Money, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.00:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Money' % {"value" : value} )
            if value > 9999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Money' % {"value" : value} )
    def validate_PackageType(self, value):
        # Validate type PackageType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BD', 'BP', 'CP', 'DC', 'DF', 'DM', 'ED', 'EE', 'FR', 'JB', 'JD', 'JJ', 'JP', 'OD', 'PA', 'YP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PackageType' % {"value" : value.encode("utf-8")} )
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PackageType' % {"value" : value.encode("utf-8")} )
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on YesNo' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on YesNo' % {"value" : value.encode("utf-8")} )
    def validate_CurrencyCode(self, value):
        # Validate type CurrencyCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCode' % {"value" : value.encode("utf-8")} )
    def validate_CustData(self, value):
        # Validate type CustData, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CustData' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CustData' % {"value" : value.encode("utf-8")} )
    def validate_ShipmentCharges(self, value):
        # Validate type ShipmentCharges, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.01:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on ShipmentCharges' % {"value" : value} )
            if value > 99999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ShipmentCharges' % {"value" : value} )
    def hasContent_(self):
        if (
            self.NumberOfPieces is not None or
            self.Pieces is not None or
            self.Weight is not None or
            self.WeightUnit is not None or
            self.GlobalProductCode is not None or
            self.LocalProductCode is not None or
            self.Date is not None or
            self.Contents is not None or
            self.DoorTo is not None or
            self.DimensionUnit is not None or
            self.InsuredAmount is not None or
            self.PackageType is not None or
            self.IsDutiable is not None or
            self.CurrencyCode is not None or
            self.AdditionalProtection is not None or
            self.DOSFlag is not None or
            self.CustData is not None or
            self.ShipmentCharges is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShipmentDetails', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentDetails')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ShipmentDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShipmentDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ShipmentDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberOfPieces is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NumberOfPieces>%s</NumberOfPieces>%s' % (self.gds_format_integer(self.NumberOfPieces, input_name='NumberOfPieces'), eol_))
        if self.Pieces is not None:
            self.Pieces.export(outfile, level, namespace_, name_='Pieces', pretty_print=pretty_print)
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Weight>%s</Weight>%s' % (self.gds_format_float(self.Weight, input_name='Weight'), eol_))
        if self.WeightUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightUnit>%s</WeightUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeightUnit), input_name='WeightUnit')), eol_))
        if self.GlobalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalProductCode>%s</GlobalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalProductCode), input_name='GlobalProductCode')), eol_))
        if self.LocalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductCode>%s</LocalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductCode), input_name='LocalProductCode')), eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Date>%s</Date>%s' % (self.gds_format_date(self.Date, input_name='Date'), eol_))
        if self.Contents is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Contents>%s</Contents>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Contents), input_name='Contents')), eol_))
        if self.DoorTo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DoorTo>%s</DoorTo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DoorTo), input_name='DoorTo')), eol_))
        if self.DimensionUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DimensionUnit>%s</DimensionUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DimensionUnit), input_name='DimensionUnit')), eol_))
        if self.InsuredAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<InsuredAmount>%s</InsuredAmount>%s' % (self.gds_format_float(self.InsuredAmount, input_name='InsuredAmount'), eol_))
        if self.PackageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PackageType>%s</PackageType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackageType), input_name='PackageType')), eol_))
        if self.IsDutiable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IsDutiable>%s</IsDutiable>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IsDutiable), input_name='IsDutiable')), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.AdditionalProtection is not None:
            self.AdditionalProtection.export(outfile, level, namespace_, name_='AdditionalProtection', pretty_print=pretty_print)
        if self.DOSFlag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DOSFlag>%s</DOSFlag>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DOSFlag), input_name='DOSFlag')), eol_))
        if self.CustData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CustData>%s</CustData>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustData), input_name='CustData')), eol_))
        if self.ShipmentCharges is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipmentCharges>%s</ShipmentCharges>%s' % (self.gds_format_float(self.ShipmentCharges, input_name='ShipmentCharges'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberOfPieces':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfPieces')
            self.NumberOfPieces = ival_
            # validate type NumberOfPiecesType
            self.validate_NumberOfPiecesType(self.NumberOfPieces)
        elif nodeName_ == 'Pieces':
            obj_ = Pieces.factory()
            obj_.build(child_)
            self.Pieces = obj_
            obj_.original_tagname_ = 'Pieces'
        elif nodeName_ == 'Weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Weight')
            self.Weight = fval_
            # validate type Weight
            self.validate_Weight(self.Weight)
        elif nodeName_ == 'WeightUnit':
            WeightUnit_ = child_.text
            WeightUnit_ = self.gds_validate_string(WeightUnit_, node, 'WeightUnit')
            self.WeightUnit = WeightUnit_
            # validate type WeightUnit
            self.validate_WeightUnit(self.WeightUnit)
        elif nodeName_ == 'GlobalProductCode':
            GlobalProductCode_ = child_.text
            GlobalProductCode_ = self.gds_validate_string(GlobalProductCode_, node, 'GlobalProductCode')
            self.GlobalProductCode = GlobalProductCode_
            # validate type GlobalProductCode
            self.validate_GlobalProductCode(self.GlobalProductCode)
        elif nodeName_ == 'LocalProductCode':
            LocalProductCode_ = child_.text
            LocalProductCode_ = self.gds_validate_string(LocalProductCode_, node, 'LocalProductCode')
            self.LocalProductCode = LocalProductCode_
            # validate type LocalProductCode
            self.validate_LocalProductCode(self.LocalProductCode)
        elif nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
            # validate type Date
            self.validate_Date(self.Date)
        elif nodeName_ == 'Contents':
            Contents_ = child_.text
            Contents_ = self.gds_validate_string(Contents_, node, 'Contents')
            self.Contents = Contents_
            # validate type ShipmentContents
            self.validate_ShipmentContents(self.Contents)
        elif nodeName_ == 'DoorTo':
            DoorTo_ = child_.text
            DoorTo_ = self.gds_validate_string(DoorTo_, node, 'DoorTo')
            self.DoorTo = DoorTo_
            # validate type DoorTo
            self.validate_DoorTo(self.DoorTo)
        elif nodeName_ == 'DimensionUnit':
            DimensionUnit_ = child_.text
            DimensionUnit_ = self.gds_validate_string(DimensionUnit_, node, 'DimensionUnit')
            self.DimensionUnit = DimensionUnit_
            # validate type DimensionUnit
            self.validate_DimensionUnit(self.DimensionUnit)
        elif nodeName_ == 'InsuredAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'InsuredAmount')
            self.InsuredAmount = fval_
            # validate type Money
            self.validate_Money(self.InsuredAmount)
        elif nodeName_ == 'PackageType':
            PackageType_ = child_.text
            PackageType_ = self.gds_validate_string(PackageType_, node, 'PackageType')
            self.PackageType = PackageType_
            # validate type PackageType
            self.validate_PackageType(self.PackageType)
        elif nodeName_ == 'IsDutiable':
            IsDutiable_ = child_.text
            IsDutiable_ = self.gds_validate_string(IsDutiable_, node, 'IsDutiable')
            self.IsDutiable = IsDutiable_
            # validate type YesNo
            self.validate_YesNo(self.IsDutiable)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCode
            self.validate_CurrencyCode(self.CurrencyCode)
        elif nodeName_ == 'AdditionalProtection':
            obj_ = AdditionalProtection.factory()
            obj_.build(child_)
            self.AdditionalProtection = obj_
            obj_.original_tagname_ = 'AdditionalProtection'
        elif nodeName_ == 'DOSFlag':
            DOSFlag_ = child_.text
            DOSFlag_ = self.gds_validate_string(DOSFlag_, node, 'DOSFlag')
            self.DOSFlag = DOSFlag_
            # validate type YesNo
            self.validate_YesNo(self.DOSFlag)
        elif nodeName_ == 'CustData':
            CustData_ = child_.text
            CustData_ = self.gds_validate_string(CustData_, node, 'CustData')
            self.CustData = CustData_
            # validate type CustData
            self.validate_CustData(self.CustData)
        elif nodeName_ == 'ShipmentCharges':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ShipmentCharges')
            self.ShipmentCharges = fval_
            # validate type ShipmentCharges
            self.validate_ShipmentCharges(self.ShipmentCharges)
# end class ShipmentDetails


class AdditionalProtection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Code=None, Value=None):
        self.original_tagname_ = None
        self.Code = Code
        self.validate_Code(self.Code)
        self.Value = Value
        self.validate_Value(self.Value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalProtection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalProtection.subclass:
            return AdditionalProtection.subclass(*args_, **kwargs_)
        else:
            return AdditionalProtection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_Code(self, value):
        # Validate type Code, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AP', 'NR']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Code' % {"value" : value.encode("utf-8")} )
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on Code' % {"value" : value.encode("utf-8")} )
    def validate_Value(self, value):
        # Validate type Value, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value > 9999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Value' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Code is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdditionalProtection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalProtection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalProtection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdditionalProtection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdditionalProtection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AdditionalProtection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Code>%s</Code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Code), input_name='Code')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Value>%s</Value>%s' % (self.gds_format_float(self.Value, input_name='Value'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
            # validate type Code
            self.validate_Code(self.Code)
        elif nodeName_ == 'Value':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Value')
            self.Value = fval_
            # validate type Value
            self.validate_Value(self.Value)
# end class AdditionalProtection


class Shipment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Weight=None, WeightUnit=None, Pieces=None, DoorTo=None, AirwarBillNumber=None, AccountType=None, ProductType=None, GlobalProductType=None, LocalProductType=None, Commodity=None, DeclaredValue=None, DeclaredCurrency=None, InsuredValue=None, InsuredCurrency=None, DimensionalUnit=None, DimensionalWeight=None):
        self.original_tagname_ = None
        self.Weight = Weight
        self.validate_Weight(self.Weight)
        self.WeightUnit = WeightUnit
        self.validate_WeightUnit(self.WeightUnit)
        self.Pieces = Pieces
        self.DoorTo = DoorTo
        self.validate_DoorTo(self.DoorTo)
        self.AirwarBillNumber = AirwarBillNumber
        self.validate_AWBNumber(self.AirwarBillNumber)
        self.AccountType = AccountType
        self.validate_AccountType(self.AccountType)
        self.ProductType = ProductType
        self.GlobalProductType = GlobalProductType
        self.LocalProductType = LocalProductType
        self.Commodity = Commodity
        self.DeclaredValue = DeclaredValue
        self.validate_Money(self.DeclaredValue)
        self.DeclaredCurrency = DeclaredCurrency
        self.validate_CurrencyCode(self.DeclaredCurrency)
        self.InsuredValue = InsuredValue
        self.validate_Money(self.InsuredValue)
        self.InsuredCurrency = InsuredCurrency
        self.validate_CurrencyCode(self.InsuredCurrency)
        self.DimensionalUnit = DimensionalUnit
        self.validate_WeightUnit(self.DimensionalUnit)
        self.DimensionalWeight = DimensionalWeight
        self.validate_Weight(self.DimensionalWeight)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Shipment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Shipment.subclass:
            return Shipment.subclass(*args_, **kwargs_)
        else:
            return Shipment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_WeightUnit(self): return self.WeightUnit
    def set_WeightUnit(self, WeightUnit): self.WeightUnit = WeightUnit
    def get_Pieces(self): return self.Pieces
    def set_Pieces(self, Pieces): self.Pieces = Pieces
    def get_DoorTo(self): return self.DoorTo
    def set_DoorTo(self, DoorTo): self.DoorTo = DoorTo
    def get_AirwarBillNumber(self): return self.AirwarBillNumber
    def set_AirwarBillNumber(self, AirwarBillNumber): self.AirwarBillNumber = AirwarBillNumber
    def get_AccountType(self): return self.AccountType
    def set_AccountType(self, AccountType): self.AccountType = AccountType
    def get_ProductType(self): return self.ProductType
    def set_ProductType(self, ProductType): self.ProductType = ProductType
    def get_GlobalProductType(self): return self.GlobalProductType
    def set_GlobalProductType(self, GlobalProductType): self.GlobalProductType = GlobalProductType
    def get_LocalProductType(self): return self.LocalProductType
    def set_LocalProductType(self, LocalProductType): self.LocalProductType = LocalProductType
    def get_Commodity(self): return self.Commodity
    def set_Commodity(self, Commodity): self.Commodity = Commodity
    def get_DeclaredValue(self): return self.DeclaredValue
    def set_DeclaredValue(self, DeclaredValue): self.DeclaredValue = DeclaredValue
    def get_DeclaredCurrency(self): return self.DeclaredCurrency
    def set_DeclaredCurrency(self, DeclaredCurrency): self.DeclaredCurrency = DeclaredCurrency
    def get_InsuredValue(self): return self.InsuredValue
    def set_InsuredValue(self, InsuredValue): self.InsuredValue = InsuredValue
    def get_InsuredCurrency(self): return self.InsuredCurrency
    def set_InsuredCurrency(self, InsuredCurrency): self.InsuredCurrency = InsuredCurrency
    def get_DimensionalUnit(self): return self.DimensionalUnit
    def set_DimensionalUnit(self, DimensionalUnit): self.DimensionalUnit = DimensionalUnit
    def get_DimensionalWeight(self): return self.DimensionalWeight
    def set_DimensionalWeight(self, DimensionalWeight): self.DimensionalWeight = DimensionalWeight
    def validate_Weight(self, value):
        # Validate type Weight, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Weight' % {"value" : value} )
            if value > 999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
    def validate_WeightUnit(self, value):
        # Validate type WeightUnit, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['K', 'L']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
    def validate_DoorTo(self, value):
        # Validate type DoorTo, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DD', 'DA', 'AA', 'DC']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DoorTo' % {"value" : value.encode("utf-8")} )
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DoorTo' % {"value" : value.encode("utf-8")} )
    def validate_AWBNumber(self, value):
        # Validate type AWBNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on AWBNumber' % {"value" : value.encode("utf-8")} )
    def validate_AccountType(self, value):
        # Validate type AccountType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['D']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AccountType' % {"value" : value.encode("utf-8")} )
    def validate_Money(self, value):
        # Validate type Money, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.00:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Money' % {"value" : value} )
            if value > 9999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Money' % {"value" : value} )
    def validate_CurrencyCode(self, value):
        # Validate type CurrencyCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Weight is not None or
            self.WeightUnit is not None or
            self.Pieces is not None or
            self.DoorTo is not None or
            self.AirwarBillNumber is not None or
            self.AccountType is not None or
            self.ProductType is not None or
            self.GlobalProductType is not None or
            self.LocalProductType is not None or
            self.Commodity is not None or
            self.DeclaredValue is not None or
            self.DeclaredCurrency is not None or
            self.InsuredValue is not None or
            self.InsuredCurrency is not None or
            self.DimensionalUnit is not None or
            self.DimensionalWeight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Shipment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Shipment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Shipment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Shipment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Shipment'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Shipment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Weight>%s</Weight>%s' % (self.gds_format_float(self.Weight, input_name='Weight'), eol_))
        if self.WeightUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightUnit>%s</WeightUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeightUnit), input_name='WeightUnit')), eol_))
        if self.Pieces is not None:
            self.Pieces.export(outfile, level, namespace_, name_='Pieces', pretty_print=pretty_print)
        if self.DoorTo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DoorTo>%s</DoorTo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DoorTo), input_name='DoorTo')), eol_))
        if self.AirwarBillNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AirwarBillNumber>%s</AirwarBillNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AirwarBillNumber), input_name='AirwarBillNumber')), eol_))
        if self.AccountType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AccountType>%s</AccountType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AccountType), input_name='AccountType')), eol_))
        if self.ProductType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ProductType>%s</ProductType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProductType), input_name='ProductType')), eol_))
        if self.GlobalProductType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalProductType>%s</GlobalProductType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalProductType), input_name='GlobalProductType')), eol_))
        if self.LocalProductType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductType>%s</LocalProductType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductType), input_name='LocalProductType')), eol_))
        if self.Commodity is not None:
            self.Commodity.export(outfile, level, namespace_, name_='Commodity', pretty_print=pretty_print)
        if self.DeclaredValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeclaredValue>%s</DeclaredValue>%s' % (self.gds_format_float(self.DeclaredValue, input_name='DeclaredValue'), eol_))
        if self.DeclaredCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeclaredCurrency>%s</DeclaredCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeclaredCurrency), input_name='DeclaredCurrency')), eol_))
        if self.InsuredValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<InsuredValue>%s</InsuredValue>%s' % (self.gds_format_float(self.InsuredValue, input_name='InsuredValue'), eol_))
        if self.InsuredCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<InsuredCurrency>%s</InsuredCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.InsuredCurrency), input_name='InsuredCurrency')), eol_))
        if self.DimensionalUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DimensionalUnit>%s</DimensionalUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DimensionalUnit), input_name='DimensionalUnit')), eol_))
        if self.DimensionalWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DimensionalWeight>%s</DimensionalWeight>%s' % (self.gds_format_float(self.DimensionalWeight, input_name='DimensionalWeight'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Weight')
            self.Weight = fval_
            # validate type Weight
            self.validate_Weight(self.Weight)
        elif nodeName_ == 'WeightUnit':
            WeightUnit_ = child_.text
            WeightUnit_ = self.gds_validate_string(WeightUnit_, node, 'WeightUnit')
            self.WeightUnit = WeightUnit_
            # validate type WeightUnit
            self.validate_WeightUnit(self.WeightUnit)
        elif nodeName_ == 'Pieces':
            obj_ = Pieces.factory()
            obj_.build(child_)
            self.Pieces = obj_
            obj_.original_tagname_ = 'Pieces'
        elif nodeName_ == 'DoorTo':
            DoorTo_ = child_.text
            DoorTo_ = self.gds_validate_string(DoorTo_, node, 'DoorTo')
            self.DoorTo = DoorTo_
            # validate type DoorTo
            self.validate_DoorTo(self.DoorTo)
        elif nodeName_ == 'AirwarBillNumber':
            AirwarBillNumber_ = child_.text
            AirwarBillNumber_ = self.gds_validate_string(AirwarBillNumber_, node, 'AirwarBillNumber')
            self.AirwarBillNumber = AirwarBillNumber_
            # validate type AWBNumber
            self.validate_AWBNumber(self.AirwarBillNumber)
        elif nodeName_ == 'AccountType':
            AccountType_ = child_.text
            AccountType_ = self.gds_validate_string(AccountType_, node, 'AccountType')
            self.AccountType = AccountType_
            # validate type AccountType
            self.validate_AccountType(self.AccountType)
        elif nodeName_ == 'ProductType':
            ProductType_ = child_.text
            ProductType_ = self.gds_validate_string(ProductType_, node, 'ProductType')
            self.ProductType = ProductType_
        elif nodeName_ == 'GlobalProductType':
            GlobalProductType_ = child_.text
            GlobalProductType_ = self.gds_validate_string(GlobalProductType_, node, 'GlobalProductType')
            self.GlobalProductType = GlobalProductType_
        elif nodeName_ == 'LocalProductType':
            LocalProductType_ = child_.text
            LocalProductType_ = self.gds_validate_string(LocalProductType_, node, 'LocalProductType')
            self.LocalProductType = LocalProductType_
        elif nodeName_ == 'Commodity':
            obj_ = Commodity.factory()
            obj_.build(child_)
            self.Commodity = obj_
            obj_.original_tagname_ = 'Commodity'
        elif nodeName_ == 'DeclaredValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DeclaredValue')
            self.DeclaredValue = fval_
            # validate type Money
            self.validate_Money(self.DeclaredValue)
        elif nodeName_ == 'DeclaredCurrency':
            DeclaredCurrency_ = child_.text
            DeclaredCurrency_ = self.gds_validate_string(DeclaredCurrency_, node, 'DeclaredCurrency')
            self.DeclaredCurrency = DeclaredCurrency_
            # validate type CurrencyCode
            self.validate_CurrencyCode(self.DeclaredCurrency)
        elif nodeName_ == 'InsuredValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'InsuredValue')
            self.InsuredValue = fval_
            # validate type Money
            self.validate_Money(self.InsuredValue)
        elif nodeName_ == 'InsuredCurrency':
            InsuredCurrency_ = child_.text
            InsuredCurrency_ = self.gds_validate_string(InsuredCurrency_, node, 'InsuredCurrency')
            self.InsuredCurrency = InsuredCurrency_
            # validate type CurrencyCode
            self.validate_CurrencyCode(self.InsuredCurrency)
        elif nodeName_ == 'DimensionalUnit':
            DimensionalUnit_ = child_.text
            DimensionalUnit_ = self.gds_validate_string(DimensionalUnit_, node, 'DimensionalUnit')
            self.DimensionalUnit = DimensionalUnit_
            # validate type WeightUnit
            self.validate_WeightUnit(self.DimensionalUnit)
        elif nodeName_ == 'DimensionalWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DimensionalWeight')
            self.DimensionalWeight = fval_
            # validate type Weight
            self.validate_Weight(self.DimensionalWeight)
# end class Shipment


class Shipper(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ShipperID=None, CompanyName=None, SuiteDepartmentName=None, RegisteredAccount=None, AddressLine=None, City=None, Division=None, DivisionCode=None, PostalCode=None, OriginServiceAreaCode=None, OriginFacilityCode=None, CountryCode=None, CountryName=None, FederalTaxId=None, StateTaxId=None, Contact=None, Suburb=None):
        self.original_tagname_ = None
        self.ShipperID = ShipperID
        self.validate_ShipperID(self.ShipperID)
        self.CompanyName = CompanyName
        self.validate_CompanyNameValidator(self.CompanyName)
        self.SuiteDepartmentName = SuiteDepartmentName
        self.validate_SuiteDepartmentName(self.SuiteDepartmentName)
        self.RegisteredAccount = RegisteredAccount
        self.validate_AccountNumber(self.RegisteredAccount)
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.City = City
        self.validate_City(self.City)
        self.Division = Division
        self.validate_Division(self.Division)
        self.DivisionCode = DivisionCode
        self.validate_DivisionCode(self.DivisionCode)
        self.PostalCode = PostalCode
        self.validate_PostalCode(self.PostalCode)
        self.OriginServiceAreaCode = OriginServiceAreaCode
        self.validate_OriginServiceAreaCode(self.OriginServiceAreaCode)
        self.OriginFacilityCode = OriginFacilityCode
        self.validate_OriginFacilityCode(self.OriginFacilityCode)
        self.CountryCode = CountryCode
        self.validate_CountryCode(self.CountryCode)
        self.CountryName = CountryName
        self.validate_CountryName(self.CountryName)
        self.FederalTaxId = FederalTaxId
        self.validate_FederalTaxIdType4(self.FederalTaxId)
        self.StateTaxId = StateTaxId
        self.validate_StateTaxIdType5(self.StateTaxId)
        self.Contact = Contact
        self.Suburb = Suburb
        self.validate_Suburb(self.Suburb)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Shipper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Shipper.subclass:
            return Shipper.subclass(*args_, **kwargs_)
        else:
            return Shipper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShipperID(self): return self.ShipperID
    def set_ShipperID(self, ShipperID): self.ShipperID = ShipperID
    def get_CompanyName(self): return self.CompanyName
    def set_CompanyName(self, CompanyName): self.CompanyName = CompanyName
    def get_SuiteDepartmentName(self): return self.SuiteDepartmentName
    def set_SuiteDepartmentName(self, SuiteDepartmentName): self.SuiteDepartmentName = SuiteDepartmentName
    def get_RegisteredAccount(self): return self.RegisteredAccount
    def set_RegisteredAccount(self, RegisteredAccount): self.RegisteredAccount = RegisteredAccount
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine_at(self, index, value): self.AddressLine.insert(index, value)
    def replace_AddressLine_at(self, index, value): self.AddressLine[index] = value
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_Division(self): return self.Division
    def set_Division(self, Division): self.Division = Division
    def get_DivisionCode(self): return self.DivisionCode
    def set_DivisionCode(self, DivisionCode): self.DivisionCode = DivisionCode
    def get_PostalCode(self): return self.PostalCode
    def set_PostalCode(self, PostalCode): self.PostalCode = PostalCode
    def get_OriginServiceAreaCode(self): return self.OriginServiceAreaCode
    def set_OriginServiceAreaCode(self, OriginServiceAreaCode): self.OriginServiceAreaCode = OriginServiceAreaCode
    def get_OriginFacilityCode(self): return self.OriginFacilityCode
    def set_OriginFacilityCode(self, OriginFacilityCode): self.OriginFacilityCode = OriginFacilityCode
    def get_CountryCode(self): return self.CountryCode
    def set_CountryCode(self, CountryCode): self.CountryCode = CountryCode
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_FederalTaxId(self): return self.FederalTaxId
    def set_FederalTaxId(self, FederalTaxId): self.FederalTaxId = FederalTaxId
    def get_StateTaxId(self): return self.StateTaxId
    def set_StateTaxId(self, StateTaxId): self.StateTaxId = StateTaxId
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def get_Suburb(self): return self.Suburb
    def set_Suburb(self, Suburb): self.Suburb = Suburb
    def validate_ShipperID(self, value):
        # Validate type ShipperID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ShipperID' % {"value" : value.encode("utf-8")} )
    def validate_CompanyNameValidator(self, value):
        # Validate type CompanyNameValidator, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CompanyNameValidator' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CompanyNameValidator' % {"value" : value.encode("utf-8")} )
    def validate_SuiteDepartmentName(self, value):
        # Validate type SuiteDepartmentName, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SuiteDepartmentName' % {"value" : value.encode("utf-8")} )
    def validate_AccountNumber(self, value):
        # Validate type AccountNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on AccountNumber' % {"value" : value.encode("utf-8")} )
    def validate_AddressLine(self, value):
        # Validate type AddressLine, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on AddressLine' % {"value" : value.encode("utf-8")} )
    def validate_City(self, value):
        # Validate type City, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on City' % {"value" : value.encode("utf-8")} )
    def validate_Division(self, value):
        # Validate type Division, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Division' % {"value" : value.encode("utf-8")} )
    def validate_DivisionCode(self, value):
        # Validate type DivisionCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DivisionCode' % {"value" : value.encode("utf-8")} )
    def validate_PostalCode(self, value):
        # Validate type PostalCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PostalCode' % {"value" : value.encode("utf-8")} )
    def validate_OriginServiceAreaCode(self, value):
        # Validate type OriginServiceAreaCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on OriginServiceAreaCode' % {"value" : value.encode("utf-8")} )
    def validate_OriginFacilityCode(self, value):
        # Validate type OriginFacilityCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on OriginFacilityCode' % {"value" : value.encode("utf-8")} )
    def validate_CountryCode(self, value):
        # Validate type CountryCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CountryCode' % {"value" : value.encode("utf-8")} )
    def validate_CountryName(self, value):
        # Validate type CountryName, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CountryName' % {"value" : value.encode("utf-8")} )
    def validate_FederalTaxIdType4(self, value):
        # Validate type FederalTaxIdType4, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on FederalTaxIdType4' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on FederalTaxIdType4' % {"value" : value.encode("utf-8")} )
    def validate_StateTaxIdType5(self, value):
        # Validate type StateTaxIdType5, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on StateTaxIdType5' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on StateTaxIdType5' % {"value" : value.encode("utf-8")} )
    def validate_Suburb(self, value):
        # Validate type Suburb, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Suburb' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ShipperID is not None or
            self.CompanyName is not None or
            self.SuiteDepartmentName is not None or
            self.RegisteredAccount is not None or
            self.AddressLine or
            self.City is not None or
            self.Division is not None or
            self.DivisionCode is not None or
            self.PostalCode is not None or
            self.OriginServiceAreaCode is not None or
            self.OriginFacilityCode is not None or
            self.CountryCode is not None or
            self.CountryName is not None or
            self.FederalTaxId is not None or
            self.StateTaxId is not None or
            self.Contact is not None or
            self.Suburb is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Shipper', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Shipper')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Shipper')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Shipper', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Shipper'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Shipper', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ShipperID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipperID>%s</ShipperID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShipperID), input_name='ShipperID')), eol_))
        if self.CompanyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CompanyName>%s</CompanyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompanyName), input_name='CompanyName')), eol_))
        if self.SuiteDepartmentName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SuiteDepartmentName>%s</SuiteDepartmentName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SuiteDepartmentName), input_name='SuiteDepartmentName')), eol_))
        if self.RegisteredAccount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RegisteredAccount>%s</RegisteredAccount>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RegisteredAccount), input_name='RegisteredAccount')), eol_))
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AddressLine>%s</AddressLine>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressLine_), input_name='AddressLine')), eol_))
        if self.City is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<City>%s</City>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.City), input_name='City')), eol_))
        if self.Division is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Division>%s</Division>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Division), input_name='Division')), eol_))
        if self.DivisionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DivisionCode>%s</DivisionCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DivisionCode), input_name='DivisionCode')), eol_))
        if self.PostalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PostalCode>%s</PostalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PostalCode), input_name='PostalCode')), eol_))
        if self.OriginServiceAreaCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OriginServiceAreaCode>%s</OriginServiceAreaCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginServiceAreaCode), input_name='OriginServiceAreaCode')), eol_))
        if self.OriginFacilityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OriginFacilityCode>%s</OriginFacilityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginFacilityCode), input_name='OriginFacilityCode')), eol_))
        if self.CountryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CountryCode>%s</CountryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryCode), input_name='CountryCode')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CountryName>%s</CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.FederalTaxId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FederalTaxId>%s</FederalTaxId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FederalTaxId), input_name='FederalTaxId')), eol_))
        if self.StateTaxId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StateTaxId>%s</StateTaxId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateTaxId), input_name='StateTaxId')), eol_))
        if self.Contact is not None:
            self.Contact.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
        if self.Suburb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Suburb>%s</Suburb>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Suburb), input_name='Suburb')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ShipperID':
            ShipperID_ = child_.text
            ShipperID_ = self.gds_validate_string(ShipperID_, node, 'ShipperID')
            self.ShipperID = ShipperID_
            # validate type ShipperID
            self.validate_ShipperID(self.ShipperID)
        elif nodeName_ == 'CompanyName':
            CompanyName_ = child_.text
            CompanyName_ = self.gds_validate_string(CompanyName_, node, 'CompanyName')
            self.CompanyName = CompanyName_
            # validate type CompanyNameValidator
            self.validate_CompanyNameValidator(self.CompanyName)
        elif nodeName_ == 'SuiteDepartmentName':
            SuiteDepartmentName_ = child_.text
            SuiteDepartmentName_ = self.gds_validate_string(SuiteDepartmentName_, node, 'SuiteDepartmentName')
            self.SuiteDepartmentName = SuiteDepartmentName_
            # validate type SuiteDepartmentName
            self.validate_SuiteDepartmentName(self.SuiteDepartmentName)
        elif nodeName_ == 'RegisteredAccount':
            RegisteredAccount_ = child_.text
            RegisteredAccount_ = self.gds_validate_string(RegisteredAccount_, node, 'RegisteredAccount')
            self.RegisteredAccount = RegisteredAccount_
            # validate type AccountNumber
            self.validate_AccountNumber(self.RegisteredAccount)
        elif nodeName_ == 'AddressLine':
            AddressLine_ = child_.text
            AddressLine_ = self.gds_validate_string(AddressLine_, node, 'AddressLine')
            self.AddressLine.append(AddressLine_)
            # validate type AddressLine
            self.validate_AddressLine(self.AddressLine[-1])
        elif nodeName_ == 'City':
            City_ = child_.text
            City_ = self.gds_validate_string(City_, node, 'City')
            self.City = City_
            # validate type City
            self.validate_City(self.City)
        elif nodeName_ == 'Division':
            Division_ = child_.text
            Division_ = self.gds_validate_string(Division_, node, 'Division')
            self.Division = Division_
            # validate type Division
            self.validate_Division(self.Division)
        elif nodeName_ == 'DivisionCode':
            DivisionCode_ = child_.text
            DivisionCode_ = self.gds_validate_string(DivisionCode_, node, 'DivisionCode')
            self.DivisionCode = DivisionCode_
            # validate type DivisionCode
            self.validate_DivisionCode(self.DivisionCode)
        elif nodeName_ == 'PostalCode':
            PostalCode_ = child_.text
            PostalCode_ = self.gds_validate_string(PostalCode_, node, 'PostalCode')
            self.PostalCode = PostalCode_
            # validate type PostalCode
            self.validate_PostalCode(self.PostalCode)
        elif nodeName_ == 'OriginServiceAreaCode':
            OriginServiceAreaCode_ = child_.text
            OriginServiceAreaCode_ = self.gds_validate_string(OriginServiceAreaCode_, node, 'OriginServiceAreaCode')
            self.OriginServiceAreaCode = OriginServiceAreaCode_
            # validate type OriginServiceAreaCode
            self.validate_OriginServiceAreaCode(self.OriginServiceAreaCode)
        elif nodeName_ == 'OriginFacilityCode':
            OriginFacilityCode_ = child_.text
            OriginFacilityCode_ = self.gds_validate_string(OriginFacilityCode_, node, 'OriginFacilityCode')
            self.OriginFacilityCode = OriginFacilityCode_
            # validate type OriginFacilityCode
            self.validate_OriginFacilityCode(self.OriginFacilityCode)
        elif nodeName_ == 'CountryCode':
            CountryCode_ = child_.text
            CountryCode_ = self.gds_validate_string(CountryCode_, node, 'CountryCode')
            self.CountryCode = CountryCode_
            # validate type CountryCode
            self.validate_CountryCode(self.CountryCode)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName
            self.validate_CountryName(self.CountryName)
        elif nodeName_ == 'FederalTaxId':
            FederalTaxId_ = child_.text
            FederalTaxId_ = self.gds_validate_string(FederalTaxId_, node, 'FederalTaxId')
            self.FederalTaxId = FederalTaxId_
            # validate type FederalTaxIdType4
            self.validate_FederalTaxIdType4(self.FederalTaxId)
        elif nodeName_ == 'StateTaxId':
            StateTaxId_ = child_.text
            StateTaxId_ = self.gds_validate_string(StateTaxId_, node, 'StateTaxId')
            self.StateTaxId = StateTaxId_
            # validate type StateTaxIdType5
            self.validate_StateTaxIdType5(self.StateTaxId)
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.Contact = obj_
            obj_.original_tagname_ = 'Contact'
        elif nodeName_ == 'Suburb':
            Suburb_ = child_.text
            Suburb_ = self.gds_validate_string(Suburb_, node, 'Suburb')
            self.Suburb = Suburb_
            # validate type Suburb
            self.validate_Suburb(self.Suburb)
# end class Shipper


class SpecialService(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SpecialServiceType=None, CommunicationAddress=None, CommunicationType=None, ChargeValue=None, CurrencyCode=None, IsWaived=None):
        self.original_tagname_ = None
        self.SpecialServiceType = SpecialServiceType
        self.validate_SpecialServiceType(self.SpecialServiceType)
        self.CommunicationAddress = CommunicationAddress
        self.validate_CommunicationAddress(self.CommunicationAddress)
        self.CommunicationType = CommunicationType
        self.validate_CommunicationType(self.CommunicationType)
        self.ChargeValue = ChargeValue
        self.validate_Money(self.ChargeValue)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCode(self.CurrencyCode)
        self.IsWaived = IsWaived
        self.validate_YesNo(self.IsWaived)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecialService)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecialService.subclass:
            return SpecialService.subclass(*args_, **kwargs_)
        else:
            return SpecialService(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialServiceType(self): return self.SpecialServiceType
    def set_SpecialServiceType(self, SpecialServiceType): self.SpecialServiceType = SpecialServiceType
    def get_CommunicationAddress(self): return self.CommunicationAddress
    def set_CommunicationAddress(self, CommunicationAddress): self.CommunicationAddress = CommunicationAddress
    def get_CommunicationType(self): return self.CommunicationType
    def set_CommunicationType(self, CommunicationType): self.CommunicationType = CommunicationType
    def get_ChargeValue(self): return self.ChargeValue
    def set_ChargeValue(self, ChargeValue): self.ChargeValue = ChargeValue
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_IsWaived(self): return self.IsWaived
    def set_IsWaived(self, IsWaived): self.IsWaived = IsWaived
    def validate_SpecialServiceType(self, value):
        # Validate type SpecialServiceType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SpecialServiceType' % {"value" : value.encode("utf-8")} )
    def validate_CommunicationAddress(self, value):
        # Validate type CommunicationAddress, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CommunicationAddress' % {"value" : value.encode("utf-8")} )
    def validate_CommunicationType(self, value):
        # Validate type CommunicationType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['P', 'F']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CommunicationType' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CommunicationType' % {"value" : value.encode("utf-8")} )
    def validate_Money(self, value):
        # Validate type Money, a restriction on xsd:float.
        if value is not None and Validate_simpletypes_:
            if value < 0.00:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Money' % {"value" : value} )
            if value > 9999999999.99:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Money' % {"value" : value} )
    def validate_CurrencyCode(self, value):
        # Validate type CurrencyCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCode' % {"value" : value.encode("utf-8")} )
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on YesNo' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on YesNo' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SpecialServiceType is not None or
            self.CommunicationAddress is not None or
            self.CommunicationType is not None or
            self.ChargeValue is not None or
            self.CurrencyCode is not None or
            self.IsWaived is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpecialService', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpecialService')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecialService')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpecialService', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpecialService'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpecialService', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecialServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SpecialServiceType>%s</SpecialServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialServiceType), input_name='SpecialServiceType')), eol_))
        if self.CommunicationAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CommunicationAddress>%s</CommunicationAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CommunicationAddress), input_name='CommunicationAddress')), eol_))
        if self.CommunicationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CommunicationType>%s</CommunicationType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CommunicationType), input_name='CommunicationType')), eol_))
        if self.ChargeValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeValue>%s</ChargeValue>%s' % (self.gds_format_float(self.ChargeValue, input_name='ChargeValue'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.IsWaived is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IsWaived>%s</IsWaived>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.IsWaived), input_name='IsWaived')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialServiceType':
            SpecialServiceType_ = child_.text
            SpecialServiceType_ = self.gds_validate_string(SpecialServiceType_, node, 'SpecialServiceType')
            self.SpecialServiceType = SpecialServiceType_
            # validate type SpecialServiceType
            self.validate_SpecialServiceType(self.SpecialServiceType)
        elif nodeName_ == 'CommunicationAddress':
            CommunicationAddress_ = child_.text
            CommunicationAddress_ = self.gds_validate_string(CommunicationAddress_, node, 'CommunicationAddress')
            self.CommunicationAddress = CommunicationAddress_
            # validate type CommunicationAddress
            self.validate_CommunicationAddress(self.CommunicationAddress)
        elif nodeName_ == 'CommunicationType':
            CommunicationType_ = child_.text
            CommunicationType_ = self.gds_validate_string(CommunicationType_, node, 'CommunicationType')
            self.CommunicationType = CommunicationType_
            # validate type CommunicationType
            self.validate_CommunicationType(self.CommunicationType)
        elif nodeName_ == 'ChargeValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeValue')
            self.ChargeValue = fval_
            # validate type Money
            self.validate_Money(self.ChargeValue)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCode
            self.validate_CurrencyCode(self.CurrencyCode)
        elif nodeName_ == 'IsWaived':
            IsWaived_ = child_.text
            IsWaived_ = self.gds_validate_string(IsWaived_, node, 'IsWaived')
            self.IsWaived = IsWaived_
            # validate type YesNo
            self.validate_YesNo(self.IsWaived)
# end class SpecialService


class WeightSeg(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Weight=None, WeightUnit=None):
        self.original_tagname_ = None
        self.Weight = Weight
        self.validate_Weight(self.Weight)
        self.WeightUnit = WeightUnit
        self.validate_WeightUnit(self.WeightUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightSeg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightSeg.subclass:
            return WeightSeg.subclass(*args_, **kwargs_)
        else:
            return WeightSeg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_WeightUnit(self): return self.WeightUnit
    def set_WeightUnit(self, WeightUnit): self.WeightUnit = WeightUnit
    def validate_Weight(self, value):
        # Validate type Weight, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Weight' % {"value" : value} )
            if value > 999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
    def validate_WeightUnit(self, value):
        # Validate type WeightUnit, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['K', 'L']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Weight is not None or
            self.WeightUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeightSeg', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightSeg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightSeg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeightSeg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeightSeg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeightSeg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Weight>%s</Weight>%s' % (self.gds_format_float(self.Weight, input_name='Weight'), eol_))
        if self.WeightUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightUnit>%s</WeightUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeightUnit), input_name='WeightUnit')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Weight')
            self.Weight = fval_
            # validate type Weight
            self.validate_Weight(self.Weight)
        elif nodeName_ == 'WeightUnit':
            WeightUnit_ = child_.text
            WeightUnit_ = self.gds_validate_string(WeightUnit_, node, 'WeightUnit')
            self.WeightUnit = WeightUnit_
            # validate type WeightUnit
            self.validate_WeightUnit(self.WeightUnit)
# end class WeightSeg


class Request(GeneratedsSuper):
    """Generic request header"""
    subclass = None
    superclass = None
    def __init__(self, ServiceHeader=None):
        self.original_tagname_ = None
        self.ServiceHeader = ServiceHeader
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Request)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Request.subclass:
            return Request.subclass(*args_, **kwargs_)
        else:
            return Request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceHeader(self): return self.ServiceHeader
    def set_ServiceHeader(self, ServiceHeader): self.ServiceHeader = ServiceHeader
    def hasContent_(self):
        if (
            self.ServiceHeader is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Request', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Request')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Request')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Request', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Request'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Request', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceHeader is not None:
            self.ServiceHeader.export(outfile, level, namespace_, name_='ServiceHeader', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceHeader':
            obj_ = ServiceHeader.factory()
            obj_.build(child_)
            self.ServiceHeader = obj_
            obj_.original_tagname_ = 'ServiceHeader'
# end class Request


class Response(GeneratedsSuper):
    """Generic response header"""
    subclass = None
    superclass = None
    def __init__(self, ServiceHeader=None):
        self.original_tagname_ = None
        self.ServiceHeader = ServiceHeader
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Response.subclass:
            return Response.subclass(*args_, **kwargs_)
        else:
            return Response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceHeader(self): return self.ServiceHeader
    def set_ServiceHeader(self, ServiceHeader): self.ServiceHeader = ServiceHeader
    def hasContent_(self):
        if (
            self.ServiceHeader is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Response'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceHeader is not None:
            self.ServiceHeader.export(outfile, level, namespace_, name_='ServiceHeader', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceHeader':
            obj_ = ResponseServiceHeader.factory()
            obj_.build(child_)
            self.ServiceHeader = obj_
            obj_.original_tagname_ = 'ServiceHeader'
# end class Response


class ResponseServiceHeader(GeneratedsSuper):
    """Standard routing header"""
    subclass = None
    superclass = None
    def __init__(self, MessageTime=None, MessageReference=None, SiteID=None):
        self.original_tagname_ = None
        if isinstance(MessageTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(MessageTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = MessageTime
        self.MessageTime = initvalue_
        self.MessageReference = MessageReference
        self.validate_MessageReference(self.MessageReference)
        self.SiteID = SiteID
        self.validate_SiteID(self.SiteID)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseServiceHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseServiceHeader.subclass:
            return ResponseServiceHeader.subclass(*args_, **kwargs_)
        else:
            return ResponseServiceHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MessageTime(self): return self.MessageTime
    def set_MessageTime(self, MessageTime): self.MessageTime = MessageTime
    def get_MessageReference(self): return self.MessageReference
    def set_MessageReference(self, MessageReference): self.MessageReference = MessageReference
    def get_SiteID(self): return self.SiteID
    def set_SiteID(self, SiteID): self.SiteID = SiteID
    def validate_MessageReference(self, value):
        # Validate type MessageReference, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 32:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on MessageReference' % {"value" : value.encode("utf-8")} )
            if len(value) < 28:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on MessageReference' % {"value" : value.encode("utf-8")} )
    def validate_SiteID(self, value):
        # Validate type SiteID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SiteID' % {"value" : value.encode("utf-8")} )
            if len(value) < 6:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on SiteID' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MessageTime is not None or
            self.MessageReference is not None or
            self.SiteID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseServiceHeader', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseServiceHeader')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseServiceHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseServiceHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseServiceHeader'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseServiceHeader', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MessageTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MessageTime>%s</MessageTime>%s' % (self.gds_format_datetime(self.MessageTime, input_name='MessageTime'), eol_))
        if self.MessageReference is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MessageReference>%s</MessageReference>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MessageReference), input_name='MessageReference')), eol_))
        if self.SiteID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SiteID>%s</SiteID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SiteID), input_name='SiteID')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MessageTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.MessageTime = dval_
        elif nodeName_ == 'MessageReference':
            MessageReference_ = child_.text
            MessageReference_ = self.gds_validate_string(MessageReference_, node, 'MessageReference')
            self.MessageReference = MessageReference_
            # validate type MessageReference
            self.validate_MessageReference(self.MessageReference)
        elif nodeName_ == 'SiteID':
            SiteID_ = child_.text
            SiteID_ = self.gds_validate_string(SiteID_, node, 'SiteID')
            self.SiteID = SiteID_
            # validate type SiteID
            self.validate_SiteID(self.SiteID)
# end class ResponseServiceHeader


class Status(GeneratedsSuper):
    """Status/Exception signal element"""
    subclass = None
    superclass = None
    def __init__(self, ActionStatus=None, Condition=None):
        self.original_tagname_ = None
        self.ActionStatus = ActionStatus
        if Condition is None:
            self.Condition = []
        else:
            self.Condition = Condition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Status)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Status.subclass:
            return Status.subclass(*args_, **kwargs_)
        else:
            return Status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionStatus(self): return self.ActionStatus
    def set_ActionStatus(self, ActionStatus): self.ActionStatus = ActionStatus
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def add_Condition(self, value): self.Condition.append(value)
    def insert_Condition_at(self, index, value): self.Condition.insert(index, value)
    def replace_Condition_at(self, index, value): self.Condition[index] = value
    def hasContent_(self):
        if (
            self.ActionStatus is not None or
            self.Condition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Status', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Status')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Status')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Status', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Status'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Status', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActionStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ActionStatus>%s</ActionStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ActionStatus), input_name='ActionStatus')), eol_))
        for Condition_ in self.Condition:
            Condition_.export(outfile, level, namespace_, name_='Condition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionStatus':
            ActionStatus_ = child_.text
            ActionStatus_ = self.gds_validate_string(ActionStatus_, node, 'ActionStatus')
            self.ActionStatus = ActionStatus_
        elif nodeName_ == 'Condition':
            obj_ = Condition.factory()
            obj_.build(child_)
            self.Condition.append(obj_)
            obj_.original_tagname_ = 'Condition'
# end class Status


class Note(GeneratedsSuper):
    """Note/Warning"""
    subclass = None
    superclass = None
    def __init__(self, ActionNote=None, Condition=None):
        self.original_tagname_ = None
        self.ActionNote = ActionNote
        if Condition is None:
            self.Condition = []
        else:
            self.Condition = Condition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Note)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Note.subclass:
            return Note.subclass(*args_, **kwargs_)
        else:
            return Note(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionNote(self): return self.ActionNote
    def set_ActionNote(self, ActionNote): self.ActionNote = ActionNote
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def add_Condition(self, value): self.Condition.append(value)
    def insert_Condition_at(self, index, value): self.Condition.insert(index, value)
    def replace_Condition_at(self, index, value): self.Condition[index] = value
    def hasContent_(self):
        if (
            self.ActionNote is not None or
            self.Condition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Note', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Note')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Note')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Note', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Note'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Note', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActionNote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ActionNote>%s</ActionNote>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ActionNote), input_name='ActionNote')), eol_))
        for Condition_ in self.Condition:
            Condition_.export(outfile, level, namespace_, name_='Condition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionNote':
            ActionNote_ = child_.text
            ActionNote_ = self.gds_validate_string(ActionNote_, node, 'ActionNote')
            self.ActionNote = ActionNote_
        elif nodeName_ == 'Condition':
            obj_ = Condition.factory()
            obj_.build(child_)
            self.Condition.append(obj_)
            obj_.original_tagname_ = 'Condition'
# end class Note


class Condition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ConditionCode=None, ConditionData=None):
        self.original_tagname_ = None
        self.ConditionCode = ConditionCode
        self.ConditionData = ConditionData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Condition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Condition.subclass:
            return Condition.subclass(*args_, **kwargs_)
        else:
            return Condition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConditionCode(self): return self.ConditionCode
    def set_ConditionCode(self, ConditionCode): self.ConditionCode = ConditionCode
    def get_ConditionData(self): return self.ConditionData
    def set_ConditionData(self, ConditionData): self.ConditionData = ConditionData
    def hasContent_(self):
        if (
            self.ConditionCode is not None or
            self.ConditionData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Condition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Condition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Condition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Condition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Condition'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Condition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConditionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConditionCode>%s</ConditionCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConditionCode), input_name='ConditionCode')), eol_))
        if self.ConditionData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConditionData>%s</ConditionData>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConditionData), input_name='ConditionData')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConditionCode':
            ConditionCode_ = child_.text
            ConditionCode_ = self.gds_validate_string(ConditionCode_, node, 'ConditionCode')
            self.ConditionCode = ConditionCode_
        elif nodeName_ == 'ConditionData':
            ConditionData_ = child_.text
            ConditionData_ = self.gds_validate_string(ConditionData_, node, 'ConditionData')
            self.ConditionData = ConditionData_
# end class Condition


class Customer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomerID=None, Name=None):
        self.original_tagname_ = None
        self.CustomerID = CustomerID
        self.Name = Name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Customer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Customer.subclass:
            return Customer.subclass(*args_, **kwargs_)
        else:
            return Customer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerID(self): return self.CustomerID
    def set_CustomerID(self, CustomerID): self.CustomerID = CustomerID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (
            self.CustomerID is not None or
            self.Name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Customer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Customer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Customer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Customer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Customer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Customer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CustomerID>%s</CustomerID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CustomerID), input_name='CustomerID')), eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerID':
            CustomerID_ = child_.text
            CustomerID_ = self.gds_validate_string(CustomerID_, node, 'CustomerID')
            self.CustomerID = CustomerID_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
# end class Customer


class BarCodes(GeneratedsSuper):
    """Element containing BarCode data"""
    subclass = None
    superclass = None
    def __init__(self, BarCode=None):
        self.original_tagname_ = None
        if BarCode is None:
            self.BarCode = []
        else:
            self.BarCode = BarCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BarCodes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BarCodes.subclass:
            return BarCodes.subclass(*args_, **kwargs_)
        else:
            return BarCodes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BarCode(self): return self.BarCode
    def set_BarCode(self, BarCode): self.BarCode = BarCode
    def add_BarCode(self, value): self.BarCode.append(value)
    def insert_BarCode_at(self, index, value): self.BarCode.insert(index, value)
    def replace_BarCode_at(self, index, value): self.BarCode[index] = value
    def validate_BarCode(self, value):
        # Validate type BarCode, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.BarCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BarCodes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BarCodes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BarCodes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BarCodes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BarCodes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BarCodes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BarCode_ in self.BarCode:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BarCode>%s</BarCode>%s' % (self.gds_format_base64(BarCode_, input_name='BarCode'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BarCode':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'BarCode')
            else:
                bval_ = None
            self.BarCode.append(bval_)
            # validate type BarCode
            self.validate_BarCode(self.BarCode[-1])
# end class BarCodes


class DestinationServiceArea(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceAreaCode=None, Description=None, InboundSortCode=None, FacilityCode=None):
        self.original_tagname_ = None
        self.ServiceAreaCode = ServiceAreaCode
        self.validate_ServiceAreaCode(self.ServiceAreaCode)
        self.Description = Description
        self.InboundSortCode = InboundSortCode
        self.validate_InboundSortCode(self.InboundSortCode)
        self.FacilityCode = FacilityCode
        self.validate_FacilityCode(self.FacilityCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DestinationServiceArea)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DestinationServiceArea.subclass:
            return DestinationServiceArea.subclass(*args_, **kwargs_)
        else:
            return DestinationServiceArea(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceAreaCode(self): return self.ServiceAreaCode
    def set_ServiceAreaCode(self, ServiceAreaCode): self.ServiceAreaCode = ServiceAreaCode
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_InboundSortCode(self): return self.InboundSortCode
    def set_InboundSortCode(self, InboundSortCode): self.InboundSortCode = InboundSortCode
    def get_FacilityCode(self): return self.FacilityCode
    def set_FacilityCode(self, FacilityCode): self.FacilityCode = FacilityCode
    def validate_ServiceAreaCode(self, value):
        # Validate type ServiceAreaCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ServiceAreaCode' % {"value" : value.encode("utf-8")} )
    def validate_InboundSortCode(self, value):
        # Validate type InboundSortCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on InboundSortCode' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on InboundSortCode' % {"value" : value.encode("utf-8")} )
    def validate_FacilityCode(self, value):
        # Validate type FacilityCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on FacilityCode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ServiceAreaCode is not None or
            self.Description is not None or
            self.InboundSortCode is not None or
            self.FacilityCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DestinationServiceArea', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DestinationServiceArea')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestinationServiceArea')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DestinationServiceArea', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DestinationServiceArea'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DestinationServiceArea', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceAreaCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ServiceAreaCode>%s</ServiceAreaCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceAreaCode), input_name='ServiceAreaCode')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Description>%s</Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.InboundSortCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<InboundSortCode>%s</InboundSortCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.InboundSortCode), input_name='InboundSortCode')), eol_))
        if self.FacilityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FacilityCode>%s</FacilityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FacilityCode), input_name='FacilityCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceAreaCode':
            ServiceAreaCode_ = child_.text
            ServiceAreaCode_ = self.gds_validate_string(ServiceAreaCode_, node, 'ServiceAreaCode')
            self.ServiceAreaCode = ServiceAreaCode_
            # validate type ServiceAreaCode
            self.validate_ServiceAreaCode(self.ServiceAreaCode)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'InboundSortCode':
            InboundSortCode_ = child_.text
            InboundSortCode_ = self.gds_validate_string(InboundSortCode_, node, 'InboundSortCode')
            self.InboundSortCode = InboundSortCode_
            # validate type InboundSortCode
            self.validate_InboundSortCode(self.InboundSortCode)
        elif nodeName_ == 'FacilityCode':
            FacilityCode_ = child_.text
            FacilityCode_ = self.gds_validate_string(FacilityCode_, node, 'FacilityCode')
            self.FacilityCode = FacilityCode_
            # validate type FacilityCode
            self.validate_FacilityCode(self.FacilityCode)
# end class DestinationServiceArea


class OriginServiceArea(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceAreaCode=None, Description=None, FacilityCode=None, OutboundSortCode=None):
        self.original_tagname_ = None
        self.ServiceAreaCode = ServiceAreaCode
        self.validate_ServiceAreaCode(self.ServiceAreaCode)
        self.Description = Description
        self.FacilityCode = FacilityCode
        self.validate_FacilityCode(self.FacilityCode)
        self.OutboundSortCode = OutboundSortCode
        self.validate_OutboundSortCode(self.OutboundSortCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OriginServiceArea)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OriginServiceArea.subclass:
            return OriginServiceArea.subclass(*args_, **kwargs_)
        else:
            return OriginServiceArea(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceAreaCode(self): return self.ServiceAreaCode
    def set_ServiceAreaCode(self, ServiceAreaCode): self.ServiceAreaCode = ServiceAreaCode
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_FacilityCode(self): return self.FacilityCode
    def set_FacilityCode(self, FacilityCode): self.FacilityCode = FacilityCode
    def get_OutboundSortCode(self): return self.OutboundSortCode
    def set_OutboundSortCode(self, OutboundSortCode): self.OutboundSortCode = OutboundSortCode
    def validate_ServiceAreaCode(self, value):
        # Validate type ServiceAreaCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ServiceAreaCode' % {"value" : value.encode("utf-8")} )
    def validate_FacilityCode(self, value):
        # Validate type FacilityCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on FacilityCode' % {"value" : value.encode("utf-8")} )
    def validate_OutboundSortCode(self, value):
        # Validate type OutboundSortCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on OutboundSortCode' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on OutboundSortCode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ServiceAreaCode is not None or
            self.Description is not None or
            self.FacilityCode is not None or
            self.OutboundSortCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OriginServiceArea', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OriginServiceArea')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OriginServiceArea')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OriginServiceArea', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OriginServiceArea'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OriginServiceArea', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceAreaCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ServiceAreaCode>%s</ServiceAreaCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceAreaCode), input_name='ServiceAreaCode')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Description>%s</Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
        if self.FacilityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FacilityCode>%s</FacilityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FacilityCode), input_name='FacilityCode')), eol_))
        if self.OutboundSortCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OutboundSortCode>%s</OutboundSortCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OutboundSortCode), input_name='OutboundSortCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceAreaCode':
            ServiceAreaCode_ = child_.text
            ServiceAreaCode_ = self.gds_validate_string(ServiceAreaCode_, node, 'ServiceAreaCode')
            self.ServiceAreaCode = ServiceAreaCode_
            # validate type ServiceAreaCode
            self.validate_ServiceAreaCode(self.ServiceAreaCode)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'FacilityCode':
            FacilityCode_ = child_.text
            FacilityCode_ = self.gds_validate_string(FacilityCode_, node, 'FacilityCode')
            self.FacilityCode = FacilityCode_
            # validate type FacilityCode
            self.validate_FacilityCode(self.FacilityCode)
        elif nodeName_ == 'OutboundSortCode':
            OutboundSortCode_ = child_.text
            OutboundSortCode_ = self.gds_validate_string(OutboundSortCode_, node, 'OutboundSortCode')
            self.OutboundSortCode = OutboundSortCode_
            # validate type OutboundSortCode
            self.validate_OutboundSortCode(self.OutboundSortCode)
# end class OriginServiceArea


class ServiceArea(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceAreaCode=None, Description=None):
        self.original_tagname_ = None
        self.ServiceAreaCode = ServiceAreaCode
        self.validate_ServiceAreaCode(self.ServiceAreaCode)
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceArea)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceArea.subclass:
            return ServiceArea.subclass(*args_, **kwargs_)
        else:
            return ServiceArea(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceAreaCode(self): return self.ServiceAreaCode
    def set_ServiceAreaCode(self, ServiceAreaCode): self.ServiceAreaCode = ServiceAreaCode
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def validate_ServiceAreaCode(self, value):
        # Validate type ServiceAreaCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ServiceAreaCode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ServiceAreaCode is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceArea', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceArea')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceArea')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceArea', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceArea'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceArea', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceAreaCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ServiceAreaCode>%s</ServiceAreaCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceAreaCode), input_name='ServiceAreaCode')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Description>%s</Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceAreaCode':
            ServiceAreaCode_ = child_.text
            ServiceAreaCode_ = self.gds_validate_string(ServiceAreaCode_, node, 'ServiceAreaCode')
            self.ServiceAreaCode = ServiceAreaCode_
            # validate type ServiceAreaCode
            self.validate_ServiceAreaCode(self.ServiceAreaCode)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class ServiceArea


class ServiceEvent(GeneratedsSuper):
    """Complex type to describe a service event. Eg Pickup, Delivery"""
    subclass = None
    superclass = None
    def __init__(self, EventCode=None, Description=None):
        self.original_tagname_ = None
        self.EventCode = EventCode
        self.validate_EventCodeType(self.EventCode)
        self.Description = Description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceEvent.subclass:
            return ServiceEvent.subclass(*args_, **kwargs_)
        else:
            return ServiceEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EventCode(self): return self.EventCode
    def set_EventCode(self, EventCode): self.EventCode = EventCode
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def validate_EventCodeType(self, value):
        # Validate type EventCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on EventCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EventCode is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceEvent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceEvent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceEvent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EventCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EventCode>%s</EventCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EventCode), input_name='EventCode')), eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Description>%s</Description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Description), input_name='Description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EventCode':
            EventCode_ = child_.text
            EventCode_ = self.gds_validate_string(EventCode_, node, 'EventCode')
            self.EventCode = EventCode_
            # validate type EventCodeType
            self.validate_EventCodeType(self.EventCode)
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
# end class ServiceEvent


class ShipmentDate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ShipmentDateFrom=None, ShipmentDateTo=None):
        self.original_tagname_ = None
        if isinstance(ShipmentDateFrom, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ShipmentDateFrom, '%Y-%m-%d').date()
        else:
            initvalue_ = ShipmentDateFrom
        self.ShipmentDateFrom = initvalue_
        if isinstance(ShipmentDateTo, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ShipmentDateTo, '%Y-%m-%d').date()
        else:
            initvalue_ = ShipmentDateTo
        self.ShipmentDateTo = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentDate.subclass:
            return ShipmentDate.subclass(*args_, **kwargs_)
        else:
            return ShipmentDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ShipmentDateFrom(self): return self.ShipmentDateFrom
    def set_ShipmentDateFrom(self, ShipmentDateFrom): self.ShipmentDateFrom = ShipmentDateFrom
    def get_ShipmentDateTo(self): return self.ShipmentDateTo
    def set_ShipmentDateTo(self, ShipmentDateTo): self.ShipmentDateTo = ShipmentDateTo
    def validate_Date(self, value):
        # Validate type Date, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_Date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Date_patterns_, ))
    validate_Date_patterns_ = [['^[0-9][0-9][0-9][0-9](-)[0-9][0-9](-)[0-9][0-9]$']]
    def hasContent_(self):
        if (
            self.ShipmentDateFrom is not None or
            self.ShipmentDateTo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShipmentDate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentDate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ShipmentDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShipmentDate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ShipmentDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ShipmentDateFrom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipmentDateFrom>%s</ShipmentDateFrom>%s' % (self.gds_format_date(self.ShipmentDateFrom, input_name='ShipmentDateFrom'), eol_))
        if self.ShipmentDateTo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipmentDateTo>%s</ShipmentDateTo>%s' % (self.gds_format_date(self.ShipmentDateTo, input_name='ShipmentDateTo'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ShipmentDateFrom':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ShipmentDateFrom = dval_
            # validate type Date
            self.validate_Date(self.ShipmentDateFrom)
        elif nodeName_ == 'ShipmentDateTo':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ShipmentDateTo = dval_
            # validate type Date
            self.validate_Date(self.ShipmentDateTo)
# end class ShipmentDate


class AWBInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AWBNumber=None, Status=None, ShipmentInfo=None, PieceInfo=None):
        self.original_tagname_ = None
        self.AWBNumber = AWBNumber
        self.validate_AWBNumber(self.AWBNumber)
        self.Status = Status
        self.ShipmentInfo = ShipmentInfo
        if PieceInfo is None:
            self.PieceInfo = []
        else:
            self.PieceInfo = PieceInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AWBInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AWBInfo.subclass:
            return AWBInfo.subclass(*args_, **kwargs_)
        else:
            return AWBInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AWBNumber(self): return self.AWBNumber
    def set_AWBNumber(self, AWBNumber): self.AWBNumber = AWBNumber
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ShipmentInfo(self): return self.ShipmentInfo
    def set_ShipmentInfo(self, ShipmentInfo): self.ShipmentInfo = ShipmentInfo
    def get_PieceInfo(self): return self.PieceInfo
    def set_PieceInfo(self, PieceInfo): self.PieceInfo = PieceInfo
    def add_PieceInfo(self, value): self.PieceInfo.append(value)
    def insert_PieceInfo_at(self, index, value): self.PieceInfo.insert(index, value)
    def replace_PieceInfo_at(self, index, value): self.PieceInfo[index] = value
    def validate_AWBNumber(self, value):
        # Validate type AWBNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on AWBNumber' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AWBNumber is not None or
            self.Status is not None or
            self.ShipmentInfo is not None or
            self.PieceInfo
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AWBInfo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AWBInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AWBInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AWBInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AWBInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AWBInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AWBNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AWBNumber>%s</AWBNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AWBNumber), input_name='AWBNumber')), eol_))
        if self.Status is not None:
            self.Status.export(outfile, level, namespace_, name_='Status', pretty_print=pretty_print)
        if self.ShipmentInfo is not None:
            self.ShipmentInfo.export(outfile, level, namespace_, name_='ShipmentInfo', pretty_print=pretty_print)
        for PieceInfo_ in self.PieceInfo:
            PieceInfo_.export(outfile, level, namespace_, name_='PieceInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AWBNumber':
            AWBNumber_ = child_.text
            AWBNumber_ = self.gds_validate_string(AWBNumber_, node, 'AWBNumber')
            self.AWBNumber = AWBNumber_
            # validate type AWBNumber
            self.validate_AWBNumber(self.AWBNumber)
        elif nodeName_ == 'Status':
            obj_ = Status.factory()
            obj_.build(child_)
            self.Status = obj_
            obj_.original_tagname_ = 'Status'
        elif nodeName_ == 'ShipmentInfo':
            obj_ = ShipmentInfo.factory()
            obj_.build(child_)
            self.ShipmentInfo = obj_
            obj_.original_tagname_ = 'ShipmentInfo'
        elif nodeName_ == 'PieceInfo':
            obj_ = PieceInfo.factory()
            obj_.build(child_)
            self.PieceInfo.append(obj_)
            obj_.original_tagname_ = 'PieceInfo'
# end class AWBInfo


class ShipmentInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OriginServiceArea=None, DestinationServiceArea=None, ShipperName=None, ShipperAccountNumber=None, ConsigneeName=None, ShipmentDate=None, Pieces=None, Weight=None, WeightUnit=None, EstDlvyDate=None, ShipmentEvent=None, ShipperReference=None):
        self.original_tagname_ = None
        self.OriginServiceArea = OriginServiceArea
        self.DestinationServiceArea = DestinationServiceArea
        self.ShipperName = ShipperName
        self.validate_PersonName(self.ShipperName)
        self.ShipperAccountNumber = ShipperAccountNumber
        self.validate_AccountNumber(self.ShipperAccountNumber)
        self.ConsigneeName = ConsigneeName
        self.validate_PersonName(self.ConsigneeName)
        if isinstance(ShipmentDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ShipmentDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ShipmentDate
        self.ShipmentDate = initvalue_
        self.Pieces = Pieces
        self.Weight = Weight
        self.WeightUnit = WeightUnit
        self.validate_WeightUnitType(self.WeightUnit)
        if isinstance(EstDlvyDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EstDlvyDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EstDlvyDate
        self.EstDlvyDate = initvalue_
        if ShipmentEvent is None:
            self.ShipmentEvent = []
        else:
            self.ShipmentEvent = ShipmentEvent
        self.ShipperReference = ShipperReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentInfo.subclass:
            return ShipmentInfo.subclass(*args_, **kwargs_)
        else:
            return ShipmentInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OriginServiceArea(self): return self.OriginServiceArea
    def set_OriginServiceArea(self, OriginServiceArea): self.OriginServiceArea = OriginServiceArea
    def get_DestinationServiceArea(self): return self.DestinationServiceArea
    def set_DestinationServiceArea(self, DestinationServiceArea): self.DestinationServiceArea = DestinationServiceArea
    def get_ShipperName(self): return self.ShipperName
    def set_ShipperName(self, ShipperName): self.ShipperName = ShipperName
    def get_ShipperAccountNumber(self): return self.ShipperAccountNumber
    def set_ShipperAccountNumber(self, ShipperAccountNumber): self.ShipperAccountNumber = ShipperAccountNumber
    def get_ConsigneeName(self): return self.ConsigneeName
    def set_ConsigneeName(self, ConsigneeName): self.ConsigneeName = ConsigneeName
    def get_ShipmentDate(self): return self.ShipmentDate
    def set_ShipmentDate(self, ShipmentDate): self.ShipmentDate = ShipmentDate
    def get_Pieces(self): return self.Pieces
    def set_Pieces(self, Pieces): self.Pieces = Pieces
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_WeightUnit(self): return self.WeightUnit
    def set_WeightUnit(self, WeightUnit): self.WeightUnit = WeightUnit
    def get_EstDlvyDate(self): return self.EstDlvyDate
    def set_EstDlvyDate(self, EstDlvyDate): self.EstDlvyDate = EstDlvyDate
    def get_ShipmentEvent(self): return self.ShipmentEvent
    def set_ShipmentEvent(self, ShipmentEvent): self.ShipmentEvent = ShipmentEvent
    def add_ShipmentEvent(self, value): self.ShipmentEvent.append(value)
    def insert_ShipmentEvent_at(self, index, value): self.ShipmentEvent.insert(index, value)
    def replace_ShipmentEvent_at(self, index, value): self.ShipmentEvent[index] = value
    def get_ShipperReference(self): return self.ShipperReference
    def set_ShipperReference(self, ShipperReference): self.ShipperReference = ShipperReference
    def validate_PersonName(self, value):
        # Validate type PersonName, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on PersonName' % {"value" : value.encode("utf-8")} )
    def validate_AccountNumber(self, value):
        # Validate type AccountNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on AccountNumber' % {"value" : value.encode("utf-8")} )
    def validate_WeightUnitType(self, value):
        # Validate type WeightUnitType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['L', 'K', 'G']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeightUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OriginServiceArea is not None or
            self.DestinationServiceArea is not None or
            self.ShipperName is not None or
            self.ShipperAccountNumber is not None or
            self.ConsigneeName is not None or
            self.ShipmentDate is not None or
            self.Pieces is not None or
            self.Weight is not None or
            self.WeightUnit is not None or
            self.EstDlvyDate is not None or
            self.ShipmentEvent or
            self.ShipperReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShipmentInfo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ShipmentInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShipmentInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ShipmentInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OriginServiceArea is not None:
            self.OriginServiceArea.export(outfile, level, namespace_, name_='OriginServiceArea', pretty_print=pretty_print)
        if self.DestinationServiceArea is not None:
            self.DestinationServiceArea.export(outfile, level, namespace_, name_='DestinationServiceArea', pretty_print=pretty_print)
        if self.ShipperName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipperName>%s</ShipperName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShipperName), input_name='ShipperName')), eol_))
        if self.ShipperAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipperAccountNumber>%s</ShipperAccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ShipperAccountNumber), input_name='ShipperAccountNumber')), eol_))
        if self.ConsigneeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConsigneeName>%s</ConsigneeName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConsigneeName), input_name='ConsigneeName')), eol_))
        if self.ShipmentDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShipmentDate>%s</ShipmentDate>%s' % (self.gds_format_datetime(self.ShipmentDate, input_name='ShipmentDate'), eol_))
        if self.Pieces is not None:
            self.Pieces.export(outfile, level, namespace_, name_='Pieces', pretty_print=pretty_print)
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Weight>%s</Weight>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Weight), input_name='Weight')), eol_))
        if self.WeightUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightUnit>%s</WeightUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeightUnit), input_name='WeightUnit')), eol_))
        if self.EstDlvyDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EstDlvyDate>%s</EstDlvyDate>%s' % (self.gds_format_datetime(self.EstDlvyDate, input_name='EstDlvyDate'), eol_))
        for ShipmentEvent_ in self.ShipmentEvent:
            ShipmentEvent_.export(outfile, level, namespace_, name_='ShipmentEvent', pretty_print=pretty_print)
        if self.ShipperReference is not None:
            self.ShipperReference.export(outfile, level, namespace_, name_='ShipperReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OriginServiceArea':
            obj_ = ServiceArea.factory()
            obj_.build(child_)
            self.OriginServiceArea = obj_
            obj_.original_tagname_ = 'OriginServiceArea'
        elif nodeName_ == 'DestinationServiceArea':
            obj_ = ServiceArea.factory()
            obj_.build(child_)
            self.DestinationServiceArea = obj_
            obj_.original_tagname_ = 'DestinationServiceArea'
        elif nodeName_ == 'ShipperName':
            ShipperName_ = child_.text
            ShipperName_ = self.gds_validate_string(ShipperName_, node, 'ShipperName')
            self.ShipperName = ShipperName_
            # validate type PersonName
            self.validate_PersonName(self.ShipperName)
        elif nodeName_ == 'ShipperAccountNumber':
            ShipperAccountNumber_ = child_.text
            ShipperAccountNumber_ = self.gds_validate_string(ShipperAccountNumber_, node, 'ShipperAccountNumber')
            self.ShipperAccountNumber = ShipperAccountNumber_
            # validate type AccountNumber
            self.validate_AccountNumber(self.ShipperAccountNumber)
        elif nodeName_ == 'ConsigneeName':
            ConsigneeName_ = child_.text
            ConsigneeName_ = self.gds_validate_string(ConsigneeName_, node, 'ConsigneeName')
            self.ConsigneeName = ConsigneeName_
            # validate type PersonName
            self.validate_PersonName(self.ConsigneeName)
        elif nodeName_ == 'ShipmentDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ShipmentDate = dval_
        elif nodeName_ == 'Pieces':
            obj_ = Pieces.factory()
            obj_.build(child_)
            self.Pieces = obj_
            obj_.original_tagname_ = 'Pieces'
        elif nodeName_ == 'Weight':
            Weight_ = child_.text
            Weight_ = self.gds_validate_string(Weight_, node, 'Weight')
            self.Weight = Weight_
        elif nodeName_ == 'WeightUnit':
            WeightUnit_ = child_.text
            WeightUnit_ = self.gds_validate_string(WeightUnit_, node, 'WeightUnit')
            self.WeightUnit = WeightUnit_
            # validate type WeightUnitType
            self.validate_WeightUnitType(self.WeightUnit)
        elif nodeName_ == 'EstDlvyDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.EstDlvyDate = dval_
        elif nodeName_ == 'ShipmentEvent':
            obj_ = ShipmentEvent.factory()
            obj_.build(child_)
            self.ShipmentEvent.append(obj_)
            obj_.original_tagname_ = 'ShipmentEvent'
        elif nodeName_ == 'ShipperReference':
            obj_ = Reference.factory()
            obj_.build(child_)
            self.ShipperReference = obj_
            obj_.original_tagname_ = 'ShipperReference'
# end class ShipmentInfo


class ErrorResponse(GeneratedsSuper):
    """Generic response header"""
    subclass = None
    superclass = None
    def __init__(self, ServiceHeader=None, Status=None):
        self.original_tagname_ = None
        self.ServiceHeader = ServiceHeader
        self.Status = Status
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ErrorResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ErrorResponse.subclass:
            return ErrorResponse.subclass(*args_, **kwargs_)
        else:
            return ErrorResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceHeader(self): return self.ServiceHeader
    def set_ServiceHeader(self, ServiceHeader): self.ServiceHeader = ServiceHeader
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def hasContent_(self):
        if (
            self.ServiceHeader is not None or
            self.Status is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ErrorResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ErrorResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ErrorResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ErrorResponse'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ErrorResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceHeader is not None:
            self.ServiceHeader.export(outfile, level, namespace_, name_='ServiceHeader', pretty_print=pretty_print)
        if self.Status is not None:
            self.Status.export(outfile, level, namespace_, name_='Status', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceHeader':
            obj_ = ServiceHeader.factory()
            obj_.build(child_)
            self.ServiceHeader = obj_
            obj_.original_tagname_ = 'ServiceHeader'
        elif nodeName_ == 'Status':
            obj_ = Status.factory()
            obj_.build(child_)
            self.Status = obj_
            obj_.original_tagname_ = 'Status'
# end class ErrorResponse


class ShipmentEvent(GeneratedsSuper):
    """Describes the checkpoint information"""
    subclass = None
    superclass = None
    def __init__(self, Date=None, Time=None, ServiceEvent=None, Signatory=None, ServiceArea=None):
        self.original_tagname_ = None
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        if isinstance(Time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Time, '%H:%M:%S').time()
        else:
            initvalue_ = Time
        self.Time = initvalue_
        self.ServiceEvent = ServiceEvent
        self.Signatory = Signatory
        self.validate_SignatoryType(self.Signatory)
        self.ServiceArea = ServiceArea
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ShipmentEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ShipmentEvent.subclass:
            return ShipmentEvent.subclass(*args_, **kwargs_)
        else:
            return ShipmentEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_ServiceEvent(self): return self.ServiceEvent
    def set_ServiceEvent(self, ServiceEvent): self.ServiceEvent = ServiceEvent
    def get_Signatory(self): return self.Signatory
    def set_Signatory(self, Signatory): self.Signatory = Signatory
    def get_ServiceArea(self): return self.ServiceArea
    def set_ServiceArea(self, ServiceArea): self.ServiceArea = ServiceArea
    def validate_SignatoryType(self, value):
        # Validate type SignatoryType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Date is not None or
            self.Time is not None or
            self.ServiceEvent is not None or
            self.Signatory is not None or
            self.ServiceArea is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ShipmentEvent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ShipmentEvent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ShipmentEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ShipmentEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ShipmentEvent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ShipmentEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Date>%s</Date>%s' % (self.gds_format_date(self.Date, input_name='Date'), eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Time>%s</Time>%s' % (self.gds_format_time(self.Time, input_name='Time'), eol_))
        if self.ServiceEvent is not None:
            self.ServiceEvent.export(outfile, level, namespace_, name_='ServiceEvent', pretty_print=pretty_print)
        if self.Signatory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Signatory>%s</Signatory>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Signatory), input_name='Signatory')), eol_))
        if self.ServiceArea is not None:
            self.ServiceArea.export(outfile, level, namespace_, name_='ServiceArea', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
        elif nodeName_ == 'Time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.Time = dval_
        elif nodeName_ == 'ServiceEvent':
            obj_ = ServiceEvent.factory()
            obj_.build(child_)
            self.ServiceEvent = obj_
            obj_.original_tagname_ = 'ServiceEvent'
        elif nodeName_ == 'Signatory':
            Signatory_ = child_.text
            Signatory_ = self.gds_validate_string(Signatory_, node, 'Signatory')
            self.Signatory = Signatory_
            # validate type SignatoryType
            self.validate_SignatoryType(self.Signatory)
        elif nodeName_ == 'ServiceArea':
            obj_ = ServiceArea.factory()
            obj_.build(child_)
            self.ServiceArea = obj_
            obj_.original_tagname_ = 'ServiceArea'
# end class ShipmentEvent


class PieceInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PieceDetails=None, PieceEvent=None):
        self.original_tagname_ = None
        self.PieceDetails = PieceDetails
        if PieceEvent is None:
            self.PieceEvent = []
        else:
            self.PieceEvent = PieceEvent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PieceInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PieceInfo.subclass:
            return PieceInfo.subclass(*args_, **kwargs_)
        else:
            return PieceInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PieceDetails(self): return self.PieceDetails
    def set_PieceDetails(self, PieceDetails): self.PieceDetails = PieceDetails
    def get_PieceEvent(self): return self.PieceEvent
    def set_PieceEvent(self, PieceEvent): self.PieceEvent = PieceEvent
    def add_PieceEvent(self, value): self.PieceEvent.append(value)
    def insert_PieceEvent_at(self, index, value): self.PieceEvent.insert(index, value)
    def replace_PieceEvent_at(self, index, value): self.PieceEvent[index] = value
    def hasContent_(self):
        if (
            self.PieceDetails is not None or
            self.PieceEvent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PieceInfo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PieceInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PieceInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PieceInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PieceInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PieceInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PieceDetails is not None:
            self.PieceDetails.export(outfile, level, namespace_, name_='PieceDetails', pretty_print=pretty_print)
        for PieceEvent_ in self.PieceEvent:
            PieceEvent_.export(outfile, level, namespace_, name_='PieceEvent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PieceDetails':
            obj_ = PieceDetails.factory()
            obj_.build(child_)
            self.PieceDetails = obj_
            obj_.original_tagname_ = 'PieceDetails'
        elif nodeName_ == 'PieceEvent':
            obj_ = PieceEvent.factory()
            obj_.build(child_)
            self.PieceEvent.append(obj_)
            obj_.original_tagname_ = 'PieceEvent'
# end class PieceInfo


class PieceEvent(GeneratedsSuper):
    """Describes the checkpoint information"""
    subclass = None
    superclass = None
    def __init__(self, Date=None, Time=None, ServiceEvent=None, Signatory=None, ServiceArea=None):
        self.original_tagname_ = None
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        if isinstance(Time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Time, '%H:%M:%S').time()
        else:
            initvalue_ = Time
        self.Time = initvalue_
        self.ServiceEvent = ServiceEvent
        self.Signatory = Signatory
        self.validate_SignatoryType6(self.Signatory)
        self.ServiceArea = ServiceArea
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PieceEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PieceEvent.subclass:
            return PieceEvent.subclass(*args_, **kwargs_)
        else:
            return PieceEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_ServiceEvent(self): return self.ServiceEvent
    def set_ServiceEvent(self, ServiceEvent): self.ServiceEvent = ServiceEvent
    def get_Signatory(self): return self.Signatory
    def set_Signatory(self, Signatory): self.Signatory = Signatory
    def get_ServiceArea(self): return self.ServiceArea
    def set_ServiceArea(self, ServiceArea): self.ServiceArea = ServiceArea
    def validate_SignatoryType6(self, value):
        # Validate type SignatoryType6, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Date is not None or
            self.Time is not None or
            self.ServiceEvent is not None or
            self.Signatory is not None or
            self.ServiceArea is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PieceEvent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PieceEvent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PieceEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PieceEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PieceEvent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PieceEvent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Date>%s</Date>%s' % (self.gds_format_date(self.Date, input_name='Date'), eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Time>%s</Time>%s' % (self.gds_format_time(self.Time, input_name='Time'), eol_))
        if self.ServiceEvent is not None:
            self.ServiceEvent.export(outfile, level, namespace_, name_='ServiceEvent', pretty_print=pretty_print)
        if self.Signatory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Signatory>%s</Signatory>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Signatory), input_name='Signatory')), eol_))
        if self.ServiceArea is not None:
            self.ServiceArea.export(outfile, level, namespace_, name_='ServiceArea', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
        elif nodeName_ == 'Time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.Time = dval_
        elif nodeName_ == 'ServiceEvent':
            obj_ = ServiceEvent.factory()
            obj_.build(child_)
            self.ServiceEvent = obj_
            obj_.original_tagname_ = 'ServiceEvent'
        elif nodeName_ == 'Signatory':
            Signatory_ = child_.text
            Signatory_ = self.gds_validate_string(Signatory_, node, 'Signatory')
            self.Signatory = Signatory_
            # validate type SignatoryType6
            self.validate_SignatoryType6(self.Signatory)
        elif nodeName_ == 'ServiceArea':
            obj_ = ServiceArea.factory()
            obj_.build(child_)
            self.ServiceArea = obj_
            obj_.original_tagname_ = 'ServiceArea'
# end class PieceEvent


class PieceDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PieceID=None, PackageType=None, Weight=None, DimWeight=None, Width=None, Height=None, Depth=None):
        self.original_tagname_ = None
        self.PieceID = PieceID
        self.validate_TrackingPieceID(self.PieceID)
        self.PackageType = PackageType
        self.validate_PackageType(self.PackageType)
        self.Weight = Weight
        self.validate_Weight(self.Weight)
        self.DimWeight = DimWeight
        self.Width = Width
        self.Height = Height
        self.Depth = Depth
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PieceDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PieceDetails.subclass:
            return PieceDetails.subclass(*args_, **kwargs_)
        else:
            return PieceDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PieceID(self): return self.PieceID
    def set_PieceID(self, PieceID): self.PieceID = PieceID
    def get_PackageType(self): return self.PackageType
    def set_PackageType(self, PackageType): self.PackageType = PackageType
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_DimWeight(self): return self.DimWeight
    def set_DimWeight(self, DimWeight): self.DimWeight = DimWeight
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def get_Depth(self): return self.Depth
    def set_Depth(self, Depth): self.Depth = Depth
    def validate_TrackingPieceID(self, value):
        # Validate type TrackingPieceID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TrackingPieceID' % {"value" : value.encode("utf-8")} )
            if len(value) < 20:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TrackingPieceID' % {"value" : value.encode("utf-8")} )
    def validate_PackageType(self, value):
        # Validate type PackageType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BD', 'BP', 'CP', 'DC', 'DF', 'DM', 'ED', 'EE', 'FR', 'JB', 'JD', 'JJ', 'JP', 'OD', 'PA', 'YP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PackageType' % {"value" : value.encode("utf-8")} )
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PackageType' % {"value" : value.encode("utf-8")} )
    def validate_Weight(self, value):
        # Validate type Weight, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Weight' % {"value" : value} )
            if value > 999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
    def hasContent_(self):
        if (
            self.PieceID is not None or
            self.PackageType is not None or
            self.Weight is not None or
            self.DimWeight is not None or
            self.Width is not None or
            self.Height is not None or
            self.Depth is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PieceDetails', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PieceDetails')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PieceDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PieceDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PieceDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PieceDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PieceID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PieceID>%s</PieceID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PieceID), input_name='PieceID')), eol_))
        if self.PackageType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PackageType>%s</PackageType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PackageType), input_name='PackageType')), eol_))
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Weight>%s</Weight>%s' % (self.gds_format_float(self.Weight, input_name='Weight'), eol_))
        if self.DimWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DimWeight>%s</DimWeight>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DimWeight), input_name='DimWeight')), eol_))
        if self.Width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Width>%s</Width>%s' % (self.gds_format_integer(self.Width, input_name='Width'), eol_))
        if self.Height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Height>%s</Height>%s' % (self.gds_format_integer(self.Height, input_name='Height'), eol_))
        if self.Depth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Depth>%s</Depth>%s' % (self.gds_format_integer(self.Depth, input_name='Depth'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PieceID':
            PieceID_ = child_.text
            PieceID_ = self.gds_validate_string(PieceID_, node, 'PieceID')
            self.PieceID = PieceID_
            # validate type TrackingPieceID
            self.validate_TrackingPieceID(self.PieceID)
        elif nodeName_ == 'PackageType':
            PackageType_ = child_.text
            PackageType_ = self.gds_validate_string(PackageType_, node, 'PackageType')
            self.PackageType = PackageType_
            # validate type PackageType
            self.validate_PackageType(self.PackageType)
        elif nodeName_ == 'Weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Weight')
            self.Weight = fval_
            # validate type Weight
            self.validate_Weight(self.Weight)
        elif nodeName_ == 'DimWeight':
            DimWeight_ = child_.text
            DimWeight_ = self.gds_validate_string(DimWeight_, node, 'DimWeight')
            self.DimWeight = DimWeight_
        elif nodeName_ == 'Width':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Width')
            self.Width = ival_
        elif nodeName_ == 'Height':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Height')
            self.Height = ival_
        elif nodeName_ == 'Depth':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Depth')
            self.Depth = ival_
# end class PieceDetails


class TrackingPieces(GeneratedsSuper):
    """Piece Info"""
    subclass = None
    superclass = None
    def __init__(self, PieceInfo=None):
        self.original_tagname_ = None
        if PieceInfo is None:
            self.PieceInfo = []
        else:
            self.PieceInfo = PieceInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrackingPieces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrackingPieces.subclass:
            return TrackingPieces.subclass(*args_, **kwargs_)
        else:
            return TrackingPieces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PieceInfo(self): return self.PieceInfo
    def set_PieceInfo(self, PieceInfo): self.PieceInfo = PieceInfo
    def add_PieceInfo(self, value): self.PieceInfo.append(value)
    def insert_PieceInfo_at(self, index, value): self.PieceInfo.insert(index, value)
    def replace_PieceInfo_at(self, index, value): self.PieceInfo[index] = value
    def hasContent_(self):
        if (
            self.PieceInfo
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TrackingPieces', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TrackingPieces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrackingPieces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TrackingPieces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TrackingPieces'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TrackingPieces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PieceInfo_ in self.PieceInfo:
            PieceInfo_.export(outfile, level, namespace_, name_='PieceInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PieceInfo':
            obj_ = PieceInfo.factory()
            obj_.build(child_)
            self.PieceInfo.append(obj_)
            obj_.original_tagname_ = 'PieceInfo'
# end class TrackingPieces


class Fault(GeneratedsSuper):
    """Piece Fault"""
    subclass = None
    superclass = None
    def __init__(self, PieceFault=None):
        self.original_tagname_ = None
        if PieceFault is None:
            self.PieceFault = []
        else:
            self.PieceFault = PieceFault
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Fault)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Fault.subclass:
            return Fault.subclass(*args_, **kwargs_)
        else:
            return Fault(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PieceFault(self): return self.PieceFault
    def set_PieceFault(self, PieceFault): self.PieceFault = PieceFault
    def add_PieceFault(self, value): self.PieceFault.append(value)
    def insert_PieceFault_at(self, index, value): self.PieceFault.insert(index, value)
    def replace_PieceFault_at(self, index, value): self.PieceFault[index] = value
    def hasContent_(self):
        if (
            self.PieceFault
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Fault', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Fault')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Fault')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Fault', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Fault'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Fault', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PieceFault_ in self.PieceFault:
            PieceFault_.export(outfile, level, namespace_, name_='PieceFault', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PieceFault':
            obj_ = PieceFault.factory()
            obj_.build(child_)
            self.PieceFault.append(obj_)
            obj_.original_tagname_ = 'PieceFault'
# end class Fault


class PieceFault(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PieceID=None, ConditionCode=None, ConditionData=None):
        self.original_tagname_ = None
        self.PieceID = PieceID
        self.validate_TrackingPieceID(self.PieceID)
        self.ConditionCode = ConditionCode
        self.ConditionData = ConditionData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PieceFault)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PieceFault.subclass:
            return PieceFault.subclass(*args_, **kwargs_)
        else:
            return PieceFault(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PieceID(self): return self.PieceID
    def set_PieceID(self, PieceID): self.PieceID = PieceID
    def get_ConditionCode(self): return self.ConditionCode
    def set_ConditionCode(self, ConditionCode): self.ConditionCode = ConditionCode
    def get_ConditionData(self): return self.ConditionData
    def set_ConditionData(self, ConditionData): self.ConditionData = ConditionData
    def validate_TrackingPieceID(self, value):
        # Validate type TrackingPieceID, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 35:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TrackingPieceID' % {"value" : value.encode("utf-8")} )
            if len(value) < 20:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TrackingPieceID' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PieceID is not None or
            self.ConditionCode is not None or
            self.ConditionData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PieceFault', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PieceFault')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PieceFault')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PieceFault', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PieceFault'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PieceFault', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PieceID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PieceID>%s</PieceID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PieceID), input_name='PieceID')), eol_))
        if self.ConditionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConditionCode>%s</ConditionCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConditionCode), input_name='ConditionCode')), eol_))
        if self.ConditionData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConditionData>%s</ConditionData>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConditionData), input_name='ConditionData')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PieceID':
            PieceID_ = child_.text
            PieceID_ = self.gds_validate_string(PieceID_, node, 'PieceID')
            self.PieceID = PieceID_
            # validate type TrackingPieceID
            self.validate_TrackingPieceID(self.PieceID)
        elif nodeName_ == 'ConditionCode':
            ConditionCode_ = child_.text
            ConditionCode_ = self.gds_validate_string(ConditionCode_, node, 'ConditionCode')
            self.ConditionCode = ConditionCode_
        elif nodeName_ == 'ConditionData':
            ConditionData_ = child_.text
            ConditionData_ = self.gds_validate_string(ConditionData_, node, 'ConditionData')
            self.ConditionData = ConditionData_
# end class PieceFault


class DocImages(GeneratedsSuper):
    """DocImages"""
    subclass = None
    superclass = None
    def __init__(self, DocImage=None):
        self.original_tagname_ = None
        if DocImage is None:
            self.DocImage = []
        else:
            self.DocImage = DocImage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocImages)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocImages.subclass:
            return DocImages.subclass(*args_, **kwargs_)
        else:
            return DocImages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocImage(self): return self.DocImage
    def set_DocImage(self, DocImage): self.DocImage = DocImage
    def add_DocImage(self, value): self.DocImage.append(value)
    def insert_DocImage_at(self, index, value): self.DocImage.insert(index, value)
    def replace_DocImage_at(self, index, value): self.DocImage[index] = value
    def hasContent_(self):
        if (
            self.DocImage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DocImages', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocImages')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocImages')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DocImages', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocImages'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DocImages', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DocImage_ in self.DocImage:
            DocImage_.export(outfile, level, namespace_, name_='DocImage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocImage':
            obj_ = DocImage.factory()
            obj_.build(child_)
            self.DocImage.append(obj_)
            obj_.original_tagname_ = 'DocImage'
# end class DocImages


class DocImage(GeneratedsSuper):
    """DocImage"""
    subclass = None
    superclass = None
    def __init__(self, Type=None, Image=None, ImageFormat=None):
        self.original_tagname_ = None
        self.Type = Type
        self.validate_Type(self.Type)
        self.Image = Image
        self.validate_Image(self.Image)
        self.ImageFormat = ImageFormat
        self.validate_ImageFormat(self.ImageFormat)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocImage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocImage.subclass:
            return DocImage.subclass(*args_, **kwargs_)
        else:
            return DocImage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Image(self): return self.Image
    def set_Image(self, Image): self.Image = Image
    def get_ImageFormat(self): return self.ImageFormat
    def set_ImageFormat(self, ImageFormat): self.ImageFormat = ImageFormat
    def validate_Type(self, value):
        # Validate type Type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['HWB', 'INV', 'PNV', 'COO', 'NAF', 'CIN', 'DCL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Type' % {"value" : value.encode("utf-8")} )
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on Type' % {"value" : value.encode("utf-8")} )
    def validate_Image(self, value):
        # Validate type Image, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ImageFormat(self, value):
        # Validate type ImageFormat, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PDF', 'PNG', 'TIFF', 'GIF', 'JPEG']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ImageFormat' % {"value" : value.encode("utf-8")} )
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ImageFormat' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Image is not None or
            self.ImageFormat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DocImage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocImage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocImage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DocImage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocImage'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DocImage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Image is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Image>%s</Image>%s' % (self.gds_format_base64(self.Image, input_name='Image'), eol_))
        if self.ImageFormat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ImageFormat>%s</ImageFormat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ImageFormat), input_name='ImageFormat')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type Type
            self.validate_Type(self.Type)
        elif nodeName_ == 'Image':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Image')
            else:
                bval_ = None
            self.Image = bval_
            # validate type Image
            self.validate_Image(self.Image)
        elif nodeName_ == 'ImageFormat':
            ImageFormat_ = child_.text
            ImageFormat_ = self.gds_validate_string(ImageFormat_, node, 'ImageFormat')
            self.ImageFormat = ImageFormat_
            # validate type ImageFormat
            self.validate_ImageFormat(self.ImageFormat)
# end class DocImage


class QtdSInAdCur(GeneratedsSuper):
    """QtdSInAdCur"""
    subclass = None
    superclass = None
    def __init__(self, CurrencyCode=None, CurrencyRoleTypeCode=None, PackageCharge=None, ShippingCharge=None):
        self.original_tagname_ = None
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCode(self.CurrencyCode)
        self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
        self.validate_CurrencyRoleTypeCode(self.CurrencyRoleTypeCode)
        self.PackageCharge = PackageCharge
        self.validate_PackageCharge(self.PackageCharge)
        self.ShippingCharge = ShippingCharge
        self.validate_ShippingCharge(self.ShippingCharge)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdSInAdCur)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdSInAdCur.subclass:
            return QtdSInAdCur.subclass(*args_, **kwargs_)
        else:
            return QtdSInAdCur(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_CurrencyRoleTypeCode(self): return self.CurrencyRoleTypeCode
    def set_CurrencyRoleTypeCode(self, CurrencyRoleTypeCode): self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
    def get_PackageCharge(self): return self.PackageCharge
    def set_PackageCharge(self, PackageCharge): self.PackageCharge = PackageCharge
    def get_ShippingCharge(self): return self.ShippingCharge
    def set_ShippingCharge(self, ShippingCharge): self.ShippingCharge = ShippingCharge
    def validate_CurrencyCode(self, value):
        # Validate type CurrencyCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCode' % {"value" : value.encode("utf-8")} )
    def validate_CurrencyRoleTypeCode(self, value):
        # Validate type CurrencyRoleTypeCode, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BILLC', 'PULCL', 'INVCU', 'BASEC']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CurrencyRoleTypeCode' % {"value" : value.encode("utf-8")} )
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CurrencyRoleTypeCode' % {"value" : value.encode("utf-8")} )
    def validate_PackageCharge(self, value):
        # Validate type PackageCharge, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on PackageCharge' % {"value" : value} )
    def validate_ShippingCharge(self, value):
        # Validate type ShippingCharge, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ShippingCharge' % {"value" : value} )
    def hasContent_(self):
        if (
            self.CurrencyCode is not None or
            self.CurrencyRoleTypeCode is not None or
            self.PackageCharge is not None or
            self.ShippingCharge is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdSInAdCur', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdSInAdCur')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdSInAdCur')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdSInAdCur', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdSInAdCur'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdSInAdCur', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.CurrencyRoleTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyRoleTypeCode>%s</CurrencyRoleTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyRoleTypeCode), input_name='CurrencyRoleTypeCode')), eol_))
        if self.PackageCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PackageCharge>%s</PackageCharge>%s' % (self.gds_format_float(self.PackageCharge, input_name='PackageCharge'), eol_))
        if self.ShippingCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShippingCharge>%s</ShippingCharge>%s' % (self.gds_format_float(self.ShippingCharge, input_name='ShippingCharge'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCode
            self.validate_CurrencyCode(self.CurrencyCode)
        elif nodeName_ == 'CurrencyRoleTypeCode':
            CurrencyRoleTypeCode_ = child_.text
            CurrencyRoleTypeCode_ = self.gds_validate_string(CurrencyRoleTypeCode_, node, 'CurrencyRoleTypeCode')
            self.CurrencyRoleTypeCode = CurrencyRoleTypeCode_
            # validate type CurrencyRoleTypeCode
            self.validate_CurrencyRoleTypeCode(self.CurrencyRoleTypeCode)
        elif nodeName_ == 'PackageCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'PackageCharge')
            self.PackageCharge = fval_
            # validate type PackageCharge
            self.validate_PackageCharge(self.PackageCharge)
        elif nodeName_ == 'ShippingCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ShippingCharge')
            self.ShippingCharge = fval_
            # validate type ShippingCharge
            self.validate_ShippingCharge(self.ShippingCharge)
# end class QtdSInAdCur


class LabelImage(GeneratedsSuper):
    """LabelImage"""
    subclass = None
    superclass = None
    def __init__(self, OutputFormat=None, OutputImage=None, MultiLabels=None, OutputImageNPC=None):
        self.original_tagname_ = None
        self.OutputFormat = OutputFormat
        self.validate_OutputFormat(self.OutputFormat)
        self.OutputImage = OutputImage
        self.validate_OutputImage(self.OutputImage)
        self.MultiLabels = MultiLabels
        self.OutputImageNPC = OutputImageNPC
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LabelImage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LabelImage.subclass:
            return LabelImage.subclass(*args_, **kwargs_)
        else:
            return LabelImage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OutputFormat(self): return self.OutputFormat
    def set_OutputFormat(self, OutputFormat): self.OutputFormat = OutputFormat
    def get_OutputImage(self): return self.OutputImage
    def set_OutputImage(self, OutputImage): self.OutputImage = OutputImage
    def get_MultiLabels(self): return self.MultiLabels
    def set_MultiLabels(self, MultiLabels): self.MultiLabels = MultiLabels
    def get_OutputImageNPC(self): return self.OutputImageNPC
    def set_OutputImageNPC(self, OutputImageNPC): self.OutputImageNPC = OutputImageNPC
    def validate_OutputFormat(self, value):
        # Validate type OutputFormat, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PDF', 'PL2', 'ZPL2', 'JPG', 'PNG', 'EPL2', 'EPLN', 'ZPLN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OutputFormat' % {"value" : value.encode("utf-8")} )
    def validate_OutputImage(self, value):
        # Validate type OutputImage, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.OutputFormat is not None or
            self.OutputImage is not None or
            self.MultiLabels is not None or
            self.OutputImageNPC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LabelImage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LabelImage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LabelImage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LabelImage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LabelImage'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LabelImage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OutputFormat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OutputFormat>%s</OutputFormat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OutputFormat), input_name='OutputFormat')), eol_))
        if self.OutputImage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OutputImage>%s</OutputImage>%s' % (self.gds_format_base64(self.OutputImage, input_name='OutputImage'), eol_))
        if self.MultiLabels is not None:
            self.MultiLabels.export(outfile, level, namespace_, name_='MultiLabels', pretty_print=pretty_print)
        if self.OutputImageNPC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OutputImageNPC>%s</OutputImageNPC>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OutputImageNPC), input_name='OutputImageNPC')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OutputFormat':
            OutputFormat_ = child_.text
            OutputFormat_ = self.gds_validate_string(OutputFormat_, node, 'OutputFormat')
            self.OutputFormat = OutputFormat_
            # validate type OutputFormat
            self.validate_OutputFormat(self.OutputFormat)
        elif nodeName_ == 'OutputImage':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'OutputImage')
            else:
                bval_ = None
            self.OutputImage = bval_
            # validate type OutputImage
            self.validate_OutputImage(self.OutputImage)
        elif nodeName_ == 'MultiLabels':
            obj_ = MultiLabels.factory()
            obj_.build(child_)
            self.MultiLabels = obj_
            obj_.original_tagname_ = 'MultiLabels'
        elif nodeName_ == 'OutputImageNPC':
            OutputImageNPC_ = child_.text
            OutputImageNPC_ = self.gds_validate_string(OutputImageNPC_, node, 'OutputImageNPC')
            self.OutputImageNPC = OutputImageNPC_
# end class LabelImage


class MultiLabels(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MultiLabel=None):
        self.original_tagname_ = None
        if MultiLabel is None:
            self.MultiLabel = []
        else:
            self.MultiLabel = MultiLabel
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultiLabels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultiLabels.subclass:
            return MultiLabels.subclass(*args_, **kwargs_)
        else:
            return MultiLabels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MultiLabel(self): return self.MultiLabel
    def set_MultiLabel(self, MultiLabel): self.MultiLabel = MultiLabel
    def add_MultiLabel(self, value): self.MultiLabel.append(value)
    def insert_MultiLabel_at(self, index, value): self.MultiLabel.insert(index, value)
    def replace_MultiLabel_at(self, index, value): self.MultiLabel[index] = value
    def hasContent_(self):
        if (
            self.MultiLabel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MultiLabels', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultiLabels')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiLabels')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MultiLabels', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiLabels'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MultiLabels', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MultiLabel_ in self.MultiLabel:
            MultiLabel_.export(outfile, level, namespace_, name_='MultiLabel', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MultiLabel':
            obj_ = MultiLabelType.factory()
            obj_.build(child_)
            self.MultiLabel.append(obj_)
            obj_.original_tagname_ = 'MultiLabel'
# end class MultiLabels


class Notification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EmailAddress=None, Message=None):
        self.original_tagname_ = None
        self.EmailAddress = EmailAddress
        self.validate_Message(self.EmailAddress)
        self.Message = Message
        self.validate_Message(self.Message)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Notification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Notification.subclass:
            return Notification.subclass(*args_, **kwargs_)
        else:
            return Notification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EmailAddress(self): return self.EmailAddress
    def set_EmailAddress(self, EmailAddress): self.EmailAddress = EmailAddress
    def get_Message(self): return self.Message
    def set_Message(self, Message): self.Message = Message
    def validate_Message(self, value):
        # Validate type Message, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 250:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on Message' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.EmailAddress is not None or
            self.Message is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Notification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Notification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Notification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Notification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Notification'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Notification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EmailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EmailAddress>%s</EmailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.EmailAddress), input_name='EmailAddress')), eol_))
        if self.Message is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Message>%s</Message>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Message), input_name='Message')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EmailAddress':
            EmailAddress_ = child_.text
            EmailAddress_ = self.gds_validate_string(EmailAddress_, node, 'EmailAddress')
            self.EmailAddress = EmailAddress_
            # validate type Message
            self.validate_Message(self.EmailAddress)
        elif nodeName_ == 'Message':
            Message_ = child_.text
            Message_ = self.gds_validate_string(Message_, node, 'Message')
            self.Message = Message_
            # validate type Message
            self.validate_Message(self.Message)
# end class Notification


class Label(GeneratedsSuper):
    """Label"""
    subclass = None
    superclass = None
    def __init__(self, HideAccount=None, LabelTemplate=None, ReceiptTemplate=None, DocDetach=None, Logo=None, CustomerLogo=None, Resolution=None):
        self.original_tagname_ = None
        self.HideAccount = HideAccount
        self.validate_YesNo(self.HideAccount)
        self.LabelTemplate = LabelTemplate
        self.validate_LabelTemplate(self.LabelTemplate)
        self.ReceiptTemplate = ReceiptTemplate
        self.validate_ReceiptTemplate(self.ReceiptTemplate)
        self.DocDetach = DocDetach
        self.validate_DocDetach(self.DocDetach)
        self.Logo = Logo
        self.validate_YesNo(self.Logo)
        self.CustomerLogo = CustomerLogo
        self.Resolution = Resolution
        self.validate_Resolution(self.Resolution)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Label)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Label.subclass:
            return Label.subclass(*args_, **kwargs_)
        else:
            return Label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HideAccount(self): return self.HideAccount
    def set_HideAccount(self, HideAccount): self.HideAccount = HideAccount
    def get_LabelTemplate(self): return self.LabelTemplate
    def set_LabelTemplate(self, LabelTemplate): self.LabelTemplate = LabelTemplate
    def get_ReceiptTemplate(self): return self.ReceiptTemplate
    def set_ReceiptTemplate(self, ReceiptTemplate): self.ReceiptTemplate = ReceiptTemplate
    def get_DocDetach(self): return self.DocDetach
    def set_DocDetach(self, DocDetach): self.DocDetach = DocDetach
    def get_Logo(self): return self.Logo
    def set_Logo(self, Logo): self.Logo = Logo
    def get_CustomerLogo(self): return self.CustomerLogo
    def set_CustomerLogo(self, CustomerLogo): self.CustomerLogo = CustomerLogo
    def get_Resolution(self): return self.Resolution
    def set_Resolution(self, Resolution): self.Resolution = Resolution
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Y', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on YesNo' % {"value" : value.encode("utf-8")} )
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on YesNo' % {"value" : value.encode("utf-8")} )
    def validate_LabelTemplate(self, value):
        # Validate type LabelTemplate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['8X4_A4_PDF', '8X4_thermal', '8X4_A4_TC_PDF', '6X4_thermal', '6X4_A4_PDF', '8X4_CI_PDF', '8X4_CI_thermal', '8X4_RU_A4_PDF', '6X4_PDF', '8X4_PDF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LabelTemplate' % {"value" : value.encode("utf-8")} )
    def validate_ReceiptTemplate(self, value):
        # Validate type ReceiptTemplate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SHIP_RECPT_A4_RU_PDF']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReceiptTemplate' % {"value" : value.encode("utf-8")} )
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ReceiptTemplate' % {"value" : value.encode("utf-8")} )
    def validate_DocDetach(self, value):
        # Validate type DocDetach, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ShpRcpt']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocDetach' % {"value" : value.encode("utf-8")} )
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DocDetach' % {"value" : value.encode("utf-8")} )
    def validate_Resolution(self, value):
        # Validate type Resolution, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_:
            if value < 200:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Resolution' % {"value" : value} )
            if value > 300:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Resolution' % {"value" : value} )
    def hasContent_(self):
        if (
            self.HideAccount is not None or
            self.LabelTemplate is not None or
            self.ReceiptTemplate is not None or
            self.DocDetach is not None or
            self.Logo is not None or
            self.CustomerLogo is not None or
            self.Resolution is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Label', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Label')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Label')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Label', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Label'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Label', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.HideAccount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<HideAccount>%s</HideAccount>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.HideAccount), input_name='HideAccount')), eol_))
        if self.LabelTemplate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LabelTemplate>%s</LabelTemplate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LabelTemplate), input_name='LabelTemplate')), eol_))
        if self.ReceiptTemplate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ReceiptTemplate>%s</ReceiptTemplate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ReceiptTemplate), input_name='ReceiptTemplate')), eol_))
        if self.DocDetach is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DocDetach>%s</DocDetach>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocDetach), input_name='DocDetach')), eol_))
        if self.Logo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Logo>%s</Logo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Logo), input_name='Logo')), eol_))
        if self.CustomerLogo is not None:
            self.CustomerLogo.export(outfile, level, namespace_, name_='CustomerLogo', pretty_print=pretty_print)
        if self.Resolution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Resolution>%s</Resolution>%s' % (self.gds_format_integer(self.Resolution, input_name='Resolution'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HideAccount':
            HideAccount_ = child_.text
            HideAccount_ = self.gds_validate_string(HideAccount_, node, 'HideAccount')
            self.HideAccount = HideAccount_
            # validate type YesNo
            self.validate_YesNo(self.HideAccount)
        elif nodeName_ == 'LabelTemplate':
            LabelTemplate_ = child_.text
            LabelTemplate_ = self.gds_validate_string(LabelTemplate_, node, 'LabelTemplate')
            self.LabelTemplate = LabelTemplate_
            # validate type LabelTemplate
            self.validate_LabelTemplate(self.LabelTemplate)
        elif nodeName_ == 'ReceiptTemplate':
            ReceiptTemplate_ = child_.text
            ReceiptTemplate_ = self.gds_validate_string(ReceiptTemplate_, node, 'ReceiptTemplate')
            self.ReceiptTemplate = ReceiptTemplate_
            # validate type ReceiptTemplate
            self.validate_ReceiptTemplate(self.ReceiptTemplate)
        elif nodeName_ == 'DocDetach':
            DocDetach_ = child_.text
            DocDetach_ = self.gds_validate_string(DocDetach_, node, 'DocDetach')
            self.DocDetach = DocDetach_
            # validate type DocDetach
            self.validate_DocDetach(self.DocDetach)
        elif nodeName_ == 'Logo':
            Logo_ = child_.text
            Logo_ = self.gds_validate_string(Logo_, node, 'Logo')
            self.Logo = Logo_
            # validate type YesNo
            self.validate_YesNo(self.Logo)
        elif nodeName_ == 'CustomerLogo':
            obj_ = CustomerLogo.factory()
            obj_.build(child_)
            self.CustomerLogo = obj_
            obj_.original_tagname_ = 'CustomerLogo'
        elif nodeName_ == 'Resolution':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'Resolution')
            self.Resolution = ival_
            # validate type Resolution
            self.validate_Resolution(self.Resolution)
# end class Label


class CustomerLogo(GeneratedsSuper):
    """CustomerLogo"""
    subclass = None
    superclass = None
    def __init__(self, LogoImage=None, LogoImageFormat=None):
        self.original_tagname_ = None
        self.LogoImage = LogoImage
        self.validate_LogoImage(self.LogoImage)
        self.LogoImageFormat = LogoImageFormat
        self.validate_LogoImageFormat(self.LogoImageFormat)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerLogo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerLogo.subclass:
            return CustomerLogo.subclass(*args_, **kwargs_)
        else:
            return CustomerLogo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LogoImage(self): return self.LogoImage
    def set_LogoImage(self, LogoImage): self.LogoImage = LogoImage
    def get_LogoImageFormat(self): return self.LogoImageFormat
    def set_LogoImageFormat(self, LogoImageFormat): self.LogoImageFormat = LogoImageFormat
    def validate_LogoImage(self, value):
        # Validate type LogoImage, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 1048576:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LogoImage' % {"value" : value} )
    def validate_LogoImageFormat(self, value):
        # Validate type LogoImageFormat, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PNG', 'GIF', 'JPEG', 'JPG']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on LogoImageFormat' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LogoImage is not None or
            self.LogoImageFormat is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerLogo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerLogo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerLogo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerLogo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerLogo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerLogo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LogoImage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LogoImage>%s</LogoImage>%s' % (self.gds_format_base64(self.LogoImage, input_name='LogoImage'), eol_))
        if self.LogoImageFormat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LogoImageFormat>%s</LogoImageFormat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LogoImageFormat), input_name='LogoImageFormat')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LogoImage':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'LogoImage')
            else:
                bval_ = None
            self.LogoImage = bval_
            # validate type LogoImage
            self.validate_LogoImage(self.LogoImage)
        elif nodeName_ == 'LogoImageFormat':
            LogoImageFormat_ = child_.text
            LogoImageFormat_ = self.gds_validate_string(LogoImageFormat_, node, 'LogoImageFormat')
            self.LogoImageFormat = LogoImageFormat_
            # validate type LogoImageFormat
            self.validate_LogoImageFormat(self.LogoImageFormat)
# end class CustomerLogo


class DCTResponseDataTypes(GeneratedsSuper):
    """Comment describing your root element"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DCTResponseDataTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DCTResponseDataTypes.subclass:
            return DCTResponseDataTypes.subclass(*args_, **kwargs_)
        else:
            return DCTResponseDataTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DCTResponseDataTypes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DCTResponseDataTypes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCTResponseDataTypes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DCTResponseDataTypes', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DCTResponseDataTypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DCTResponseDataTypes', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DCTResponseDataTypes


class OrgnSvcAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FacilityCode=None, ServiceAreaCode=None):
        self.original_tagname_ = None
        self.FacilityCode = FacilityCode
        self.validate_FacilityCodeType(self.FacilityCode)
        self.ServiceAreaCode = ServiceAreaCode
        self.validate_ServiceAreaCodeType(self.ServiceAreaCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrgnSvcAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrgnSvcAreaType.subclass:
            return OrgnSvcAreaType.subclass(*args_, **kwargs_)
        else:
            return OrgnSvcAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FacilityCode(self): return self.FacilityCode
    def set_FacilityCode(self, FacilityCode): self.FacilityCode = FacilityCode
    def get_ServiceAreaCode(self): return self.ServiceAreaCode
    def set_ServiceAreaCode(self, ServiceAreaCode): self.ServiceAreaCode = ServiceAreaCode
    def validate_FacilityCodeType(self, value):
        # Validate type FacilityCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on FacilityCodeType' % {"value" : value.encode("utf-8")} )
    def validate_ServiceAreaCodeType(self, value):
        # Validate type ServiceAreaCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ServiceAreaCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FacilityCode is not None or
            self.ServiceAreaCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrgnSvcAreaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrgnSvcAreaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrgnSvcAreaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrgnSvcAreaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrgnSvcAreaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OrgnSvcAreaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FacilityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FacilityCode>%s</FacilityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FacilityCode), input_name='FacilityCode')), eol_))
        if self.ServiceAreaCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ServiceAreaCode>%s</ServiceAreaCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceAreaCode), input_name='ServiceAreaCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FacilityCode':
            FacilityCode_ = child_.text
            FacilityCode_ = self.gds_validate_string(FacilityCode_, node, 'FacilityCode')
            self.FacilityCode = FacilityCode_
            # validate type FacilityCodeType
            self.validate_FacilityCodeType(self.FacilityCode)
        elif nodeName_ == 'ServiceAreaCode':
            ServiceAreaCode_ = child_.text
            ServiceAreaCode_ = self.gds_validate_string(ServiceAreaCode_, node, 'ServiceAreaCode')
            self.ServiceAreaCode = ServiceAreaCode_
            # validate type ServiceAreaCodeType
            self.validate_ServiceAreaCodeType(self.ServiceAreaCode)
# end class OrgnSvcAreaType


class DestSvcAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FacilityCode=None, ServiceAreaCode=None):
        self.original_tagname_ = None
        self.FacilityCode = FacilityCode
        self.validate_FacilityCodeType7(self.FacilityCode)
        self.ServiceAreaCode = ServiceAreaCode
        self.validate_ServiceAreaCodeType8(self.ServiceAreaCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DestSvcAreaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DestSvcAreaType.subclass:
            return DestSvcAreaType.subclass(*args_, **kwargs_)
        else:
            return DestSvcAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FacilityCode(self): return self.FacilityCode
    def set_FacilityCode(self, FacilityCode): self.FacilityCode = FacilityCode
    def get_ServiceAreaCode(self): return self.ServiceAreaCode
    def set_ServiceAreaCode(self, ServiceAreaCode): self.ServiceAreaCode = ServiceAreaCode
    def validate_FacilityCodeType7(self, value):
        # Validate type FacilityCodeType7, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on FacilityCodeType7' % {"value" : value.encode("utf-8")} )
    def validate_ServiceAreaCodeType8(self, value):
        # Validate type ServiceAreaCodeType8, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ServiceAreaCodeType8' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FacilityCode is not None or
            self.ServiceAreaCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DestSvcAreaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DestSvcAreaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestSvcAreaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DestSvcAreaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DestSvcAreaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DestSvcAreaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FacilityCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FacilityCode>%s</FacilityCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FacilityCode), input_name='FacilityCode')), eol_))
        if self.ServiceAreaCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ServiceAreaCode>%s</ServiceAreaCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceAreaCode), input_name='ServiceAreaCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FacilityCode':
            FacilityCode_ = child_.text
            FacilityCode_ = self.gds_validate_string(FacilityCode_, node, 'FacilityCode')
            self.FacilityCode = FacilityCode_
            # validate type FacilityCodeType7
            self.validate_FacilityCodeType7(self.FacilityCode)
        elif nodeName_ == 'ServiceAreaCode':
            ServiceAreaCode_ = child_.text
            ServiceAreaCode_ = self.gds_validate_string(ServiceAreaCode_, node, 'ServiceAreaCode')
            self.ServiceAreaCode = ServiceAreaCode_
            # validate type ServiceAreaCodeType8
            self.validate_ServiceAreaCodeType8(self.ServiceAreaCode)
# end class DestSvcAreaType


class BkgDetailsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, QtdShp=None):
        self.original_tagname_ = None
        if QtdShp is None:
            self.QtdShp = []
        else:
            self.QtdShp = QtdShp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BkgDetailsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BkgDetailsType.subclass:
            return BkgDetailsType.subclass(*args_, **kwargs_)
        else:
            return BkgDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QtdShp(self): return self.QtdShp
    def set_QtdShp(self, QtdShp): self.QtdShp = QtdShp
    def add_QtdShp(self, value): self.QtdShp.append(value)
    def insert_QtdShp_at(self, index, value): self.QtdShp.insert(index, value)
    def replace_QtdShp_at(self, index, value): self.QtdShp[index] = value
    def hasContent_(self):
        if (
            self.QtdShp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BkgDetailsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BkgDetailsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BkgDetailsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BkgDetailsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BkgDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BkgDetailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for QtdShp_ in self.QtdShp:
            QtdShp_.export(outfile, level, namespace_, name_='QtdShp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QtdShp':
            obj_ = QtdShpType.factory()
            obj_.build(child_)
            self.QtdShp.append(obj_)
            obj_.original_tagname_ = 'QtdShp'
# end class BkgDetailsType


class SrvCombType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GlobalServiceName=None, GlobalServiceCode=None, LocalServiceCode=None, LocalServiceTypeName=None, ChargeCodeType=None, SOfferedCustAgreement=None, SrvComb=None):
        self.original_tagname_ = None
        self.GlobalServiceName = GlobalServiceName
        self.validate_GlobalServiceNameType(self.GlobalServiceName)
        self.GlobalServiceCode = GlobalServiceCode
        self.validate_GlobalServiceCodeType(self.GlobalServiceCode)
        self.LocalServiceCode = LocalServiceCode
        self.validate_LocalServiceCodeType(self.LocalServiceCode)
        self.LocalServiceTypeName = LocalServiceTypeName
        self.validate_LocalServiceTypeNameType(self.LocalServiceTypeName)
        self.ChargeCodeType = ChargeCodeType
        self.validate_ChargeCodeTypeType(self.ChargeCodeType)
        self.SOfferedCustAgreement = SOfferedCustAgreement
        self.validate_SOfferedCustAgreementType(self.SOfferedCustAgreement)
        self.SrvComb = SrvComb
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SrvCombType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SrvCombType.subclass:
            return SrvCombType.subclass(*args_, **kwargs_)
        else:
            return SrvCombType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GlobalServiceName(self): return self.GlobalServiceName
    def set_GlobalServiceName(self, GlobalServiceName): self.GlobalServiceName = GlobalServiceName
    def get_GlobalServiceCode(self): return self.GlobalServiceCode
    def set_GlobalServiceCode(self, GlobalServiceCode): self.GlobalServiceCode = GlobalServiceCode
    def get_LocalServiceCode(self): return self.LocalServiceCode
    def set_LocalServiceCode(self, LocalServiceCode): self.LocalServiceCode = LocalServiceCode
    def get_LocalServiceTypeName(self): return self.LocalServiceTypeName
    def set_LocalServiceTypeName(self, LocalServiceTypeName): self.LocalServiceTypeName = LocalServiceTypeName
    def get_ChargeCodeType(self): return self.ChargeCodeType
    def set_ChargeCodeType(self, ChargeCodeType): self.ChargeCodeType = ChargeCodeType
    def get_SOfferedCustAgreement(self): return self.SOfferedCustAgreement
    def set_SOfferedCustAgreement(self, SOfferedCustAgreement): self.SOfferedCustAgreement = SOfferedCustAgreement
    def get_SrvComb(self): return self.SrvComb
    def set_SrvComb(self, SrvComb): self.SrvComb = SrvComb
    def validate_GlobalServiceNameType(self, value):
        # Validate type GlobalServiceNameType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 45:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on GlobalServiceNameType' % {"value" : value.encode("utf-8")} )
    def validate_GlobalServiceCodeType(self, value):
        # Validate type GlobalServiceCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 6:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on GlobalServiceCodeType' % {"value" : value.encode("utf-8")} )
    def validate_LocalServiceCodeType(self, value):
        # Validate type LocalServiceCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on LocalServiceCodeType' % {"value" : value.encode("utf-8")} )
    def validate_LocalServiceTypeNameType(self, value):
        # Validate type LocalServiceTypeNameType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 45:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on LocalServiceTypeNameType' % {"value" : value.encode("utf-8")} )
    def validate_ChargeCodeTypeType(self, value):
        # Validate type ChargeCodeTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FEE', 'SCH', 'XCH', 'NRI']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ChargeCodeTypeType' % {"value" : value.encode("utf-8")} )
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on ChargeCodeTypeType' % {"value" : value.encode("utf-8")} )
    def validate_SOfferedCustAgreementType(self, value):
        # Validate type SOfferedCustAgreementType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on SOfferedCustAgreementType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.GlobalServiceName is not None or
            self.GlobalServiceCode is not None or
            self.LocalServiceCode is not None or
            self.LocalServiceTypeName is not None or
            self.ChargeCodeType is not None or
            self.SOfferedCustAgreement is not None or
            self.SrvComb is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SrvCombType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SrvCombType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SrvCombType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SrvCombType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SrvCombType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SrvCombType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GlobalServiceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceName>%s</GlobalServiceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceName), input_name='GlobalServiceName')), eol_))
        if self.GlobalServiceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceCode>%s</GlobalServiceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceCode), input_name='GlobalServiceCode')), eol_))
        if self.LocalServiceCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceCode>%s</LocalServiceCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceCode), input_name='LocalServiceCode')), eol_))
        if self.LocalServiceTypeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceTypeName>%s</LocalServiceTypeName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceTypeName), input_name='LocalServiceTypeName')), eol_))
        if self.ChargeCodeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeCodeType>%s</ChargeCodeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeCodeType), input_name='ChargeCodeType')), eol_))
        if self.SOfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SOfferedCustAgreement>%s</SOfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SOfferedCustAgreement), input_name='SOfferedCustAgreement')), eol_))
        if self.SrvComb is not None:
            self.SrvComb.export(outfile, level, namespace_, name_='SrvComb', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GlobalServiceName':
            GlobalServiceName_ = child_.text
            GlobalServiceName_ = self.gds_validate_string(GlobalServiceName_, node, 'GlobalServiceName')
            self.GlobalServiceName = GlobalServiceName_
            # validate type GlobalServiceNameType
            self.validate_GlobalServiceNameType(self.GlobalServiceName)
        elif nodeName_ == 'GlobalServiceCode':
            GlobalServiceCode_ = child_.text
            GlobalServiceCode_ = self.gds_validate_string(GlobalServiceCode_, node, 'GlobalServiceCode')
            self.GlobalServiceCode = GlobalServiceCode_
            # validate type GlobalServiceCodeType
            self.validate_GlobalServiceCodeType(self.GlobalServiceCode)
        elif nodeName_ == 'LocalServiceCode':
            LocalServiceCode_ = child_.text
            LocalServiceCode_ = self.gds_validate_string(LocalServiceCode_, node, 'LocalServiceCode')
            self.LocalServiceCode = LocalServiceCode_
            # validate type LocalServiceCodeType
            self.validate_LocalServiceCodeType(self.LocalServiceCode)
        elif nodeName_ == 'LocalServiceTypeName':
            LocalServiceTypeName_ = child_.text
            LocalServiceTypeName_ = self.gds_validate_string(LocalServiceTypeName_, node, 'LocalServiceTypeName')
            self.LocalServiceTypeName = LocalServiceTypeName_
            # validate type LocalServiceTypeNameType
            self.validate_LocalServiceTypeNameType(self.LocalServiceTypeName)
        elif nodeName_ == 'ChargeCodeType':
            ChargeCodeType_ = child_.text
            ChargeCodeType_ = self.gds_validate_string(ChargeCodeType_, node, 'ChargeCodeType')
            self.ChargeCodeType = ChargeCodeType_
            # validate type ChargeCodeTypeType
            self.validate_ChargeCodeTypeType(self.ChargeCodeType)
        elif nodeName_ == 'SOfferedCustAgreement':
            SOfferedCustAgreement_ = child_.text
            SOfferedCustAgreement_ = self.gds_validate_string(SOfferedCustAgreement_, node, 'SOfferedCustAgreement')
            self.SOfferedCustAgreement = SOfferedCustAgreement_
            # validate type SOfferedCustAgreementType
            self.validate_SOfferedCustAgreementType(self.SOfferedCustAgreement)
        elif nodeName_ == 'SrvComb':
            obj_ = SrvCombType9.factory()
            obj_.build(child_)
            self.SrvComb = obj_
            obj_.original_tagname_ = 'SrvComb'
# end class SrvCombType


class ProdType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VldSrvComb=None, TotalDiscount=None):
        self.original_tagname_ = None
        if VldSrvComb is None:
            self.VldSrvComb = []
        else:
            self.VldSrvComb = VldSrvComb
        self.TotalDiscount = TotalDiscount
        self.validate_TotalDiscountType(self.TotalDiscount)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProdType.subclass:
            return ProdType.subclass(*args_, **kwargs_)
        else:
            return ProdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VldSrvComb(self): return self.VldSrvComb
    def set_VldSrvComb(self, VldSrvComb): self.VldSrvComb = VldSrvComb
    def add_VldSrvComb(self, value): self.VldSrvComb.append(value)
    def insert_VldSrvComb_at(self, index, value): self.VldSrvComb.insert(index, value)
    def replace_VldSrvComb_at(self, index, value): self.VldSrvComb[index] = value
    def get_TotalDiscount(self): return self.TotalDiscount
    def set_TotalDiscount(self, TotalDiscount): self.TotalDiscount = TotalDiscount
    def validate_TotalDiscountType(self, value):
        # Validate type TotalDiscountType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on TotalDiscountType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.VldSrvComb or
            self.TotalDiscount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProdType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProdType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProdType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProdType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProdType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProdType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VldSrvComb_ in self.VldSrvComb:
            VldSrvComb_.export(outfile, level, namespace_, name_='VldSrvComb', pretty_print=pretty_print)
        if self.TotalDiscount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalDiscount>%s</TotalDiscount>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TotalDiscount), input_name='TotalDiscount')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VldSrvComb':
            obj_ = VldSrvCombType.factory()
            obj_.build(child_)
            self.VldSrvComb.append(obj_)
            obj_.original_tagname_ = 'VldSrvComb'
        elif nodeName_ == 'TotalDiscount':
            TotalDiscount_ = child_.text
            TotalDiscount_ = self.gds_validate_string(TotalDiscount_, node, 'TotalDiscount')
            self.TotalDiscount = TotalDiscount_
            # validate type TotalDiscountType
            self.validate_TotalDiscountType(self.TotalDiscount)
# end class ProdType


class NoteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ActionStatus=None, Condition=None):
        self.original_tagname_ = None
        self.ActionStatus = ActionStatus
        if Condition is None:
            self.Condition = []
        else:
            self.Condition = Condition
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NoteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NoteType.subclass:
            return NoteType.subclass(*args_, **kwargs_)
        else:
            return NoteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionStatus(self): return self.ActionStatus
    def set_ActionStatus(self, ActionStatus): self.ActionStatus = ActionStatus
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def add_Condition(self, value): self.Condition.append(value)
    def insert_Condition_at(self, index, value): self.Condition.insert(index, value)
    def replace_Condition_at(self, index, value): self.Condition[index] = value
    def hasContent_(self):
        if (
            self.ActionStatus is not None or
            self.Condition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NoteType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NoteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NoteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NoteType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NoteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActionStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ActionStatus>%s</ActionStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ActionStatus), input_name='ActionStatus')), eol_))
        for Condition_ in self.Condition:
            Condition_.export(outfile, level, namespace_, name_='Condition', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionStatus':
            ActionStatus_ = child_.text
            ActionStatus_ = self.gds_validate_string(ActionStatus_, node, 'ActionStatus')
            self.ActionStatus = ActionStatus_
        elif nodeName_ == 'Condition':
            obj_ = ConditionType.factory()
            obj_.build(child_)
            self.Condition.append(obj_)
            obj_.original_tagname_ = 'Condition'
# end class NoteType


class QtdShpExChrgType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SpecialServiceType=None, LocalServiceType=None, GlobalServiceName=None, LocalServiceTypeName=None, SOfferedCustAgreement=None, ChargeCodeType=None, InsPrmRateInPercentage=None, CurrencyCode=None, ChargeValue=None, ChargeTaxAmount=None, ChargeTaxRate=None, ChargeTaxAmountDet=None, QtdSExtrChrgInAdCur=None):
        self.original_tagname_ = None
        self.SpecialServiceType = SpecialServiceType
        self.validate_SpecialServiceTypeType(self.SpecialServiceType)
        self.LocalServiceType = LocalServiceType
        self.validate_LocalServiceTypeType(self.LocalServiceType)
        self.GlobalServiceName = GlobalServiceName
        self.LocalServiceTypeName = LocalServiceTypeName
        self.SOfferedCustAgreement = SOfferedCustAgreement
        self.ChargeCodeType = ChargeCodeType
        self.InsPrmRateInPercentage = InsPrmRateInPercentage
        self.validate_InsPrmRateInPercentageType(self.InsPrmRateInPercentage)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType(self.CurrencyCode)
        self.ChargeValue = ChargeValue
        self.validate_ChargeValueType(self.ChargeValue)
        self.ChargeTaxAmount = ChargeTaxAmount
        self.validate_ChargeTaxAmountType(self.ChargeTaxAmount)
        if ChargeTaxRate is None:
            self.ChargeTaxRate = []
        else:
            self.ChargeTaxRate = ChargeTaxRate
        if ChargeTaxAmountDet is None:
            self.ChargeTaxAmountDet = []
        else:
            self.ChargeTaxAmountDet = ChargeTaxAmountDet
        if QtdSExtrChrgInAdCur is None:
            self.QtdSExtrChrgInAdCur = []
        else:
            self.QtdSExtrChrgInAdCur = QtdSExtrChrgInAdCur
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdShpExChrgType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdShpExChrgType.subclass:
            return QtdShpExChrgType.subclass(*args_, **kwargs_)
        else:
            return QtdShpExChrgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialServiceType(self): return self.SpecialServiceType
    def set_SpecialServiceType(self, SpecialServiceType): self.SpecialServiceType = SpecialServiceType
    def get_LocalServiceType(self): return self.LocalServiceType
    def set_LocalServiceType(self, LocalServiceType): self.LocalServiceType = LocalServiceType
    def get_GlobalServiceName(self): return self.GlobalServiceName
    def set_GlobalServiceName(self, GlobalServiceName): self.GlobalServiceName = GlobalServiceName
    def get_LocalServiceTypeName(self): return self.LocalServiceTypeName
    def set_LocalServiceTypeName(self, LocalServiceTypeName): self.LocalServiceTypeName = LocalServiceTypeName
    def get_SOfferedCustAgreement(self): return self.SOfferedCustAgreement
    def set_SOfferedCustAgreement(self, SOfferedCustAgreement): self.SOfferedCustAgreement = SOfferedCustAgreement
    def get_ChargeCodeType(self): return self.ChargeCodeType
    def set_ChargeCodeType(self, ChargeCodeType): self.ChargeCodeType = ChargeCodeType
    def get_InsPrmRateInPercentage(self): return self.InsPrmRateInPercentage
    def set_InsPrmRateInPercentage(self, InsPrmRateInPercentage): self.InsPrmRateInPercentage = InsPrmRateInPercentage
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_ChargeValue(self): return self.ChargeValue
    def set_ChargeValue(self, ChargeValue): self.ChargeValue = ChargeValue
    def get_ChargeTaxAmount(self): return self.ChargeTaxAmount
    def set_ChargeTaxAmount(self, ChargeTaxAmount): self.ChargeTaxAmount = ChargeTaxAmount
    def get_ChargeTaxRate(self): return self.ChargeTaxRate
    def set_ChargeTaxRate(self, ChargeTaxRate): self.ChargeTaxRate = ChargeTaxRate
    def add_ChargeTaxRate(self, value): self.ChargeTaxRate.append(value)
    def insert_ChargeTaxRate_at(self, index, value): self.ChargeTaxRate.insert(index, value)
    def replace_ChargeTaxRate_at(self, index, value): self.ChargeTaxRate[index] = value
    def get_ChargeTaxAmountDet(self): return self.ChargeTaxAmountDet
    def set_ChargeTaxAmountDet(self, ChargeTaxAmountDet): self.ChargeTaxAmountDet = ChargeTaxAmountDet
    def add_ChargeTaxAmountDet(self, value): self.ChargeTaxAmountDet.append(value)
    def insert_ChargeTaxAmountDet_at(self, index, value): self.ChargeTaxAmountDet.insert(index, value)
    def replace_ChargeTaxAmountDet_at(self, index, value): self.ChargeTaxAmountDet[index] = value
    def get_QtdSExtrChrgInAdCur(self): return self.QtdSExtrChrgInAdCur
    def set_QtdSExtrChrgInAdCur(self, QtdSExtrChrgInAdCur): self.QtdSExtrChrgInAdCur = QtdSExtrChrgInAdCur
    def add_QtdSExtrChrgInAdCur(self, value): self.QtdSExtrChrgInAdCur.append(value)
    def insert_QtdSExtrChrgInAdCur_at(self, index, value): self.QtdSExtrChrgInAdCur.insert(index, value)
    def replace_QtdSExtrChrgInAdCur_at(self, index, value): self.QtdSExtrChrgInAdCur[index] = value
    def validate_SpecialServiceTypeType(self, value):
        # Validate type SpecialServiceTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on SpecialServiceTypeType' % {"value" : value.encode("utf-8")} )
    def validate_LocalServiceTypeType(self, value):
        # Validate type LocalServiceTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LocalServiceTypeType' % {"value" : value.encode("utf-8")} )
    def validate_InsPrmRateInPercentageType(self, value):
        # Validate type InsPrmRateInPercentageType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 8:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on InsPrmRateInPercentageType' % {"value" : value} )
    def validate_CurrencyCodeType(self, value):
        # Validate type CurrencyCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType' % {"value" : value.encode("utf-8")} )
    def validate_ChargeValueType(self, value):
        # Validate type ChargeValueType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeValueType' % {"value" : value} )
    def validate_ChargeTaxAmountType(self, value):
        # Validate type ChargeTaxAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeTaxAmountType' % {"value" : value} )
    def validate_ChargeTaxRateType(self, value):
        # Validate type ChargeTaxRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeTaxRateType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.SpecialServiceType is not None or
            self.LocalServiceType is not None or
            self.GlobalServiceName is not None or
            self.LocalServiceTypeName is not None or
            self.SOfferedCustAgreement is not None or
            self.ChargeCodeType is not None or
            self.InsPrmRateInPercentage is not None or
            self.CurrencyCode is not None or
            self.ChargeValue is not None or
            self.ChargeTaxAmount is not None or
            self.ChargeTaxRate or
            self.ChargeTaxAmountDet or
            self.QtdSExtrChrgInAdCur
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdShpExChrgType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdShpExChrgType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdShpExChrgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdShpExChrgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdShpExChrgType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdShpExChrgType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecialServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SpecialServiceType>%s</SpecialServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialServiceType), input_name='SpecialServiceType')), eol_))
        if self.LocalServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceType>%s</LocalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceType), input_name='LocalServiceType')), eol_))
        if self.GlobalServiceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceName>%s</GlobalServiceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceName), input_name='GlobalServiceName')), eol_))
        if self.LocalServiceTypeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceTypeName>%s</LocalServiceTypeName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceTypeName), input_name='LocalServiceTypeName')), eol_))
        if self.SOfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SOfferedCustAgreement>%s</SOfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SOfferedCustAgreement), input_name='SOfferedCustAgreement')), eol_))
        if self.ChargeCodeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeCodeType>%s</ChargeCodeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ChargeCodeType), input_name='ChargeCodeType')), eol_))
        if self.InsPrmRateInPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<InsPrmRateInPercentage>%s</InsPrmRateInPercentage>%s' % (self.gds_format_float(self.InsPrmRateInPercentage, input_name='InsPrmRateInPercentage'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.ChargeValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeValue>%s</ChargeValue>%s' % (self.gds_format_float(self.ChargeValue, input_name='ChargeValue'), eol_))
        if self.ChargeTaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeTaxAmount>%s</ChargeTaxAmount>%s' % (self.gds_format_float(self.ChargeTaxAmount, input_name='ChargeTaxAmount'), eol_))
        for ChargeTaxRate_ in self.ChargeTaxRate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeTaxRate>%s</ChargeTaxRate>%s' % (self.gds_format_float(ChargeTaxRate_, input_name='ChargeTaxRate'), eol_))
        for ChargeTaxAmountDet_ in self.ChargeTaxAmountDet:
            ChargeTaxAmountDet_.export(outfile, level, namespace_, name_='ChargeTaxAmountDet', pretty_print=pretty_print)
        for QtdSExtrChrgInAdCur_ in self.QtdSExtrChrgInAdCur:
            QtdSExtrChrgInAdCur_.export(outfile, level, namespace_, name_='QtdSExtrChrgInAdCur', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialServiceType':
            SpecialServiceType_ = child_.text
            SpecialServiceType_ = self.gds_validate_string(SpecialServiceType_, node, 'SpecialServiceType')
            self.SpecialServiceType = SpecialServiceType_
            # validate type SpecialServiceTypeType
            self.validate_SpecialServiceTypeType(self.SpecialServiceType)
        elif nodeName_ == 'LocalServiceType':
            LocalServiceType_ = child_.text
            LocalServiceType_ = self.gds_validate_string(LocalServiceType_, node, 'LocalServiceType')
            self.LocalServiceType = LocalServiceType_
            # validate type LocalServiceTypeType
            self.validate_LocalServiceTypeType(self.LocalServiceType)
        elif nodeName_ == 'GlobalServiceName':
            GlobalServiceName_ = child_.text
            GlobalServiceName_ = self.gds_validate_string(GlobalServiceName_, node, 'GlobalServiceName')
            self.GlobalServiceName = GlobalServiceName_
        elif nodeName_ == 'LocalServiceTypeName':
            LocalServiceTypeName_ = child_.text
            LocalServiceTypeName_ = self.gds_validate_string(LocalServiceTypeName_, node, 'LocalServiceTypeName')
            self.LocalServiceTypeName = LocalServiceTypeName_
        elif nodeName_ == 'SOfferedCustAgreement':
            SOfferedCustAgreement_ = child_.text
            SOfferedCustAgreement_ = self.gds_validate_string(SOfferedCustAgreement_, node, 'SOfferedCustAgreement')
            self.SOfferedCustAgreement = SOfferedCustAgreement_
        elif nodeName_ == 'ChargeCodeType':
            ChargeCodeType_ = child_.text
            ChargeCodeType_ = self.gds_validate_string(ChargeCodeType_, node, 'ChargeCodeType')
            self.ChargeCodeType = ChargeCodeType_
        elif nodeName_ == 'InsPrmRateInPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'InsPrmRateInPercentage')
            self.InsPrmRateInPercentage = fval_
            # validate type InsPrmRateInPercentageType
            self.validate_InsPrmRateInPercentageType(self.InsPrmRateInPercentage)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType
            self.validate_CurrencyCodeType(self.CurrencyCode)
        elif nodeName_ == 'ChargeValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeValue')
            self.ChargeValue = fval_
            # validate type ChargeValueType
            self.validate_ChargeValueType(self.ChargeValue)
        elif nodeName_ == 'ChargeTaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeTaxAmount')
            self.ChargeTaxAmount = fval_
            # validate type ChargeTaxAmountType
            self.validate_ChargeTaxAmountType(self.ChargeTaxAmount)
        elif nodeName_ == 'ChargeTaxRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeTaxRate')
            self.ChargeTaxRate.append(fval_)
            # validate type ChargeTaxRateType
            self.validate_ChargeTaxRateType(self.ChargeTaxRate[-1])
        elif nodeName_ == 'ChargeTaxAmountDet':
            obj_ = ChargeTaxAmountDetType.factory()
            obj_.build(child_)
            self.ChargeTaxAmountDet.append(obj_)
            obj_.original_tagname_ = 'ChargeTaxAmountDet'
        elif nodeName_ == 'QtdSExtrChrgInAdCur':
            obj_ = QtdSExtrChrgInAdCurType.factory()
            obj_.build(child_)
            self.QtdSExtrChrgInAdCur.append(obj_)
            obj_.original_tagname_ = 'QtdSExtrChrgInAdCur'
# end class QtdShpExChrgType


class WeightChargeTaxDetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxTypeRate=None, TaxTypeCode=None, WeightChargeTax=None, BaseAmt=None):
        self.original_tagname_ = None
        self.TaxTypeRate = TaxTypeRate
        self.validate_TaxTypeRateType(self.TaxTypeRate)
        self.TaxTypeCode = TaxTypeCode
        self.validate_TaxTypeCodeType(self.TaxTypeCode)
        self.WeightChargeTax = WeightChargeTax
        self.validate_WeightChargeTaxType(self.WeightChargeTax)
        self.BaseAmt = BaseAmt
        self.validate_BaseAmtType(self.BaseAmt)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightChargeTaxDetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightChargeTaxDetType.subclass:
            return WeightChargeTaxDetType.subclass(*args_, **kwargs_)
        else:
            return WeightChargeTaxDetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxTypeRate(self): return self.TaxTypeRate
    def set_TaxTypeRate(self, TaxTypeRate): self.TaxTypeRate = TaxTypeRate
    def get_TaxTypeCode(self): return self.TaxTypeCode
    def set_TaxTypeCode(self, TaxTypeCode): self.TaxTypeCode = TaxTypeCode
    def get_WeightChargeTax(self): return self.WeightChargeTax
    def set_WeightChargeTax(self, WeightChargeTax): self.WeightChargeTax = WeightChargeTax
    def get_BaseAmt(self): return self.BaseAmt
    def set_BaseAmt(self, BaseAmt): self.BaseAmt = BaseAmt
    def validate_TaxTypeRateType(self, value):
        # Validate type TaxTypeRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 8:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TaxTypeRateType' % {"value" : value} )
    def validate_TaxTypeCodeType(self, value):
        # Validate type TaxTypeCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TaxTypeCodeType' % {"value" : value.encode("utf-8")} )
    def validate_WeightChargeTaxType(self, value):
        # Validate type WeightChargeTaxType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeTaxType' % {"value" : value} )
    def validate_BaseAmtType(self, value):
        # Validate type BaseAmtType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseAmtType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TaxTypeRate is not None or
            self.TaxTypeCode is not None or
            self.WeightChargeTax is not None or
            self.BaseAmt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeightChargeTaxDetType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightChargeTaxDetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightChargeTaxDetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeightChargeTaxDetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeightChargeTaxDetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeightChargeTaxDetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxTypeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxTypeRate>%s</TaxTypeRate>%s' % (self.gds_format_float(self.TaxTypeRate, input_name='TaxTypeRate'), eol_))
        if self.TaxTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxTypeCode>%s</TaxTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxTypeCode), input_name='TaxTypeCode')), eol_))
        if self.WeightChargeTax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightChargeTax>%s</WeightChargeTax>%s' % (self.gds_format_float(self.WeightChargeTax, input_name='WeightChargeTax'), eol_))
        if self.BaseAmt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BaseAmt>%s</BaseAmt>%s' % (self.gds_format_float(self.BaseAmt, input_name='BaseAmt'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxTypeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TaxTypeRate')
            self.TaxTypeRate = fval_
            # validate type TaxTypeRateType
            self.validate_TaxTypeRateType(self.TaxTypeRate)
        elif nodeName_ == 'TaxTypeCode':
            TaxTypeCode_ = child_.text
            TaxTypeCode_ = self.gds_validate_string(TaxTypeCode_, node, 'TaxTypeCode')
            self.TaxTypeCode = TaxTypeCode_
            # validate type TaxTypeCodeType
            self.validate_TaxTypeCodeType(self.TaxTypeCode)
        elif nodeName_ == 'WeightChargeTax':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightChargeTax')
            self.WeightChargeTax = fval_
            # validate type WeightChargeTaxType
            self.validate_WeightChargeTaxType(self.WeightChargeTax)
        elif nodeName_ == 'BaseAmt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BaseAmt')
            self.BaseAmt = fval_
            # validate type BaseAmtType
            self.validate_BaseAmtType(self.BaseAmt)
# end class WeightChargeTaxDetType


class ChargeTaxAmountDetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TaxTypeRate=None, TaxTypeCode=None, TaxAmount=None, BaseAmount=None):
        self.original_tagname_ = None
        self.TaxTypeRate = TaxTypeRate
        self.validate_TaxTypeRateType10(self.TaxTypeRate)
        self.TaxTypeCode = TaxTypeCode
        self.validate_TaxTypeCodeType11(self.TaxTypeCode)
        self.TaxAmount = TaxAmount
        self.validate_TaxAmountType(self.TaxAmount)
        self.BaseAmount = BaseAmount
        self.validate_BaseAmountType(self.BaseAmount)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChargeTaxAmountDetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChargeTaxAmountDetType.subclass:
            return ChargeTaxAmountDetType.subclass(*args_, **kwargs_)
        else:
            return ChargeTaxAmountDetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TaxTypeRate(self): return self.TaxTypeRate
    def set_TaxTypeRate(self, TaxTypeRate): self.TaxTypeRate = TaxTypeRate
    def get_TaxTypeCode(self): return self.TaxTypeCode
    def set_TaxTypeCode(self, TaxTypeCode): self.TaxTypeCode = TaxTypeCode
    def get_TaxAmount(self): return self.TaxAmount
    def set_TaxAmount(self, TaxAmount): self.TaxAmount = TaxAmount
    def get_BaseAmount(self): return self.BaseAmount
    def set_BaseAmount(self, BaseAmount): self.BaseAmount = BaseAmount
    def validate_TaxTypeRateType10(self, value):
        # Validate type TaxTypeRateType10, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 8:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TaxTypeRateType10' % {"value" : value} )
    def validate_TaxTypeCodeType11(self, value):
        # Validate type TaxTypeCodeType11, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TaxTypeCodeType11' % {"value" : value.encode("utf-8")} )
    def validate_TaxAmountType(self, value):
        # Validate type TaxAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TaxAmountType' % {"value" : value} )
    def validate_BaseAmountType(self, value):
        # Validate type BaseAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseAmountType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TaxTypeRate is not None or
            self.TaxTypeCode is not None or
            self.TaxAmount is not None or
            self.BaseAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChargeTaxAmountDetType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChargeTaxAmountDetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChargeTaxAmountDetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChargeTaxAmountDetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChargeTaxAmountDetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChargeTaxAmountDetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TaxTypeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxTypeRate>%s</TaxTypeRate>%s' % (self.gds_format_float(self.TaxTypeRate, input_name='TaxTypeRate'), eol_))
        if self.TaxTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxTypeCode>%s</TaxTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TaxTypeCode), input_name='TaxTypeCode')), eol_))
        if self.TaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TaxAmount>%s</TaxAmount>%s' % (self.gds_format_float(self.TaxAmount, input_name='TaxAmount'), eol_))
        if self.BaseAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BaseAmount>%s</BaseAmount>%s' % (self.gds_format_float(self.BaseAmount, input_name='BaseAmount'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TaxTypeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TaxTypeRate')
            self.TaxTypeRate = fval_
            # validate type TaxTypeRateType10
            self.validate_TaxTypeRateType10(self.TaxTypeRate)
        elif nodeName_ == 'TaxTypeCode':
            TaxTypeCode_ = child_.text
            TaxTypeCode_ = self.gds_validate_string(TaxTypeCode_, node, 'TaxTypeCode')
            self.TaxTypeCode = TaxTypeCode_
            # validate type TaxTypeCodeType11
            self.validate_TaxTypeCodeType11(self.TaxTypeCode)
        elif nodeName_ == 'TaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TaxAmount')
            self.TaxAmount = fval_
            # validate type TaxAmountType
            self.validate_TaxAmountType(self.TaxAmount)
        elif nodeName_ == 'BaseAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BaseAmount')
            self.BaseAmount = fval_
            # validate type BaseAmountType
            self.validate_BaseAmountType(self.BaseAmount)
# end class ChargeTaxAmountDetType


class QtdSInAdCurType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomsValue=None, ExchangeRate=None, CurrencyCode=None, CurrencyRoleTypeCode=None, WeightCharge=None, TotalAmount=None, TotalTaxAmount=None, WeightChargeTax=None, WeightChargeTaxDet=None):
        self.original_tagname_ = None
        self.CustomsValue = CustomsValue
        self.validate_CustomsValueType(self.CustomsValue)
        self.ExchangeRate = ExchangeRate
        self.validate_ExchangeRateType(self.ExchangeRate)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType12(self.CurrencyCode)
        self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
        self.validate_CurrencyRoleTypeCodeType(self.CurrencyRoleTypeCode)
        self.WeightCharge = WeightCharge
        self.validate_WeightChargeType(self.WeightCharge)
        self.TotalAmount = TotalAmount
        self.validate_TotalAmountType(self.TotalAmount)
        self.TotalTaxAmount = TotalTaxAmount
        self.validate_TotalTaxAmountType(self.TotalTaxAmount)
        self.WeightChargeTax = WeightChargeTax
        self.validate_WeightChargeTaxType13(self.WeightChargeTax)
        if WeightChargeTaxDet is None:
            self.WeightChargeTaxDet = []
        else:
            self.WeightChargeTaxDet = WeightChargeTaxDet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdSInAdCurType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdSInAdCurType.subclass:
            return QtdSInAdCurType.subclass(*args_, **kwargs_)
        else:
            return QtdSInAdCurType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomsValue(self): return self.CustomsValue
    def set_CustomsValue(self, CustomsValue): self.CustomsValue = CustomsValue
    def get_ExchangeRate(self): return self.ExchangeRate
    def set_ExchangeRate(self, ExchangeRate): self.ExchangeRate = ExchangeRate
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_CurrencyRoleTypeCode(self): return self.CurrencyRoleTypeCode
    def set_CurrencyRoleTypeCode(self, CurrencyRoleTypeCode): self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
    def get_WeightCharge(self): return self.WeightCharge
    def set_WeightCharge(self, WeightCharge): self.WeightCharge = WeightCharge
    def get_TotalAmount(self): return self.TotalAmount
    def set_TotalAmount(self, TotalAmount): self.TotalAmount = TotalAmount
    def get_TotalTaxAmount(self): return self.TotalTaxAmount
    def set_TotalTaxAmount(self, TotalTaxAmount): self.TotalTaxAmount = TotalTaxAmount
    def get_WeightChargeTax(self): return self.WeightChargeTax
    def set_WeightChargeTax(self, WeightChargeTax): self.WeightChargeTax = WeightChargeTax
    def get_WeightChargeTaxDet(self): return self.WeightChargeTaxDet
    def set_WeightChargeTaxDet(self, WeightChargeTaxDet): self.WeightChargeTaxDet = WeightChargeTaxDet
    def add_WeightChargeTaxDet(self, value): self.WeightChargeTaxDet.append(value)
    def insert_WeightChargeTaxDet_at(self, index, value): self.WeightChargeTaxDet.insert(index, value)
    def replace_WeightChargeTaxDet_at(self, index, value): self.WeightChargeTaxDet[index] = value
    def validate_CustomsValueType(self, value):
        # Validate type CustomsValueType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on CustomsValueType' % {"value" : value} )
    def validate_ExchangeRateType(self, value):
        # Validate type ExchangeRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ExchangeRateType' % {"value" : value} )
    def validate_CurrencyCodeType12(self, value):
        # Validate type CurrencyCodeType12, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType12' % {"value" : value.encode("utf-8")} )
    def validate_CurrencyRoleTypeCodeType(self, value):
        # Validate type CurrencyRoleTypeCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 5:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyRoleTypeCodeType' % {"value" : value.encode("utf-8")} )
    def validate_WeightChargeType(self, value):
        # Validate type WeightChargeType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeType' % {"value" : value} )
    def validate_TotalAmountType(self, value):
        # Validate type TotalAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TotalAmountType' % {"value" : value} )
    def validate_TotalTaxAmountType(self, value):
        # Validate type TotalTaxAmountType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TotalTaxAmountType' % {"value" : value} )
    def validate_WeightChargeTaxType13(self, value):
        # Validate type WeightChargeTaxType13, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeTaxType13' % {"value" : value} )
    def hasContent_(self):
        if (
            self.CustomsValue is not None or
            self.ExchangeRate is not None or
            self.CurrencyCode is not None or
            self.CurrencyRoleTypeCode is not None or
            self.WeightCharge is not None or
            self.TotalAmount is not None or
            self.TotalTaxAmount is not None or
            self.WeightChargeTax is not None or
            self.WeightChargeTaxDet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdSInAdCurType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdSInAdCurType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdSInAdCurType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdSInAdCurType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdSInAdCurType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdSInAdCurType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomsValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CustomsValue>%s</CustomsValue>%s' % (self.gds_format_float(self.CustomsValue, input_name='CustomsValue'), eol_))
        if self.ExchangeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ExchangeRate>%s</ExchangeRate>%s' % (self.gds_format_float(self.ExchangeRate, input_name='ExchangeRate'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.CurrencyRoleTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyRoleTypeCode>%s</CurrencyRoleTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyRoleTypeCode), input_name='CurrencyRoleTypeCode')), eol_))
        if self.WeightCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightCharge>%s</WeightCharge>%s' % (self.gds_format_float(self.WeightCharge, input_name='WeightCharge'), eol_))
        if self.TotalAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalAmount>%s</TotalAmount>%s' % (self.gds_format_float(self.TotalAmount, input_name='TotalAmount'), eol_))
        if self.TotalTaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalTaxAmount>%s</TotalTaxAmount>%s' % (self.gds_format_float(self.TotalTaxAmount, input_name='TotalTaxAmount'), eol_))
        if self.WeightChargeTax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightChargeTax>%s</WeightChargeTax>%s' % (self.gds_format_float(self.WeightChargeTax, input_name='WeightChargeTax'), eol_))
        for WeightChargeTaxDet_ in self.WeightChargeTaxDet:
            WeightChargeTaxDet_.export(outfile, level, namespace_, name_='WeightChargeTaxDet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomsValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CustomsValue')
            self.CustomsValue = fval_
            # validate type CustomsValueType
            self.validate_CustomsValueType(self.CustomsValue)
        elif nodeName_ == 'ExchangeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ExchangeRate')
            self.ExchangeRate = fval_
            # validate type ExchangeRateType
            self.validate_ExchangeRateType(self.ExchangeRate)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType12
            self.validate_CurrencyCodeType12(self.CurrencyCode)
        elif nodeName_ == 'CurrencyRoleTypeCode':
            CurrencyRoleTypeCode_ = child_.text
            CurrencyRoleTypeCode_ = self.gds_validate_string(CurrencyRoleTypeCode_, node, 'CurrencyRoleTypeCode')
            self.CurrencyRoleTypeCode = CurrencyRoleTypeCode_
            # validate type CurrencyRoleTypeCodeType
            self.validate_CurrencyRoleTypeCodeType(self.CurrencyRoleTypeCode)
        elif nodeName_ == 'WeightCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightCharge')
            self.WeightCharge = fval_
            # validate type WeightChargeType
            self.validate_WeightChargeType(self.WeightCharge)
        elif nodeName_ == 'TotalAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TotalAmount')
            self.TotalAmount = fval_
            # validate type TotalAmountType
            self.validate_TotalAmountType(self.TotalAmount)
        elif nodeName_ == 'TotalTaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TotalTaxAmount')
            self.TotalTaxAmount = fval_
            # validate type TotalTaxAmountType
            self.validate_TotalTaxAmountType(self.TotalTaxAmount)
        elif nodeName_ == 'WeightChargeTax':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightChargeTax')
            self.WeightChargeTax = fval_
            # validate type WeightChargeTaxType13
            self.validate_WeightChargeTaxType13(self.WeightChargeTax)
        elif nodeName_ == 'WeightChargeTaxDet':
            obj_ = WeightChargeTaxDetType.factory()
            obj_.build(child_)
            self.WeightChargeTaxDet.append(obj_)
            obj_.original_tagname_ = 'WeightChargeTaxDet'
# end class QtdSInAdCurType


class QtdSExtrChrgInAdCurType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChargeValue=None, ChargeExchangeRate=None, ChargeTaxAmount=None, CurrencyCode=None, CurrencyRoleTypeCode=None, ChargeTaxAmountDet=None):
        self.original_tagname_ = None
        self.ChargeValue = ChargeValue
        self.validate_ChargeValueType14(self.ChargeValue)
        self.ChargeExchangeRate = ChargeExchangeRate
        self.validate_ChargeExchangeRateType(self.ChargeExchangeRate)
        self.ChargeTaxAmount = ChargeTaxAmount
        self.validate_ChargeTaxAmountType15(self.ChargeTaxAmount)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType16(self.CurrencyCode)
        self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
        self.validate_CurrencyRoleTypeCodeType17(self.CurrencyRoleTypeCode)
        if ChargeTaxAmountDet is None:
            self.ChargeTaxAmountDet = []
        else:
            self.ChargeTaxAmountDet = ChargeTaxAmountDet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdSExtrChrgInAdCurType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdSExtrChrgInAdCurType.subclass:
            return QtdSExtrChrgInAdCurType.subclass(*args_, **kwargs_)
        else:
            return QtdSExtrChrgInAdCurType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChargeValue(self): return self.ChargeValue
    def set_ChargeValue(self, ChargeValue): self.ChargeValue = ChargeValue
    def get_ChargeExchangeRate(self): return self.ChargeExchangeRate
    def set_ChargeExchangeRate(self, ChargeExchangeRate): self.ChargeExchangeRate = ChargeExchangeRate
    def get_ChargeTaxAmount(self): return self.ChargeTaxAmount
    def set_ChargeTaxAmount(self, ChargeTaxAmount): self.ChargeTaxAmount = ChargeTaxAmount
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_CurrencyRoleTypeCode(self): return self.CurrencyRoleTypeCode
    def set_CurrencyRoleTypeCode(self, CurrencyRoleTypeCode): self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
    def get_ChargeTaxAmountDet(self): return self.ChargeTaxAmountDet
    def set_ChargeTaxAmountDet(self, ChargeTaxAmountDet): self.ChargeTaxAmountDet = ChargeTaxAmountDet
    def add_ChargeTaxAmountDet(self, value): self.ChargeTaxAmountDet.append(value)
    def insert_ChargeTaxAmountDet_at(self, index, value): self.ChargeTaxAmountDet.insert(index, value)
    def replace_ChargeTaxAmountDet_at(self, index, value): self.ChargeTaxAmountDet[index] = value
    def validate_ChargeValueType14(self, value):
        # Validate type ChargeValueType14, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeValueType14' % {"value" : value} )
    def validate_ChargeExchangeRateType(self, value):
        # Validate type ChargeExchangeRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeExchangeRateType' % {"value" : value} )
    def validate_ChargeTaxAmountType15(self, value):
        # Validate type ChargeTaxAmountType15, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ChargeTaxAmountType15' % {"value" : value} )
    def validate_CurrencyCodeType16(self, value):
        # Validate type CurrencyCodeType16, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType16' % {"value" : value.encode("utf-8")} )
    def validate_CurrencyRoleTypeCodeType17(self, value):
        # Validate type CurrencyRoleTypeCodeType17, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 5:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyRoleTypeCodeType17' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ChargeValue is not None or
            self.ChargeExchangeRate is not None or
            self.ChargeTaxAmount is not None or
            self.CurrencyCode is not None or
            self.CurrencyRoleTypeCode is not None or
            self.ChargeTaxAmountDet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdSExtrChrgInAdCurType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdSExtrChrgInAdCurType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdSExtrChrgInAdCurType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdSExtrChrgInAdCurType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdSExtrChrgInAdCurType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdSExtrChrgInAdCurType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChargeValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeValue>%s</ChargeValue>%s' % (self.gds_format_float(self.ChargeValue, input_name='ChargeValue'), eol_))
        if self.ChargeExchangeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeExchangeRate>%s</ChargeExchangeRate>%s' % (self.gds_format_float(self.ChargeExchangeRate, input_name='ChargeExchangeRate'), eol_))
        if self.ChargeTaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeTaxAmount>%s</ChargeTaxAmount>%s' % (self.gds_format_float(self.ChargeTaxAmount, input_name='ChargeTaxAmount'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.CurrencyRoleTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyRoleTypeCode>%s</CurrencyRoleTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyRoleTypeCode), input_name='CurrencyRoleTypeCode')), eol_))
        for ChargeTaxAmountDet_ in self.ChargeTaxAmountDet:
            ChargeTaxAmountDet_.export(outfile, level, namespace_, name_='ChargeTaxAmountDet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChargeValue':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeValue')
            self.ChargeValue = fval_
            # validate type ChargeValueType14
            self.validate_ChargeValueType14(self.ChargeValue)
        elif nodeName_ == 'ChargeExchangeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeExchangeRate')
            self.ChargeExchangeRate = fval_
            # validate type ChargeExchangeRateType
            self.validate_ChargeExchangeRateType(self.ChargeExchangeRate)
        elif nodeName_ == 'ChargeTaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ChargeTaxAmount')
            self.ChargeTaxAmount = fval_
            # validate type ChargeTaxAmountType15
            self.validate_ChargeTaxAmountType15(self.ChargeTaxAmount)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType16
            self.validate_CurrencyCodeType16(self.CurrencyCode)
        elif nodeName_ == 'CurrencyRoleTypeCode':
            CurrencyRoleTypeCode_ = child_.text
            CurrencyRoleTypeCode_ = self.gds_validate_string(CurrencyRoleTypeCode_, node, 'CurrencyRoleTypeCode')
            self.CurrencyRoleTypeCode = CurrencyRoleTypeCode_
            # validate type CurrencyRoleTypeCodeType17
            self.validate_CurrencyRoleTypeCodeType17(self.CurrencyRoleTypeCode)
        elif nodeName_ == 'ChargeTaxAmountDet':
            obj_ = ChargeTaxAmountDetType.factory()
            obj_.build(child_)
            self.ChargeTaxAmountDet.append(obj_)
            obj_.original_tagname_ = 'ChargeTaxAmountDet'
# end class QtdSExtrChrgInAdCurType


class QtdShpType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OriginServiceArea=None, DestinationServiceArea=None, GlobalProductCode=None, LocalProductCode=None, ProductShortName=None, LocalProductName=None, NetworkTypeCode=None, POfferedCustAgreement=None, TransInd=None, PickupDate=None, PickupCutoffTime=None, BookingTime=None, CurrencyCode=None, ExchangeRate=None, WeightCharge=None, WeightChargeTax=None, weightChargeTaxRate=None, TotalTransitDays=None, PickupPostalLocAddDays=None, DeliveryPostalLocAddDays=None, DeliveryTime=None, DeliveryTimeGMTOffset=None, DimensionalWeight=None, WeightUnit=None, PickupDayOfWeekNum=None, DestinationDayOfWeekNum=None, QuotedWeight=None, QuotedWeightUOM=None, QtdShpExChrg=None, PricingDate=None, ShippingCharge=None, TotalTaxAmount=None, TotalDiscount=None, WeightChargeTaxDet=None, PickupWindowEarliestTime=None, PickupWindowLatestTime=None, BookingCutoffOffset=None, DeliveryDate=None, PickupLeadTime=None, PickupCloseTime=None, WeightChargeDisc=None, QtdShpExChrgDisc=None):
        self.original_tagname_ = None
        self.OriginServiceArea = OriginServiceArea
        self.DestinationServiceArea = DestinationServiceArea
        self.GlobalProductCode = GlobalProductCode
        self.validate_GlobalProductCodeType(self.GlobalProductCode)
        self.LocalProductCode = LocalProductCode
        self.validate_LocalProductCodeType(self.LocalProductCode)
        self.ProductShortName = ProductShortName
        self.LocalProductName = LocalProductName
        self.NetworkTypeCode = NetworkTypeCode
        self.POfferedCustAgreement = POfferedCustAgreement
        self.TransInd = TransInd
        if isinstance(PickupDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PickupDate, '%Y-%m-%d').date()
        else:
            initvalue_ = PickupDate
        self.PickupDate = initvalue_
        self.PickupCutoffTime = PickupCutoffTime
        self.BookingTime = BookingTime
        self.validate_BookingTimeType(self.BookingTime)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType18(self.CurrencyCode)
        self.ExchangeRate = ExchangeRate
        self.validate_ExchangeRateType19(self.ExchangeRate)
        self.WeightCharge = WeightCharge
        self.validate_WeightChargeType20(self.WeightCharge)
        self.WeightChargeTax = WeightChargeTax
        self.validate_WeightChargeTaxType21(self.WeightChargeTax)
        self.weightChargeTaxRate = weightChargeTaxRate
        self.validate_weightChargeTaxRateType(self.weightChargeTaxRate)
        self.TotalTransitDays = TotalTransitDays
        self.validate_TotalTransitDaysType(self.TotalTransitDays)
        self.PickupPostalLocAddDays = PickupPostalLocAddDays
        self.validate_PickupPostalLocAddDaysType(self.PickupPostalLocAddDays)
        self.DeliveryPostalLocAddDays = DeliveryPostalLocAddDays
        self.validate_DeliveryPostalLocAddDaysType(self.DeliveryPostalLocAddDays)
        self.DeliveryTime = DeliveryTime
        self.validate_DeliveryTimeType(self.DeliveryTime)
        self.DeliveryTimeGMTOffset = DeliveryTimeGMTOffset
        self.validate_DeliveryTimeGMTOffsetType(self.DeliveryTimeGMTOffset)
        self.DimensionalWeight = DimensionalWeight
        self.validate_DimensionalWeightType(self.DimensionalWeight)
        self.WeightUnit = WeightUnit
        self.validate_WeightUnitType22(self.WeightUnit)
        self.PickupDayOfWeekNum = PickupDayOfWeekNum
        self.validate_PickupDayOfWeekNumType(self.PickupDayOfWeekNum)
        self.DestinationDayOfWeekNum = DestinationDayOfWeekNum
        self.validate_DestinationDayOfWeekNumType(self.DestinationDayOfWeekNum)
        self.QuotedWeight = QuotedWeight
        self.validate_QuotedWeight(self.QuotedWeight)
        self.QuotedWeightUOM = QuotedWeightUOM
        self.validate_QuotedWeightUOM(self.QuotedWeightUOM)
        if QtdShpExChrg is None:
            self.QtdShpExChrg = []
        else:
            self.QtdShpExChrg = QtdShpExChrg
        if isinstance(PricingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(PricingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = PricingDate
        self.PricingDate = initvalue_
        self.ShippingCharge = ShippingCharge
        self.validate_ShippingChargeType(self.ShippingCharge)
        self.TotalTaxAmount = TotalTaxAmount
        self.validate_TotalTaxAmountType23(self.TotalTaxAmount)
        self.TotalDiscount = TotalDiscount
        self.validate_TotalDiscountType24(self.TotalDiscount)
        if WeightChargeTaxDet is None:
            self.WeightChargeTaxDet = []
        else:
            self.WeightChargeTaxDet = WeightChargeTaxDet
        self.PickupWindowEarliestTime = PickupWindowEarliestTime
        self.validate_PickupWindowEarliestTimeType(self.PickupWindowEarliestTime)
        self.PickupWindowLatestTime = PickupWindowLatestTime
        self.validate_PickupWindowLatestTimeType(self.PickupWindowLatestTime)
        self.BookingCutoffOffset = BookingCutoffOffset
        self.validate_BookingCutoffOffsetType(self.BookingCutoffOffset)
        if DeliveryDate is None:
            self.DeliveryDate = []
        else:
            self.DeliveryDate = DeliveryDate
        self.PickupLeadTime = PickupLeadTime
        self.validate_PickupLeadTimeType(self.PickupLeadTime)
        self.PickupCloseTime = PickupCloseTime
        self.validate_PickupCloseTimeType(self.PickupCloseTime)
        if WeightChargeDisc is None:
            self.WeightChargeDisc = []
        else:
            self.WeightChargeDisc = WeightChargeDisc
        if QtdShpExChrgDisc is None:
            self.QtdShpExChrgDisc = []
        else:
            self.QtdShpExChrgDisc = QtdShpExChrgDisc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdShpType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdShpType.subclass:
            return QtdShpType.subclass(*args_, **kwargs_)
        else:
            return QtdShpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OriginServiceArea(self): return self.OriginServiceArea
    def set_OriginServiceArea(self, OriginServiceArea): self.OriginServiceArea = OriginServiceArea
    def get_DestinationServiceArea(self): return self.DestinationServiceArea
    def set_DestinationServiceArea(self, DestinationServiceArea): self.DestinationServiceArea = DestinationServiceArea
    def get_GlobalProductCode(self): return self.GlobalProductCode
    def set_GlobalProductCode(self, GlobalProductCode): self.GlobalProductCode = GlobalProductCode
    def get_LocalProductCode(self): return self.LocalProductCode
    def set_LocalProductCode(self, LocalProductCode): self.LocalProductCode = LocalProductCode
    def get_ProductShortName(self): return self.ProductShortName
    def set_ProductShortName(self, ProductShortName): self.ProductShortName = ProductShortName
    def get_LocalProductName(self): return self.LocalProductName
    def set_LocalProductName(self, LocalProductName): self.LocalProductName = LocalProductName
    def get_NetworkTypeCode(self): return self.NetworkTypeCode
    def set_NetworkTypeCode(self, NetworkTypeCode): self.NetworkTypeCode = NetworkTypeCode
    def get_POfferedCustAgreement(self): return self.POfferedCustAgreement
    def set_POfferedCustAgreement(self, POfferedCustAgreement): self.POfferedCustAgreement = POfferedCustAgreement
    def get_TransInd(self): return self.TransInd
    def set_TransInd(self, TransInd): self.TransInd = TransInd
    def get_PickupDate(self): return self.PickupDate
    def set_PickupDate(self, PickupDate): self.PickupDate = PickupDate
    def get_PickupCutoffTime(self): return self.PickupCutoffTime
    def set_PickupCutoffTime(self, PickupCutoffTime): self.PickupCutoffTime = PickupCutoffTime
    def get_BookingTime(self): return self.BookingTime
    def set_BookingTime(self, BookingTime): self.BookingTime = BookingTime
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_ExchangeRate(self): return self.ExchangeRate
    def set_ExchangeRate(self, ExchangeRate): self.ExchangeRate = ExchangeRate
    def get_WeightCharge(self): return self.WeightCharge
    def set_WeightCharge(self, WeightCharge): self.WeightCharge = WeightCharge
    def get_WeightChargeTax(self): return self.WeightChargeTax
    def set_WeightChargeTax(self, WeightChargeTax): self.WeightChargeTax = WeightChargeTax
    def get_weightChargeTaxRate(self): return self.weightChargeTaxRate
    def set_weightChargeTaxRate(self, weightChargeTaxRate): self.weightChargeTaxRate = weightChargeTaxRate
    def get_TotalTransitDays(self): return self.TotalTransitDays
    def set_TotalTransitDays(self, TotalTransitDays): self.TotalTransitDays = TotalTransitDays
    def get_PickupPostalLocAddDays(self): return self.PickupPostalLocAddDays
    def set_PickupPostalLocAddDays(self, PickupPostalLocAddDays): self.PickupPostalLocAddDays = PickupPostalLocAddDays
    def get_DeliveryPostalLocAddDays(self): return self.DeliveryPostalLocAddDays
    def set_DeliveryPostalLocAddDays(self, DeliveryPostalLocAddDays): self.DeliveryPostalLocAddDays = DeliveryPostalLocAddDays
    def get_DeliveryTime(self): return self.DeliveryTime
    def set_DeliveryTime(self, DeliveryTime): self.DeliveryTime = DeliveryTime
    def get_DeliveryTimeGMTOffset(self): return self.DeliveryTimeGMTOffset
    def set_DeliveryTimeGMTOffset(self, DeliveryTimeGMTOffset): self.DeliveryTimeGMTOffset = DeliveryTimeGMTOffset
    def get_DimensionalWeight(self): return self.DimensionalWeight
    def set_DimensionalWeight(self, DimensionalWeight): self.DimensionalWeight = DimensionalWeight
    def get_WeightUnit(self): return self.WeightUnit
    def set_WeightUnit(self, WeightUnit): self.WeightUnit = WeightUnit
    def get_PickupDayOfWeekNum(self): return self.PickupDayOfWeekNum
    def set_PickupDayOfWeekNum(self, PickupDayOfWeekNum): self.PickupDayOfWeekNum = PickupDayOfWeekNum
    def get_DestinationDayOfWeekNum(self): return self.DestinationDayOfWeekNum
    def set_DestinationDayOfWeekNum(self, DestinationDayOfWeekNum): self.DestinationDayOfWeekNum = DestinationDayOfWeekNum
    def get_QuotedWeight(self): return self.QuotedWeight
    def set_QuotedWeight(self, QuotedWeight): self.QuotedWeight = QuotedWeight
    def get_QuotedWeightUOM(self): return self.QuotedWeightUOM
    def set_QuotedWeightUOM(self, QuotedWeightUOM): self.QuotedWeightUOM = QuotedWeightUOM
    def get_QtdShpExChrg(self): return self.QtdShpExChrg
    def set_QtdShpExChrg(self, QtdShpExChrg): self.QtdShpExChrg = QtdShpExChrg
    def add_QtdShpExChrg(self, value): self.QtdShpExChrg.append(value)
    def insert_QtdShpExChrg_at(self, index, value): self.QtdShpExChrg.insert(index, value)
    def replace_QtdShpExChrg_at(self, index, value): self.QtdShpExChrg[index] = value
    def get_PricingDate(self): return self.PricingDate
    def set_PricingDate(self, PricingDate): self.PricingDate = PricingDate
    def get_ShippingCharge(self): return self.ShippingCharge
    def set_ShippingCharge(self, ShippingCharge): self.ShippingCharge = ShippingCharge
    def get_TotalTaxAmount(self): return self.TotalTaxAmount
    def set_TotalTaxAmount(self, TotalTaxAmount): self.TotalTaxAmount = TotalTaxAmount
    def get_TotalDiscount(self): return self.TotalDiscount
    def set_TotalDiscount(self, TotalDiscount): self.TotalDiscount = TotalDiscount
    def get_WeightChargeTaxDet(self): return self.WeightChargeTaxDet
    def set_WeightChargeTaxDet(self, WeightChargeTaxDet): self.WeightChargeTaxDet = WeightChargeTaxDet
    def add_WeightChargeTaxDet(self, value): self.WeightChargeTaxDet.append(value)
    def insert_WeightChargeTaxDet_at(self, index, value): self.WeightChargeTaxDet.insert(index, value)
    def replace_WeightChargeTaxDet_at(self, index, value): self.WeightChargeTaxDet[index] = value
    def get_PickupWindowEarliestTime(self): return self.PickupWindowEarliestTime
    def set_PickupWindowEarliestTime(self, PickupWindowEarliestTime): self.PickupWindowEarliestTime = PickupWindowEarliestTime
    def get_PickupWindowLatestTime(self): return self.PickupWindowLatestTime
    def set_PickupWindowLatestTime(self, PickupWindowLatestTime): self.PickupWindowLatestTime = PickupWindowLatestTime
    def get_BookingCutoffOffset(self): return self.BookingCutoffOffset
    def set_BookingCutoffOffset(self, BookingCutoffOffset): self.BookingCutoffOffset = BookingCutoffOffset
    def get_DeliveryDate(self): return self.DeliveryDate
    def set_DeliveryDate(self, DeliveryDate): self.DeliveryDate = DeliveryDate
    def add_DeliveryDate(self, value): self.DeliveryDate.append(value)
    def insert_DeliveryDate_at(self, index, value): self.DeliveryDate.insert(index, value)
    def replace_DeliveryDate_at(self, index, value): self.DeliveryDate[index] = value
    def get_PickupLeadTime(self): return self.PickupLeadTime
    def set_PickupLeadTime(self, PickupLeadTime): self.PickupLeadTime = PickupLeadTime
    def get_PickupCloseTime(self): return self.PickupCloseTime
    def set_PickupCloseTime(self, PickupCloseTime): self.PickupCloseTime = PickupCloseTime
    def get_WeightChargeDisc(self): return self.WeightChargeDisc
    def set_WeightChargeDisc(self, WeightChargeDisc): self.WeightChargeDisc = WeightChargeDisc
    def add_WeightChargeDisc(self, value): self.WeightChargeDisc.append(value)
    def insert_WeightChargeDisc_at(self, index, value): self.WeightChargeDisc.insert(index, value)
    def replace_WeightChargeDisc_at(self, index, value): self.WeightChargeDisc[index] = value
    def get_QtdShpExChrgDisc(self): return self.QtdShpExChrgDisc
    def set_QtdShpExChrgDisc(self, QtdShpExChrgDisc): self.QtdShpExChrgDisc = QtdShpExChrgDisc
    def add_QtdShpExChrgDisc(self, value): self.QtdShpExChrgDisc.append(value)
    def insert_QtdShpExChrgDisc_at(self, index, value): self.QtdShpExChrgDisc.insert(index, value)
    def replace_QtdShpExChrgDisc_at(self, index, value): self.QtdShpExChrgDisc[index] = value
    def validate_GlobalProductCodeType(self, value):
        # Validate type GlobalProductCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on GlobalProductCodeType' % {"value" : value.encode("utf-8")} )
    def validate_LocalProductCodeType(self, value):
        # Validate type LocalProductCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LocalProductCodeType' % {"value" : value.encode("utf-8")} )
    def validate_PickupDateType(self, value):
        # Validate type PickupDateType, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_BookingTimeType(self, value):
        # Validate type BookingTimeType, a restriction on xsd:duration.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_CurrencyCodeType18(self, value):
        # Validate type CurrencyCodeType18, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType18' % {"value" : value.encode("utf-8")} )
    def validate_ExchangeRateType19(self, value):
        # Validate type ExchangeRateType19, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ExchangeRateType19' % {"value" : value} )
    def validate_WeightChargeType20(self, value):
        # Validate type WeightChargeType20, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeType20' % {"value" : value} )
    def validate_WeightChargeTaxType21(self, value):
        # Validate type WeightChargeTaxType21, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on WeightChargeTaxType21' % {"value" : value} )
    def validate_weightChargeTaxRateType(self, value):
        # Validate type weightChargeTaxRateType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on weightChargeTaxRateType' % {"value" : value} )
    def validate_TotalTransitDaysType(self, value):
        # Validate type TotalTransitDaysType, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PickupPostalLocAddDaysType(self, value):
        # Validate type PickupPostalLocAddDaysType, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DeliveryPostalLocAddDaysType(self, value):
        # Validate type DeliveryPostalLocAddDaysType, a restriction on xsd:int.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DeliveryTimeType(self, value):
        # Validate type DeliveryTimeType, a restriction on xsd:duration.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DeliveryTimeGMTOffsetType(self, value):
        # Validate type DeliveryTimeGMTOffsetType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DeliveryTimeGMTOffsetType' % {"value" : value.encode("utf-8")} )
    def validate_DimensionalWeightType(self, value):
        # Validate type DimensionalWeightType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DimensionalWeightType' % {"value" : value} )
    def validate_WeightUnitType22(self, value):
        # Validate type WeightUnitType22, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on WeightUnitType22' % {"value" : value.encode("utf-8")} )
    def validate_PickupDayOfWeekNumType(self, value):
        # Validate type PickupDayOfWeekNumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PickupDayOfWeekNumType' % {"value" : value.encode("utf-8")} )
    def validate_DestinationDayOfWeekNumType(self, value):
        # Validate type DestinationDayOfWeekNumType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DestinationDayOfWeekNumType' % {"value" : value.encode("utf-8")} )
    def validate_QuotedWeight(self, value):
        # Validate type QuotedWeight, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on QuotedWeight' % {"value" : value} )
            if value > 999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on QuotedWeight' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on QuotedWeight' % {"value" : value} )
    def validate_QuotedWeightUOM(self, value):
        # Validate type QuotedWeightUOM, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['KG', 'Lbs']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on QuotedWeightUOM' % {"value" : value.encode("utf-8")} )
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on QuotedWeightUOM' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on QuotedWeightUOM' % {"value" : value.encode("utf-8")} )
    def validate_PricingDateType(self, value):
        # Validate type PricingDateType, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ShippingChargeType(self, value):
        # Validate type ShippingChargeType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on ShippingChargeType' % {"value" : value} )
    def validate_TotalTaxAmountType23(self, value):
        # Validate type TotalTaxAmountType23, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TotalTaxAmountType23' % {"value" : value} )
    def validate_TotalDiscountType24(self, value):
        # Validate type TotalDiscountType24, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on TotalDiscountType24' % {"value" : value} )
    def validate_PickupWindowEarliestTimeType(self, value):
        # Validate type PickupWindowEarliestTimeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PickupWindowLatestTimeType(self, value):
        # Validate type PickupWindowLatestTimeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_BookingCutoffOffsetType(self, value):
        # Validate type BookingCutoffOffsetType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PickupLeadTimeType(self, value):
        # Validate type PickupLeadTimeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PickupLeadTimeType' % {"value" : value.encode("utf-8")} )
    def validate_PickupCloseTimeType(self, value):
        # Validate type PickupCloseTimeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on PickupCloseTimeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OriginServiceArea is not None or
            self.DestinationServiceArea is not None or
            self.GlobalProductCode is not None or
            self.LocalProductCode is not None or
            self.ProductShortName is not None or
            self.LocalProductName is not None or
            self.NetworkTypeCode is not None or
            self.POfferedCustAgreement is not None or
            self.TransInd is not None or
            self.PickupDate is not None or
            self.PickupCutoffTime is not None or
            self.BookingTime is not None or
            self.CurrencyCode is not None or
            self.ExchangeRate is not None or
            self.WeightCharge is not None or
            self.WeightChargeTax is not None or
            self.weightChargeTaxRate is not None or
            self.TotalTransitDays is not None or
            self.PickupPostalLocAddDays is not None or
            self.DeliveryPostalLocAddDays is not None or
            self.DeliveryTime is not None or
            self.DeliveryTimeGMTOffset is not None or
            self.DimensionalWeight is not None or
            self.WeightUnit is not None or
            self.PickupDayOfWeekNum is not None or
            self.DestinationDayOfWeekNum is not None or
            self.QuotedWeight is not None or
            self.QuotedWeightUOM is not None or
            self.QtdShpExChrg or
            self.PricingDate is not None or
            self.ShippingCharge is not None or
            self.TotalTaxAmount is not None or
            self.TotalDiscount is not None or
            self.WeightChargeTaxDet or
            self.PickupWindowEarliestTime is not None or
            self.PickupWindowLatestTime is not None or
            self.BookingCutoffOffset is not None or
            self.DeliveryDate or
            self.PickupLeadTime is not None or
            self.PickupCloseTime is not None or
            self.WeightChargeDisc or
            self.QtdShpExChrgDisc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdShpType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdShpType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdShpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdShpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdShpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdShpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OriginServiceArea is not None:
            self.OriginServiceArea.export(outfile, level, namespace_, name_='OriginServiceArea', pretty_print=pretty_print)
        if self.DestinationServiceArea is not None:
            self.DestinationServiceArea.export(outfile, level, namespace_, name_='DestinationServiceArea', pretty_print=pretty_print)
        if self.GlobalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalProductCode>%s</GlobalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalProductCode), input_name='GlobalProductCode')), eol_))
        if self.LocalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductCode>%s</LocalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductCode), input_name='LocalProductCode')), eol_))
        if self.ProductShortName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ProductShortName>%s</ProductShortName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProductShortName), input_name='ProductShortName')), eol_))
        if self.LocalProductName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductName>%s</LocalProductName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductName), input_name='LocalProductName')), eol_))
        if self.NetworkTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NetworkTypeCode>%s</NetworkTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NetworkTypeCode), input_name='NetworkTypeCode')), eol_))
        if self.POfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<POfferedCustAgreement>%s</POfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.POfferedCustAgreement), input_name='POfferedCustAgreement')), eol_))
        if self.TransInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TransInd>%s</TransInd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransInd), input_name='TransInd')), eol_))
        if self.PickupDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupDate>%s</PickupDate>%s' % (self.gds_format_date(self.PickupDate, input_name='PickupDate'), eol_))
        if self.PickupCutoffTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupCutoffTime>%s</PickupCutoffTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupCutoffTime), input_name='PickupCutoffTime')), eol_))
        if self.BookingTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BookingTime>%s</BookingTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BookingTime), input_name='BookingTime')), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.ExchangeRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ExchangeRate>%s</ExchangeRate>%s' % (self.gds_format_float(self.ExchangeRate, input_name='ExchangeRate'), eol_))
        if self.WeightCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightCharge>%s</WeightCharge>%s' % (self.gds_format_float(self.WeightCharge, input_name='WeightCharge'), eol_))
        if self.WeightChargeTax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightChargeTax>%s</WeightChargeTax>%s' % (self.gds_format_float(self.WeightChargeTax, input_name='WeightChargeTax'), eol_))
        if self.weightChargeTaxRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<weightChargeTaxRate>%s</weightChargeTaxRate>%s' % (self.gds_format_float(self.weightChargeTaxRate, input_name='weightChargeTaxRate'), eol_))
        if self.TotalTransitDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalTransitDays>%s</TotalTransitDays>%s' % (self.gds_format_integer(self.TotalTransitDays, input_name='TotalTransitDays'), eol_))
        if self.PickupPostalLocAddDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupPostalLocAddDays>%s</PickupPostalLocAddDays>%s' % (self.gds_format_integer(self.PickupPostalLocAddDays, input_name='PickupPostalLocAddDays'), eol_))
        if self.DeliveryPostalLocAddDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryPostalLocAddDays>%s</DeliveryPostalLocAddDays>%s' % (self.gds_format_integer(self.DeliveryPostalLocAddDays, input_name='DeliveryPostalLocAddDays'), eol_))
        if self.DeliveryTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryTime>%s</DeliveryTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryTime), input_name='DeliveryTime')), eol_))
        if self.DeliveryTimeGMTOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryTimeGMTOffset>%s</DeliveryTimeGMTOffset>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryTimeGMTOffset), input_name='DeliveryTimeGMTOffset')), eol_))
        if self.DimensionalWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DimensionalWeight>%s</DimensionalWeight>%s' % (self.gds_format_float(self.DimensionalWeight, input_name='DimensionalWeight'), eol_))
        if self.WeightUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightUnit>%s</WeightUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeightUnit), input_name='WeightUnit')), eol_))
        if self.PickupDayOfWeekNum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupDayOfWeekNum>%s</PickupDayOfWeekNum>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupDayOfWeekNum), input_name='PickupDayOfWeekNum')), eol_))
        if self.DestinationDayOfWeekNum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DestinationDayOfWeekNum>%s</DestinationDayOfWeekNum>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DestinationDayOfWeekNum), input_name='DestinationDayOfWeekNum')), eol_))
        if self.QuotedWeight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<QuotedWeight>%s</QuotedWeight>%s' % (self.gds_format_float(self.QuotedWeight, input_name='QuotedWeight'), eol_))
        if self.QuotedWeightUOM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<QuotedWeightUOM>%s</QuotedWeightUOM>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.QuotedWeightUOM), input_name='QuotedWeightUOM')), eol_))
        for QtdShpExChrg_ in self.QtdShpExChrg:
            QtdShpExChrg_.export(outfile, level, namespace_, name_='QtdShpExChrg', pretty_print=pretty_print)
        if self.PricingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PricingDate>%s</PricingDate>%s' % (self.gds_format_date(self.PricingDate, input_name='PricingDate'), eol_))
        if self.ShippingCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ShippingCharge>%s</ShippingCharge>%s' % (self.gds_format_float(self.ShippingCharge, input_name='ShippingCharge'), eol_))
        if self.TotalTaxAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalTaxAmount>%s</TotalTaxAmount>%s' % (self.gds_format_float(self.TotalTaxAmount, input_name='TotalTaxAmount'), eol_))
        if self.TotalDiscount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TotalDiscount>%s</TotalDiscount>%s' % (self.gds_format_float(self.TotalDiscount, input_name='TotalDiscount'), eol_))
        for WeightChargeTaxDet_ in self.WeightChargeTaxDet:
            WeightChargeTaxDet_.export(outfile, level, namespace_, name_='WeightChargeTaxDet', pretty_print=pretty_print)
        if self.PickupWindowEarliestTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupWindowEarliestTime>%s</PickupWindowEarliestTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupWindowEarliestTime), input_name='PickupWindowEarliestTime')), eol_))
        if self.PickupWindowLatestTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupWindowLatestTime>%s</PickupWindowLatestTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupWindowLatestTime), input_name='PickupWindowLatestTime')), eol_))
        if self.BookingCutoffOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BookingCutoffOffset>%s</BookingCutoffOffset>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BookingCutoffOffset), input_name='BookingCutoffOffset')), eol_))
        for DeliveryDate_ in self.DeliveryDate:
            DeliveryDate_.export(outfile, level, namespace_, name_='DeliveryDate', pretty_print=pretty_print)
        if self.PickupLeadTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupLeadTime>%s</PickupLeadTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupLeadTime), input_name='PickupLeadTime')), eol_))
        if self.PickupCloseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<PickupCloseTime>%s</PickupCloseTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PickupCloseTime), input_name='PickupCloseTime')), eol_))
        for WeightChargeDisc_ in self.WeightChargeDisc:
            WeightChargeDisc_.export(outfile, level, namespace_, name_='WeightChargeDisc', pretty_print=pretty_print)
        for QtdShpExChrgDisc_ in self.QtdShpExChrgDisc:
            QtdShpExChrgDisc_.export(outfile, level, namespace_, name_='QtdShpExChrgDisc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OriginServiceArea':
            obj_ = OrgnSvcAreaType.factory()
            obj_.build(child_)
            self.OriginServiceArea = obj_
            obj_.original_tagname_ = 'OriginServiceArea'
        elif nodeName_ == 'DestinationServiceArea':
            obj_ = DestSvcAreaType.factory()
            obj_.build(child_)
            self.DestinationServiceArea = obj_
            obj_.original_tagname_ = 'DestinationServiceArea'
        elif nodeName_ == 'GlobalProductCode':
            GlobalProductCode_ = child_.text
            GlobalProductCode_ = self.gds_validate_string(GlobalProductCode_, node, 'GlobalProductCode')
            self.GlobalProductCode = GlobalProductCode_
            # validate type GlobalProductCodeType
            self.validate_GlobalProductCodeType(self.GlobalProductCode)
        elif nodeName_ == 'LocalProductCode':
            LocalProductCode_ = child_.text
            LocalProductCode_ = self.gds_validate_string(LocalProductCode_, node, 'LocalProductCode')
            self.LocalProductCode = LocalProductCode_
            # validate type LocalProductCodeType
            self.validate_LocalProductCodeType(self.LocalProductCode)
        elif nodeName_ == 'ProductShortName':
            ProductShortName_ = child_.text
            ProductShortName_ = self.gds_validate_string(ProductShortName_, node, 'ProductShortName')
            self.ProductShortName = ProductShortName_
        elif nodeName_ == 'LocalProductName':
            LocalProductName_ = child_.text
            LocalProductName_ = self.gds_validate_string(LocalProductName_, node, 'LocalProductName')
            self.LocalProductName = LocalProductName_
        elif nodeName_ == 'NetworkTypeCode':
            NetworkTypeCode_ = child_.text
            NetworkTypeCode_ = self.gds_validate_string(NetworkTypeCode_, node, 'NetworkTypeCode')
            self.NetworkTypeCode = NetworkTypeCode_
        elif nodeName_ == 'POfferedCustAgreement':
            POfferedCustAgreement_ = child_.text
            POfferedCustAgreement_ = self.gds_validate_string(POfferedCustAgreement_, node, 'POfferedCustAgreement')
            self.POfferedCustAgreement = POfferedCustAgreement_
        elif nodeName_ == 'TransInd':
            TransInd_ = child_.text
            TransInd_ = self.gds_validate_string(TransInd_, node, 'TransInd')
            self.TransInd = TransInd_
        elif nodeName_ == 'PickupDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PickupDate = dval_
            # validate type PickupDateType
            self.validate_PickupDateType(self.PickupDate)
        elif nodeName_ == 'PickupCutoffTime':
            PickupCutoffTime_ = child_.text
            PickupCutoffTime_ = self.gds_validate_string(PickupCutoffTime_, node, 'PickupCutoffTime')
            self.PickupCutoffTime = PickupCutoffTime_
        elif nodeName_ == 'BookingTime':
            BookingTime_ = child_.text
            BookingTime_ = self.gds_validate_string(BookingTime_, node, 'BookingTime')
            self.BookingTime = BookingTime_
            # validate type BookingTimeType
            self.validate_BookingTimeType(self.BookingTime)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType18
            self.validate_CurrencyCodeType18(self.CurrencyCode)
        elif nodeName_ == 'ExchangeRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ExchangeRate')
            self.ExchangeRate = fval_
            # validate type ExchangeRateType19
            self.validate_ExchangeRateType19(self.ExchangeRate)
        elif nodeName_ == 'WeightCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightCharge')
            self.WeightCharge = fval_
            # validate type WeightChargeType20
            self.validate_WeightChargeType20(self.WeightCharge)
        elif nodeName_ == 'WeightChargeTax':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'WeightChargeTax')
            self.WeightChargeTax = fval_
            # validate type WeightChargeTaxType21
            self.validate_WeightChargeTaxType21(self.WeightChargeTax)
        elif nodeName_ == 'weightChargeTaxRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'weightChargeTaxRate')
            self.weightChargeTaxRate = fval_
            # validate type weightChargeTaxRateType
            self.validate_weightChargeTaxRateType(self.weightChargeTaxRate)
        elif nodeName_ == 'TotalTransitDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TotalTransitDays')
            self.TotalTransitDays = ival_
            # validate type TotalTransitDaysType
            self.validate_TotalTransitDaysType(self.TotalTransitDays)
        elif nodeName_ == 'PickupPostalLocAddDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PickupPostalLocAddDays')
            self.PickupPostalLocAddDays = ival_
            # validate type PickupPostalLocAddDaysType
            self.validate_PickupPostalLocAddDaysType(self.PickupPostalLocAddDays)
        elif nodeName_ == 'DeliveryPostalLocAddDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DeliveryPostalLocAddDays')
            self.DeliveryPostalLocAddDays = ival_
            # validate type DeliveryPostalLocAddDaysType
            self.validate_DeliveryPostalLocAddDaysType(self.DeliveryPostalLocAddDays)
        elif nodeName_ == 'DeliveryTime':
            DeliveryTime_ = child_.text
            DeliveryTime_ = self.gds_validate_string(DeliveryTime_, node, 'DeliveryTime')
            self.DeliveryTime = DeliveryTime_
            # validate type DeliveryTimeType
            self.validate_DeliveryTimeType(self.DeliveryTime)
        elif nodeName_ == 'DeliveryTimeGMTOffset':
            DeliveryTimeGMTOffset_ = child_.text
            DeliveryTimeGMTOffset_ = self.gds_validate_string(DeliveryTimeGMTOffset_, node, 'DeliveryTimeGMTOffset')
            self.DeliveryTimeGMTOffset = DeliveryTimeGMTOffset_
            # validate type DeliveryTimeGMTOffsetType
            self.validate_DeliveryTimeGMTOffsetType(self.DeliveryTimeGMTOffset)
        elif nodeName_ == 'DimensionalWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DimensionalWeight')
            self.DimensionalWeight = fval_
            # validate type DimensionalWeightType
            self.validate_DimensionalWeightType(self.DimensionalWeight)
        elif nodeName_ == 'WeightUnit':
            WeightUnit_ = child_.text
            WeightUnit_ = self.gds_validate_string(WeightUnit_, node, 'WeightUnit')
            self.WeightUnit = WeightUnit_
            # validate type WeightUnitType22
            self.validate_WeightUnitType22(self.WeightUnit)
        elif nodeName_ == 'PickupDayOfWeekNum':
            PickupDayOfWeekNum_ = child_.text
            PickupDayOfWeekNum_ = self.gds_validate_string(PickupDayOfWeekNum_, node, 'PickupDayOfWeekNum')
            self.PickupDayOfWeekNum = PickupDayOfWeekNum_
            # validate type PickupDayOfWeekNumType
            self.validate_PickupDayOfWeekNumType(self.PickupDayOfWeekNum)
        elif nodeName_ == 'DestinationDayOfWeekNum':
            DestinationDayOfWeekNum_ = child_.text
            DestinationDayOfWeekNum_ = self.gds_validate_string(DestinationDayOfWeekNum_, node, 'DestinationDayOfWeekNum')
            self.DestinationDayOfWeekNum = DestinationDayOfWeekNum_
            # validate type DestinationDayOfWeekNumType
            self.validate_DestinationDayOfWeekNumType(self.DestinationDayOfWeekNum)
        elif nodeName_ == 'QuotedWeight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QuotedWeight')
            self.QuotedWeight = fval_
            # validate type QuotedWeight
            self.validate_QuotedWeight(self.QuotedWeight)
        elif nodeName_ == 'QuotedWeightUOM':
            QuotedWeightUOM_ = child_.text
            QuotedWeightUOM_ = self.gds_validate_string(QuotedWeightUOM_, node, 'QuotedWeightUOM')
            self.QuotedWeightUOM = QuotedWeightUOM_
            # validate type QuotedWeightUOM
            self.validate_QuotedWeightUOM(self.QuotedWeightUOM)
        elif nodeName_ == 'QtdShpExChrg':
            obj_ = QtdShpExChrgType.factory()
            obj_.build(child_)
            self.QtdShpExChrg.append(obj_)
            obj_.original_tagname_ = 'QtdShpExChrg'
        elif nodeName_ == 'PricingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.PricingDate = dval_
            # validate type PricingDateType
            self.validate_PricingDateType(self.PricingDate)
        elif nodeName_ == 'ShippingCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ShippingCharge')
            self.ShippingCharge = fval_
            # validate type ShippingChargeType
            self.validate_ShippingChargeType(self.ShippingCharge)
        elif nodeName_ == 'TotalTaxAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TotalTaxAmount')
            self.TotalTaxAmount = fval_
            # validate type TotalTaxAmountType23
            self.validate_TotalTaxAmountType23(self.TotalTaxAmount)
        elif nodeName_ == 'TotalDiscount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TotalDiscount')
            self.TotalDiscount = fval_
            # validate type TotalDiscountType24
            self.validate_TotalDiscountType24(self.TotalDiscount)
        elif nodeName_ == 'WeightChargeTaxDet':
            obj_ = WeightChargeTaxDetType.factory()
            obj_.build(child_)
            self.WeightChargeTaxDet.append(obj_)
            obj_.original_tagname_ = 'WeightChargeTaxDet'
        elif nodeName_ == 'PickupWindowEarliestTime':
            PickupWindowEarliestTime_ = child_.text
            PickupWindowEarliestTime_ = self.gds_validate_string(PickupWindowEarliestTime_, node, 'PickupWindowEarliestTime')
            self.PickupWindowEarliestTime = PickupWindowEarliestTime_
            # validate type PickupWindowEarliestTimeType
            self.validate_PickupWindowEarliestTimeType(self.PickupWindowEarliestTime)
        elif nodeName_ == 'PickupWindowLatestTime':
            PickupWindowLatestTime_ = child_.text
            PickupWindowLatestTime_ = self.gds_validate_string(PickupWindowLatestTime_, node, 'PickupWindowLatestTime')
            self.PickupWindowLatestTime = PickupWindowLatestTime_
            # validate type PickupWindowLatestTimeType
            self.validate_PickupWindowLatestTimeType(self.PickupWindowLatestTime)
        elif nodeName_ == 'BookingCutoffOffset':
            BookingCutoffOffset_ = child_.text
            BookingCutoffOffset_ = self.gds_validate_string(BookingCutoffOffset_, node, 'BookingCutoffOffset')
            self.BookingCutoffOffset = BookingCutoffOffset_
            # validate type BookingCutoffOffsetType
            self.validate_BookingCutoffOffsetType(self.BookingCutoffOffset)
        elif nodeName_ == 'DeliveryDate':
            obj_ = DeliveryDate.factory()
            obj_.build(child_)
            self.DeliveryDate.append(obj_)
            obj_.original_tagname_ = 'DeliveryDate'
        elif nodeName_ == 'PickupLeadTime':
            PickupLeadTime_ = child_.text
            PickupLeadTime_ = self.gds_validate_string(PickupLeadTime_, node, 'PickupLeadTime')
            self.PickupLeadTime = PickupLeadTime_
            # validate type PickupLeadTimeType
            self.validate_PickupLeadTimeType(self.PickupLeadTime)
        elif nodeName_ == 'PickupCloseTime':
            PickupCloseTime_ = child_.text
            PickupCloseTime_ = self.gds_validate_string(PickupCloseTime_, node, 'PickupCloseTime')
            self.PickupCloseTime = PickupCloseTime_
            # validate type PickupCloseTimeType
            self.validate_PickupCloseTimeType(self.PickupCloseTime)
        elif nodeName_ == 'WeightChargeDisc':
            obj_ = WeightChargeDisc.factory()
            obj_.build(child_)
            self.WeightChargeDisc.append(obj_)
            obj_.original_tagname_ = 'WeightChargeDisc'
        elif nodeName_ == 'QtdShpExChrgDisc':
            obj_ = QtdShpExChrgDisc.factory()
            obj_.build(child_)
            self.QtdShpExChrgDisc.append(obj_)
            obj_.original_tagname_ = 'QtdShpExChrgDisc'
# end class QtdShpType


class MrkSrvType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LocalProductCode=None, LocalServiceType=None, ProductShortName=None, GlobalServiceName=None, LocalProductName=None, LocalServiceTypeName=None, ProductDesc=None, ServiceDesc=None, NetworkTypeCode=None, POfferedCustAgreement=None, SOfferedCustAgreement=None, TransInd=None, ChargeCodeType=None, MrkSrvInd=None, LocalProductCtryCd=None, LocalProductDesc=None, GlobalProductDesc=None, GlobalServiceType=None, BillingServiceIndicator=None, LocalServiceName=None):
        self.original_tagname_ = None
        self.LocalProductCode = LocalProductCode
        self.LocalServiceType = LocalServiceType
        self.ProductShortName = ProductShortName
        self.GlobalServiceName = GlobalServiceName
        self.LocalProductName = LocalProductName
        self.LocalServiceTypeName = LocalServiceTypeName
        self.ProductDesc = ProductDesc
        self.ServiceDesc = ServiceDesc
        self.NetworkTypeCode = NetworkTypeCode
        self.POfferedCustAgreement = POfferedCustAgreement
        self.SOfferedCustAgreement = SOfferedCustAgreement
        self.TransInd = TransInd
        if ChargeCodeType is None:
            self.ChargeCodeType = []
        else:
            self.ChargeCodeType = ChargeCodeType
        self.MrkSrvInd = MrkSrvInd
        self.validate_MrkSrvIndType(self.MrkSrvInd)
        self.LocalProductCtryCd = LocalProductCtryCd
        self.validate_LocalProductCtryCdType(self.LocalProductCtryCd)
        self.LocalProductDesc = LocalProductDesc
        self.GlobalProductDesc = GlobalProductDesc
        self.GlobalServiceType = GlobalServiceType
        self.BillingServiceIndicator = BillingServiceIndicator
        self.LocalServiceName = LocalServiceName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MrkSrvType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MrkSrvType.subclass:
            return MrkSrvType.subclass(*args_, **kwargs_)
        else:
            return MrkSrvType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocalProductCode(self): return self.LocalProductCode
    def set_LocalProductCode(self, LocalProductCode): self.LocalProductCode = LocalProductCode
    def get_LocalServiceType(self): return self.LocalServiceType
    def set_LocalServiceType(self, LocalServiceType): self.LocalServiceType = LocalServiceType
    def get_ProductShortName(self): return self.ProductShortName
    def set_ProductShortName(self, ProductShortName): self.ProductShortName = ProductShortName
    def get_GlobalServiceName(self): return self.GlobalServiceName
    def set_GlobalServiceName(self, GlobalServiceName): self.GlobalServiceName = GlobalServiceName
    def get_LocalProductName(self): return self.LocalProductName
    def set_LocalProductName(self, LocalProductName): self.LocalProductName = LocalProductName
    def get_LocalServiceTypeName(self): return self.LocalServiceTypeName
    def set_LocalServiceTypeName(self, LocalServiceTypeName): self.LocalServiceTypeName = LocalServiceTypeName
    def get_ProductDesc(self): return self.ProductDesc
    def set_ProductDesc(self, ProductDesc): self.ProductDesc = ProductDesc
    def get_ServiceDesc(self): return self.ServiceDesc
    def set_ServiceDesc(self, ServiceDesc): self.ServiceDesc = ServiceDesc
    def get_NetworkTypeCode(self): return self.NetworkTypeCode
    def set_NetworkTypeCode(self, NetworkTypeCode): self.NetworkTypeCode = NetworkTypeCode
    def get_POfferedCustAgreement(self): return self.POfferedCustAgreement
    def set_POfferedCustAgreement(self, POfferedCustAgreement): self.POfferedCustAgreement = POfferedCustAgreement
    def get_SOfferedCustAgreement(self): return self.SOfferedCustAgreement
    def set_SOfferedCustAgreement(self, SOfferedCustAgreement): self.SOfferedCustAgreement = SOfferedCustAgreement
    def get_TransInd(self): return self.TransInd
    def set_TransInd(self, TransInd): self.TransInd = TransInd
    def get_ChargeCodeType(self): return self.ChargeCodeType
    def set_ChargeCodeType(self, ChargeCodeType): self.ChargeCodeType = ChargeCodeType
    def add_ChargeCodeType(self, value): self.ChargeCodeType.append(value)
    def insert_ChargeCodeType_at(self, index, value): self.ChargeCodeType.insert(index, value)
    def replace_ChargeCodeType_at(self, index, value): self.ChargeCodeType[index] = value
    def get_MrkSrvInd(self): return self.MrkSrvInd
    def set_MrkSrvInd(self, MrkSrvInd): self.MrkSrvInd = MrkSrvInd
    def get_LocalProductCtryCd(self): return self.LocalProductCtryCd
    def set_LocalProductCtryCd(self, LocalProductCtryCd): self.LocalProductCtryCd = LocalProductCtryCd
    def get_LocalProductDesc(self): return self.LocalProductDesc
    def set_LocalProductDesc(self, LocalProductDesc): self.LocalProductDesc = LocalProductDesc
    def get_GlobalProductDesc(self): return self.GlobalProductDesc
    def set_GlobalProductDesc(self, GlobalProductDesc): self.GlobalProductDesc = GlobalProductDesc
    def get_GlobalServiceType(self): return self.GlobalServiceType
    def set_GlobalServiceType(self, GlobalServiceType): self.GlobalServiceType = GlobalServiceType
    def get_BillingServiceIndicator(self): return self.BillingServiceIndicator
    def set_BillingServiceIndicator(self, BillingServiceIndicator): self.BillingServiceIndicator = BillingServiceIndicator
    def get_LocalServiceName(self): return self.LocalServiceName
    def set_LocalServiceName(self, LocalServiceName): self.LocalServiceName = LocalServiceName
    def validate_MrkSrvIndType(self, value):
        # Validate type MrkSrvIndType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on MrkSrvIndType' % {"value" : value.encode("utf-8")} )
    def validate_LocalProductCtryCdType(self, value):
        # Validate type LocalProductCtryCdType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on LocalProductCtryCdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LocalProductCode is not None or
            self.LocalServiceType is not None or
            self.ProductShortName is not None or
            self.GlobalServiceName is not None or
            self.LocalProductName is not None or
            self.LocalServiceTypeName is not None or
            self.ProductDesc is not None or
            self.ServiceDesc is not None or
            self.NetworkTypeCode is not None or
            self.POfferedCustAgreement is not None or
            self.SOfferedCustAgreement is not None or
            self.TransInd is not None or
            self.ChargeCodeType or
            self.MrkSrvInd is not None or
            self.LocalProductCtryCd is not None or
            self.LocalProductDesc is not None or
            self.GlobalProductDesc is not None or
            self.GlobalServiceType is not None or
            self.BillingServiceIndicator is not None or
            self.LocalServiceName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MrkSrvType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MrkSrvType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MrkSrvType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MrkSrvType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MrkSrvType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MrkSrvType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LocalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductCode>%s</LocalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductCode), input_name='LocalProductCode')), eol_))
        if self.LocalServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceType>%s</LocalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceType), input_name='LocalServiceType')), eol_))
        if self.ProductShortName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ProductShortName>%s</ProductShortName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProductShortName), input_name='ProductShortName')), eol_))
        if self.GlobalServiceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceName>%s</GlobalServiceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceName), input_name='GlobalServiceName')), eol_))
        if self.LocalProductName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductName>%s</LocalProductName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductName), input_name='LocalProductName')), eol_))
        if self.LocalServiceTypeName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceTypeName>%s</LocalServiceTypeName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceTypeName), input_name='LocalServiceTypeName')), eol_))
        if self.ProductDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ProductDesc>%s</ProductDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ProductDesc), input_name='ProductDesc')), eol_))
        if self.ServiceDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ServiceDesc>%s</ServiceDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ServiceDesc), input_name='ServiceDesc')), eol_))
        if self.NetworkTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NetworkTypeCode>%s</NetworkTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NetworkTypeCode), input_name='NetworkTypeCode')), eol_))
        if self.POfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<POfferedCustAgreement>%s</POfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.POfferedCustAgreement), input_name='POfferedCustAgreement')), eol_))
        if self.SOfferedCustAgreement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SOfferedCustAgreement>%s</SOfferedCustAgreement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SOfferedCustAgreement), input_name='SOfferedCustAgreement')), eol_))
        if self.TransInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TransInd>%s</TransInd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransInd), input_name='TransInd')), eol_))
        for ChargeCodeType_ in self.ChargeCodeType:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ChargeCodeType>%s</ChargeCodeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(ChargeCodeType_), input_name='ChargeCodeType')), eol_))
        if self.MrkSrvInd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MrkSrvInd>%s</MrkSrvInd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MrkSrvInd), input_name='MrkSrvInd')), eol_))
        if self.LocalProductCtryCd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductCtryCd>%s</LocalProductCtryCd>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductCtryCd), input_name='LocalProductCtryCd')), eol_))
        if self.LocalProductDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalProductDesc>%s</LocalProductDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalProductDesc), input_name='LocalProductDesc')), eol_))
        if self.GlobalProductDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalProductDesc>%s</GlobalProductDesc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalProductDesc), input_name='GlobalProductDesc')), eol_))
        if self.GlobalServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalServiceType>%s</GlobalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalServiceType), input_name='GlobalServiceType')), eol_))
        if self.BillingServiceIndicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BillingServiceIndicator>%s</BillingServiceIndicator>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.BillingServiceIndicator), input_name='BillingServiceIndicator')), eol_))
        if self.LocalServiceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceName>%s</LocalServiceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocalServiceName), input_name='LocalServiceName')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocalProductCode':
            LocalProductCode_ = child_.text
            LocalProductCode_ = self.gds_validate_string(LocalProductCode_, node, 'LocalProductCode')
            self.LocalProductCode = LocalProductCode_
        elif nodeName_ == 'LocalServiceType':
            LocalServiceType_ = child_.text
            LocalServiceType_ = self.gds_validate_string(LocalServiceType_, node, 'LocalServiceType')
            self.LocalServiceType = LocalServiceType_
        elif nodeName_ == 'ProductShortName':
            ProductShortName_ = child_.text
            ProductShortName_ = self.gds_validate_string(ProductShortName_, node, 'ProductShortName')
            self.ProductShortName = ProductShortName_
        elif nodeName_ == 'GlobalServiceName':
            GlobalServiceName_ = child_.text
            GlobalServiceName_ = self.gds_validate_string(GlobalServiceName_, node, 'GlobalServiceName')
            self.GlobalServiceName = GlobalServiceName_
        elif nodeName_ == 'LocalProductName':
            LocalProductName_ = child_.text
            LocalProductName_ = self.gds_validate_string(LocalProductName_, node, 'LocalProductName')
            self.LocalProductName = LocalProductName_
        elif nodeName_ == 'LocalServiceTypeName':
            LocalServiceTypeName_ = child_.text
            LocalServiceTypeName_ = self.gds_validate_string(LocalServiceTypeName_, node, 'LocalServiceTypeName')
            self.LocalServiceTypeName = LocalServiceTypeName_
        elif nodeName_ == 'ProductDesc':
            ProductDesc_ = child_.text
            ProductDesc_ = self.gds_validate_string(ProductDesc_, node, 'ProductDesc')
            self.ProductDesc = ProductDesc_
        elif nodeName_ == 'ServiceDesc':
            ServiceDesc_ = child_.text
            ServiceDesc_ = self.gds_validate_string(ServiceDesc_, node, 'ServiceDesc')
            self.ServiceDesc = ServiceDesc_
        elif nodeName_ == 'NetworkTypeCode':
            NetworkTypeCode_ = child_.text
            NetworkTypeCode_ = self.gds_validate_string(NetworkTypeCode_, node, 'NetworkTypeCode')
            self.NetworkTypeCode = NetworkTypeCode_
        elif nodeName_ == 'POfferedCustAgreement':
            POfferedCustAgreement_ = child_.text
            POfferedCustAgreement_ = self.gds_validate_string(POfferedCustAgreement_, node, 'POfferedCustAgreement')
            self.POfferedCustAgreement = POfferedCustAgreement_
        elif nodeName_ == 'SOfferedCustAgreement':
            SOfferedCustAgreement_ = child_.text
            SOfferedCustAgreement_ = self.gds_validate_string(SOfferedCustAgreement_, node, 'SOfferedCustAgreement')
            self.SOfferedCustAgreement = SOfferedCustAgreement_
        elif nodeName_ == 'TransInd':
            TransInd_ = child_.text
            TransInd_ = self.gds_validate_string(TransInd_, node, 'TransInd')
            self.TransInd = TransInd_
        elif nodeName_ == 'ChargeCodeType':
            ChargeCodeType_ = child_.text
            ChargeCodeType_ = self.gds_validate_string(ChargeCodeType_, node, 'ChargeCodeType')
            self.ChargeCodeType.append(ChargeCodeType_)
        elif nodeName_ == 'MrkSrvInd':
            MrkSrvInd_ = child_.text
            MrkSrvInd_ = self.gds_validate_string(MrkSrvInd_, node, 'MrkSrvInd')
            self.MrkSrvInd = MrkSrvInd_
            # validate type MrkSrvIndType
            self.validate_MrkSrvIndType(self.MrkSrvInd)
        elif nodeName_ == 'LocalProductCtryCd':
            LocalProductCtryCd_ = child_.text
            LocalProductCtryCd_ = self.gds_validate_string(LocalProductCtryCd_, node, 'LocalProductCtryCd')
            self.LocalProductCtryCd = LocalProductCtryCd_
            # validate type LocalProductCtryCdType
            self.validate_LocalProductCtryCdType(self.LocalProductCtryCd)
        elif nodeName_ == 'LocalProductDesc':
            LocalProductDesc_ = child_.text
            LocalProductDesc_ = self.gds_validate_string(LocalProductDesc_, node, 'LocalProductDesc')
            self.LocalProductDesc = LocalProductDesc_
        elif nodeName_ == 'GlobalProductDesc':
            GlobalProductDesc_ = child_.text
            GlobalProductDesc_ = self.gds_validate_string(GlobalProductDesc_, node, 'GlobalProductDesc')
            self.GlobalProductDesc = GlobalProductDesc_
        elif nodeName_ == 'GlobalServiceType':
            GlobalServiceType_ = child_.text
            GlobalServiceType_ = self.gds_validate_string(GlobalServiceType_, node, 'GlobalServiceType')
            self.GlobalServiceType = GlobalServiceType_
        elif nodeName_ == 'BillingServiceIndicator':
            BillingServiceIndicator_ = child_.text
            BillingServiceIndicator_ = self.gds_validate_string(BillingServiceIndicator_, node, 'BillingServiceIndicator')
            self.BillingServiceIndicator = BillingServiceIndicator_
        elif nodeName_ == 'LocalServiceName':
            LocalServiceName_ = child_.text
            LocalServiceName_ = self.gds_validate_string(LocalServiceName_, node, 'LocalServiceName')
            self.LocalServiceName = LocalServiceName_
# end class MrkSrvType


class ProdNtwrkType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NetworkTypeCode=None):
        self.original_tagname_ = None
        self.NetworkTypeCode = NetworkTypeCode
        self.validate_NetworkTypeCodeType(self.NetworkTypeCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProdNtwrkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProdNtwrkType.subclass:
            return ProdNtwrkType.subclass(*args_, **kwargs_)
        else:
            return ProdNtwrkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkTypeCode(self): return self.NetworkTypeCode
    def set_NetworkTypeCode(self, NetworkTypeCode): self.NetworkTypeCode = NetworkTypeCode
    def validate_NetworkTypeCodeType(self, value):
        # Validate type NetworkTypeCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 2:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on NetworkTypeCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NetworkTypeCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProdNtwrkType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProdNtwrkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProdNtwrkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProdNtwrkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProdNtwrkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProdNtwrkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetworkTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NetworkTypeCode>%s</NetworkTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NetworkTypeCode), input_name='NetworkTypeCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkTypeCode':
            NetworkTypeCode_ = child_.text
            NetworkTypeCode_ = self.gds_validate_string(NetworkTypeCode_, node, 'NetworkTypeCode')
            self.NetworkTypeCode = NetworkTypeCode_
            # validate type NetworkTypeCodeType
            self.validate_NetworkTypeCodeType(self.NetworkTypeCode)
# end class ProdNtwrkType


class SrvType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GlobalProductCode=None, MrkSrv=None, SBTP=None):
        self.original_tagname_ = None
        self.GlobalProductCode = GlobalProductCode
        if MrkSrv is None:
            self.MrkSrv = []
        else:
            self.MrkSrv = MrkSrv
        self.SBTP = SBTP
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SrvType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SrvType.subclass:
            return SrvType.subclass(*args_, **kwargs_)
        else:
            return SrvType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GlobalProductCode(self): return self.GlobalProductCode
    def set_GlobalProductCode(self, GlobalProductCode): self.GlobalProductCode = GlobalProductCode
    def get_MrkSrv(self): return self.MrkSrv
    def set_MrkSrv(self, MrkSrv): self.MrkSrv = MrkSrv
    def add_MrkSrv(self, value): self.MrkSrv.append(value)
    def insert_MrkSrv_at(self, index, value): self.MrkSrv.insert(index, value)
    def replace_MrkSrv_at(self, index, value): self.MrkSrv[index] = value
    def get_SBTP(self): return self.SBTP
    def set_SBTP(self, SBTP): self.SBTP = SBTP
    def hasContent_(self):
        if (
            self.GlobalProductCode is not None or
            self.MrkSrv or
            self.SBTP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SrvType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SrvType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SrvType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SrvType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SrvType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SrvType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GlobalProductCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GlobalProductCode>%s</GlobalProductCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GlobalProductCode), input_name='GlobalProductCode')), eol_))
        for MrkSrv_ in self.MrkSrv:
            MrkSrv_.export(outfile, level, namespace_, name_='MrkSrv', pretty_print=pretty_print)
        if self.SBTP is not None:
            self.SBTP.export(outfile, level, namespace_, name_='SBTP', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GlobalProductCode':
            GlobalProductCode_ = child_.text
            GlobalProductCode_ = self.gds_validate_string(GlobalProductCode_, node, 'GlobalProductCode')
            self.GlobalProductCode = GlobalProductCode_
        elif nodeName_ == 'MrkSrv':
            obj_ = MrkSrvType.factory()
            obj_.build(child_)
            self.MrkSrv.append(obj_)
            obj_.original_tagname_ = 'MrkSrv'
        elif nodeName_ == 'SBTP':
            obj_ = SBTPType.factory()
            obj_.build(child_)
            self.SBTP = obj_
            obj_.original_tagname_ = 'SBTP'
# end class SrvType


class SBTPType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Prod=None):
        self.original_tagname_ = None
        self.Prod = Prod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SBTPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SBTPType.subclass:
            return SBTPType.subclass(*args_, **kwargs_)
        else:
            return SBTPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Prod(self): return self.Prod
    def set_Prod(self, Prod): self.Prod = Prod
    def hasContent_(self):
        if (
            self.Prod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SBTPType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SBTPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SBTPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SBTPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SBTPType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SBTPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Prod is not None:
            self.Prod.export(outfile, level, namespace_, name_='Prod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Prod':
            obj_ = ProdType.factory()
            obj_.build(child_)
            self.Prod = obj_
            obj_.original_tagname_ = 'Prod'
# end class SBTPType


class DeliveryDate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeliveryType=None, DlvyDateTime=None, DeliveryDateTimeOffset=None):
        self.original_tagname_ = None
        self.DeliveryType = DeliveryType
        self.DlvyDateTime = DlvyDateTime
        self.DeliveryDateTimeOffset = DeliveryDateTimeOffset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryDate.subclass:
            return DeliveryDate.subclass(*args_, **kwargs_)
        else:
            return DeliveryDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeliveryType(self): return self.DeliveryType
    def set_DeliveryType(self, DeliveryType): self.DeliveryType = DeliveryType
    def get_DlvyDateTime(self): return self.DlvyDateTime
    def set_DlvyDateTime(self, DlvyDateTime): self.DlvyDateTime = DlvyDateTime
    def get_DeliveryDateTimeOffset(self): return self.DeliveryDateTimeOffset
    def set_DeliveryDateTimeOffset(self, DeliveryDateTimeOffset): self.DeliveryDateTimeOffset = DeliveryDateTimeOffset
    def hasContent_(self):
        if (
            self.DeliveryType is not None or
            self.DlvyDateTime is not None or
            self.DeliveryDateTimeOffset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeliveryDate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeliveryDate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeliveryDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeliveryDate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeliveryDate'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeliveryDate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DeliveryType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryType>%s</DeliveryType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryType), input_name='DeliveryType')), eol_))
        if self.DlvyDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DlvyDateTime>%s</DlvyDateTime>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DlvyDateTime), input_name='DlvyDateTime')), eol_))
        if self.DeliveryDateTimeOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DeliveryDateTimeOffset>%s</DeliveryDateTimeOffset>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DeliveryDateTimeOffset), input_name='DeliveryDateTimeOffset')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DeliveryType':
            DeliveryType_ = child_.text
            DeliveryType_ = self.gds_validate_string(DeliveryType_, node, 'DeliveryType')
            self.DeliveryType = DeliveryType_
        elif nodeName_ == 'DlvyDateTime':
            DlvyDateTime_ = child_.text
            DlvyDateTime_ = self.gds_validate_string(DlvyDateTime_, node, 'DlvyDateTime')
            self.DlvyDateTime = DlvyDateTime_
        elif nodeName_ == 'DeliveryDateTimeOffset':
            DeliveryDateTimeOffset_ = child_.text
            DeliveryDateTimeOffset_ = self.gds_validate_string(DeliveryDateTimeOffset_, node, 'DeliveryDateTimeOffset')
            self.DeliveryDateTimeOffset = DeliveryDateTimeOffset_
# end class DeliveryDate


class WeightChargeDisc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DiscAmt=None, BaseAmount=None, CurrencyCode=None, DiscType=None, DiscPercentage=None):
        self.original_tagname_ = None
        self.DiscAmt = DiscAmt
        self.validate_DiscAmtType(self.DiscAmt)
        self.BaseAmount = BaseAmount
        self.validate_BaseAmountType25(self.BaseAmount)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType26(self.CurrencyCode)
        self.DiscType = DiscType
        self.validate_DiscTypeType(self.DiscType)
        self.DiscPercentage = DiscPercentage
        self.validate_DiscPercentageType(self.DiscPercentage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightChargeDisc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightChargeDisc.subclass:
            return WeightChargeDisc.subclass(*args_, **kwargs_)
        else:
            return WeightChargeDisc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DiscAmt(self): return self.DiscAmt
    def set_DiscAmt(self, DiscAmt): self.DiscAmt = DiscAmt
    def get_BaseAmount(self): return self.BaseAmount
    def set_BaseAmount(self, BaseAmount): self.BaseAmount = BaseAmount
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_DiscType(self): return self.DiscType
    def set_DiscType(self, DiscType): self.DiscType = DiscType
    def get_DiscPercentage(self): return self.DiscPercentage
    def set_DiscPercentage(self, DiscPercentage): self.DiscPercentage = DiscPercentage
    def validate_DiscAmtType(self, value):
        # Validate type DiscAmtType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DiscAmtType' % {"value" : value} )
    def validate_BaseAmountType25(self, value):
        # Validate type BaseAmountType25, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseAmountType25' % {"value" : value} )
    def validate_CurrencyCodeType26(self, value):
        # Validate type CurrencyCodeType26, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType26' % {"value" : value.encode("utf-8")} )
    def validate_DiscTypeType(self, value):
        # Validate type DiscTypeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DiscTypeType' % {"value" : value.encode("utf-8")} )
    def validate_DiscPercentageType(self, value):
        # Validate type DiscPercentageType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DiscPercentageType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DiscAmt is not None or
            self.BaseAmount is not None or
            self.CurrencyCode is not None or
            self.DiscType is not None or
            self.DiscPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeightChargeDisc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightChargeDisc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightChargeDisc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeightChargeDisc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeightChargeDisc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeightChargeDisc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DiscAmt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscAmt>%s</DiscAmt>%s' % (self.gds_format_float(self.DiscAmt, input_name='DiscAmt'), eol_))
        if self.BaseAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BaseAmount>%s</BaseAmount>%s' % (self.gds_format_float(self.BaseAmount, input_name='BaseAmount'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.DiscType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscType>%s</DiscType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DiscType), input_name='DiscType')), eol_))
        if self.DiscPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscPercentage>%s</DiscPercentage>%s' % (self.gds_format_float(self.DiscPercentage, input_name='DiscPercentage'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DiscAmt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DiscAmt')
            self.DiscAmt = fval_
            # validate type DiscAmtType
            self.validate_DiscAmtType(self.DiscAmt)
        elif nodeName_ == 'BaseAmount':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BaseAmount')
            self.BaseAmount = fval_
            # validate type BaseAmountType25
            self.validate_BaseAmountType25(self.BaseAmount)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType26
            self.validate_CurrencyCodeType26(self.CurrencyCode)
        elif nodeName_ == 'DiscType':
            DiscType_ = child_.text
            DiscType_ = self.gds_validate_string(DiscType_, node, 'DiscType')
            self.DiscType = DiscType_
            # validate type DiscTypeType
            self.validate_DiscTypeType(self.DiscType)
        elif nodeName_ == 'DiscPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DiscPercentage')
            self.DiscPercentage = fval_
            # validate type DiscPercentageType
            self.validate_DiscPercentageType(self.DiscPercentage)
# end class WeightChargeDisc


class QtdShpExChrgDisc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DiscAmt=None, BaseAmt=None, CurrencyCode=None, CurrencyRoleTypeCode=None, DiscPercentage=None):
        self.original_tagname_ = None
        self.DiscAmt = DiscAmt
        self.validate_DiscAmtType27(self.DiscAmt)
        self.BaseAmt = BaseAmt
        self.validate_BaseAmtType28(self.BaseAmt)
        self.CurrencyCode = CurrencyCode
        self.validate_CurrencyCodeType29(self.CurrencyCode)
        self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
        self.validate_CurrencyRoleTypeCodeType30(self.CurrencyRoleTypeCode)
        self.DiscPercentage = DiscPercentage
        self.validate_DiscPercentageType31(self.DiscPercentage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QtdShpExChrgDisc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QtdShpExChrgDisc.subclass:
            return QtdShpExChrgDisc.subclass(*args_, **kwargs_)
        else:
            return QtdShpExChrgDisc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DiscAmt(self): return self.DiscAmt
    def set_DiscAmt(self, DiscAmt): self.DiscAmt = DiscAmt
    def get_BaseAmt(self): return self.BaseAmt
    def set_BaseAmt(self, BaseAmt): self.BaseAmt = BaseAmt
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def get_CurrencyRoleTypeCode(self): return self.CurrencyRoleTypeCode
    def set_CurrencyRoleTypeCode(self, CurrencyRoleTypeCode): self.CurrencyRoleTypeCode = CurrencyRoleTypeCode
    def get_DiscPercentage(self): return self.DiscPercentage
    def set_DiscPercentage(self, DiscPercentage): self.DiscPercentage = DiscPercentage
    def validate_DiscAmtType27(self, value):
        # Validate type DiscAmtType27, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 5:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DiscAmtType27' % {"value" : value.encode("utf-8")} )
    def validate_BaseAmtType28(self, value):
        # Validate type BaseAmtType28, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on BaseAmtType28' % {"value" : value} )
    def validate_CurrencyCodeType29(self, value):
        # Validate type CurrencyCodeType29, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyCodeType29' % {"value" : value.encode("utf-8")} )
    def validate_CurrencyRoleTypeCodeType30(self, value):
        # Validate type CurrencyRoleTypeCodeType30, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 5:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on CurrencyRoleTypeCodeType30' % {"value" : value.encode("utf-8")} )
    def validate_DiscPercentageType31(self, value):
        # Validate type DiscPercentageType31, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 18:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on DiscPercentageType31' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DiscAmt is not None or
            self.BaseAmt is not None or
            self.CurrencyCode is not None or
            self.CurrencyRoleTypeCode is not None or
            self.DiscPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QtdShpExChrgDisc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QtdShpExChrgDisc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QtdShpExChrgDisc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QtdShpExChrgDisc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QtdShpExChrgDisc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QtdShpExChrgDisc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DiscAmt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscAmt>%s</DiscAmt>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DiscAmt), input_name='DiscAmt')), eol_))
        if self.BaseAmt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BaseAmt>%s</BaseAmt>%s' % (self.gds_format_float(self.BaseAmt, input_name='BaseAmt'), eol_))
        if self.CurrencyCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyCode>%s</CurrencyCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyCode), input_name='CurrencyCode')), eol_))
        if self.CurrencyRoleTypeCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CurrencyRoleTypeCode>%s</CurrencyRoleTypeCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CurrencyRoleTypeCode), input_name='CurrencyRoleTypeCode')), eol_))
        if self.DiscPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DiscPercentage>%s</DiscPercentage>%s' % (self.gds_format_float(self.DiscPercentage, input_name='DiscPercentage'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DiscAmt':
            DiscAmt_ = child_.text
            DiscAmt_ = self.gds_validate_string(DiscAmt_, node, 'DiscAmt')
            self.DiscAmt = DiscAmt_
            # validate type DiscAmtType27
            self.validate_DiscAmtType27(self.DiscAmt)
        elif nodeName_ == 'BaseAmt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BaseAmt')
            self.BaseAmt = fval_
            # validate type BaseAmtType28
            self.validate_BaseAmtType28(self.BaseAmt)
        elif nodeName_ == 'CurrencyCode':
            CurrencyCode_ = child_.text
            CurrencyCode_ = self.gds_validate_string(CurrencyCode_, node, 'CurrencyCode')
            self.CurrencyCode = CurrencyCode_
            # validate type CurrencyCodeType29
            self.validate_CurrencyCodeType29(self.CurrencyCode)
        elif nodeName_ == 'CurrencyRoleTypeCode':
            CurrencyRoleTypeCode_ = child_.text
            CurrencyRoleTypeCode_ = self.gds_validate_string(CurrencyRoleTypeCode_, node, 'CurrencyRoleTypeCode')
            self.CurrencyRoleTypeCode = CurrencyRoleTypeCode_
            # validate type CurrencyRoleTypeCodeType30
            self.validate_CurrencyRoleTypeCodeType30(self.CurrencyRoleTypeCode)
        elif nodeName_ == 'DiscPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DiscPercentage')
            self.DiscPercentage = fval_
            # validate type DiscPercentageType31
            self.validate_DiscPercentageType31(self.DiscPercentage)
# end class QtdShpExChrgDisc


class GetQuoteResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, BkgDetails=None, Srvs=None, Note=None):
        self.original_tagname_ = None
        self.Response = Response
        if BkgDetails is None:
            self.BkgDetails = []
        else:
            self.BkgDetails = BkgDetails
        self.Srvs = Srvs
        if Note is None:
            self.Note = []
        else:
            self.Note = Note
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GetQuoteResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GetQuoteResponseType.subclass:
            return GetQuoteResponseType.subclass(*args_, **kwargs_)
        else:
            return GetQuoteResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_BkgDetails(self): return self.BkgDetails
    def set_BkgDetails(self, BkgDetails): self.BkgDetails = BkgDetails
    def add_BkgDetails(self, value): self.BkgDetails.append(value)
    def insert_BkgDetails_at(self, index, value): self.BkgDetails.insert(index, value)
    def replace_BkgDetails_at(self, index, value): self.BkgDetails[index] = value
    def get_Srvs(self): return self.Srvs
    def set_Srvs(self, Srvs): self.Srvs = Srvs
    def get_Note(self): return self.Note
    def set_Note(self, Note): self.Note = Note
    def add_Note(self, value): self.Note.append(value)
    def insert_Note_at(self, index, value): self.Note.insert(index, value)
    def replace_Note_at(self, index, value): self.Note[index] = value
    def hasContent_(self):
        if (
            self.Response is not None or
            self.BkgDetails or
            self.Srvs is not None or
            self.Note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GetQuoteResponseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GetQuoteResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GetQuoteResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GetQuoteResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GetQuoteResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GetQuoteResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_, name_='Response', pretty_print=pretty_print)
        for BkgDetails_ in self.BkgDetails:
            BkgDetails_.export(outfile, level, namespace_, name_='BkgDetails', pretty_print=pretty_print)
        if self.Srvs is not None:
            self.Srvs.export(outfile, level, namespace_, name_='Srvs', pretty_print=pretty_print)
        for Note_ in self.Note:
            Note_.export(outfile, level, namespace_, name_='Note', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'BkgDetails':
            obj_ = BkgDetailsType.factory()
            obj_.build(child_)
            self.BkgDetails.append(obj_)
            obj_.original_tagname_ = 'BkgDetails'
        elif nodeName_ == 'Srvs':
            obj_ = SrvsType.factory()
            obj_.build(child_)
            self.Srvs = obj_
            obj_.original_tagname_ = 'Srvs'
        elif nodeName_ == 'Note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.Note.append(obj_)
            obj_.original_tagname_ = 'Note'
# end class GetQuoteResponseType


class ResponseType(GeneratedsSuper):
    """Generic response header"""
    subclass = None
    superclass = None
    def __init__(self, ServiceHeader=None):
        self.original_tagname_ = None
        self.ServiceHeader = ServiceHeader
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseType.subclass:
            return ResponseType.subclass(*args_, **kwargs_)
        else:
            return ResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceHeader(self): return self.ServiceHeader
    def set_ServiceHeader(self, ServiceHeader): self.ServiceHeader = ServiceHeader
    def hasContent_(self):
        if (
            self.ServiceHeader is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceHeader is not None:
            self.ServiceHeader.export(outfile, level, namespace_, name_='ServiceHeader', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceHeader':
            obj_ = ServiceHeader.factory()
            obj_.build(child_)
            self.ServiceHeader = obj_
            obj_.original_tagname_ = 'ServiceHeader'
# end class ResponseType


class SrvsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Srv=None):
        self.original_tagname_ = None
        if Srv is None:
            self.Srv = []
        else:
            self.Srv = Srv
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SrvsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SrvsType.subclass:
            return SrvsType.subclass(*args_, **kwargs_)
        else:
            return SrvsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Srv(self): return self.Srv
    def set_Srv(self, Srv): self.Srv = Srv
    def add_Srv(self, value): self.Srv.append(value)
    def insert_Srv_at(self, index, value): self.Srv.insert(index, value)
    def replace_Srv_at(self, index, value): self.Srv[index] = value
    def hasContent_(self):
        if (
            self.Srv
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SrvsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SrvsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SrvsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SrvsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SrvsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SrvsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Srv_ in self.Srv:
            Srv_.export(outfile, level, namespace_, name_='Srv', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Srv':
            obj_ = SrvType.factory()
            obj_.build(child_)
            self.Srv.append(obj_)
            obj_.original_tagname_ = 'Srv'
# end class SrvsType


class GetCapabilityResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Response=None, BkgDetails=None, Srvs=None, Note=None):
        self.original_tagname_ = None
        self.Response = Response
        if BkgDetails is None:
            self.BkgDetails = []
        else:
            self.BkgDetails = BkgDetails
        self.Srvs = Srvs
        if Note is None:
            self.Note = []
        else:
            self.Note = Note
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GetCapabilityResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GetCapabilityResponseType.subclass:
            return GetCapabilityResponseType.subclass(*args_, **kwargs_)
        else:
            return GetCapabilityResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def get_BkgDetails(self): return self.BkgDetails
    def set_BkgDetails(self, BkgDetails): self.BkgDetails = BkgDetails
    def add_BkgDetails(self, value): self.BkgDetails.append(value)
    def insert_BkgDetails_at(self, index, value): self.BkgDetails.insert(index, value)
    def replace_BkgDetails_at(self, index, value): self.BkgDetails[index] = value
    def get_Srvs(self): return self.Srvs
    def set_Srvs(self, Srvs): self.Srvs = Srvs
    def get_Note(self): return self.Note
    def set_Note(self, Note): self.Note = Note
    def add_Note(self, value): self.Note.append(value)
    def insert_Note_at(self, index, value): self.Note.insert(index, value)
    def replace_Note_at(self, index, value): self.Note[index] = value
    def hasContent_(self):
        if (
            self.Response is not None or
            self.BkgDetails or
            self.Srvs is not None or
            self.Note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GetCapabilityResponseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GetCapabilityResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GetCapabilityResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GetCapabilityResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GetCapabilityResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GetCapabilityResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Response is not None:
            self.Response.export(outfile, level, namespace_, name_='Response', pretty_print=pretty_print)
        for BkgDetails_ in self.BkgDetails:
            BkgDetails_.export(outfile, level, namespace_, name_='BkgDetails', pretty_print=pretty_print)
        if self.Srvs is not None:
            self.Srvs.export(outfile, level, namespace_, name_='Srvs', pretty_print=pretty_print)
        for Note_ in self.Note:
            Note_.export(outfile, level, namespace_, name_='Note', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            obj_ = ResponseType1.factory()
            obj_.build(child_)
            self.Response = obj_
            obj_.original_tagname_ = 'Response'
        elif nodeName_ == 'BkgDetails':
            obj_ = BkgDetailsType.factory()
            obj_.build(child_)
            self.BkgDetails.append(obj_)
            obj_.original_tagname_ = 'BkgDetails'
        elif nodeName_ == 'Srvs':
            obj_ = SrvsType2.factory()
            obj_.build(child_)
            self.Srvs = obj_
            obj_.original_tagname_ = 'Srvs'
        elif nodeName_ == 'Note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.Note.append(obj_)
            obj_.original_tagname_ = 'Note'
# end class GetCapabilityResponseType


class ResponseType1(GeneratedsSuper):
    """Generic response header"""
    subclass = None
    superclass = None
    def __init__(self, ServiceHeader=None):
        self.original_tagname_ = None
        self.ServiceHeader = ServiceHeader
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseType1.subclass:
            return ResponseType1.subclass(*args_, **kwargs_)
        else:
            return ResponseType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceHeader(self): return self.ServiceHeader
    def set_ServiceHeader(self, ServiceHeader): self.ServiceHeader = ServiceHeader
    def hasContent_(self):
        if (
            self.ServiceHeader is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceHeader is not None:
            self.ServiceHeader.export(outfile, level, namespace_, name_='ServiceHeader', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceHeader':
            obj_ = ServiceHeader.factory()
            obj_.build(child_)
            self.ServiceHeader = obj_
            obj_.original_tagname_ = 'ServiceHeader'
# end class ResponseType1


class SrvsType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Srv=None):
        self.original_tagname_ = None
        if Srv is None:
            self.Srv = []
        else:
            self.Srv = Srv
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SrvsType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SrvsType2.subclass:
            return SrvsType2.subclass(*args_, **kwargs_)
        else:
            return SrvsType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Srv(self): return self.Srv
    def set_Srv(self, Srv): self.Srv = Srv
    def add_Srv(self, value): self.Srv.append(value)
    def insert_Srv_at(self, index, value): self.Srv.insert(index, value)
    def replace_Srv_at(self, index, value): self.Srv[index] = value
    def hasContent_(self):
        if (
            self.Srv
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SrvsType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SrvsType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SrvsType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SrvsType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SrvsType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SrvsType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Srv_ in self.Srv:
            Srv_.export(outfile, level, namespace_, name_='Srv', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Srv':
            obj_ = SrvType.factory()
            obj_.build(child_)
            self.Srv.append(obj_)
            obj_.original_tagname_ = 'Srv'
# end class SrvsType2


class WeightType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Weight=None, WeightUnit=None):
        self.original_tagname_ = None
        self.Weight = Weight
        self.validate_Weight(self.Weight)
        self.WeightUnit = WeightUnit
        self.validate_WeightUnit(self.WeightUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeightType.subclass:
            return WeightType.subclass(*args_, **kwargs_)
        else:
            return WeightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_WeightUnit(self): return self.WeightUnit
    def set_WeightUnit(self, WeightUnit): self.WeightUnit = WeightUnit
    def validate_Weight(self, value):
        # Validate type Weight, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0.000:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on Weight' % {"value" : value} )
            if value > 999999.999:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
            if len(str(value)) >= 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on Weight' % {"value" : value} )
    def validate_WeightUnit(self, value):
        # Validate type WeightUnit, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['K', 'L']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
            if len(value) > 1:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on WeightUnit' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Weight is not None or
            self.WeightUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WeightType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WeightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WeightType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WeightType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Weight>%s</Weight>%s' % (self.gds_format_float(self.Weight, input_name='Weight'), eol_))
        if self.WeightUnit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<WeightUnit>%s</WeightUnit>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.WeightUnit), input_name='WeightUnit')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Weight')
            self.Weight = fval_
            # validate type Weight
            self.validate_Weight(self.Weight)
        elif nodeName_ == 'WeightUnit':
            WeightUnit_ = child_.text
            WeightUnit_ = self.gds_validate_string(WeightUnit_, node, 'WeightUnit')
            self.WeightUnit = WeightUnit_
            # validate type WeightUnit
            self.validate_WeightUnit(self.WeightUnit)
# end class WeightType


class LicenseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LicenseNumber=None, ExpiryDate=None):
        self.original_tagname_ = None
        self.LicenseNumber = LicenseNumber
        self.validate_LicenseNumber(self.LicenseNumber)
        if isinstance(ExpiryDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(ExpiryDate, '%Y-%m-%d').date()
        else:
            initvalue_ = ExpiryDate
        self.ExpiryDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LicenseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LicenseType.subclass:
            return LicenseType.subclass(*args_, **kwargs_)
        else:
            return LicenseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LicenseNumber(self): return self.LicenseNumber
    def set_LicenseNumber(self, LicenseNumber): self.LicenseNumber = LicenseNumber
    def get_ExpiryDate(self): return self.ExpiryDate
    def set_ExpiryDate(self, ExpiryDate): self.ExpiryDate = ExpiryDate
    def validate_LicenseNumber(self, value):
        # Validate type LicenseNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 16:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on LicenseNumber' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LicenseNumber is not None or
            self.ExpiryDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LicenseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LicenseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LicenseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LicenseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LicenseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LicenseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LicenseNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LicenseNumber>%s</LicenseNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LicenseNumber), input_name='LicenseNumber')), eol_))
        if self.ExpiryDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ExpiryDate>%s</ExpiryDate>%s' % (self.gds_format_date(self.ExpiryDate, input_name='ExpiryDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LicenseNumber':
            LicenseNumber_ = child_.text
            LicenseNumber_ = self.gds_validate_string(LicenseNumber_, node, 'LicenseNumber')
            self.LicenseNumber = LicenseNumber_
            # validate type LicenseNumber
            self.validate_LicenseNumber(self.LicenseNumber)
        elif nodeName_ == 'ExpiryDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.ExpiryDate = dval_
# end class LicenseType


class MultiLabelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DocName=None, DocFormat=None, DocImage=None):
        self.original_tagname_ = None
        self.DocName = DocName
        self.DocFormat = DocFormat
        self.validate_DocFormat(self.DocFormat)
        self.DocImage = DocImage
        self.validate_DocImageVal(self.DocImage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultiLabelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultiLabelType.subclass:
            return MultiLabelType.subclass(*args_, **kwargs_)
        else:
            return MultiLabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocName(self): return self.DocName
    def set_DocName(self, DocName): self.DocName = DocName
    def get_DocFormat(self): return self.DocFormat
    def set_DocFormat(self, DocFormat): self.DocFormat = DocFormat
    def get_DocImage(self): return self.DocImage
    def set_DocImage(self, DocImage): self.DocImage = DocImage
    def validate_DocFormat(self, value):
        # Validate type DocFormat, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 3:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on DocFormat' % {"value" : value.encode("utf-8")} )
    def validate_DocImageVal(self, value):
        # Validate type DocImageVal, a restriction on xsd:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.DocName is not None or
            self.DocFormat is not None or
            self.DocImage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MultiLabelType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultiLabelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MultiLabelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MultiLabelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MultiLabelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MultiLabelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DocName>%s</DocName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocName), input_name='DocName')), eol_))
        if self.DocFormat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DocFormat>%s</DocFormat>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DocFormat), input_name='DocFormat')), eol_))
        if self.DocImage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DocImage>%s</DocImage>%s' % (self.gds_format_base64(self.DocImage, input_name='DocImage'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocName':
            DocName_ = child_.text
            DocName_ = self.gds_validate_string(DocName_, node, 'DocName')
            self.DocName = DocName_
        elif nodeName_ == 'DocFormat':
            DocFormat_ = child_.text
            DocFormat_ = self.gds_validate_string(DocFormat_, node, 'DocFormat')
            self.DocFormat = DocFormat_
            # validate type DocFormat
            self.validate_DocFormat(self.DocFormat)
        elif nodeName_ == 'DocImage':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'DocImage')
            else:
                bval_ = None
            self.DocImage = bval_
            # validate type DocImageVal
            self.validate_DocImageVal(self.DocImage)
# end class MultiLabelType


class SrvCombType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Prod=None):
        self.original_tagname_ = None
        self.Prod = Prod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SrvCombType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SrvCombType9.subclass:
            return SrvCombType9.subclass(*args_, **kwargs_)
        else:
            return SrvCombType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Prod(self): return self.Prod
    def set_Prod(self, Prod): self.Prod = Prod
    def hasContent_(self):
        if (
            self.Prod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SrvCombType9', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SrvCombType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SrvCombType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SrvCombType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SrvCombType9'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SrvCombType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Prod is not None:
            self.Prod.export(outfile, level, namespace_, name_='Prod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Prod':
            obj_ = ProdType.factory()
            obj_.build(child_)
            self.Prod = obj_
            obj_.original_tagname_ = 'Prod'
# end class SrvCombType9


class VldSrvCombType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SpecialServiceType=None, LocalServiceType=None, CombRSrv=None):
        self.original_tagname_ = None
        self.SpecialServiceType = SpecialServiceType
        if LocalServiceType is None:
            self.LocalServiceType = []
        else:
            self.LocalServiceType = LocalServiceType
        if CombRSrv is None:
            self.CombRSrv = []
        else:
            self.CombRSrv = CombRSrv
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VldSrvCombType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VldSrvCombType.subclass:
            return VldSrvCombType.subclass(*args_, **kwargs_)
        else:
            return VldSrvCombType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialServiceType(self): return self.SpecialServiceType
    def set_SpecialServiceType(self, SpecialServiceType): self.SpecialServiceType = SpecialServiceType
    def get_LocalServiceType(self): return self.LocalServiceType
    def set_LocalServiceType(self, LocalServiceType): self.LocalServiceType = LocalServiceType
    def add_LocalServiceType(self, value): self.LocalServiceType.append(value)
    def insert_LocalServiceType_at(self, index, value): self.LocalServiceType.insert(index, value)
    def replace_LocalServiceType_at(self, index, value): self.LocalServiceType[index] = value
    def get_CombRSrv(self): return self.CombRSrv
    def set_CombRSrv(self, CombRSrv): self.CombRSrv = CombRSrv
    def add_CombRSrv(self, value): self.CombRSrv.append(value)
    def insert_CombRSrv_at(self, index, value): self.CombRSrv.insert(index, value)
    def replace_CombRSrv_at(self, index, value): self.CombRSrv[index] = value
    def hasContent_(self):
        if (
            self.SpecialServiceType is not None or
            self.LocalServiceType or
            self.CombRSrv
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VldSrvCombType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VldSrvCombType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VldSrvCombType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VldSrvCombType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VldSrvCombType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VldSrvCombType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecialServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SpecialServiceType>%s</SpecialServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SpecialServiceType), input_name='SpecialServiceType')), eol_))
        for LocalServiceType_ in self.LocalServiceType:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LocalServiceType>%s</LocalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(LocalServiceType_), input_name='LocalServiceType')), eol_))
        for CombRSrv_ in self.CombRSrv:
            CombRSrv_.export(outfile, level, namespace_, name_='CombRSrv', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialServiceType':
            SpecialServiceType_ = child_.text
            SpecialServiceType_ = self.gds_validate_string(SpecialServiceType_, node, 'SpecialServiceType')
            self.SpecialServiceType = SpecialServiceType_
        elif nodeName_ == 'LocalServiceType':
            LocalServiceType_ = child_.text
            LocalServiceType_ = self.gds_validate_string(LocalServiceType_, node, 'LocalServiceType')
            self.LocalServiceType.append(LocalServiceType_)
        elif nodeName_ == 'CombRSrv':
            obj_ = CombRSrvType.factory()
            obj_.build(child_)
            self.CombRSrv.append(obj_)
            obj_.original_tagname_ = 'CombRSrv'
# end class VldSrvCombType


class CombRSrvType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RestrictedSpecialServiceType=None, RestrictedLocalServiceType=None):
        self.original_tagname_ = None
        self.RestrictedSpecialServiceType = RestrictedSpecialServiceType
        if RestrictedLocalServiceType is None:
            self.RestrictedLocalServiceType = []
        else:
            self.RestrictedLocalServiceType = RestrictedLocalServiceType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CombRSrvType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CombRSrvType.subclass:
            return CombRSrvType.subclass(*args_, **kwargs_)
        else:
            return CombRSrvType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RestrictedSpecialServiceType(self): return self.RestrictedSpecialServiceType
    def set_RestrictedSpecialServiceType(self, RestrictedSpecialServiceType): self.RestrictedSpecialServiceType = RestrictedSpecialServiceType
    def get_RestrictedLocalServiceType(self): return self.RestrictedLocalServiceType
    def set_RestrictedLocalServiceType(self, RestrictedLocalServiceType): self.RestrictedLocalServiceType = RestrictedLocalServiceType
    def add_RestrictedLocalServiceType(self, value): self.RestrictedLocalServiceType.append(value)
    def insert_RestrictedLocalServiceType_at(self, index, value): self.RestrictedLocalServiceType.insert(index, value)
    def replace_RestrictedLocalServiceType_at(self, index, value): self.RestrictedLocalServiceType[index] = value
    def hasContent_(self):
        if (
            self.RestrictedSpecialServiceType is not None or
            self.RestrictedLocalServiceType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CombRSrvType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CombRSrvType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CombRSrvType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CombRSrvType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CombRSrvType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CombRSrvType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RestrictedSpecialServiceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RestrictedSpecialServiceType>%s</RestrictedSpecialServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RestrictedSpecialServiceType), input_name='RestrictedSpecialServiceType')), eol_))
        for RestrictedLocalServiceType_ in self.RestrictedLocalServiceType:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RestrictedLocalServiceType>%s</RestrictedLocalServiceType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(RestrictedLocalServiceType_), input_name='RestrictedLocalServiceType')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RestrictedSpecialServiceType':
            RestrictedSpecialServiceType_ = child_.text
            RestrictedSpecialServiceType_ = self.gds_validate_string(RestrictedSpecialServiceType_, node, 'RestrictedSpecialServiceType')
            self.RestrictedSpecialServiceType = RestrictedSpecialServiceType_
        elif nodeName_ == 'RestrictedLocalServiceType':
            RestrictedLocalServiceType_ = child_.text
            RestrictedLocalServiceType_ = self.gds_validate_string(RestrictedLocalServiceType_, node, 'RestrictedLocalServiceType')
            self.RestrictedLocalServiceType.append(RestrictedLocalServiceType_)
# end class CombRSrvType


class ConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ConditionCode=None, ConditionData=None):
        self.original_tagname_ = None
        self.ConditionCode = ConditionCode
        self.validate_ConditionCodeType(self.ConditionCode)
        self.ConditionData = ConditionData
        self.validate_ConditionDataType(self.ConditionData)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConditionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConditionType.subclass:
            return ConditionType.subclass(*args_, **kwargs_)
        else:
            return ConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConditionCode(self): return self.ConditionCode
    def set_ConditionCode(self, ConditionCode): self.ConditionCode = ConditionCode
    def get_ConditionData(self): return self.ConditionData
    def set_ConditionData(self, ConditionData): self.ConditionData = ConditionData
    def validate_ConditionCodeType(self, value):
        # Validate type ConditionCodeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ConditionCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ConditionCodeType' % {"value" : value.encode("utf-8")} )
    def validate_ConditionDataType(self, value):
        # Validate type ConditionDataType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.ConditionCode is not None or
            self.ConditionData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConditionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConditionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConditionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConditionCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConditionCode>%s</ConditionCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConditionCode), input_name='ConditionCode')), eol_))
        if self.ConditionData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ConditionData>%s</ConditionData>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ConditionData), input_name='ConditionData')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConditionCode':
            ConditionCode_ = child_.text
            ConditionCode_ = self.gds_validate_string(ConditionCode_, node, 'ConditionCode')
            self.ConditionCode = ConditionCode_
            # validate type ConditionCodeType
            self.validate_ConditionCodeType(self.ConditionCode)
        elif nodeName_ == 'ConditionData':
            ConditionData_ = child_.text
            ConditionData_ = self.gds_validate_string(ConditionData_, node, 'ConditionData')
            self.ConditionData = ConditionData_
            # validate type ConditionDataType
            self.validate_ConditionDataType(self.ConditionData)
# end class ConditionType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTResponse'
        rootClass = DCTResponse
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTResponse'
        rootClass = DCTResponse
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTResponse'
        rootClass = DCTResponse
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DCTResponse'
        rootClass = DCTResponse
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from DCT_Response_global import *\n\n')
        sys.stdout.write('import DCT_Response_global as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AWBInfo",
    "AdditionalProtection",
    "BarCodes",
    "Billing",
    "BkgDetailsType",
    "ChargeTaxAmountDetType",
    "CombRSrvType",
    "Commodity",
    "Condition",
    "ConditionType",
    "Consignee",
    "Contact",
    "Customer",
    "CustomerLogo",
    "DCTResponse",
    "DCTResponseDataTypes",
    "DataTypes",
    "DeliveryDate",
    "DestSvcAreaType",
    "DestinationServiceArea",
    "DocImage",
    "DocImages",
    "Dutiable",
    "ErrorResponse",
    "ExportDeclaration",
    "ExportLineItem",
    "Fault",
    "Filing",
    "GetCapabilityResponseType",
    "GetQuoteResponseType",
    "Label",
    "LabelImage",
    "LicenseType",
    "MrkSrvType",
    "MultiLabelType",
    "MultiLabels",
    "Note",
    "NoteType",
    "Notification",
    "OrgnSvcAreaType",
    "OriginServiceArea",
    "Piece",
    "PieceDetails",
    "PieceEvent",
    "PieceFault",
    "PieceInfo",
    "Pieces",
    "Place",
    "ProdNtwrkType",
    "ProdType",
    "QtdSExtrChrgInAdCurType",
    "QtdSInAdCur",
    "QtdSInAdCurType",
    "QtdShpExChrgDisc",
    "QtdShpExChrgType",
    "QtdShpType",
    "Reference",
    "Request",
    "Response",
    "ResponseServiceHeader",
    "ResponseType",
    "ResponseType1",
    "SBTPType",
    "ServiceArea",
    "ServiceEvent",
    "ServiceHeader",
    "ShipValResponsePiece",
    "ShipValResponsePieces",
    "Shipment",
    "ShipmentDate",
    "ShipmentDetails",
    "ShipmentEvent",
    "ShipmentInfo",
    "Shipper",
    "SpecialService",
    "SrvCombType",
    "SrvCombType9",
    "SrvType",
    "SrvsType",
    "SrvsType2",
    "Status",
    "TrackingPieces",
    "VldSrvCombType",
    "WeightChargeDisc",
    "WeightChargeTaxDetType",
    "WeightSeg",
    "WeightType"
]
